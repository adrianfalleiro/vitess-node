// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vschema.proto" (package "vschema", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains the types needed to define a vschema.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Type } from "./query";
/**
 * RoutingRules specify the high level routing rules for the VSchema.
 *
 * @generated from protobuf message vschema.RoutingRules
 */
export interface RoutingRules {
    /**
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     *
     * @generated from protobuf field: repeated vschema.RoutingRule rules = 1;
     */
    rules: RoutingRule[];
}
/**
 * RoutingRule specifies a routing rule.
 *
 * @generated from protobuf message vschema.RoutingRule
 */
export interface RoutingRule {
    /**
     * @generated from protobuf field: string from_table = 1;
     */
    fromTable: string;
    /**
     * @generated from protobuf field: repeated string to_tables = 2;
     */
    toTables: string[];
}
/**
 * Keyspace is the vschema for a keyspace.
 *
 * @generated from protobuf message vschema.Keyspace
 */
export interface Keyspace {
    /**
     * If sharded is false, vindexes and tables are ignored.
     *
     * @generated from protobuf field: bool sharded = 1;
     */
    sharded: boolean;
    /**
     * @generated from protobuf field: map<string, vschema.Vindex> vindexes = 2;
     */
    vindexes: {
        [key: string]: Vindex;
    };
    /**
     * @generated from protobuf field: map<string, vschema.Table> tables = 3;
     */
    tables: {
        [key: string]: Table;
    };
    /**
     * If require_explicit_routing is true, vindexes and tables are not added to global routing
     *
     * @generated from protobuf field: bool require_explicit_routing = 4;
     */
    requireExplicitRouting: boolean;
    /**
     * foreign_key_mode dictates how Vitess should handle foreign keys for this keyspace.
     *
     * @generated from protobuf field: vschema.Keyspace.ForeignKeyMode foreign_key_mode = 5;
     */
    foreignKeyMode: Keyspace_ForeignKeyMode;
    /**
     * multi_tenant_mode specifies that the keyspace is multi-tenant. Currently used during migrations with MoveTables.
     *
     * @generated from protobuf field: vschema.MultiTenantSpec multi_tenant_spec = 6;
     */
    multiTenantSpec?: MultiTenantSpec;
}
/**
 * @generated from protobuf enum vschema.Keyspace.ForeignKeyMode
 */
export enum Keyspace_ForeignKeyMode {
    /**
     * @generated from protobuf enum value: unspecified = 0;
     */
    unspecified = 0,
    /**
     * @generated from protobuf enum value: disallow = 1;
     */
    disallow = 1,
    /**
     * @generated from protobuf enum value: unmanaged = 2;
     */
    unmanaged = 2,
    /**
     * @generated from protobuf enum value: managed = 3;
     */
    managed = 3
}
/**
 * @generated from protobuf message vschema.MultiTenantSpec
 */
export interface MultiTenantSpec {
    /**
     * tenant_column is the name of the column that specifies the tenant id.
     *
     * @generated from protobuf field: string tenant_id_column_name = 1;
     */
    tenantIdColumnName: string;
    /**
     * tenant_column_type is the type of the column that specifies the tenant id.
     *
     * @generated from protobuf field: query.Type tenant_id_column_type = 2;
     */
    tenantIdColumnType: Type;
}
/**
 * Vindex is the vindex info for a Keyspace.
 *
 * @generated from protobuf message vschema.Vindex
 */
export interface Vindex {
    /**
     * The type must match one of the predefined
     * (or plugged in) vindex names.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     *
     * @generated from protobuf field: map<string, string> params = 2;
     */
    params: {
        [key: string]: string;
    };
    /**
     * A lookup vindex can have an owner table defined.
     * If so, rows in the lookup table are created or
     * deleted in sync with corresponding rows in the
     * owner table.
     *
     * @generated from protobuf field: string owner = 3;
     */
    owner: string;
}
/**
 * Table is the table info for a Keyspace.
 *
 * @generated from protobuf message vschema.Table
 */
export interface Table {
    /**
     * If the table is a sequence, type must be
     * "sequence".
     *
     * If the table is a reference, type must be
     * "reference".
     * See https://vitess.io/docs/reference/features/vschema/#reference-tables.
     *
     * Otherwise, it should be empty.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * column_vindexes associates columns to vindexes.
     *
     * @generated from protobuf field: repeated vschema.ColumnVindex column_vindexes = 2;
     */
    columnVindexes: ColumnVindex[];
    /**
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     *
     * @generated from protobuf field: vschema.AutoIncrement auto_increment = 3;
     */
    autoIncrement?: AutoIncrement;
    /**
     * columns lists the columns for the table.
     *
     * @generated from protobuf field: repeated vschema.Column columns = 4;
     */
    columns: Column[];
    /**
     * pinned pins an unsharded table to a specific
     * shard, as dictated by the keyspace id.
     * The keyspace id is represented in hex form
     * like in keyranges.
     *
     * @generated from protobuf field: string pinned = 5;
     */
    pinned: string;
    /**
     * column_list_authoritative is set to true if columns is
     * an authoritative list for the table. This allows
     * us to expand 'select *' expressions.
     *
     * @generated from protobuf field: bool column_list_authoritative = 6;
     */
    columnListAuthoritative: boolean;
    /**
     * reference tables may optionally indicate their source table.
     *
     * @generated from protobuf field: string source = 7;
     */
    source: string;
}
/**
 * ColumnVindex is used to associate a column to a vindex.
 *
 * @generated from protobuf message vschema.ColumnVindex
 */
export interface ColumnVindex {
    /**
     * Legacy implementation, moving forward all vindexes should define a list of columns.
     *
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * The name must match a vindex defined in Keyspace.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * List of columns that define this Vindex
     *
     * @generated from protobuf field: repeated string columns = 3;
     */
    columns: string[];
}
/**
 * Autoincrement is used to designate a column as auto-inc.
 *
 * @generated from protobuf message vschema.AutoIncrement
 */
export interface AutoIncrement {
    /**
     * @generated from protobuf field: string column = 1;
     */
    column: string;
    /**
     * The sequence must match a table of type SEQUENCE.
     *
     * @generated from protobuf field: string sequence = 2;
     */
    sequence: string;
}
/**
 * Column describes a column.
 *
 * @generated from protobuf message vschema.Column
 */
export interface Column {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: query.Type type = 2;
     */
    type: Type;
    /**
     * @generated from protobuf field: bool invisible = 3;
     */
    invisible: boolean;
    /**
     * @generated from protobuf field: string default = 4;
     */
    default: string;
    /**
     * @generated from protobuf field: string collation_name = 5;
     */
    collationName: string;
    /**
     * @generated from protobuf field: int32 size = 6;
     */
    size: number;
    /**
     * @generated from protobuf field: int32 scale = 7;
     */
    scale: number;
    /**
     * @generated from protobuf field: optional bool nullable = 8;
     */
    nullable?: boolean;
    /**
     * values contains the list of values for an enum or set column.
     *
     * @generated from protobuf field: repeated string values = 9;
     */
    values: string[];
}
/**
 * SrvVSchema is the roll-up of all the Keyspace schema for a cell.
 *
 * @generated from protobuf message vschema.SrvVSchema
 */
export interface SrvVSchema {
    /**
     * keyspaces is a map of keyspace name -> Keyspace object.
     *
     * @generated from protobuf field: map<string, vschema.Keyspace> keyspaces = 1;
     */
    keyspaces: {
        [key: string]: Keyspace;
    };
    /**
     * @generated from protobuf field: vschema.RoutingRules routing_rules = 2;
     */
    routingRules?: RoutingRules; // table routing rules
    /**
     * @generated from protobuf field: vschema.ShardRoutingRules shard_routing_rules = 3;
     */
    shardRoutingRules?: ShardRoutingRules;
    /**
     * @generated from protobuf field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 4;
     */
    keyspaceRoutingRules?: KeyspaceRoutingRules;
    /**
     * @generated from protobuf field: vschema.MirrorRules mirror_rules = 5;
     */
    mirrorRules?: MirrorRules; // mirror rules
}
/**
 * ShardRoutingRules specify the shard routing rules for the VSchema.
 *
 * @generated from protobuf message vschema.ShardRoutingRules
 */
export interface ShardRoutingRules {
    /**
     * @generated from protobuf field: repeated vschema.ShardRoutingRule rules = 1;
     */
    rules: ShardRoutingRule[];
}
/**
 * ShardRoutingRule specifies a routing rule.
 *
 * @generated from protobuf message vschema.ShardRoutingRule
 */
export interface ShardRoutingRule {
    /**
     * @generated from protobuf field: string from_keyspace = 1;
     */
    fromKeyspace: string;
    /**
     * @generated from protobuf field: string to_keyspace = 2;
     */
    toKeyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
}
/**
 * @generated from protobuf message vschema.KeyspaceRoutingRules
 */
export interface KeyspaceRoutingRules {
    /**
     * @generated from protobuf field: repeated vschema.KeyspaceRoutingRule rules = 1;
     */
    rules: KeyspaceRoutingRule[];
}
/**
 * @generated from protobuf message vschema.KeyspaceRoutingRule
 */
export interface KeyspaceRoutingRule {
    /**
     * @generated from protobuf field: string from_keyspace = 1;
     */
    fromKeyspace: string;
    /**
     * @generated from protobuf field: string to_keyspace = 2;
     */
    toKeyspace: string;
}
/**
 * MirrorRules specify the high level mirror rules for the VSchema.
 *
 * @generated from protobuf message vschema.MirrorRules
 */
export interface MirrorRules {
    /**
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     *
     * @generated from protobuf field: repeated vschema.MirrorRule rules = 1;
     */
    rules: MirrorRule[];
}
/**
 * MirrorRule specifies a mirror rule.
 *
 * @generated from protobuf message vschema.MirrorRule
 */
export interface MirrorRule {
    /**
     * @generated from protobuf field: string from_table = 1;
     */
    fromTable: string;
    /**
     * @generated from protobuf field: string to_table = 2;
     */
    toTable: string;
    /**
     * @generated from protobuf field: float percent = 3;
     */
    percent: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class RoutingRules$Type extends MessageType<RoutingRules> {
    constructor() {
        super("vschema.RoutingRules", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutingRule }
        ]);
    }
    create(value?: PartialMessage<RoutingRules>): RoutingRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<RoutingRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutingRules): RoutingRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vschema.RoutingRule rules */ 1:
                    message.rules.push(RoutingRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutingRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vschema.RoutingRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            RoutingRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.RoutingRules
 */
export const RoutingRules = new RoutingRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutingRule$Type extends MessageType<RoutingRule> {
    constructor() {
        super("vschema.RoutingRule", [
            { no: 1, name: "from_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RoutingRule>): RoutingRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromTable = "";
        message.toTables = [];
        if (value !== undefined)
            reflectionMergePartial<RoutingRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutingRule): RoutingRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_table */ 1:
                    message.fromTable = reader.string();
                    break;
                case /* repeated string to_tables */ 2:
                    message.toTables.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutingRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_table = 1; */
        if (message.fromTable !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromTable);
        /* repeated string to_tables = 2; */
        for (let i = 0; i < message.toTables.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.toTables[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.RoutingRule
 */
export const RoutingRule = new RoutingRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Keyspace$Type extends MessageType<Keyspace> {
    constructor() {
        super("vschema.Keyspace", [
            { no: 1, name: "sharded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "vindexes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Vindex } },
            { no: 3, name: "tables", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Table } },
            { no: 4, name: "require_explicit_routing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "foreign_key_mode", kind: "enum", T: () => ["vschema.Keyspace.ForeignKeyMode", Keyspace_ForeignKeyMode] },
            { no: 6, name: "multi_tenant_spec", kind: "message", T: () => MultiTenantSpec }
        ]);
    }
    create(value?: PartialMessage<Keyspace>): Keyspace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sharded = false;
        message.vindexes = {};
        message.tables = {};
        message.requireExplicitRouting = false;
        message.foreignKeyMode = 0;
        if (value !== undefined)
            reflectionMergePartial<Keyspace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Keyspace): Keyspace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool sharded */ 1:
                    message.sharded = reader.bool();
                    break;
                case /* map<string, vschema.Vindex> vindexes */ 2:
                    this.binaryReadMap2(message.vindexes, reader, options);
                    break;
                case /* map<string, vschema.Table> tables */ 3:
                    this.binaryReadMap3(message.tables, reader, options);
                    break;
                case /* bool require_explicit_routing */ 4:
                    message.requireExplicitRouting = reader.bool();
                    break;
                case /* vschema.Keyspace.ForeignKeyMode foreign_key_mode */ 5:
                    message.foreignKeyMode = reader.int32();
                    break;
                case /* vschema.MultiTenantSpec multi_tenant_spec */ 6:
                    message.multiTenantSpec = MultiTenantSpec.internalBinaryRead(reader, reader.uint32(), options, message.multiTenantSpec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Keyspace["vindexes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Keyspace["vindexes"] | undefined, val: Keyspace["vindexes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Vindex.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vschema.Keyspace.vindexes");
            }
        }
        map[key ?? ""] = val ?? Vindex.create();
    }
    private binaryReadMap3(map: Keyspace["tables"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Keyspace["tables"] | undefined, val: Keyspace["tables"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Table.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vschema.Keyspace.tables");
            }
        }
        map[key ?? ""] = val ?? Table.create();
    }
    internalBinaryWrite(message: Keyspace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool sharded = 1; */
        if (message.sharded !== false)
            writer.tag(1, WireType.Varint).bool(message.sharded);
        /* map<string, vschema.Vindex> vindexes = 2; */
        for (let k of globalThis.Object.keys(message.vindexes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Vindex.internalBinaryWrite(message.vindexes[k], writer, options);
            writer.join().join();
        }
        /* map<string, vschema.Table> tables = 3; */
        for (let k of globalThis.Object.keys(message.tables)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Table.internalBinaryWrite(message.tables[k], writer, options);
            writer.join().join();
        }
        /* bool require_explicit_routing = 4; */
        if (message.requireExplicitRouting !== false)
            writer.tag(4, WireType.Varint).bool(message.requireExplicitRouting);
        /* vschema.Keyspace.ForeignKeyMode foreign_key_mode = 5; */
        if (message.foreignKeyMode !== 0)
            writer.tag(5, WireType.Varint).int32(message.foreignKeyMode);
        /* vschema.MultiTenantSpec multi_tenant_spec = 6; */
        if (message.multiTenantSpec)
            MultiTenantSpec.internalBinaryWrite(message.multiTenantSpec, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.Keyspace
 */
export const Keyspace = new Keyspace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiTenantSpec$Type extends MessageType<MultiTenantSpec> {
    constructor() {
        super("vschema.MultiTenantSpec", [
            { no: 1, name: "tenant_id_column_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tenant_id_column_type", kind: "enum", T: () => ["query.Type", Type] }
        ]);
    }
    create(value?: PartialMessage<MultiTenantSpec>): MultiTenantSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantIdColumnName = "";
        message.tenantIdColumnType = 0;
        if (value !== undefined)
            reflectionMergePartial<MultiTenantSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiTenantSpec): MultiTenantSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id_column_name */ 1:
                    message.tenantIdColumnName = reader.string();
                    break;
                case /* query.Type tenant_id_column_type */ 2:
                    message.tenantIdColumnType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiTenantSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id_column_name = 1; */
        if (message.tenantIdColumnName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantIdColumnName);
        /* query.Type tenant_id_column_type = 2; */
        if (message.tenantIdColumnType !== 0)
            writer.tag(2, WireType.Varint).int32(message.tenantIdColumnType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.MultiTenantSpec
 */
export const MultiTenantSpec = new MultiTenantSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vindex$Type extends MessageType<Vindex> {
    constructor() {
        super("vschema.Vindex", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Vindex>): Vindex {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.params = {};
        message.owner = "";
        if (value !== undefined)
            reflectionMergePartial<Vindex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vindex): Vindex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* map<string, string> params */ 2:
                    this.binaryReadMap2(message.params, reader, options);
                    break;
                case /* string owner */ 3:
                    message.owner = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Vindex["params"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Vindex["params"] | undefined, val: Vindex["params"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vschema.Vindex.params");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Vindex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* map<string, string> params = 2; */
        for (let k of globalThis.Object.keys(message.params))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.params[k]).join();
        /* string owner = 3; */
        if (message.owner !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.owner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.Vindex
 */
export const Vindex = new Vindex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Table$Type extends MessageType<Table> {
    constructor() {
        super("vschema.Table", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "column_vindexes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ColumnVindex },
            { no: 3, name: "auto_increment", kind: "message", T: () => AutoIncrement },
            { no: 4, name: "columns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Column },
            { no: 5, name: "pinned", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "column_list_authoritative", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Table>): Table {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = "";
        message.columnVindexes = [];
        message.columns = [];
        message.pinned = "";
        message.columnListAuthoritative = false;
        message.source = "";
        if (value !== undefined)
            reflectionMergePartial<Table>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Table): Table {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated vschema.ColumnVindex column_vindexes */ 2:
                    message.columnVindexes.push(ColumnVindex.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* vschema.AutoIncrement auto_increment */ 3:
                    message.autoIncrement = AutoIncrement.internalBinaryRead(reader, reader.uint32(), options, message.autoIncrement);
                    break;
                case /* repeated vschema.Column columns */ 4:
                    message.columns.push(Column.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string pinned */ 5:
                    message.pinned = reader.string();
                    break;
                case /* bool column_list_authoritative */ 6:
                    message.columnListAuthoritative = reader.bool();
                    break;
                case /* string source */ 7:
                    message.source = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Table, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated vschema.ColumnVindex column_vindexes = 2; */
        for (let i = 0; i < message.columnVindexes.length; i++)
            ColumnVindex.internalBinaryWrite(message.columnVindexes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vschema.AutoIncrement auto_increment = 3; */
        if (message.autoIncrement)
            AutoIncrement.internalBinaryWrite(message.autoIncrement, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated vschema.Column columns = 4; */
        for (let i = 0; i < message.columns.length; i++)
            Column.internalBinaryWrite(message.columns[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string pinned = 5; */
        if (message.pinned !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.pinned);
        /* bool column_list_authoritative = 6; */
        if (message.columnListAuthoritative !== false)
            writer.tag(6, WireType.Varint).bool(message.columnListAuthoritative);
        /* string source = 7; */
        if (message.source !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.source);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.Table
 */
export const Table = new Table$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnVindex$Type extends MessageType<ColumnVindex> {
    constructor() {
        super("vschema.ColumnVindex", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "columns", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ColumnVindex>): ColumnVindex {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.column = "";
        message.name = "";
        message.columns = [];
        if (value !== undefined)
            reflectionMergePartial<ColumnVindex>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ColumnVindex): ColumnVindex {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated string columns */ 3:
                    message.columns.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ColumnVindex, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated string columns = 3; */
        for (let i = 0; i < message.columns.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.columns[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.ColumnVindex
 */
export const ColumnVindex = new ColumnVindex$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoIncrement$Type extends MessageType<AutoIncrement> {
    constructor() {
        super("vschema.AutoIncrement", [
            { no: 1, name: "column", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sequence", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AutoIncrement>): AutoIncrement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.column = "";
        message.sequence = "";
        if (value !== undefined)
            reflectionMergePartial<AutoIncrement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoIncrement): AutoIncrement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string column */ 1:
                    message.column = reader.string();
                    break;
                case /* string sequence */ 2:
                    message.sequence = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoIncrement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string column = 1; */
        if (message.column !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.column);
        /* string sequence = 2; */
        if (message.sequence !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.AutoIncrement
 */
export const AutoIncrement = new AutoIncrement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Column$Type extends MessageType<Column> {
    constructor() {
        super("vschema.Column", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["query.Type", Type] },
            { no: 3, name: "invisible", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "default", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "collation_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "scale", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "nullable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "values", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Column>): Column {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = 0;
        message.invisible = false;
        message.default = "";
        message.collationName = "";
        message.size = 0;
        message.scale = 0;
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<Column>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Column): Column {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* query.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* bool invisible */ 3:
                    message.invisible = reader.bool();
                    break;
                case /* string default */ 4:
                    message.default = reader.string();
                    break;
                case /* string collation_name */ 5:
                    message.collationName = reader.string();
                    break;
                case /* int32 size */ 6:
                    message.size = reader.int32();
                    break;
                case /* int32 scale */ 7:
                    message.scale = reader.int32();
                    break;
                case /* optional bool nullable */ 8:
                    message.nullable = reader.bool();
                    break;
                case /* repeated string values */ 9:
                    message.values.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Column, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* query.Type type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* bool invisible = 3; */
        if (message.invisible !== false)
            writer.tag(3, WireType.Varint).bool(message.invisible);
        /* string default = 4; */
        if (message.default !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.default);
        /* string collation_name = 5; */
        if (message.collationName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.collationName);
        /* int32 size = 6; */
        if (message.size !== 0)
            writer.tag(6, WireType.Varint).int32(message.size);
        /* int32 scale = 7; */
        if (message.scale !== 0)
            writer.tag(7, WireType.Varint).int32(message.scale);
        /* optional bool nullable = 8; */
        if (message.nullable !== undefined)
            writer.tag(8, WireType.Varint).bool(message.nullable);
        /* repeated string values = 9; */
        for (let i = 0; i < message.values.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.values[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.Column
 */
export const Column = new Column$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SrvVSchema$Type extends MessageType<SrvVSchema> {
    constructor() {
        super("vschema.SrvVSchema", [
            { no: 1, name: "keyspaces", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Keyspace } },
            { no: 2, name: "routing_rules", kind: "message", T: () => RoutingRules },
            { no: 3, name: "shard_routing_rules", kind: "message", T: () => ShardRoutingRules },
            { no: 4, name: "keyspace_routing_rules", kind: "message", T: () => KeyspaceRoutingRules },
            { no: 5, name: "mirror_rules", kind: "message", T: () => MirrorRules }
        ]);
    }
    create(value?: PartialMessage<SrvVSchema>): SrvVSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaces = {};
        if (value !== undefined)
            reflectionMergePartial<SrvVSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SrvVSchema): SrvVSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vschema.Keyspace> keyspaces */ 1:
                    this.binaryReadMap1(message.keyspaces, reader, options);
                    break;
                case /* vschema.RoutingRules routing_rules */ 2:
                    message.routingRules = RoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.routingRules);
                    break;
                case /* vschema.ShardRoutingRules shard_routing_rules */ 3:
                    message.shardRoutingRules = ShardRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.shardRoutingRules);
                    break;
                case /* vschema.KeyspaceRoutingRules keyspace_routing_rules */ 4:
                    message.keyspaceRoutingRules = KeyspaceRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.keyspaceRoutingRules);
                    break;
                case /* vschema.MirrorRules mirror_rules */ 5:
                    message.mirrorRules = MirrorRules.internalBinaryRead(reader, reader.uint32(), options, message.mirrorRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SrvVSchema["keyspaces"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SrvVSchema["keyspaces"] | undefined, val: SrvVSchema["keyspaces"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Keyspace.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vschema.SrvVSchema.keyspaces");
            }
        }
        map[key ?? ""] = val ?? Keyspace.create();
    }
    internalBinaryWrite(message: SrvVSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vschema.Keyspace> keyspaces = 1; */
        for (let k of globalThis.Object.keys(message.keyspaces)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Keyspace.internalBinaryWrite(message.keyspaces[k], writer, options);
            writer.join().join();
        }
        /* vschema.RoutingRules routing_rules = 2; */
        if (message.routingRules)
            RoutingRules.internalBinaryWrite(message.routingRules, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vschema.ShardRoutingRules shard_routing_rules = 3; */
        if (message.shardRoutingRules)
            ShardRoutingRules.internalBinaryWrite(message.shardRoutingRules, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* vschema.KeyspaceRoutingRules keyspace_routing_rules = 4; */
        if (message.keyspaceRoutingRules)
            KeyspaceRoutingRules.internalBinaryWrite(message.keyspaceRoutingRules, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* vschema.MirrorRules mirror_rules = 5; */
        if (message.mirrorRules)
            MirrorRules.internalBinaryWrite(message.mirrorRules, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.SrvVSchema
 */
export const SrvVSchema = new SrvVSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardRoutingRules$Type extends MessageType<ShardRoutingRules> {
    constructor() {
        super("vschema.ShardRoutingRules", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardRoutingRule }
        ]);
    }
    create(value?: PartialMessage<ShardRoutingRules>): ShardRoutingRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<ShardRoutingRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardRoutingRules): ShardRoutingRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vschema.ShardRoutingRule rules */ 1:
                    message.rules.push(ShardRoutingRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardRoutingRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vschema.ShardRoutingRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            ShardRoutingRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.ShardRoutingRules
 */
export const ShardRoutingRules = new ShardRoutingRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardRoutingRule$Type extends MessageType<ShardRoutingRule> {
    constructor() {
        super("vschema.ShardRoutingRule", [
            { no: 1, name: "from_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShardRoutingRule>): ShardRoutingRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromKeyspace = "";
        message.toKeyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ShardRoutingRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardRoutingRule): ShardRoutingRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_keyspace */ 1:
                    message.fromKeyspace = reader.string();
                    break;
                case /* string to_keyspace */ 2:
                    message.toKeyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardRoutingRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_keyspace = 1; */
        if (message.fromKeyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromKeyspace);
        /* string to_keyspace = 2; */
        if (message.toKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toKeyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.ShardRoutingRule
 */
export const ShardRoutingRule = new ShardRoutingRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyspaceRoutingRules$Type extends MessageType<KeyspaceRoutingRules> {
    constructor() {
        super("vschema.KeyspaceRoutingRules", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyspaceRoutingRule }
        ]);
    }
    create(value?: PartialMessage<KeyspaceRoutingRules>): KeyspaceRoutingRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<KeyspaceRoutingRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyspaceRoutingRules): KeyspaceRoutingRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vschema.KeyspaceRoutingRule rules */ 1:
                    message.rules.push(KeyspaceRoutingRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyspaceRoutingRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vschema.KeyspaceRoutingRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            KeyspaceRoutingRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.KeyspaceRoutingRules
 */
export const KeyspaceRoutingRules = new KeyspaceRoutingRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyspaceRoutingRule$Type extends MessageType<KeyspaceRoutingRule> {
    constructor() {
        super("vschema.KeyspaceRoutingRule", [
            { no: 1, name: "from_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyspaceRoutingRule>): KeyspaceRoutingRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromKeyspace = "";
        message.toKeyspace = "";
        if (value !== undefined)
            reflectionMergePartial<KeyspaceRoutingRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyspaceRoutingRule): KeyspaceRoutingRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_keyspace */ 1:
                    message.fromKeyspace = reader.string();
                    break;
                case /* string to_keyspace */ 2:
                    message.toKeyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyspaceRoutingRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_keyspace = 1; */
        if (message.fromKeyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromKeyspace);
        /* string to_keyspace = 2; */
        if (message.toKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toKeyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.KeyspaceRoutingRule
 */
export const KeyspaceRoutingRule = new KeyspaceRoutingRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MirrorRules$Type extends MessageType<MirrorRules> {
    constructor() {
        super("vschema.MirrorRules", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MirrorRule }
        ]);
    }
    create(value?: PartialMessage<MirrorRules>): MirrorRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<MirrorRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MirrorRules): MirrorRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vschema.MirrorRule rules */ 1:
                    message.rules.push(MirrorRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MirrorRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vschema.MirrorRule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            MirrorRule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.MirrorRules
 */
export const MirrorRules = new MirrorRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MirrorRule$Type extends MessageType<MirrorRule> {
    constructor() {
        super("vschema.MirrorRule", [
            { no: 1, name: "from_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<MirrorRule>): MirrorRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromTable = "";
        message.toTable = "";
        message.percent = 0;
        if (value !== undefined)
            reflectionMergePartial<MirrorRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MirrorRule): MirrorRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_table */ 1:
                    message.fromTable = reader.string();
                    break;
                case /* string to_table */ 2:
                    message.toTable = reader.string();
                    break;
                case /* float percent */ 3:
                    message.percent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MirrorRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_table = 1; */
        if (message.fromTable !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromTable);
        /* string to_table = 2; */
        if (message.toTable !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toTable);
        /* float percent = 3; */
        if (message.percent !== 0)
            writer.tag(3, WireType.Bit32).float(message.percent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vschema.MirrorRule
 */
export const MirrorRule = new MirrorRule$Type();
