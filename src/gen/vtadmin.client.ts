// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtadmin.proto" (package "vtadmin", syntax proto3)
// tslint:disable
//
//
//Copyright 2020 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This package contains the types used by VTAdmin (and later an RPC service).
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { VTAdmin } from "./vtadmin";
import type { VTExplainResponse } from "./vtadmin";
import type { VTExplainRequest } from "./vtadmin";
import type { ValidateVersionShardResponse } from "./vtctldata";
import type { ValidateVersionShardRequest } from "./vtadmin";
import type { ValidateVersionKeyspaceResponse } from "./vtctldata";
import type { ValidateVersionKeyspaceRequest } from "./vtadmin";
import type { ValidateShardResponse } from "./vtctldata";
import type { ValidateShardRequest } from "./vtadmin";
import type { ValidateSchemaKeyspaceResponse } from "./vtctldata";
import type { ValidateSchemaKeyspaceRequest } from "./vtadmin";
import type { ValidateKeyspaceResponse } from "./vtctldata";
import type { ValidateKeyspaceRequest } from "./vtadmin";
import type { ValidateResponse } from "./vtctldata";
import type { ValidateRequest } from "./vtadmin";
import type { TabletExternallyPromotedResponse } from "./vtadmin";
import type { TabletExternallyPromotedRequest } from "./vtadmin";
import type { StopReplicationResponse } from "./vtadmin";
import type { StopReplicationRequest } from "./vtadmin";
import type { StartReplicationResponse } from "./vtadmin";
import type { StartReplicationRequest } from "./vtadmin";
import type { SetReadWriteResponse } from "./vtadmin";
import type { SetReadWriteRequest } from "./vtadmin";
import type { SetReadOnlyResponse } from "./vtadmin";
import type { SetReadOnlyRequest } from "./vtadmin";
import type { RunHealthCheckResponse } from "./vtadmin";
import type { RunHealthCheckRequest } from "./vtadmin";
import type { RetrySchemaMigrationResponse } from "./vtctldata";
import type { RetrySchemaMigrationRequest } from "./vtadmin";
import type { RemoveKeyspaceCellResponse } from "./vtadmin";
import type { RemoveKeyspaceCellRequest } from "./vtadmin";
import type { ReloadSchemaShardResponse } from "./vtadmin";
import type { ReloadSchemaShardRequest } from "./vtadmin";
import type { ReloadSchemasResponse } from "./vtadmin";
import type { ReloadSchemasRequest } from "./vtadmin";
import type { RefreshTabletReplicationSourceResponse } from "./vtadmin";
import type { RefreshTabletReplicationSourceRequest } from "./vtadmin";
import type { RefreshStateResponse } from "./vtadmin";
import type { RefreshStateRequest } from "./vtadmin";
import type { RebuildKeyspaceGraphResponse } from "./vtadmin";
import type { RebuildKeyspaceGraphRequest } from "./vtadmin";
import type { PlannedFailoverShardResponse } from "./vtadmin";
import type { PlannedFailoverShardRequest } from "./vtadmin";
import type { PingTabletResponse } from "./vtadmin";
import type { PingTabletRequest } from "./vtadmin";
import type { MoveTablesCreateRequest } from "./vtadmin";
import type { LaunchSchemaMigrationResponse } from "./vtctldata";
import type { LaunchSchemaMigrationRequest } from "./vtadmin";
import type { StopWorkflowRequest } from "./vtadmin";
import type { WorkflowUpdateResponse } from "./vtctldata";
import type { StartWorkflowRequest } from "./vtadmin";
import type { WorkflowStatusResponse } from "./vtctldata";
import type { GetWorkflowStatusRequest } from "./vtadmin";
import type { GetWorkflowsResponse } from "./vtadmin";
import type { GetWorkflowsRequest } from "./vtadmin";
import type { Workflow } from "./vtadmin";
import type { GetWorkflowRequest } from "./vtadmin";
import type { GetVtctldsResponse } from "./vtadmin";
import type { GetVtctldsRequest } from "./vtadmin";
import type { GetVSchemasResponse } from "./vtadmin";
import type { GetVSchemasRequest } from "./vtadmin";
import type { VSchema } from "./vtadmin";
import type { GetVSchemaRequest } from "./vtadmin";
import type { GetUnresolvedTransactionsResponse } from "./vtctldata";
import type { GetUnresolvedTransactionsRequest } from "./vtadmin";
import type { GetTopologyPathResponse } from "./vtctldata";
import type { GetTopologyPathRequest } from "./vtadmin";
import type { GetTabletsResponse } from "./vtadmin";
import type { GetTabletsRequest } from "./vtadmin";
import type { Tablet } from "./vtadmin";
import type { GetTabletRequest } from "./vtadmin";
import type { GetSrvVSchemasResponse } from "./vtadmin";
import type { GetSrvVSchemasRequest } from "./vtadmin";
import type { SrvVSchema } from "./vtadmin";
import type { GetSrvVSchemaRequest } from "./vtadmin";
import type { GetSrvKeyspacesResponse as GetSrvKeyspacesResponse$ } from "./vtadmin";
import type { GetSrvKeyspacesRequest } from "./vtadmin";
import type { GetSrvKeyspacesResponse } from "./vtctldata";
import type { GetSrvKeyspaceRequest } from "./vtadmin";
import type { GetShardReplicationPositionsResponse } from "./vtadmin";
import type { GetShardReplicationPositionsRequest } from "./vtadmin";
import type { GetSchemaMigrationsResponse } from "./vtadmin";
import type { GetSchemaMigrationsRequest } from "./vtadmin";
import type { GetSchemasResponse } from "./vtadmin";
import type { GetSchemasRequest } from "./vtadmin";
import type { GetSchemaRequest } from "./vtadmin";
import type { GetKeyspacesResponse } from "./vtadmin";
import type { GetKeyspacesRequest } from "./vtadmin";
import type { Keyspace } from "./vtadmin";
import type { GetKeyspaceRequest } from "./vtadmin";
import type { GetGatesResponse } from "./vtadmin";
import type { GetGatesRequest } from "./vtadmin";
import type { GetFullStatusResponse } from "./vtctldata";
import type { GetFullStatusRequest } from "./vtadmin";
import type { GetClustersResponse } from "./vtadmin";
import type { GetClustersRequest } from "./vtadmin";
import type { GetCellsAliasesResponse } from "./vtadmin";
import type { GetCellsAliasesRequest } from "./vtadmin";
import type { GetCellInfosResponse } from "./vtadmin";
import type { GetCellInfosRequest } from "./vtadmin";
import type { GetBackupsResponse } from "./vtadmin";
import type { GetBackupsRequest } from "./vtadmin";
import type { Schema } from "./vtadmin";
import type { FindSchemaRequest } from "./vtadmin";
import type { EmergencyFailoverShardResponse } from "./vtadmin";
import type { EmergencyFailoverShardRequest } from "./vtadmin";
import type { DeleteTabletResponse } from "./vtadmin";
import type { DeleteTabletRequest } from "./vtadmin";
import type { DeleteShardsResponse } from "./vtctldata";
import type { DeleteShardsRequest } from "./vtadmin";
import type { DeleteKeyspaceResponse } from "./vtctldata";
import type { DeleteKeyspaceRequest } from "./vtadmin";
import type { CreateShardResponse } from "./vtctldata";
import type { CreateShardRequest } from "./vtadmin";
import type { CreateKeyspaceResponse } from "./vtadmin";
import type { CreateKeyspaceRequest } from "./vtadmin";
import type { ConcludeTransactionResponse } from "./vtctldata";
import type { ConcludeTransactionRequest } from "./vtadmin";
import type { CompleteSchemaMigrationResponse } from "./vtctldata";
import type { CompleteSchemaMigrationRequest } from "./vtadmin";
import type { CleanupSchemaMigrationResponse } from "./vtctldata";
import type { CleanupSchemaMigrationRequest } from "./vtadmin";
import type { CancelSchemaMigrationResponse } from "./vtctldata";
import type { CancelSchemaMigrationRequest } from "./vtadmin";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ApplySchemaResponse } from "./vtctldata";
import type { ApplySchemaRequest } from "./vtadmin";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
// Services 

/**
 * VTAdmin is the Vitess Admin API service. It provides RPCs that operate on
 * across a range of Vitess clusters.
 *
 * @generated from protobuf service vtadmin.VTAdmin
 */
export interface IVTAdminClient {
    /**
     * ApplySchema applies a schema to a keyspace in the given cluster.
     *
     * @generated from protobuf rpc: ApplySchema(vtadmin.ApplySchemaRequest) returns (vtctldata.ApplySchemaResponse);
     */
    applySchema(input: ApplySchemaRequest, options?: RpcOptions): UnaryCall<ApplySchemaRequest, ApplySchemaResponse>;
    /**
     * CancelSchemaMigration cancels one or all schema migrations in the given
     * cluster, terminating any running ones as needed.
     *
     * @generated from protobuf rpc: CancelSchemaMigration(vtadmin.CancelSchemaMigrationRequest) returns (vtctldata.CancelSchemaMigrationResponse);
     */
    cancelSchemaMigration(input: CancelSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse>;
    /**
     * CleanupSchemaMigration marks a schema migration in the given cluster as
     * ready for artifact cleanup.
     *
     * @generated from protobuf rpc: CleanupSchemaMigration(vtadmin.CleanupSchemaMigrationRequest) returns (vtctldata.CleanupSchemaMigrationResponse);
     */
    cleanupSchemaMigration(input: CleanupSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse>;
    /**
     * CompleteSchemaMigration completes one or all migrations in the given
     * cluster executed with --postpone-completion.
     *
     * @generated from protobuf rpc: CompleteSchemaMigration(vtadmin.CompleteSchemaMigrationRequest) returns (vtctldata.CompleteSchemaMigrationResponse);
     */
    completeSchemaMigration(input: CompleteSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse>;
    /**
     * ConcludeTransaction concludes a distributed transaction identified by the provided dtid.
     *
     * @generated from protobuf rpc: ConcludeTransaction(vtadmin.ConcludeTransactionRequest) returns (vtctldata.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse>;
    /**
     * CreateKeyspace creates a new keyspace in the given cluster.
     *
     * @generated from protobuf rpc: CreateKeyspace(vtadmin.CreateKeyspaceRequest) returns (vtadmin.CreateKeyspaceResponse);
     */
    createKeyspace(input: CreateKeyspaceRequest, options?: RpcOptions): UnaryCall<CreateKeyspaceRequest, CreateKeyspaceResponse>;
    /**
     * CreateShard creates a new shard in the given cluster and keyspace.
     *
     * @generated from protobuf rpc: CreateShard(vtadmin.CreateShardRequest) returns (vtctldata.CreateShardResponse);
     */
    createShard(input: CreateShardRequest, options?: RpcOptions): UnaryCall<CreateShardRequest, CreateShardResponse>;
    /**
     * DeleteKeyspace deletes a keyspace in the given cluster.
     *
     * @generated from protobuf rpc: DeleteKeyspace(vtadmin.DeleteKeyspaceRequest) returns (vtctldata.DeleteKeyspaceResponse);
     */
    deleteKeyspace(input: DeleteKeyspaceRequest, options?: RpcOptions): UnaryCall<DeleteKeyspaceRequest, DeleteKeyspaceResponse>;
    /**
     * DeleteShard deletes one or more shards in the given cluster and keyspace.
     *
     * @generated from protobuf rpc: DeleteShards(vtadmin.DeleteShardsRequest) returns (vtctldata.DeleteShardsResponse);
     */
    deleteShards(input: DeleteShardsRequest, options?: RpcOptions): UnaryCall<DeleteShardsRequest, DeleteShardsResponse>;
    /**
     * DeleteTablet deletes a tablet from the topology
     *
     * @generated from protobuf rpc: DeleteTablet(vtadmin.DeleteTabletRequest) returns (vtadmin.DeleteTabletResponse);
     */
    deleteTablet(input: DeleteTabletRequest, options?: RpcOptions): UnaryCall<DeleteTabletRequest, DeleteTabletResponse>;
    /**
     * EmergencyFailoverShard fails over a shard to a new primary. It assumes
     * the old primary is dead or otherwise not responding.
     *
     * @generated from protobuf rpc: EmergencyFailoverShard(vtadmin.EmergencyFailoverShardRequest) returns (vtadmin.EmergencyFailoverShardResponse);
     */
    emergencyFailoverShard(input: EmergencyFailoverShardRequest, options?: RpcOptions): UnaryCall<EmergencyFailoverShardRequest, EmergencyFailoverShardResponse>;
    /**
     * FindSchema returns a single Schema that matches the provided table name
     * across all specified clusters IDs. Not specifying a set of cluster IDs
     * causes the search to span all configured clusters.
     *
     * An error occurs if either no table exists across any of the clusters with
     * the specified table name, or if multiple tables exist with that name.
     *
     * @generated from protobuf rpc: FindSchema(vtadmin.FindSchemaRequest) returns (vtadmin.Schema);
     */
    findSchema(input: FindSchemaRequest, options?: RpcOptions): UnaryCall<FindSchemaRequest, Schema>;
    /**
     * GetBackups returns backups grouped by cluster.
     *
     * @generated from protobuf rpc: GetBackups(vtadmin.GetBackupsRequest) returns (vtadmin.GetBackupsResponse);
     */
    getBackups(input: GetBackupsRequest, options?: RpcOptions): UnaryCall<GetBackupsRequest, GetBackupsResponse>;
    /**
     * GetCellInfos returns the CellInfo objects for the specified clusters.
     *
     * Callers may optionally restrict the set of CellInfos, or restrict the
     * response to include only cell names.
     *
     * @generated from protobuf rpc: GetCellInfos(vtadmin.GetCellInfosRequest) returns (vtadmin.GetCellInfosResponse);
     */
    getCellInfos(input: GetCellInfosRequest, options?: RpcOptions): UnaryCall<GetCellInfosRequest, GetCellInfosResponse>;
    /**
     * GetCellsAliases returns the CellsAliases data for the specified clusters.
     *
     * @generated from protobuf rpc: GetCellsAliases(vtadmin.GetCellsAliasesRequest) returns (vtadmin.GetCellsAliasesResponse);
     */
    getCellsAliases(input: GetCellsAliasesRequest, options?: RpcOptions): UnaryCall<GetCellsAliasesRequest, GetCellsAliasesResponse>;
    /**
     * GetClusters returns all configured clusters.
     *
     * @generated from protobuf rpc: GetClusters(vtadmin.GetClustersRequest) returns (vtadmin.GetClustersResponse);
     */
    getClusters(input: GetClustersRequest, options?: RpcOptions): UnaryCall<GetClustersRequest, GetClustersResponse>;
    /**
     * GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
     *
     * @generated from protobuf rpc: GetFullStatus(vtadmin.GetFullStatusRequest) returns (vtctldata.GetFullStatusResponse);
     */
    getFullStatus(input: GetFullStatusRequest, options?: RpcOptions): UnaryCall<GetFullStatusRequest, GetFullStatusResponse>;
    /**
     * GetGates returns all gates across all the specified clusters.
     *
     * @generated from protobuf rpc: GetGates(vtadmin.GetGatesRequest) returns (vtadmin.GetGatesResponse);
     */
    getGates(input: GetGatesRequest, options?: RpcOptions): UnaryCall<GetGatesRequest, GetGatesResponse>;
    /**
     * GetKeyspace returns a keyspace by name in the specified cluster.
     *
     * @generated from protobuf rpc: GetKeyspace(vtadmin.GetKeyspaceRequest) returns (vtadmin.Keyspace);
     */
    getKeyspace(input: GetKeyspaceRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRequest, Keyspace>;
    /**
     * GetKeyspaces returns all keyspaces across the specified clusters.
     *
     * @generated from protobuf rpc: GetKeyspaces(vtadmin.GetKeyspacesRequest) returns (vtadmin.GetKeyspacesResponse);
     */
    getKeyspaces(input: GetKeyspacesRequest, options?: RpcOptions): UnaryCall<GetKeyspacesRequest, GetKeyspacesResponse>;
    /**
     * GetSchema returns the schema for the specified (cluster, keyspace, table)
     * tuple.
     *
     * @generated from protobuf rpc: GetSchema(vtadmin.GetSchemaRequest) returns (vtadmin.Schema);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): UnaryCall<GetSchemaRequest, Schema>;
    /**
     * GetSchemas returns all schemas across the specified clusters.
     *
     * @generated from protobuf rpc: GetSchemas(vtadmin.GetSchemasRequest) returns (vtadmin.GetSchemasResponse);
     */
    getSchemas(input: GetSchemasRequest, options?: RpcOptions): UnaryCall<GetSchemasRequest, GetSchemasResponse>;
    /**
     * GetSchemaMigrations returns one or more online schema migrations for the
     * set of keyspaces (or all keyspaces) in the given clusters, analagous to
     * repeated executions of `SHOW VITESS_MIGRATIONS`.
     *
     * Different fields in the request message result in different behaviors.
     * See the documentation on vtctldata.GetSchemaMigrationsRequest for details.
     *
     * @generated from protobuf rpc: GetSchemaMigrations(vtadmin.GetSchemaMigrationsRequest) returns (vtadmin.GetSchemaMigrationsResponse);
     */
    getSchemaMigrations(input: GetSchemaMigrationsRequest, options?: RpcOptions): UnaryCall<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse>;
    /**
     * GetShardReplicationPositions returns shard replication positions grouped
     * by cluster.
     *
     * @generated from protobuf rpc: GetShardReplicationPositions(vtadmin.GetShardReplicationPositionsRequest) returns (vtadmin.GetShardReplicationPositionsResponse);
     */
    getShardReplicationPositions(input: GetShardReplicationPositionsRequest, options?: RpcOptions): UnaryCall<GetShardReplicationPositionsRequest, GetShardReplicationPositionsResponse>;
    /**
     * GetSrvKeyspace returns the SrvKeyspace for a keyspace in one or more cells.
     *
     * @generated from protobuf rpc: GetSrvKeyspace(vtadmin.GetSrvKeyspaceRequest) returns (vtctldata.GetSrvKeyspacesResponse);
     */
    getSrvKeyspace(input: GetSrvKeyspaceRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspaceRequest, GetSrvKeyspacesResponse>;
    /**
     * GetSrvKeyspaces returns the SrvKeyspaces for all keyspaces across all the specified clusters.
     *
     * @generated from protobuf rpc: GetSrvKeyspaces(vtadmin.GetSrvKeyspacesRequest) returns (vtadmin.GetSrvKeyspacesResponse);
     */
    getSrvKeyspaces(input: GetSrvKeyspacesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse$>;
    /**
     * GetSrvVSchema returns the SrvVSchema for the given cluster and cell.
     *
     * @generated from protobuf rpc: GetSrvVSchema(vtadmin.GetSrvVSchemaRequest) returns (vtadmin.SrvVSchema);
     */
    getSrvVSchema(input: GetSrvVSchemaRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemaRequest, SrvVSchema>;
    /**
     * GetSrvVSchemas returns all SrvVSchemas across all (or specified) clusters
     * and cells.
     *
     * @generated from protobuf rpc: GetSrvVSchemas(vtadmin.GetSrvVSchemasRequest) returns (vtadmin.GetSrvVSchemasResponse);
     */
    getSrvVSchemas(input: GetSrvVSchemasRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemasRequest, GetSrvVSchemasResponse>;
    /**
     * GetTablet looks up a tablet by hostname across all clusters and returns
     * the result.
     *
     * @generated from protobuf rpc: GetTablet(vtadmin.GetTabletRequest) returns (vtadmin.Tablet);
     */
    getTablet(input: GetTabletRequest, options?: RpcOptions): UnaryCall<GetTabletRequest, Tablet>;
    /**
     * GetTablets returns all tablets across all the specified clusters.
     *
     * @generated from protobuf rpc: GetTablets(vtadmin.GetTabletsRequest) returns (vtadmin.GetTabletsResponse);
     */
    getTablets(input: GetTabletsRequest, options?: RpcOptions): UnaryCall<GetTabletsRequest, GetTabletsResponse>;
    /**
     * GetTopologyPath returns the cell located at the specified path in the topology server.
     *
     * @generated from protobuf rpc: GetTopologyPath(vtadmin.GetTopologyPathRequest) returns (vtctldata.GetTopologyPathResponse);
     */
    getTopologyPath(input: GetTopologyPathRequest, options?: RpcOptions): UnaryCall<GetTopologyPathRequest, GetTopologyPathResponse>;
    /**
     * GetUnresolvedTransactions returns the unresolved transactions for the request.
     *
     * @generated from protobuf rpc: GetUnresolvedTransactions(vtadmin.GetUnresolvedTransactionsRequest) returns (vtctldata.GetUnresolvedTransactionsResponse);
     */
    getUnresolvedTransactions(input: GetUnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse>;
    /**
     * GetVSchema returns a VSchema for the specified keyspace in the specified
     * cluster.
     *
     * @generated from protobuf rpc: GetVSchema(vtadmin.GetVSchemaRequest) returns (vtadmin.VSchema);
     */
    getVSchema(input: GetVSchemaRequest, options?: RpcOptions): UnaryCall<GetVSchemaRequest, VSchema>;
    /**
     * GetVSchemas returns the VSchemas for all specified clusters.
     *
     * @generated from protobuf rpc: GetVSchemas(vtadmin.GetVSchemasRequest) returns (vtadmin.GetVSchemasResponse);
     */
    getVSchemas(input: GetVSchemasRequest, options?: RpcOptions): UnaryCall<GetVSchemasRequest, GetVSchemasResponse>;
    /**
     * GetVtctlds returns the Vtctlds for all specified clusters.
     *
     * @generated from protobuf rpc: GetVtctlds(vtadmin.GetVtctldsRequest) returns (vtadmin.GetVtctldsResponse);
     */
    getVtctlds(input: GetVtctldsRequest, options?: RpcOptions): UnaryCall<GetVtctldsRequest, GetVtctldsResponse>;
    /**
     * GetWorkflow returns a single Workflow for a given cluster, keyspace, and
     * workflow name.
     *
     * @generated from protobuf rpc: GetWorkflow(vtadmin.GetWorkflowRequest) returns (vtadmin.Workflow);
     */
    getWorkflow(input: GetWorkflowRequest, options?: RpcOptions): UnaryCall<GetWorkflowRequest, Workflow>;
    /**
     * GetWorkflows returns the Workflows for all specified clusters.
     *
     * @generated from protobuf rpc: GetWorkflows(vtadmin.GetWorkflowsRequest) returns (vtadmin.GetWorkflowsResponse);
     */
    getWorkflows(input: GetWorkflowsRequest, options?: RpcOptions): UnaryCall<GetWorkflowsRequest, GetWorkflowsResponse>;
    /**
     * GetWorkflowStatus returns the status for a specific workflow.
     *
     * @generated from protobuf rpc: GetWorkflowStatus(vtadmin.GetWorkflowStatusRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    getWorkflowStatus(input: GetWorkflowStatusRequest, options?: RpcOptions): UnaryCall<GetWorkflowStatusRequest, WorkflowStatusResponse>;
    /**
     * StartWorkflow starts a vreplication workflow.
     *
     * @generated from protobuf rpc: StartWorkflow(vtadmin.StartWorkflowRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    startWorkflow(input: StartWorkflowRequest, options?: RpcOptions): UnaryCall<StartWorkflowRequest, WorkflowUpdateResponse>;
    /**
     * StopWorkflow stops a vreplication workflow.
     *
     * @generated from protobuf rpc: StopWorkflow(vtadmin.StopWorkflowRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    stopWorkflow(input: StopWorkflowRequest, options?: RpcOptions): UnaryCall<StopWorkflowRequest, WorkflowUpdateResponse>;
    /**
     * LaunchSchemaMigration launches one or all migrations in the given
     * cluster executed with --postpone-launch.
     *
     * @generated from protobuf rpc: LaunchSchemaMigration(vtadmin.LaunchSchemaMigrationRequest) returns (vtctldata.LaunchSchemaMigrationResponse);
     */
    launchSchemaMigration(input: LaunchSchemaMigrationRequest, options?: RpcOptions): UnaryCall<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse>;
    /**
     * MoveTablesCreate creates a workflow which moves one or more tables from a
     * source keyspace to a target keyspace.
     *
     * @generated from protobuf rpc: MoveTablesCreate(vtadmin.MoveTablesCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    moveTablesCreate(input: MoveTablesCreateRequest, options?: RpcOptions): UnaryCall<MoveTablesCreateRequest, WorkflowStatusResponse>;
    /**
     * PingTablet checks that the specified tablet is awake and responding to
     * RPCs. This command can be blocked by other in-flight operations.
     *
     * @generated from protobuf rpc: PingTablet(vtadmin.PingTabletRequest) returns (vtadmin.PingTabletResponse);
     */
    pingTablet(input: PingTabletRequest, options?: RpcOptions): UnaryCall<PingTabletRequest, PingTabletResponse>;
    /**
     * PlannedFailoverShard fails over the shard to a new primary, or away from
     * an old primary. Both the old and new primaries must be reachable and
     * running.
     *
     * NOTE: A planned failover will not consider replicas outside the current
     * shard primary's cell as promotion candidates unless NewPrimary is
     * explicitly provided in the request.
     *
     * @generated from protobuf rpc: PlannedFailoverShard(vtadmin.PlannedFailoverShardRequest) returns (vtadmin.PlannedFailoverShardResponse);
     */
    plannedFailoverShard(input: PlannedFailoverShardRequest, options?: RpcOptions): UnaryCall<PlannedFailoverShardRequest, PlannedFailoverShardResponse>;
    /**
     * RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
     *
     * @generated from protobuf rpc: RebuildKeyspaceGraph(vtadmin.RebuildKeyspaceGraphRequest) returns (vtadmin.RebuildKeyspaceGraphResponse);
     */
    rebuildKeyspaceGraph(input: RebuildKeyspaceGraphRequest, options?: RpcOptions): UnaryCall<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse>;
    /**
     * RefreshState reloads the tablet record on the specified tablet.
     *
     * @generated from protobuf rpc: RefreshState(vtadmin.RefreshStateRequest) returns (vtadmin.RefreshStateResponse);
     */
    refreshState(input: RefreshStateRequest, options?: RpcOptions): UnaryCall<RefreshStateRequest, RefreshStateResponse>;
    /**
     * RefreshTabletReplicationSource performs a `CHANGE REPLICATION SOURCE TO`
     * on a tablet to replicate from the current primary in the shard.
     *
     * @generated from protobuf rpc: RefreshTabletReplicationSource(vtadmin.RefreshTabletReplicationSourceRequest) returns (vtadmin.RefreshTabletReplicationSourceResponse);
     */
    refreshTabletReplicationSource(input: RefreshTabletReplicationSourceRequest, options?: RpcOptions): UnaryCall<RefreshTabletReplicationSourceRequest, RefreshTabletReplicationSourceResponse>;
    /**
     * ReloadSchemas reloads the schema definition across keyspaces, shards, or
     * tablets in one or more clusters, depending on the request fields (see
     * ReloadSchemasRequest for details).
     *
     * @generated from protobuf rpc: ReloadSchemas(vtadmin.ReloadSchemasRequest) returns (vtadmin.ReloadSchemasResponse);
     */
    reloadSchemas(input: ReloadSchemasRequest, options?: RpcOptions): UnaryCall<ReloadSchemasRequest, ReloadSchemasResponse>;
    /**
     * ReloadSchemaShard reloads the schema on all tablets in a shard. This is done on a best-effort basis.
     *
     * @generated from protobuf rpc: ReloadSchemaShard(vtadmin.ReloadSchemaShardRequest) returns (vtadmin.ReloadSchemaShardResponse);
     */
    reloadSchemaShard(input: ReloadSchemaShardRequest, options?: RpcOptions): UnaryCall<ReloadSchemaShardRequest, ReloadSchemaShardResponse>;
    /**
     * RemoveKeyspaceCell removes the cell from the Cells list for all shards in the keyspace, and the SrvKeyspace for that keyspace in that cell.
     *
     * @generated from protobuf rpc: RemoveKeyspaceCell(vtadmin.RemoveKeyspaceCellRequest) returns (vtadmin.RemoveKeyspaceCellResponse);
     */
    removeKeyspaceCell(input: RemoveKeyspaceCellRequest, options?: RpcOptions): UnaryCall<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse>;
    /**
     * RetrySchemaMigration marks a given schema migration in the given cluster
     * for retry.
     *
     * @generated from protobuf rpc: RetrySchemaMigration(vtadmin.RetrySchemaMigrationRequest) returns (vtctldata.RetrySchemaMigrationResponse);
     */
    retrySchemaMigration(input: RetrySchemaMigrationRequest, options?: RpcOptions): UnaryCall<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse>;
    /**
     * RunHealthCheck runs a healthcheck on the tablet.
     *
     * @generated from protobuf rpc: RunHealthCheck(vtadmin.RunHealthCheckRequest) returns (vtadmin.RunHealthCheckResponse);
     */
    runHealthCheck(input: RunHealthCheckRequest, options?: RpcOptions): UnaryCall<RunHealthCheckRequest, RunHealthCheckResponse>;
    /**
     * SetReadOnly sets the tablet to read-only mode.
     *
     * @generated from protobuf rpc: SetReadOnly(vtadmin.SetReadOnlyRequest) returns (vtadmin.SetReadOnlyResponse);
     */
    setReadOnly(input: SetReadOnlyRequest, options?: RpcOptions): UnaryCall<SetReadOnlyRequest, SetReadOnlyResponse>;
    /**
     * SetReadWrite sets the tablet to read-write mode.
     *
     * @generated from protobuf rpc: SetReadWrite(vtadmin.SetReadWriteRequest) returns (vtadmin.SetReadWriteResponse);
     */
    setReadWrite(input: SetReadWriteRequest, options?: RpcOptions): UnaryCall<SetReadWriteRequest, SetReadWriteResponse>;
    /**
     * StartReplication runs the underlying database command to start
     * replication on a tablet.
     *
     * @generated from protobuf rpc: StartReplication(vtadmin.StartReplicationRequest) returns (vtadmin.StartReplicationResponse);
     */
    startReplication(input: StartReplicationRequest, options?: RpcOptions): UnaryCall<StartReplicationRequest, StartReplicationResponse>;
    /**
     * StopReplication runs the underlying database command to stop replication
     * on a tablet
     *
     * @generated from protobuf rpc: StopReplication(vtadmin.StopReplicationRequest) returns (vtadmin.StopReplicationResponse);
     */
    stopReplication(input: StopReplicationRequest, options?: RpcOptions): UnaryCall<StopReplicationRequest, StopReplicationResponse>;
    /**
     * TabletExternallyPromoted updates the metadata in a cluster's topology
     * to acknowledge a shard primary change performed by an external tool
     * (e.g. orchestrator*).
     *
     * See the Reparenting guide for more information:
     * https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
     *
     * * "orchestrator" here refers to external orchestrator, not the newer,
     * Vitess-aware orchestrator, VTOrc.
     *
     * @generated from protobuf rpc: TabletExternallyPromoted(vtadmin.TabletExternallyPromotedRequest) returns (vtadmin.TabletExternallyPromotedResponse);
     */
    tabletExternallyPromoted(input: TabletExternallyPromotedRequest, options?: RpcOptions): UnaryCall<TabletExternallyPromotedRequest, TabletExternallyPromotedResponse>;
    /**
     * Validate validates all nodes in a cluster that are reachable from the global replication graph,
     * as well as all tablets in discoverable cells, are consistent
     *
     * @generated from protobuf rpc: Validate(vtadmin.ValidateRequest) returns (vtctldata.ValidateResponse);
     */
    validate(input: ValidateRequest, options?: RpcOptions): UnaryCall<ValidateRequest, ValidateResponse>;
    /**
     * ValidateKeyspace validates that all nodes reachable from the specified
     * keyspace are consistent.
     *
     * @generated from protobuf rpc: ValidateKeyspace(vtadmin.ValidateKeyspaceRequest) returns (vtctldata.ValidateKeyspaceResponse);
     */
    validateKeyspace(input: ValidateKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateKeyspaceRequest, ValidateKeyspaceResponse>;
    /**
     * ValidateSchemaKeyspace validates that the schema on the primary tablet
     * for shard 0 matches the schema on all of the other tablets in the
     * keyspace.
     *
     * @generated from protobuf rpc: ValidateSchemaKeyspace(vtadmin.ValidateSchemaKeyspaceRequest) returns (vtctldata.ValidateSchemaKeyspaceResponse);
     */
    validateSchemaKeyspace(input: ValidateSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse>;
    /**
     * ValidateShard validates that that all nodes reachable from the specified shard are consistent.
     *
     * @generated from protobuf rpc: ValidateShard(vtadmin.ValidateShardRequest) returns (vtctldata.ValidateShardResponse);
     */
    validateShard(input: ValidateShardRequest, options?: RpcOptions): UnaryCall<ValidateShardRequest, ValidateShardResponse>;
    /**
     * ValidateVersionKeyspace validates that the version on the primary of
     * shard 0 matches all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateVersionKeyspace(vtadmin.ValidateVersionKeyspaceRequest) returns (vtctldata.ValidateVersionKeyspaceResponse);
     */
    validateVersionKeyspace(input: ValidateVersionKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse>;
    /**
     * ValidateVersionShard validates that the version on the primary matches all of the replicas.
     *
     * @generated from protobuf rpc: ValidateVersionShard(vtadmin.ValidateVersionShardRequest) returns (vtctldata.ValidateVersionShardResponse);
     */
    validateVersionShard(input: ValidateVersionShardRequest, options?: RpcOptions): UnaryCall<ValidateVersionShardRequest, ValidateVersionShardResponse>;
    /**
     * VTExplain provides information on how Vitess plans to execute a
     * particular query.
     *
     * @generated from protobuf rpc: VTExplain(vtadmin.VTExplainRequest) returns (vtadmin.VTExplainResponse);
     */
    vTExplain(input: VTExplainRequest, options?: RpcOptions): UnaryCall<VTExplainRequest, VTExplainResponse>;
}
// Services 

/**
 * VTAdmin is the Vitess Admin API service. It provides RPCs that operate on
 * across a range of Vitess clusters.
 *
 * @generated from protobuf service vtadmin.VTAdmin
 */
export class VTAdminClient implements IVTAdminClient, ServiceInfo {
    typeName = VTAdmin.typeName;
    methods = VTAdmin.methods;
    options = VTAdmin.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * ApplySchema applies a schema to a keyspace in the given cluster.
     *
     * @generated from protobuf rpc: ApplySchema(vtadmin.ApplySchemaRequest) returns (vtctldata.ApplySchemaResponse);
     */
    applySchema(input: ApplySchemaRequest, options?: RpcOptions): UnaryCall<ApplySchemaRequest, ApplySchemaResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplySchemaRequest, ApplySchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CancelSchemaMigration cancels one or all schema migrations in the given
     * cluster, terminating any running ones as needed.
     *
     * @generated from protobuf rpc: CancelSchemaMigration(vtadmin.CancelSchemaMigrationRequest) returns (vtctldata.CancelSchemaMigrationResponse);
     */
    cancelSchemaMigration(input: CancelSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CleanupSchemaMigration marks a schema migration in the given cluster as
     * ready for artifact cleanup.
     *
     * @generated from protobuf rpc: CleanupSchemaMigration(vtadmin.CleanupSchemaMigrationRequest) returns (vtctldata.CleanupSchemaMigrationResponse);
     */
    cleanupSchemaMigration(input: CleanupSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CompleteSchemaMigration completes one or all migrations in the given
     * cluster executed with --postpone-completion.
     *
     * @generated from protobuf rpc: CompleteSchemaMigration(vtadmin.CompleteSchemaMigrationRequest) returns (vtctldata.CompleteSchemaMigrationResponse);
     */
    completeSchemaMigration(input: CompleteSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ConcludeTransaction concludes a distributed transaction identified by the provided dtid.
     *
     * @generated from protobuf rpc: ConcludeTransaction(vtadmin.ConcludeTransactionRequest) returns (vtctldata.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<ConcludeTransactionRequest, ConcludeTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateKeyspace creates a new keyspace in the given cluster.
     *
     * @generated from protobuf rpc: CreateKeyspace(vtadmin.CreateKeyspaceRequest) returns (vtadmin.CreateKeyspaceResponse);
     */
    createKeyspace(input: CreateKeyspaceRequest, options?: RpcOptions): UnaryCall<CreateKeyspaceRequest, CreateKeyspaceResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateKeyspaceRequest, CreateKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateShard creates a new shard in the given cluster and keyspace.
     *
     * @generated from protobuf rpc: CreateShard(vtadmin.CreateShardRequest) returns (vtctldata.CreateShardResponse);
     */
    createShard(input: CreateShardRequest, options?: RpcOptions): UnaryCall<CreateShardRequest, CreateShardResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateShardRequest, CreateShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteKeyspace deletes a keyspace in the given cluster.
     *
     * @generated from protobuf rpc: DeleteKeyspace(vtadmin.DeleteKeyspaceRequest) returns (vtctldata.DeleteKeyspaceResponse);
     */
    deleteKeyspace(input: DeleteKeyspaceRequest, options?: RpcOptions): UnaryCall<DeleteKeyspaceRequest, DeleteKeyspaceResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteKeyspaceRequest, DeleteKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteShard deletes one or more shards in the given cluster and keyspace.
     *
     * @generated from protobuf rpc: DeleteShards(vtadmin.DeleteShardsRequest) returns (vtctldata.DeleteShardsResponse);
     */
    deleteShards(input: DeleteShardsRequest, options?: RpcOptions): UnaryCall<DeleteShardsRequest, DeleteShardsResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteShardsRequest, DeleteShardsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteTablet deletes a tablet from the topology
     *
     * @generated from protobuf rpc: DeleteTablet(vtadmin.DeleteTabletRequest) returns (vtadmin.DeleteTabletResponse);
     */
    deleteTablet(input: DeleteTabletRequest, options?: RpcOptions): UnaryCall<DeleteTabletRequest, DeleteTabletResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteTabletRequest, DeleteTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * EmergencyFailoverShard fails over a shard to a new primary. It assumes
     * the old primary is dead or otherwise not responding.
     *
     * @generated from protobuf rpc: EmergencyFailoverShard(vtadmin.EmergencyFailoverShardRequest) returns (vtadmin.EmergencyFailoverShardResponse);
     */
    emergencyFailoverShard(input: EmergencyFailoverShardRequest, options?: RpcOptions): UnaryCall<EmergencyFailoverShardRequest, EmergencyFailoverShardResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<EmergencyFailoverShardRequest, EmergencyFailoverShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * FindSchema returns a single Schema that matches the provided table name
     * across all specified clusters IDs. Not specifying a set of cluster IDs
     * causes the search to span all configured clusters.
     *
     * An error occurs if either no table exists across any of the clusters with
     * the specified table name, or if multiple tables exist with that name.
     *
     * @generated from protobuf rpc: FindSchema(vtadmin.FindSchemaRequest) returns (vtadmin.Schema);
     */
    findSchema(input: FindSchemaRequest, options?: RpcOptions): UnaryCall<FindSchemaRequest, Schema> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<FindSchemaRequest, Schema>("unary", this._transport, method, opt, input);
    }
    /**
     * GetBackups returns backups grouped by cluster.
     *
     * @generated from protobuf rpc: GetBackups(vtadmin.GetBackupsRequest) returns (vtadmin.GetBackupsResponse);
     */
    getBackups(input: GetBackupsRequest, options?: RpcOptions): UnaryCall<GetBackupsRequest, GetBackupsResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetBackupsRequest, GetBackupsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCellInfos returns the CellInfo objects for the specified clusters.
     *
     * Callers may optionally restrict the set of CellInfos, or restrict the
     * response to include only cell names.
     *
     * @generated from protobuf rpc: GetCellInfos(vtadmin.GetCellInfosRequest) returns (vtadmin.GetCellInfosResponse);
     */
    getCellInfos(input: GetCellInfosRequest, options?: RpcOptions): UnaryCall<GetCellInfosRequest, GetCellInfosResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCellInfosRequest, GetCellInfosResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCellsAliases returns the CellsAliases data for the specified clusters.
     *
     * @generated from protobuf rpc: GetCellsAliases(vtadmin.GetCellsAliasesRequest) returns (vtadmin.GetCellsAliasesResponse);
     */
    getCellsAliases(input: GetCellsAliasesRequest, options?: RpcOptions): UnaryCall<GetCellsAliasesRequest, GetCellsAliasesResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCellsAliasesRequest, GetCellsAliasesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetClusters returns all configured clusters.
     *
     * @generated from protobuf rpc: GetClusters(vtadmin.GetClustersRequest) returns (vtadmin.GetClustersResponse);
     */
    getClusters(input: GetClustersRequest, options?: RpcOptions): UnaryCall<GetClustersRequest, GetClustersResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetClustersRequest, GetClustersResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
     *
     * @generated from protobuf rpc: GetFullStatus(vtadmin.GetFullStatusRequest) returns (vtctldata.GetFullStatusResponse);
     */
    getFullStatus(input: GetFullStatusRequest, options?: RpcOptions): UnaryCall<GetFullStatusRequest, GetFullStatusResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetFullStatusRequest, GetFullStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetGates returns all gates across all the specified clusters.
     *
     * @generated from protobuf rpc: GetGates(vtadmin.GetGatesRequest) returns (vtadmin.GetGatesResponse);
     */
    getGates(input: GetGatesRequest, options?: RpcOptions): UnaryCall<GetGatesRequest, GetGatesResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetGatesRequest, GetGatesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetKeyspace returns a keyspace by name in the specified cluster.
     *
     * @generated from protobuf rpc: GetKeyspace(vtadmin.GetKeyspaceRequest) returns (vtadmin.Keyspace);
     */
    getKeyspace(input: GetKeyspaceRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRequest, Keyspace> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetKeyspaceRequest, Keyspace>("unary", this._transport, method, opt, input);
    }
    /**
     * GetKeyspaces returns all keyspaces across the specified clusters.
     *
     * @generated from protobuf rpc: GetKeyspaces(vtadmin.GetKeyspacesRequest) returns (vtadmin.GetKeyspacesResponse);
     */
    getKeyspaces(input: GetKeyspacesRequest, options?: RpcOptions): UnaryCall<GetKeyspacesRequest, GetKeyspacesResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetKeyspacesRequest, GetKeyspacesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSchema returns the schema for the specified (cluster, keyspace, table)
     * tuple.
     *
     * @generated from protobuf rpc: GetSchema(vtadmin.GetSchemaRequest) returns (vtadmin.Schema);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): UnaryCall<GetSchemaRequest, Schema> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemaRequest, Schema>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSchemas returns all schemas across the specified clusters.
     *
     * @generated from protobuf rpc: GetSchemas(vtadmin.GetSchemasRequest) returns (vtadmin.GetSchemasResponse);
     */
    getSchemas(input: GetSchemasRequest, options?: RpcOptions): UnaryCall<GetSchemasRequest, GetSchemasResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemasRequest, GetSchemasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSchemaMigrations returns one or more online schema migrations for the
     * set of keyspaces (or all keyspaces) in the given clusters, analagous to
     * repeated executions of `SHOW VITESS_MIGRATIONS`.
     *
     * Different fields in the request message result in different behaviors.
     * See the documentation on vtctldata.GetSchemaMigrationsRequest for details.
     *
     * @generated from protobuf rpc: GetSchemaMigrations(vtadmin.GetSchemaMigrationsRequest) returns (vtadmin.GetSchemaMigrationsResponse);
     */
    getSchemaMigrations(input: GetSchemaMigrationsRequest, options?: RpcOptions): UnaryCall<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetShardReplicationPositions returns shard replication positions grouped
     * by cluster.
     *
     * @generated from protobuf rpc: GetShardReplicationPositions(vtadmin.GetShardReplicationPositionsRequest) returns (vtadmin.GetShardReplicationPositionsResponse);
     */
    getShardReplicationPositions(input: GetShardReplicationPositionsRequest, options?: RpcOptions): UnaryCall<GetShardReplicationPositionsRequest, GetShardReplicationPositionsResponse> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetShardReplicationPositionsRequest, GetShardReplicationPositionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvKeyspace returns the SrvKeyspace for a keyspace in one or more cells.
     *
     * @generated from protobuf rpc: GetSrvKeyspace(vtadmin.GetSrvKeyspaceRequest) returns (vtctldata.GetSrvKeyspacesResponse);
     */
    getSrvKeyspace(input: GetSrvKeyspaceRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspaceRequest, GetSrvKeyspacesResponse> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvKeyspaceRequest, GetSrvKeyspacesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvKeyspaces returns the SrvKeyspaces for all keyspaces across all the specified clusters.
     *
     * @generated from protobuf rpc: GetSrvKeyspaces(vtadmin.GetSrvKeyspacesRequest) returns (vtadmin.GetSrvKeyspacesResponse);
     */
    getSrvKeyspaces(input: GetSrvKeyspacesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse$> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse$>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvVSchema returns the SrvVSchema for the given cluster and cell.
     *
     * @generated from protobuf rpc: GetSrvVSchema(vtadmin.GetSrvVSchemaRequest) returns (vtadmin.SrvVSchema);
     */
    getSrvVSchema(input: GetSrvVSchemaRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemaRequest, SrvVSchema> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvVSchemaRequest, SrvVSchema>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvVSchemas returns all SrvVSchemas across all (or specified) clusters
     * and cells.
     *
     * @generated from protobuf rpc: GetSrvVSchemas(vtadmin.GetSrvVSchemasRequest) returns (vtadmin.GetSrvVSchemasResponse);
     */
    getSrvVSchemas(input: GetSrvVSchemasRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemasRequest, GetSrvVSchemasResponse> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvVSchemasRequest, GetSrvVSchemasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTablet looks up a tablet by hostname across all clusters and returns
     * the result.
     *
     * @generated from protobuf rpc: GetTablet(vtadmin.GetTabletRequest) returns (vtadmin.Tablet);
     */
    getTablet(input: GetTabletRequest, options?: RpcOptions): UnaryCall<GetTabletRequest, Tablet> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTabletRequest, Tablet>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTablets returns all tablets across all the specified clusters.
     *
     * @generated from protobuf rpc: GetTablets(vtadmin.GetTabletsRequest) returns (vtadmin.GetTabletsResponse);
     */
    getTablets(input: GetTabletsRequest, options?: RpcOptions): UnaryCall<GetTabletsRequest, GetTabletsResponse> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTabletsRequest, GetTabletsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTopologyPath returns the cell located at the specified path in the topology server.
     *
     * @generated from protobuf rpc: GetTopologyPath(vtadmin.GetTopologyPathRequest) returns (vtctldata.GetTopologyPathResponse);
     */
    getTopologyPath(input: GetTopologyPathRequest, options?: RpcOptions): UnaryCall<GetTopologyPathRequest, GetTopologyPathResponse> {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTopologyPathRequest, GetTopologyPathResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetUnresolvedTransactions returns the unresolved transactions for the request.
     *
     * @generated from protobuf rpc: GetUnresolvedTransactions(vtadmin.GetUnresolvedTransactionsRequest) returns (vtctldata.GetUnresolvedTransactionsResponse);
     */
    getUnresolvedTransactions(input: GetUnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse> {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetVSchema returns a VSchema for the specified keyspace in the specified
     * cluster.
     *
     * @generated from protobuf rpc: GetVSchema(vtadmin.GetVSchemaRequest) returns (vtadmin.VSchema);
     */
    getVSchema(input: GetVSchemaRequest, options?: RpcOptions): UnaryCall<GetVSchemaRequest, VSchema> {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetVSchemaRequest, VSchema>("unary", this._transport, method, opt, input);
    }
    /**
     * GetVSchemas returns the VSchemas for all specified clusters.
     *
     * @generated from protobuf rpc: GetVSchemas(vtadmin.GetVSchemasRequest) returns (vtadmin.GetVSchemasResponse);
     */
    getVSchemas(input: GetVSchemasRequest, options?: RpcOptions): UnaryCall<GetVSchemasRequest, GetVSchemasResponse> {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetVSchemasRequest, GetVSchemasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetVtctlds returns the Vtctlds for all specified clusters.
     *
     * @generated from protobuf rpc: GetVtctlds(vtadmin.GetVtctldsRequest) returns (vtadmin.GetVtctldsResponse);
     */
    getVtctlds(input: GetVtctldsRequest, options?: RpcOptions): UnaryCall<GetVtctldsRequest, GetVtctldsResponse> {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetVtctldsRequest, GetVtctldsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetWorkflow returns a single Workflow for a given cluster, keyspace, and
     * workflow name.
     *
     * @generated from protobuf rpc: GetWorkflow(vtadmin.GetWorkflowRequest) returns (vtadmin.Workflow);
     */
    getWorkflow(input: GetWorkflowRequest, options?: RpcOptions): UnaryCall<GetWorkflowRequest, Workflow> {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetWorkflowRequest, Workflow>("unary", this._transport, method, opt, input);
    }
    /**
     * GetWorkflows returns the Workflows for all specified clusters.
     *
     * @generated from protobuf rpc: GetWorkflows(vtadmin.GetWorkflowsRequest) returns (vtadmin.GetWorkflowsResponse);
     */
    getWorkflows(input: GetWorkflowsRequest, options?: RpcOptions): UnaryCall<GetWorkflowsRequest, GetWorkflowsResponse> {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetWorkflowsRequest, GetWorkflowsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetWorkflowStatus returns the status for a specific workflow.
     *
     * @generated from protobuf rpc: GetWorkflowStatus(vtadmin.GetWorkflowStatusRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    getWorkflowStatus(input: GetWorkflowStatusRequest, options?: RpcOptions): UnaryCall<GetWorkflowStatusRequest, WorkflowStatusResponse> {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetWorkflowStatusRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StartWorkflow starts a vreplication workflow.
     *
     * @generated from protobuf rpc: StartWorkflow(vtadmin.StartWorkflowRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    startWorkflow(input: StartWorkflowRequest, options?: RpcOptions): UnaryCall<StartWorkflowRequest, WorkflowUpdateResponse> {
        const method = this.methods[38], opt = this._transport.mergeOptions(options);
        return stackIntercept<StartWorkflowRequest, WorkflowUpdateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StopWorkflow stops a vreplication workflow.
     *
     * @generated from protobuf rpc: StopWorkflow(vtadmin.StopWorkflowRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    stopWorkflow(input: StopWorkflowRequest, options?: RpcOptions): UnaryCall<StopWorkflowRequest, WorkflowUpdateResponse> {
        const method = this.methods[39], opt = this._transport.mergeOptions(options);
        return stackIntercept<StopWorkflowRequest, WorkflowUpdateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * LaunchSchemaMigration launches one or all migrations in the given
     * cluster executed with --postpone-launch.
     *
     * @generated from protobuf rpc: LaunchSchemaMigration(vtadmin.LaunchSchemaMigrationRequest) returns (vtctldata.LaunchSchemaMigrationResponse);
     */
    launchSchemaMigration(input: LaunchSchemaMigrationRequest, options?: RpcOptions): UnaryCall<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse> {
        const method = this.methods[40], opt = this._transport.mergeOptions(options);
        return stackIntercept<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MoveTablesCreate creates a workflow which moves one or more tables from a
     * source keyspace to a target keyspace.
     *
     * @generated from protobuf rpc: MoveTablesCreate(vtadmin.MoveTablesCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    moveTablesCreate(input: MoveTablesCreateRequest, options?: RpcOptions): UnaryCall<MoveTablesCreateRequest, WorkflowStatusResponse> {
        const method = this.methods[41], opt = this._transport.mergeOptions(options);
        return stackIntercept<MoveTablesCreateRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PingTablet checks that the specified tablet is awake and responding to
     * RPCs. This command can be blocked by other in-flight operations.
     *
     * @generated from protobuf rpc: PingTablet(vtadmin.PingTabletRequest) returns (vtadmin.PingTabletResponse);
     */
    pingTablet(input: PingTabletRequest, options?: RpcOptions): UnaryCall<PingTabletRequest, PingTabletResponse> {
        const method = this.methods[42], opt = this._transport.mergeOptions(options);
        return stackIntercept<PingTabletRequest, PingTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PlannedFailoverShard fails over the shard to a new primary, or away from
     * an old primary. Both the old and new primaries must be reachable and
     * running.
     *
     * NOTE: A planned failover will not consider replicas outside the current
     * shard primary's cell as promotion candidates unless NewPrimary is
     * explicitly provided in the request.
     *
     * @generated from protobuf rpc: PlannedFailoverShard(vtadmin.PlannedFailoverShardRequest) returns (vtadmin.PlannedFailoverShardResponse);
     */
    plannedFailoverShard(input: PlannedFailoverShardRequest, options?: RpcOptions): UnaryCall<PlannedFailoverShardRequest, PlannedFailoverShardResponse> {
        const method = this.methods[43], opt = this._transport.mergeOptions(options);
        return stackIntercept<PlannedFailoverShardRequest, PlannedFailoverShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
     *
     * @generated from protobuf rpc: RebuildKeyspaceGraph(vtadmin.RebuildKeyspaceGraphRequest) returns (vtadmin.RebuildKeyspaceGraphResponse);
     */
    rebuildKeyspaceGraph(input: RebuildKeyspaceGraphRequest, options?: RpcOptions): UnaryCall<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse> {
        const method = this.methods[44], opt = this._transport.mergeOptions(options);
        return stackIntercept<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RefreshState reloads the tablet record on the specified tablet.
     *
     * @generated from protobuf rpc: RefreshState(vtadmin.RefreshStateRequest) returns (vtadmin.RefreshStateResponse);
     */
    refreshState(input: RefreshStateRequest, options?: RpcOptions): UnaryCall<RefreshStateRequest, RefreshStateResponse> {
        const method = this.methods[45], opt = this._transport.mergeOptions(options);
        return stackIntercept<RefreshStateRequest, RefreshStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RefreshTabletReplicationSource performs a `CHANGE REPLICATION SOURCE TO`
     * on a tablet to replicate from the current primary in the shard.
     *
     * @generated from protobuf rpc: RefreshTabletReplicationSource(vtadmin.RefreshTabletReplicationSourceRequest) returns (vtadmin.RefreshTabletReplicationSourceResponse);
     */
    refreshTabletReplicationSource(input: RefreshTabletReplicationSourceRequest, options?: RpcOptions): UnaryCall<RefreshTabletReplicationSourceRequest, RefreshTabletReplicationSourceResponse> {
        const method = this.methods[46], opt = this._transport.mergeOptions(options);
        return stackIntercept<RefreshTabletReplicationSourceRequest, RefreshTabletReplicationSourceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReloadSchemas reloads the schema definition across keyspaces, shards, or
     * tablets in one or more clusters, depending on the request fields (see
     * ReloadSchemasRequest for details).
     *
     * @generated from protobuf rpc: ReloadSchemas(vtadmin.ReloadSchemasRequest) returns (vtadmin.ReloadSchemasResponse);
     */
    reloadSchemas(input: ReloadSchemasRequest, options?: RpcOptions): UnaryCall<ReloadSchemasRequest, ReloadSchemasResponse> {
        const method = this.methods[47], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReloadSchemasRequest, ReloadSchemasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReloadSchemaShard reloads the schema on all tablets in a shard. This is done on a best-effort basis.
     *
     * @generated from protobuf rpc: ReloadSchemaShard(vtadmin.ReloadSchemaShardRequest) returns (vtadmin.ReloadSchemaShardResponse);
     */
    reloadSchemaShard(input: ReloadSchemaShardRequest, options?: RpcOptions): UnaryCall<ReloadSchemaShardRequest, ReloadSchemaShardResponse> {
        const method = this.methods[48], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReloadSchemaShardRequest, ReloadSchemaShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveKeyspaceCell removes the cell from the Cells list for all shards in the keyspace, and the SrvKeyspace for that keyspace in that cell.
     *
     * @generated from protobuf rpc: RemoveKeyspaceCell(vtadmin.RemoveKeyspaceCellRequest) returns (vtadmin.RemoveKeyspaceCellResponse);
     */
    removeKeyspaceCell(input: RemoveKeyspaceCellRequest, options?: RpcOptions): UnaryCall<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse> {
        const method = this.methods[49], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RetrySchemaMigration marks a given schema migration in the given cluster
     * for retry.
     *
     * @generated from protobuf rpc: RetrySchemaMigration(vtadmin.RetrySchemaMigrationRequest) returns (vtctldata.RetrySchemaMigrationResponse);
     */
    retrySchemaMigration(input: RetrySchemaMigrationRequest, options?: RpcOptions): UnaryCall<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse> {
        const method = this.methods[50], opt = this._transport.mergeOptions(options);
        return stackIntercept<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RunHealthCheck runs a healthcheck on the tablet.
     *
     * @generated from protobuf rpc: RunHealthCheck(vtadmin.RunHealthCheckRequest) returns (vtadmin.RunHealthCheckResponse);
     */
    runHealthCheck(input: RunHealthCheckRequest, options?: RpcOptions): UnaryCall<RunHealthCheckRequest, RunHealthCheckResponse> {
        const method = this.methods[51], opt = this._transport.mergeOptions(options);
        return stackIntercept<RunHealthCheckRequest, RunHealthCheckResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetReadOnly sets the tablet to read-only mode.
     *
     * @generated from protobuf rpc: SetReadOnly(vtadmin.SetReadOnlyRequest) returns (vtadmin.SetReadOnlyResponse);
     */
    setReadOnly(input: SetReadOnlyRequest, options?: RpcOptions): UnaryCall<SetReadOnlyRequest, SetReadOnlyResponse> {
        const method = this.methods[52], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetReadOnlyRequest, SetReadOnlyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetReadWrite sets the tablet to read-write mode.
     *
     * @generated from protobuf rpc: SetReadWrite(vtadmin.SetReadWriteRequest) returns (vtadmin.SetReadWriteResponse);
     */
    setReadWrite(input: SetReadWriteRequest, options?: RpcOptions): UnaryCall<SetReadWriteRequest, SetReadWriteResponse> {
        const method = this.methods[53], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetReadWriteRequest, SetReadWriteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StartReplication runs the underlying database command to start
     * replication on a tablet.
     *
     * @generated from protobuf rpc: StartReplication(vtadmin.StartReplicationRequest) returns (vtadmin.StartReplicationResponse);
     */
    startReplication(input: StartReplicationRequest, options?: RpcOptions): UnaryCall<StartReplicationRequest, StartReplicationResponse> {
        const method = this.methods[54], opt = this._transport.mergeOptions(options);
        return stackIntercept<StartReplicationRequest, StartReplicationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StopReplication runs the underlying database command to stop replication
     * on a tablet
     *
     * @generated from protobuf rpc: StopReplication(vtadmin.StopReplicationRequest) returns (vtadmin.StopReplicationResponse);
     */
    stopReplication(input: StopReplicationRequest, options?: RpcOptions): UnaryCall<StopReplicationRequest, StopReplicationResponse> {
        const method = this.methods[55], opt = this._transport.mergeOptions(options);
        return stackIntercept<StopReplicationRequest, StopReplicationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TabletExternallyPromoted updates the metadata in a cluster's topology
     * to acknowledge a shard primary change performed by an external tool
     * (e.g. orchestrator*).
     *
     * See the Reparenting guide for more information:
     * https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
     *
     * * "orchestrator" here refers to external orchestrator, not the newer,
     * Vitess-aware orchestrator, VTOrc.
     *
     * @generated from protobuf rpc: TabletExternallyPromoted(vtadmin.TabletExternallyPromotedRequest) returns (vtadmin.TabletExternallyPromotedResponse);
     */
    tabletExternallyPromoted(input: TabletExternallyPromotedRequest, options?: RpcOptions): UnaryCall<TabletExternallyPromotedRequest, TabletExternallyPromotedResponse> {
        const method = this.methods[56], opt = this._transport.mergeOptions(options);
        return stackIntercept<TabletExternallyPromotedRequest, TabletExternallyPromotedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Validate validates all nodes in a cluster that are reachable from the global replication graph,
     * as well as all tablets in discoverable cells, are consistent
     *
     * @generated from protobuf rpc: Validate(vtadmin.ValidateRequest) returns (vtctldata.ValidateResponse);
     */
    validate(input: ValidateRequest, options?: RpcOptions): UnaryCall<ValidateRequest, ValidateResponse> {
        const method = this.methods[57], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateRequest, ValidateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateKeyspace validates that all nodes reachable from the specified
     * keyspace are consistent.
     *
     * @generated from protobuf rpc: ValidateKeyspace(vtadmin.ValidateKeyspaceRequest) returns (vtctldata.ValidateKeyspaceResponse);
     */
    validateKeyspace(input: ValidateKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateKeyspaceRequest, ValidateKeyspaceResponse> {
        const method = this.methods[58], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateKeyspaceRequest, ValidateKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateSchemaKeyspace validates that the schema on the primary tablet
     * for shard 0 matches the schema on all of the other tablets in the
     * keyspace.
     *
     * @generated from protobuf rpc: ValidateSchemaKeyspace(vtadmin.ValidateSchemaKeyspaceRequest) returns (vtctldata.ValidateSchemaKeyspaceResponse);
     */
    validateSchemaKeyspace(input: ValidateSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse> {
        const method = this.methods[59], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateShard validates that that all nodes reachable from the specified shard are consistent.
     *
     * @generated from protobuf rpc: ValidateShard(vtadmin.ValidateShardRequest) returns (vtctldata.ValidateShardResponse);
     */
    validateShard(input: ValidateShardRequest, options?: RpcOptions): UnaryCall<ValidateShardRequest, ValidateShardResponse> {
        const method = this.methods[60], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateShardRequest, ValidateShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateVersionKeyspace validates that the version on the primary of
     * shard 0 matches all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateVersionKeyspace(vtadmin.ValidateVersionKeyspaceRequest) returns (vtctldata.ValidateVersionKeyspaceResponse);
     */
    validateVersionKeyspace(input: ValidateVersionKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse> {
        const method = this.methods[61], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateVersionShard validates that the version on the primary matches all of the replicas.
     *
     * @generated from protobuf rpc: ValidateVersionShard(vtadmin.ValidateVersionShardRequest) returns (vtctldata.ValidateVersionShardResponse);
     */
    validateVersionShard(input: ValidateVersionShardRequest, options?: RpcOptions): UnaryCall<ValidateVersionShardRequest, ValidateVersionShardResponse> {
        const method = this.methods[62], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateVersionShardRequest, ValidateVersionShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * VTExplain provides information on how Vitess plans to execute a
     * particular query.
     *
     * @generated from protobuf rpc: VTExplain(vtadmin.VTExplainRequest) returns (vtadmin.VTExplainResponse);
     */
    vTExplain(input: VTExplainRequest, options?: RpcOptions): UnaryCall<VTExplainRequest, VTExplainResponse> {
        const method = this.methods[63], opt = this._transport.mergeOptions(options);
        return stackIntercept<VTExplainRequest, VTExplainResponse>("unary", this._transport, method, opt, input);
    }
}
