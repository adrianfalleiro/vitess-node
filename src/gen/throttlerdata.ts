// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "throttlerdata.proto" (package "throttlerdata", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// Data structures for the throttler RPC interface.
//
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * MaxRatesRequest is the payload for the MaxRates RPC.
 *
 * @generated from protobuf message throttlerdata.MaxRatesRequest
 */
export interface MaxRatesRequest {
}
/**
 * MaxRatesResponse is returned by the MaxRates RPC.
 *
 * @generated from protobuf message throttlerdata.MaxRatesResponse
 */
export interface MaxRatesResponse {
    /**
     * max_rates returns the max rate for each throttler. It's keyed by the
     * throttler name.
     *
     * @generated from protobuf field: map<string, int64> rates = 1;
     */
    rates: {
        [key: string]: bigint;
    };
}
/**
 * SetMaxRateRequest is the payload for the SetMaxRate RPC.
 *
 * @generated from protobuf message throttlerdata.SetMaxRateRequest
 */
export interface SetMaxRateRequest {
    /**
     * @generated from protobuf field: int64 rate = 1;
     */
    rate: bigint;
}
/**
 * SetMaxRateResponse is returned by the SetMaxRate RPC.
 *
 * @generated from protobuf message throttlerdata.SetMaxRateResponse
 */
export interface SetMaxRateResponse {
    /**
     * names is the list of throttler names which were updated.
     *
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * Configuration holds the configuration parameters for the
 * MaxReplicationLagModule which adaptively adjusts the throttling rate based on
 * the observed replication lag across all replicas.
 *
 * @generated from protobuf message throttlerdata.Configuration
 */
export interface Configuration {
    /**
     * target_replication_lag_sec is the replication lag (in seconds) the
     * MaxReplicationLagModule tries to aim for.
     * If it is within the target, it tries to increase the throttler
     * rate, otherwise it will lower it based on an educated guess of the
     * replica's throughput.
     *
     * @generated from protobuf field: int64 target_replication_lag_sec = 1;
     */
    targetReplicationLagSec: bigint;
    /**
     * max_replication_lag_sec is meant as a last resort.
     * By default, the module tries to find out the system maximum capacity while
     * trying to keep the replication lag around "target_replication_lag_sec".
     * Usually, we'll wait min_duration_between_(increases|decreases)_sec to see
     * the effect of a throttler rate change on the replication lag.
     * But if the lag goes above this field's value we will go into an "emergency"
     * state and throttle more aggressively (see "emergency_decrease" below).
     * This is the only way to ensure that the system will recover.
     *
     * @generated from protobuf field: int64 max_replication_lag_sec = 2;
     */
    maxReplicationLagSec: bigint;
    /**
     * initial_rate is the rate at which the module will start.
     *
     * @generated from protobuf field: int64 initial_rate = 3;
     */
    initialRate: bigint;
    /**
     * max_increase defines by how much we will increase the rate
     * e.g. 0.05 increases the rate by 5% while 1.0 by 100%.
     * Note that any increase will let the system wait for at least
     * (1 / MaxIncrease) seconds. If we wait for shorter periods of time, we
     * won't notice if the rate increase also increases the replication lag.
     * (If the system was already at its maximum capacity (e.g. 1k QPS) and we
     * increase the rate by e.g. 5% to 1050 QPS, it will take 20 seconds until
     * 1000 extra queries are buffered and the lag increases by 1 second.)
     *
     * @generated from protobuf field: double max_increase = 4;
     */
    maxIncrease: number;
    /**
     * emergency_decrease defines by how much we will decrease the current rate
     * if the observed replication lag is above "max_replication_lag_sec".
     * E.g. 0.50 decreases the current rate by 50%.
     *
     * @generated from protobuf field: double emergency_decrease = 5;
     */
    emergencyDecrease: number;
    /**
     * min_duration_between_increases_sec specifies how long we'll wait at least
     * for the last rate increase to have an effect on the system.
     *
     * @generated from protobuf field: int64 min_duration_between_increases_sec = 6;
     */
    minDurationBetweenIncreasesSec: bigint;
    /**
     * max_duration_between_increases_sec specifies how long we'll wait at most
     * for the last rate increase to have an effect on the system.
     *
     * @generated from protobuf field: int64 max_duration_between_increases_sec = 7;
     */
    maxDurationBetweenIncreasesSec: bigint;
    /**
     * min_duration_between_decreases_sec specifies how long we'll wait at least
     * for the last rate decrease to have an effect on the system.
     *
     * @generated from protobuf field: int64 min_duration_between_decreases_sec = 8;
     */
    minDurationBetweenDecreasesSec: bigint;
    /**
     * spread_backlog_across_sec is used when we set the throttler rate after
     * we guessed the rate of a replica and determined its backlog.
     * For example, at a guessed rate of 100 QPS and a lag of 10s, the replica has
     * a backlog of 1000 queries.
     * When we set the new, decreased throttler rate, we factor in how long it
     * will take the replica to go through the backlog (in addition to new
     * requests). This field specifies over which timespan we plan to spread this.
     * For example, for a backlog of 1000 queries spread over 5s means that we
     * have to further reduce the rate by 200 QPS or the backlog will not be
     * processed within the 5 seconds.
     *
     * @generated from protobuf field: int64 spread_backlog_across_sec = 9;
     */
    spreadBacklogAcrossSec: bigint;
    /**
     * ignore_n_slowest_replicas will ignore replication lag updates from the
     * N slowest REPLICA tablets. Under certain circumstances, replicas are still
     * considered e.g. a) if the lag is at most max_replication_lag_sec, b) there
     * are less than N+1 replicas or c) the lag increased on each replica such
     * that all replicas were ignored in a row.
     *
     * @generated from protobuf field: int32 ignore_n_slowest_replicas = 10;
     */
    ignoreNSlowestReplicas: number;
    /**
     * ignore_n_slowest_rdonlys does the same thing as ignore_n_slowest_replicas
     * but for RDONLY tablets. Note that these two settings are independent.
     *
     * @generated from protobuf field: int32 ignore_n_slowest_rdonlys = 11;
     */
    ignoreNSlowestRdonlys: number;
    /**
     * age_bad_rate_after_sec is the duration after which an unchanged bad rate
     * will "age out" and increase by "bad_rate_increase".
     * Bad rates are tracked by the code in memory.go and serve as an upper bound
     * for future rate changes. This ensures that the adaptive throttler does not
     * try known too high (bad) rates over and over again.
     * To avoid that temporary degradations permanently reduce the maximum rate,
     * a stable bad rate "ages out" after "age_bad_rate_after_sec".
     *
     * @generated from protobuf field: int64 age_bad_rate_after_sec = 12;
     */
    ageBadRateAfterSec: bigint;
    /**
     * bad_rate_increase defines the percentage by which a bad rate will be
     * increased when it's aging out.
     *
     * @generated from protobuf field: double bad_rate_increase = 13;
     */
    badRateIncrease: number;
    /**
     * max_rate_approach_threshold is the fraction of the current rate limit that the actual
     * rate must exceed for the throttler to increase the limit when the replication lag
     * is below target_replication_lag_sec. For example, assuming the actual replication lag
     * is below target_replication_lag_sec, if the current rate limit is 100, then the actual
     * rate must exceed 100*max_rate_approach_threshold for the throttler to increase the current
     * limit.
     *
     * @generated from protobuf field: double max_rate_approach_threshold = 14;
     */
    maxRateApproachThreshold: number;
}
/**
 * GetConfigurationRequest is the payload for the GetConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.GetConfigurationRequest
 */
export interface GetConfigurationRequest {
    /**
     * throttler_name specifies which throttler to select. If empty, all active
     * throttlers will be selected.
     *
     * @generated from protobuf field: string throttler_name = 1;
     */
    throttlerName: string;
}
/**
 * GetConfigurationResponse is returned by the GetConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.GetConfigurationResponse
 */
export interface GetConfigurationResponse {
    /**
     * max_rates returns the configurations for each throttler.
     * It's keyed by the throttler name.
     *
     * @generated from protobuf field: map<string, throttlerdata.Configuration> configurations = 1;
     */
    configurations: {
        [key: string]: Configuration;
    };
}
/**
 * UpdateConfigurationRequest is the payload for the UpdateConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.UpdateConfigurationRequest
 */
export interface UpdateConfigurationRequest {
    /**
     * throttler_name specifies which throttler to update. If empty, all active
     * throttlers will be updated.
     *
     * @generated from protobuf field: string throttler_name = 1;
     */
    throttlerName: string;
    /**
     * configuration is the new (partial) configuration.
     *
     * @generated from protobuf field: throttlerdata.Configuration configuration = 2;
     */
    configuration?: Configuration;
    /**
     * copy_zero_values specifies whether fields with zero values should be copied
     * as well.
     *
     * @generated from protobuf field: bool copy_zero_values = 3;
     */
    copyZeroValues: boolean;
}
/**
 * UpdateConfigurationResponse is returned by the UpdateConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.UpdateConfigurationResponse
 */
export interface UpdateConfigurationResponse {
    /**
     * names is the list of throttler names which were updated.
     *
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * ResetConfigurationRequest is the payload for the ResetConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.ResetConfigurationRequest
 */
export interface ResetConfigurationRequest {
    /**
     * throttler_name specifies which throttler to reset. If empty, all active
     * throttlers will be reset.
     *
     * @generated from protobuf field: string throttler_name = 1;
     */
    throttlerName: string;
}
/**
 * ResetConfigurationResponse is returned by the ResetConfiguration RPC.
 *
 * @generated from protobuf message throttlerdata.ResetConfigurationResponse
 */
export interface ResetConfigurationResponse {
    /**
     * names is the list of throttler names which were updated.
     *
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class MaxRatesRequest$Type extends MessageType<MaxRatesRequest> {
    constructor() {
        super("throttlerdata.MaxRatesRequest", []);
    }
    create(value?: PartialMessage<MaxRatesRequest>): MaxRatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MaxRatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxRatesRequest): MaxRatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaxRatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.MaxRatesRequest
 */
export const MaxRatesRequest = new MaxRatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaxRatesResponse$Type extends MessageType<MaxRatesResponse> {
    constructor() {
        super("throttlerdata.MaxRatesResponse", [
            { no: 1, name: "rates", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<MaxRatesResponse>): MaxRatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rates = {};
        if (value !== undefined)
            reflectionMergePartial<MaxRatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxRatesResponse): MaxRatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int64> rates */ 1:
                    this.binaryReadMap1(message.rates, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MaxRatesResponse["rates"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MaxRatesResponse["rates"] | undefined, val: MaxRatesResponse["rates"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field throttlerdata.MaxRatesResponse.rates");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: MaxRatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int64> rates = 1; */
        for (let k of globalThis.Object.keys(message.rates))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.rates[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.MaxRatesResponse
 */
export const MaxRatesResponse = new MaxRatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMaxRateRequest$Type extends MessageType<SetMaxRateRequest> {
    constructor() {
        super("throttlerdata.SetMaxRateRequest", [
            { no: 1, name: "rate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetMaxRateRequest>): SetMaxRateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rate = 0n;
        if (value !== undefined)
            reflectionMergePartial<SetMaxRateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMaxRateRequest): SetMaxRateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rate */ 1:
                    message.rate = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetMaxRateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rate = 1; */
        if (message.rate !== 0n)
            writer.tag(1, WireType.Varint).int64(message.rate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.SetMaxRateRequest
 */
export const SetMaxRateRequest = new SetMaxRateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMaxRateResponse$Type extends MessageType<SetMaxRateResponse> {
    constructor() {
        super("throttlerdata.SetMaxRateResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetMaxRateResponse>): SetMaxRateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<SetMaxRateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMaxRateResponse): SetMaxRateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetMaxRateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.SetMaxRateResponse
 */
export const SetMaxRateResponse = new SetMaxRateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Configuration$Type extends MessageType<Configuration> {
    constructor() {
        super("throttlerdata.Configuration", [
            { no: 1, name: "target_replication_lag_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_replication_lag_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "initial_rate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_increase", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "emergency_decrease", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "min_duration_between_increases_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "max_duration_between_increases_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "min_duration_between_decreases_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "spread_backlog_across_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "ignore_n_slowest_replicas", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "ignore_n_slowest_rdonlys", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "age_bad_rate_after_sec", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "bad_rate_increase", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "max_rate_approach_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Configuration>): Configuration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetReplicationLagSec = 0n;
        message.maxReplicationLagSec = 0n;
        message.initialRate = 0n;
        message.maxIncrease = 0;
        message.emergencyDecrease = 0;
        message.minDurationBetweenIncreasesSec = 0n;
        message.maxDurationBetweenIncreasesSec = 0n;
        message.minDurationBetweenDecreasesSec = 0n;
        message.spreadBacklogAcrossSec = 0n;
        message.ignoreNSlowestReplicas = 0;
        message.ignoreNSlowestRdonlys = 0;
        message.ageBadRateAfterSec = 0n;
        message.badRateIncrease = 0;
        message.maxRateApproachThreshold = 0;
        if (value !== undefined)
            reflectionMergePartial<Configuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Configuration): Configuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 target_replication_lag_sec */ 1:
                    message.targetReplicationLagSec = reader.int64().toBigInt();
                    break;
                case /* int64 max_replication_lag_sec */ 2:
                    message.maxReplicationLagSec = reader.int64().toBigInt();
                    break;
                case /* int64 initial_rate */ 3:
                    message.initialRate = reader.int64().toBigInt();
                    break;
                case /* double max_increase */ 4:
                    message.maxIncrease = reader.double();
                    break;
                case /* double emergency_decrease */ 5:
                    message.emergencyDecrease = reader.double();
                    break;
                case /* int64 min_duration_between_increases_sec */ 6:
                    message.minDurationBetweenIncreasesSec = reader.int64().toBigInt();
                    break;
                case /* int64 max_duration_between_increases_sec */ 7:
                    message.maxDurationBetweenIncreasesSec = reader.int64().toBigInt();
                    break;
                case /* int64 min_duration_between_decreases_sec */ 8:
                    message.minDurationBetweenDecreasesSec = reader.int64().toBigInt();
                    break;
                case /* int64 spread_backlog_across_sec */ 9:
                    message.spreadBacklogAcrossSec = reader.int64().toBigInt();
                    break;
                case /* int32 ignore_n_slowest_replicas */ 10:
                    message.ignoreNSlowestReplicas = reader.int32();
                    break;
                case /* int32 ignore_n_slowest_rdonlys */ 11:
                    message.ignoreNSlowestRdonlys = reader.int32();
                    break;
                case /* int64 age_bad_rate_after_sec */ 12:
                    message.ageBadRateAfterSec = reader.int64().toBigInt();
                    break;
                case /* double bad_rate_increase */ 13:
                    message.badRateIncrease = reader.double();
                    break;
                case /* double max_rate_approach_threshold */ 14:
                    message.maxRateApproachThreshold = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Configuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 target_replication_lag_sec = 1; */
        if (message.targetReplicationLagSec !== 0n)
            writer.tag(1, WireType.Varint).int64(message.targetReplicationLagSec);
        /* int64 max_replication_lag_sec = 2; */
        if (message.maxReplicationLagSec !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxReplicationLagSec);
        /* int64 initial_rate = 3; */
        if (message.initialRate !== 0n)
            writer.tag(3, WireType.Varint).int64(message.initialRate);
        /* double max_increase = 4; */
        if (message.maxIncrease !== 0)
            writer.tag(4, WireType.Bit64).double(message.maxIncrease);
        /* double emergency_decrease = 5; */
        if (message.emergencyDecrease !== 0)
            writer.tag(5, WireType.Bit64).double(message.emergencyDecrease);
        /* int64 min_duration_between_increases_sec = 6; */
        if (message.minDurationBetweenIncreasesSec !== 0n)
            writer.tag(6, WireType.Varint).int64(message.minDurationBetweenIncreasesSec);
        /* int64 max_duration_between_increases_sec = 7; */
        if (message.maxDurationBetweenIncreasesSec !== 0n)
            writer.tag(7, WireType.Varint).int64(message.maxDurationBetweenIncreasesSec);
        /* int64 min_duration_between_decreases_sec = 8; */
        if (message.minDurationBetweenDecreasesSec !== 0n)
            writer.tag(8, WireType.Varint).int64(message.minDurationBetweenDecreasesSec);
        /* int64 spread_backlog_across_sec = 9; */
        if (message.spreadBacklogAcrossSec !== 0n)
            writer.tag(9, WireType.Varint).int64(message.spreadBacklogAcrossSec);
        /* int32 ignore_n_slowest_replicas = 10; */
        if (message.ignoreNSlowestReplicas !== 0)
            writer.tag(10, WireType.Varint).int32(message.ignoreNSlowestReplicas);
        /* int32 ignore_n_slowest_rdonlys = 11; */
        if (message.ignoreNSlowestRdonlys !== 0)
            writer.tag(11, WireType.Varint).int32(message.ignoreNSlowestRdonlys);
        /* int64 age_bad_rate_after_sec = 12; */
        if (message.ageBadRateAfterSec !== 0n)
            writer.tag(12, WireType.Varint).int64(message.ageBadRateAfterSec);
        /* double bad_rate_increase = 13; */
        if (message.badRateIncrease !== 0)
            writer.tag(13, WireType.Bit64).double(message.badRateIncrease);
        /* double max_rate_approach_threshold = 14; */
        if (message.maxRateApproachThreshold !== 0)
            writer.tag(14, WireType.Bit64).double(message.maxRateApproachThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.Configuration
 */
export const Configuration = new Configuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigurationRequest$Type extends MessageType<GetConfigurationRequest> {
    constructor() {
        super("throttlerdata.GetConfigurationRequest", [
            { no: 1, name: "throttler_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetConfigurationRequest>): GetConfigurationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.throttlerName = "";
        if (value !== undefined)
            reflectionMergePartial<GetConfigurationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigurationRequest): GetConfigurationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string throttler_name */ 1:
                    message.throttlerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConfigurationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string throttler_name = 1; */
        if (message.throttlerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.throttlerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.GetConfigurationRequest
 */
export const GetConfigurationRequest = new GetConfigurationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigurationResponse$Type extends MessageType<GetConfigurationResponse> {
    constructor() {
        super("throttlerdata.GetConfigurationResponse", [
            { no: 1, name: "configurations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Configuration } }
        ]);
    }
    create(value?: PartialMessage<GetConfigurationResponse>): GetConfigurationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configurations = {};
        if (value !== undefined)
            reflectionMergePartial<GetConfigurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigurationResponse): GetConfigurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, throttlerdata.Configuration> configurations */ 1:
                    this.binaryReadMap1(message.configurations, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetConfigurationResponse["configurations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetConfigurationResponse["configurations"] | undefined, val: GetConfigurationResponse["configurations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Configuration.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field throttlerdata.GetConfigurationResponse.configurations");
            }
        }
        map[key ?? ""] = val ?? Configuration.create();
    }
    internalBinaryWrite(message: GetConfigurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, throttlerdata.Configuration> configurations = 1; */
        for (let k of globalThis.Object.keys(message.configurations)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Configuration.internalBinaryWrite(message.configurations[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.GetConfigurationResponse
 */
export const GetConfigurationResponse = new GetConfigurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfigurationRequest$Type extends MessageType<UpdateConfigurationRequest> {
    constructor() {
        super("throttlerdata.UpdateConfigurationRequest", [
            { no: 1, name: "throttler_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "configuration", kind: "message", T: () => Configuration },
            { no: 3, name: "copy_zero_values", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateConfigurationRequest>): UpdateConfigurationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.throttlerName = "";
        message.copyZeroValues = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateConfigurationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfigurationRequest): UpdateConfigurationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string throttler_name */ 1:
                    message.throttlerName = reader.string();
                    break;
                case /* throttlerdata.Configuration configuration */ 2:
                    message.configuration = Configuration.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* bool copy_zero_values */ 3:
                    message.copyZeroValues = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfigurationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string throttler_name = 1; */
        if (message.throttlerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.throttlerName);
        /* throttlerdata.Configuration configuration = 2; */
        if (message.configuration)
            Configuration.internalBinaryWrite(message.configuration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool copy_zero_values = 3; */
        if (message.copyZeroValues !== false)
            writer.tag(3, WireType.Varint).bool(message.copyZeroValues);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.UpdateConfigurationRequest
 */
export const UpdateConfigurationRequest = new UpdateConfigurationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfigurationResponse$Type extends MessageType<UpdateConfigurationResponse> {
    constructor() {
        super("throttlerdata.UpdateConfigurationResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateConfigurationResponse>): UpdateConfigurationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateConfigurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfigurationResponse): UpdateConfigurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfigurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.UpdateConfigurationResponse
 */
export const UpdateConfigurationResponse = new UpdateConfigurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetConfigurationRequest$Type extends MessageType<ResetConfigurationRequest> {
    constructor() {
        super("throttlerdata.ResetConfigurationRequest", [
            { no: 1, name: "throttler_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResetConfigurationRequest>): ResetConfigurationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.throttlerName = "";
        if (value !== undefined)
            reflectionMergePartial<ResetConfigurationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetConfigurationRequest): ResetConfigurationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string throttler_name */ 1:
                    message.throttlerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetConfigurationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string throttler_name = 1; */
        if (message.throttlerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.throttlerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.ResetConfigurationRequest
 */
export const ResetConfigurationRequest = new ResetConfigurationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetConfigurationResponse$Type extends MessageType<ResetConfigurationResponse> {
    constructor() {
        super("throttlerdata.ResetConfigurationResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResetConfigurationResponse>): ResetConfigurationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<ResetConfigurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetConfigurationResponse): ResetConfigurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetConfigurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message throttlerdata.ResetConfigurationResponse
 */
export const ResetConfigurationResponse = new ResetConfigurationResponse$Type();
