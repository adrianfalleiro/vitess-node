// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "queryservice.proto" (package "queryservice", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains the service VtTablet exposes for queries.
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Query } from "./queryservice";
import type { GetSchemaResponse } from "./query";
import type { GetSchemaRequest } from "./query";
import type { VStreamResultsResponse } from "./binlogdata";
import type { VStreamResultsRequest } from "./binlogdata";
import type { VStreamTablesResponse } from "./binlogdata";
import type { VStreamTablesRequest } from "./binlogdata";
import type { VStreamRowsResponse } from "./binlogdata";
import type { VStreamRowsRequest } from "./binlogdata";
import type { VStreamResponse } from "./binlogdata";
import type { VStreamRequest } from "./binlogdata";
import type { StreamHealthResponse } from "./query";
import type { StreamHealthRequest } from "./query";
import type { ReleaseResponse } from "./query";
import type { ReleaseRequest } from "./query";
import type { ReserveBeginStreamExecuteResponse } from "./query";
import type { ReserveBeginStreamExecuteRequest } from "./query";
import type { ReserveStreamExecuteResponse } from "./query";
import type { ReserveStreamExecuteRequest } from "./query";
import type { ReserveBeginExecuteResponse } from "./query";
import type { ReserveBeginExecuteRequest } from "./query";
import type { ReserveExecuteResponse } from "./query";
import type { ReserveExecuteRequest } from "./query";
import type { MessageAckResponse } from "./query";
import type { MessageAckRequest } from "./query";
import type { MessageStreamResponse } from "./query";
import type { MessageStreamRequest } from "./query";
import type { BeginStreamExecuteResponse } from "./query";
import type { BeginStreamExecuteRequest } from "./query";
import type { BeginExecuteResponse } from "./query";
import type { BeginExecuteRequest } from "./query";
import type { UnresolvedTransactionsResponse } from "./query";
import type { UnresolvedTransactionsRequest } from "./query";
import type { ReadTransactionResponse } from "./query";
import type { ReadTransactionRequest } from "./query";
import type { ConcludeTransactionResponse } from "./query";
import type { ConcludeTransactionRequest } from "./query";
import type { SetRollbackResponse } from "./query";
import type { SetRollbackRequest } from "./query";
import type { StartCommitResponse } from "./query";
import type { StartCommitRequest } from "./query";
import type { CreateTransactionResponse } from "./query";
import type { CreateTransactionRequest } from "./query";
import type { RollbackPreparedResponse } from "./query";
import type { RollbackPreparedRequest } from "./query";
import type { CommitPreparedResponse } from "./query";
import type { CommitPreparedRequest } from "./query";
import type { PrepareResponse } from "./query";
import type { PrepareRequest } from "./query";
import type { RollbackResponse } from "./query";
import type { RollbackRequest } from "./query";
import type { CommitResponse } from "./query";
import type { CommitRequest } from "./query";
import type { BeginResponse } from "./query";
import type { BeginRequest } from "./query";
import type { StreamExecuteResponse } from "./query";
import type { StreamExecuteRequest } from "./query";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ExecuteResponse } from "./query";
import type { ExecuteRequest } from "./query";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Query defines the tablet query service, implemented by vttablet.
 *
 * @generated from protobuf service queryservice.Query
 */
export interface IQueryClient {
    /**
     * Execute executes the specified SQL query (might be in a
     * transaction context, if Query.transaction_id is set).
     *
     * @generated from protobuf rpc: Execute(query.ExecuteRequest) returns (query.ExecuteResponse);
     */
    execute(input: ExecuteRequest, options?: RpcOptions): UnaryCall<ExecuteRequest, ExecuteResponse>;
    /**
     * StreamExecute executes a streaming query. Use this method if the
     * query returns a large number of rows. The first QueryResult will
     * contain the Fields, subsequent QueryResult messages will contain
     * the rows.
     *
     * @generated from protobuf rpc: StreamExecute(query.StreamExecuteRequest) returns (stream query.StreamExecuteResponse);
     */
    streamExecute(input: StreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<StreamExecuteRequest, StreamExecuteResponse>;
    /**
     * Begin a transaction.
     *
     * @generated from protobuf rpc: Begin(query.BeginRequest) returns (query.BeginResponse);
     */
    begin(input: BeginRequest, options?: RpcOptions): UnaryCall<BeginRequest, BeginResponse>;
    /**
     * Commit a transaction.
     *
     * @generated from protobuf rpc: Commit(query.CommitRequest) returns (query.CommitResponse);
     */
    commit(input: CommitRequest, options?: RpcOptions): UnaryCall<CommitRequest, CommitResponse>;
    /**
     * Rollback a transaction.
     *
     * @generated from protobuf rpc: Rollback(query.RollbackRequest) returns (query.RollbackResponse);
     */
    rollback(input: RollbackRequest, options?: RpcOptions): UnaryCall<RollbackRequest, RollbackResponse>;
    /**
     * Prepare preares a transaction.
     *
     * @generated from protobuf rpc: Prepare(query.PrepareRequest) returns (query.PrepareResponse);
     */
    prepare(input: PrepareRequest, options?: RpcOptions): UnaryCall<PrepareRequest, PrepareResponse>;
    /**
     * CommitPrepared commits a prepared transaction.
     *
     * @generated from protobuf rpc: CommitPrepared(query.CommitPreparedRequest) returns (query.CommitPreparedResponse);
     */
    commitPrepared(input: CommitPreparedRequest, options?: RpcOptions): UnaryCall<CommitPreparedRequest, CommitPreparedResponse>;
    /**
     * RollbackPrepared rolls back a prepared transaction.
     *
     * @generated from protobuf rpc: RollbackPrepared(query.RollbackPreparedRequest) returns (query.RollbackPreparedResponse);
     */
    rollbackPrepared(input: RollbackPreparedRequest, options?: RpcOptions): UnaryCall<RollbackPreparedRequest, RollbackPreparedResponse>;
    /**
     * CreateTransaction creates the metadata for a 2pc transaction.
     *
     * @generated from protobuf rpc: CreateTransaction(query.CreateTransactionRequest) returns (query.CreateTransactionResponse);
     */
    createTransaction(input: CreateTransactionRequest, options?: RpcOptions): UnaryCall<CreateTransactionRequest, CreateTransactionResponse>;
    /**
     * StartCommit initiates a commit for a 2pc transaction.
     *
     * @generated from protobuf rpc: StartCommit(query.StartCommitRequest) returns (query.StartCommitResponse);
     */
    startCommit(input: StartCommitRequest, options?: RpcOptions): UnaryCall<StartCommitRequest, StartCommitResponse>;
    /**
     * SetRollback marks the 2pc transaction for rollback.
     *
     * @generated from protobuf rpc: SetRollback(query.SetRollbackRequest) returns (query.SetRollbackResponse);
     */
    setRollback(input: SetRollbackRequest, options?: RpcOptions): UnaryCall<SetRollbackRequest, SetRollbackResponse>;
    /**
     * ConcludeTransaction marks the 2pc transaction as resolved.
     *
     * @generated from protobuf rpc: ConcludeTransaction(query.ConcludeTransactionRequest) returns (query.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse>;
    /**
     * ReadTransaction returns the 2pc transaction info.
     *
     * @generated from protobuf rpc: ReadTransaction(query.ReadTransactionRequest) returns (query.ReadTransactionResponse);
     */
    readTransaction(input: ReadTransactionRequest, options?: RpcOptions): UnaryCall<ReadTransactionRequest, ReadTransactionResponse>;
    /**
     * UnresolvedTransactions returns the 2pc transaction info.
     *
     * @generated from protobuf rpc: UnresolvedTransactions(query.UnresolvedTransactionsRequest) returns (query.UnresolvedTransactionsResponse);
     */
    unresolvedTransactions(input: UnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<UnresolvedTransactionsRequest, UnresolvedTransactionsResponse>;
    /**
     * BeginExecute executes a begin and the specified SQL query.
     *
     * @generated from protobuf rpc: BeginExecute(query.BeginExecuteRequest) returns (query.BeginExecuteResponse);
     */
    beginExecute(input: BeginExecuteRequest, options?: RpcOptions): UnaryCall<BeginExecuteRequest, BeginExecuteResponse>;
    /**
     * BeginStreamExecute executes a begin and the specified SQL query.
     *
     * @generated from protobuf rpc: BeginStreamExecute(query.BeginStreamExecuteRequest) returns (stream query.BeginStreamExecuteResponse);
     */
    beginStreamExecute(input: BeginStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<BeginStreamExecuteRequest, BeginStreamExecuteResponse>;
    /**
     * MessageStream streams messages from a message table.
     *
     * @generated from protobuf rpc: MessageStream(query.MessageStreamRequest) returns (stream query.MessageStreamResponse);
     */
    messageStream(input: MessageStreamRequest, options?: RpcOptions): ServerStreamingCall<MessageStreamRequest, MessageStreamResponse>;
    /**
     * MessageAck acks messages for a table.
     *
     * @generated from protobuf rpc: MessageAck(query.MessageAckRequest) returns (query.MessageAckResponse);
     */
    messageAck(input: MessageAckRequest, options?: RpcOptions): UnaryCall<MessageAckRequest, MessageAckResponse>;
    /**
     * ReserveExecute executes a query on a reserved connection
     *
     * @generated from protobuf rpc: ReserveExecute(query.ReserveExecuteRequest) returns (query.ReserveExecuteResponse);
     */
    reserveExecute(input: ReserveExecuteRequest, options?: RpcOptions): UnaryCall<ReserveExecuteRequest, ReserveExecuteResponse>;
    /**
     * ReserveBeginExecute starts a transaction and executes a query in the transaction on a reserved connection
     *
     * @generated from protobuf rpc: ReserveBeginExecute(query.ReserveBeginExecuteRequest) returns (query.ReserveBeginExecuteResponse);
     */
    reserveBeginExecute(input: ReserveBeginExecuteRequest, options?: RpcOptions): UnaryCall<ReserveBeginExecuteRequest, ReserveBeginExecuteResponse>;
    /**
     * ReserveStreamExecute executes a streaming query on a reserved connection
     *
     * @generated from protobuf rpc: ReserveStreamExecute(query.ReserveStreamExecuteRequest) returns (stream query.ReserveStreamExecuteResponse);
     */
    reserveStreamExecute(input: ReserveStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<ReserveStreamExecuteRequest, ReserveStreamExecuteResponse>;
    /**
     * ReserveBeginStreamExecute starts a transaction and executes a streaming query in the transaction on a reserved connection
     *
     * @generated from protobuf rpc: ReserveBeginStreamExecute(query.ReserveBeginStreamExecuteRequest) returns (stream query.ReserveBeginStreamExecuteResponse);
     */
    reserveBeginStreamExecute(input: ReserveBeginStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<ReserveBeginStreamExecuteRequest, ReserveBeginStreamExecuteResponse>;
    /**
     * Release releases the connection
     *
     * @generated from protobuf rpc: Release(query.ReleaseRequest) returns (query.ReleaseResponse);
     */
    release(input: ReleaseRequest, options?: RpcOptions): UnaryCall<ReleaseRequest, ReleaseResponse>;
    /**
     * StreamHealth runs a streaming RPC to the tablet, that returns the
     * current health of the tablet on a regular basis.
     *
     * @generated from protobuf rpc: StreamHealth(query.StreamHealthRequest) returns (stream query.StreamHealthResponse);
     */
    streamHealth(input: StreamHealthRequest, options?: RpcOptions): ServerStreamingCall<StreamHealthRequest, StreamHealthResponse>;
    /**
     * VStream streams vreplication events.
     *
     * @generated from protobuf rpc: VStream(binlogdata.VStreamRequest) returns (stream binlogdata.VStreamResponse);
     */
    vStream(input: VStreamRequest, options?: RpcOptions): ServerStreamingCall<VStreamRequest, VStreamResponse>;
    /**
     * VStreamRows streams rows from the specified starting point.
     *
     * @generated from protobuf rpc: VStreamRows(binlogdata.VStreamRowsRequest) returns (stream binlogdata.VStreamRowsResponse);
     */
    vStreamRows(input: VStreamRowsRequest, options?: RpcOptions): ServerStreamingCall<VStreamRowsRequest, VStreamRowsResponse>;
    /**
     * VStreamTables streams rows from the specified starting point.
     *
     * @generated from protobuf rpc: VStreamTables(binlogdata.VStreamTablesRequest) returns (stream binlogdata.VStreamTablesResponse);
     */
    vStreamTables(input: VStreamTablesRequest, options?: RpcOptions): ServerStreamingCall<VStreamTablesRequest, VStreamTablesResponse>;
    /**
     * VStreamResults streams results along with the gtid of the snapshot.
     *
     * @generated from protobuf rpc: VStreamResults(binlogdata.VStreamResultsRequest) returns (stream binlogdata.VStreamResultsResponse);
     */
    vStreamResults(input: VStreamResultsRequest, options?: RpcOptions): ServerStreamingCall<VStreamResultsRequest, VStreamResultsResponse>;
    /**
     * GetSchema returns the schema information.
     *
     * @generated from protobuf rpc: GetSchema(query.GetSchemaRequest) returns (stream query.GetSchemaResponse);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): ServerStreamingCall<GetSchemaRequest, GetSchemaResponse>;
}
/**
 * Query defines the tablet query service, implemented by vttablet.
 *
 * @generated from protobuf service queryservice.Query
 */
export class QueryClient implements IQueryClient, ServiceInfo {
    typeName = Query.typeName;
    methods = Query.methods;
    options = Query.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Execute executes the specified SQL query (might be in a
     * transaction context, if Query.transaction_id is set).
     *
     * @generated from protobuf rpc: Execute(query.ExecuteRequest) returns (query.ExecuteResponse);
     */
    execute(input: ExecuteRequest, options?: RpcOptions): UnaryCall<ExecuteRequest, ExecuteResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteRequest, ExecuteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StreamExecute executes a streaming query. Use this method if the
     * query returns a large number of rows. The first QueryResult will
     * contain the Fields, subsequent QueryResult messages will contain
     * the rows.
     *
     * @generated from protobuf rpc: StreamExecute(query.StreamExecuteRequest) returns (stream query.StreamExecuteResponse);
     */
    streamExecute(input: StreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<StreamExecuteRequest, StreamExecuteResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamExecuteRequest, StreamExecuteResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Begin a transaction.
     *
     * @generated from protobuf rpc: Begin(query.BeginRequest) returns (query.BeginResponse);
     */
    begin(input: BeginRequest, options?: RpcOptions): UnaryCall<BeginRequest, BeginResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<BeginRequest, BeginResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Commit a transaction.
     *
     * @generated from protobuf rpc: Commit(query.CommitRequest) returns (query.CommitResponse);
     */
    commit(input: CommitRequest, options?: RpcOptions): UnaryCall<CommitRequest, CommitResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<CommitRequest, CommitResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Rollback a transaction.
     *
     * @generated from protobuf rpc: Rollback(query.RollbackRequest) returns (query.RollbackResponse);
     */
    rollback(input: RollbackRequest, options?: RpcOptions): UnaryCall<RollbackRequest, RollbackResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<RollbackRequest, RollbackResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Prepare preares a transaction.
     *
     * @generated from protobuf rpc: Prepare(query.PrepareRequest) returns (query.PrepareResponse);
     */
    prepare(input: PrepareRequest, options?: RpcOptions): UnaryCall<PrepareRequest, PrepareResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<PrepareRequest, PrepareResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CommitPrepared commits a prepared transaction.
     *
     * @generated from protobuf rpc: CommitPrepared(query.CommitPreparedRequest) returns (query.CommitPreparedResponse);
     */
    commitPrepared(input: CommitPreparedRequest, options?: RpcOptions): UnaryCall<CommitPreparedRequest, CommitPreparedResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<CommitPreparedRequest, CommitPreparedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RollbackPrepared rolls back a prepared transaction.
     *
     * @generated from protobuf rpc: RollbackPrepared(query.RollbackPreparedRequest) returns (query.RollbackPreparedResponse);
     */
    rollbackPrepared(input: RollbackPreparedRequest, options?: RpcOptions): UnaryCall<RollbackPreparedRequest, RollbackPreparedResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<RollbackPreparedRequest, RollbackPreparedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateTransaction creates the metadata for a 2pc transaction.
     *
     * @generated from protobuf rpc: CreateTransaction(query.CreateTransactionRequest) returns (query.CreateTransactionResponse);
     */
    createTransaction(input: CreateTransactionRequest, options?: RpcOptions): UnaryCall<CreateTransactionRequest, CreateTransactionResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateTransactionRequest, CreateTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StartCommit initiates a commit for a 2pc transaction.
     *
     * @generated from protobuf rpc: StartCommit(query.StartCommitRequest) returns (query.StartCommitResponse);
     */
    startCommit(input: StartCommitRequest, options?: RpcOptions): UnaryCall<StartCommitRequest, StartCommitResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<StartCommitRequest, StartCommitResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetRollback marks the 2pc transaction for rollback.
     *
     * @generated from protobuf rpc: SetRollback(query.SetRollbackRequest) returns (query.SetRollbackResponse);
     */
    setRollback(input: SetRollbackRequest, options?: RpcOptions): UnaryCall<SetRollbackRequest, SetRollbackResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetRollbackRequest, SetRollbackResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ConcludeTransaction marks the 2pc transaction as resolved.
     *
     * @generated from protobuf rpc: ConcludeTransaction(query.ConcludeTransactionRequest) returns (query.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<ConcludeTransactionRequest, ConcludeTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReadTransaction returns the 2pc transaction info.
     *
     * @generated from protobuf rpc: ReadTransaction(query.ReadTransactionRequest) returns (query.ReadTransactionResponse);
     */
    readTransaction(input: ReadTransactionRequest, options?: RpcOptions): UnaryCall<ReadTransactionRequest, ReadTransactionResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReadTransactionRequest, ReadTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UnresolvedTransactions returns the 2pc transaction info.
     *
     * @generated from protobuf rpc: UnresolvedTransactions(query.UnresolvedTransactionsRequest) returns (query.UnresolvedTransactionsResponse);
     */
    unresolvedTransactions(input: UnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<UnresolvedTransactionsRequest, UnresolvedTransactionsResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<UnresolvedTransactionsRequest, UnresolvedTransactionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * BeginExecute executes a begin and the specified SQL query.
     *
     * @generated from protobuf rpc: BeginExecute(query.BeginExecuteRequest) returns (query.BeginExecuteResponse);
     */
    beginExecute(input: BeginExecuteRequest, options?: RpcOptions): UnaryCall<BeginExecuteRequest, BeginExecuteResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<BeginExecuteRequest, BeginExecuteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * BeginStreamExecute executes a begin and the specified SQL query.
     *
     * @generated from protobuf rpc: BeginStreamExecute(query.BeginStreamExecuteRequest) returns (stream query.BeginStreamExecuteResponse);
     */
    beginStreamExecute(input: BeginStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<BeginStreamExecuteRequest, BeginStreamExecuteResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<BeginStreamExecuteRequest, BeginStreamExecuteResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * MessageStream streams messages from a message table.
     *
     * @generated from protobuf rpc: MessageStream(query.MessageStreamRequest) returns (stream query.MessageStreamResponse);
     */
    messageStream(input: MessageStreamRequest, options?: RpcOptions): ServerStreamingCall<MessageStreamRequest, MessageStreamResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<MessageStreamRequest, MessageStreamResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * MessageAck acks messages for a table.
     *
     * @generated from protobuf rpc: MessageAck(query.MessageAckRequest) returns (query.MessageAckResponse);
     */
    messageAck(input: MessageAckRequest, options?: RpcOptions): UnaryCall<MessageAckRequest, MessageAckResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<MessageAckRequest, MessageAckResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReserveExecute executes a query on a reserved connection
     *
     * @generated from protobuf rpc: ReserveExecute(query.ReserveExecuteRequest) returns (query.ReserveExecuteResponse);
     */
    reserveExecute(input: ReserveExecuteRequest, options?: RpcOptions): UnaryCall<ReserveExecuteRequest, ReserveExecuteResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReserveExecuteRequest, ReserveExecuteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReserveBeginExecute starts a transaction and executes a query in the transaction on a reserved connection
     *
     * @generated from protobuf rpc: ReserveBeginExecute(query.ReserveBeginExecuteRequest) returns (query.ReserveBeginExecuteResponse);
     */
    reserveBeginExecute(input: ReserveBeginExecuteRequest, options?: RpcOptions): UnaryCall<ReserveBeginExecuteRequest, ReserveBeginExecuteResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReserveBeginExecuteRequest, ReserveBeginExecuteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReserveStreamExecute executes a streaming query on a reserved connection
     *
     * @generated from protobuf rpc: ReserveStreamExecute(query.ReserveStreamExecuteRequest) returns (stream query.ReserveStreamExecuteResponse);
     */
    reserveStreamExecute(input: ReserveStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<ReserveStreamExecuteRequest, ReserveStreamExecuteResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReserveStreamExecuteRequest, ReserveStreamExecuteResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * ReserveBeginStreamExecute starts a transaction and executes a streaming query in the transaction on a reserved connection
     *
     * @generated from protobuf rpc: ReserveBeginStreamExecute(query.ReserveBeginStreamExecuteRequest) returns (stream query.ReserveBeginStreamExecuteResponse);
     */
    reserveBeginStreamExecute(input: ReserveBeginStreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<ReserveBeginStreamExecuteRequest, ReserveBeginStreamExecuteResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReserveBeginStreamExecuteRequest, ReserveBeginStreamExecuteResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Release releases the connection
     *
     * @generated from protobuf rpc: Release(query.ReleaseRequest) returns (query.ReleaseResponse);
     */
    release(input: ReleaseRequest, options?: RpcOptions): UnaryCall<ReleaseRequest, ReleaseResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReleaseRequest, ReleaseResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StreamHealth runs a streaming RPC to the tablet, that returns the
     * current health of the tablet on a regular basis.
     *
     * @generated from protobuf rpc: StreamHealth(query.StreamHealthRequest) returns (stream query.StreamHealthResponse);
     */
    streamHealth(input: StreamHealthRequest, options?: RpcOptions): ServerStreamingCall<StreamHealthRequest, StreamHealthResponse> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamHealthRequest, StreamHealthResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * VStream streams vreplication events.
     *
     * @generated from protobuf rpc: VStream(binlogdata.VStreamRequest) returns (stream binlogdata.VStreamResponse);
     */
    vStream(input: VStreamRequest, options?: RpcOptions): ServerStreamingCall<VStreamRequest, VStreamResponse> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<VStreamRequest, VStreamResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * VStreamRows streams rows from the specified starting point.
     *
     * @generated from protobuf rpc: VStreamRows(binlogdata.VStreamRowsRequest) returns (stream binlogdata.VStreamRowsResponse);
     */
    vStreamRows(input: VStreamRowsRequest, options?: RpcOptions): ServerStreamingCall<VStreamRowsRequest, VStreamRowsResponse> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<VStreamRowsRequest, VStreamRowsResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * VStreamTables streams rows from the specified starting point.
     *
     * @generated from protobuf rpc: VStreamTables(binlogdata.VStreamTablesRequest) returns (stream binlogdata.VStreamTablesResponse);
     */
    vStreamTables(input: VStreamTablesRequest, options?: RpcOptions): ServerStreamingCall<VStreamTablesRequest, VStreamTablesResponse> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<VStreamTablesRequest, VStreamTablesResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * VStreamResults streams results along with the gtid of the snapshot.
     *
     * @generated from protobuf rpc: VStreamResults(binlogdata.VStreamResultsRequest) returns (stream binlogdata.VStreamResultsResponse);
     */
    vStreamResults(input: VStreamResultsRequest, options?: RpcOptions): ServerStreamingCall<VStreamResultsRequest, VStreamResultsResponse> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<VStreamResultsRequest, VStreamResultsResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * GetSchema returns the schema information.
     *
     * @generated from protobuf rpc: GetSchema(query.GetSchemaRequest) returns (stream query.GetSchemaResponse);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): ServerStreamingCall<GetSchemaRequest, GetSchemaResponse> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemaRequest, GetSchemaResponse>("serverStreaming", this._transport, method, opt, input);
    }
}
