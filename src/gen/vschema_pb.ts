//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the types needed to define a vschema.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file vschema.proto (package vschema, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Type, TypeJson } from "./query_pb";
import { file_query } from "./query_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file vschema.proto.
 */
export const file_vschema: GenFile = /*@__PURE__*/
  fileDesc("Cg12c2NoZW1hLnByb3RvEgd2c2NoZW1hIjMKDFJvdXRpbmdSdWxlcxIjCgVydWxlcxgBIAMoCzIULnZzY2hlbWEuUm91dGluZ1J1bGUiNAoLUm91dGluZ1J1bGUSEgoKZnJvbV90YWJsZRgBIAEoCRIRCgl0b190YWJsZXMYAiADKAki3gMKCEtleXNwYWNlEg8KB3NoYXJkZWQYASABKAgSMQoIdmluZGV4ZXMYAiADKAsyHy52c2NoZW1hLktleXNwYWNlLlZpbmRleGVzRW50cnkSLQoGdGFibGVzGAMgAygLMh0udnNjaGVtYS5LZXlzcGFjZS5UYWJsZXNFbnRyeRIgChhyZXF1aXJlX2V4cGxpY2l0X3JvdXRpbmcYBCABKAgSOgoQZm9yZWlnbl9rZXlfbW9kZRgFIAEoDjIgLnZzY2hlbWEuS2V5c3BhY2UuRm9yZWlnbktleU1vZGUSMwoRbXVsdGlfdGVuYW50X3NwZWMYBiABKAsyGC52c2NoZW1hLk11bHRpVGVuYW50U3BlYxpACg1WaW5kZXhlc0VudHJ5EgsKA2tleRgBIAEoCRIeCgV2YWx1ZRgCIAEoCzIPLnZzY2hlbWEuVmluZGV4OgI4ARo9CgtUYWJsZXNFbnRyeRILCgNrZXkYASABKAkSHQoFdmFsdWUYAiABKAsyDi52c2NoZW1hLlRhYmxlOgI4ASJLCg5Gb3JlaWduS2V5TW9kZRIPCgt1bnNwZWNpZmllZBAAEgwKCGRpc2FsbG93EAESDQoJdW5tYW5hZ2VkEAISCwoHbWFuYWdlZBADIlwKD011bHRpVGVuYW50U3BlYxIdChV0ZW5hbnRfaWRfY29sdW1uX25hbWUYASABKAkSKgoVdGVuYW50X2lkX2NvbHVtbl90eXBlGAIgASgOMgsucXVlcnkuVHlwZSKBAQoGVmluZGV4EgwKBHR5cGUYASABKAkSKwoGcGFyYW1zGAIgAygLMhsudnNjaGVtYS5WaW5kZXguUGFyYW1zRW50cnkSDQoFb3duZXIYAyABKAkaLQoLUGFyYW1zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASLaAQoFVGFibGUSDAoEdHlwZRgBIAEoCRIuCg9jb2x1bW5fdmluZGV4ZXMYAiADKAsyFS52c2NoZW1hLkNvbHVtblZpbmRleBIuCg5hdXRvX2luY3JlbWVudBgDIAEoCzIWLnZzY2hlbWEuQXV0b0luY3JlbWVudBIgCgdjb2x1bW5zGAQgAygLMg8udnNjaGVtYS5Db2x1bW4SDgoGcGlubmVkGAUgASgJEiEKGWNvbHVtbl9saXN0X2F1dGhvcml0YXRpdmUYBiABKAgSDgoGc291cmNlGAcgASgJIj0KDENvbHVtblZpbmRleBIOCgZjb2x1bW4YASABKAkSDAoEbmFtZRgCIAEoCRIPCgdjb2x1bW5zGAMgAygJIjEKDUF1dG9JbmNyZW1lbnQSDgoGY29sdW1uGAEgASgJEhAKCHNlcXVlbmNlGAIgASgJIr4BCgZDb2x1bW4SDAoEbmFtZRgBIAEoCRIZCgR0eXBlGAIgASgOMgsucXVlcnkuVHlwZRIRCglpbnZpc2libGUYAyABKAgSDwoHZGVmYXVsdBgEIAEoCRIWCg5jb2xsYXRpb25fbmFtZRgFIAEoCRIMCgRzaXplGAYgASgFEg0KBXNjYWxlGAcgASgFEhUKCG51bGxhYmxlGAggASgISACIAQESDgoGdmFsdWVzGAkgAygJQgsKCV9udWxsYWJsZSLaAgoKU3J2VlNjaGVtYRI1CglrZXlzcGFjZXMYASADKAsyIi52c2NoZW1hLlNydlZTY2hlbWEuS2V5c3BhY2VzRW50cnkSLAoNcm91dGluZ19ydWxlcxgCIAEoCzIVLnZzY2hlbWEuUm91dGluZ1J1bGVzEjcKE3NoYXJkX3JvdXRpbmdfcnVsZXMYAyABKAsyGi52c2NoZW1hLlNoYXJkUm91dGluZ1J1bGVzEj0KFmtleXNwYWNlX3JvdXRpbmdfcnVsZXMYBCABKAsyHS52c2NoZW1hLktleXNwYWNlUm91dGluZ1J1bGVzEioKDG1pcnJvcl9ydWxlcxgFIAEoCzIULnZzY2hlbWEuTWlycm9yUnVsZXMaQwoOS2V5c3BhY2VzRW50cnkSCwoDa2V5GAEgASgJEiAKBXZhbHVlGAIgASgLMhEudnNjaGVtYS5LZXlzcGFjZToCOAEiPQoRU2hhcmRSb3V0aW5nUnVsZXMSKAoFcnVsZXMYASADKAsyGS52c2NoZW1hLlNoYXJkUm91dGluZ1J1bGUiTQoQU2hhcmRSb3V0aW5nUnVsZRIVCg1mcm9tX2tleXNwYWNlGAEgASgJEhMKC3RvX2tleXNwYWNlGAIgASgJEg0KBXNoYXJkGAMgASgJIkMKFEtleXNwYWNlUm91dGluZ1J1bGVzEisKBXJ1bGVzGAEgAygLMhwudnNjaGVtYS5LZXlzcGFjZVJvdXRpbmdSdWxlIkEKE0tleXNwYWNlUm91dGluZ1J1bGUSFQoNZnJvbV9rZXlzcGFjZRgBIAEoCRITCgt0b19rZXlzcGFjZRgCIAEoCSIxCgtNaXJyb3JSdWxlcxIiCgVydWxlcxgBIAMoCzITLnZzY2hlbWEuTWlycm9yUnVsZSJDCgpNaXJyb3JSdWxlEhIKCmZyb21fdGFibGUYASABKAkSEAoIdG9fdGFibGUYAiABKAkSDwoHcGVyY2VudBgDIAEoAkImWiR2aXRlc3MuaW8vdml0ZXNzL2dvL3Z0L3Byb3RvL3ZzY2hlbWFiBnByb3RvMw", [file_query]);

/**
 * RoutingRules specify the high level routing rules for the VSchema.
 *
 * @generated from message vschema.RoutingRules
 */
export type RoutingRules = Message<"vschema.RoutingRules"> & {
  /**
   * rules should ideally be a map. However protos dont't allow
   * repeated fields as elements of a map. So, we use a list
   * instead.
   *
   * @generated from field: repeated vschema.RoutingRule rules = 1;
   */
  rules: RoutingRule[];
};

/**
 * RoutingRules specify the high level routing rules for the VSchema.
 *
 * @generated from message vschema.RoutingRules
 */
export type RoutingRulesJson = {
  /**
   * rules should ideally be a map. However protos dont't allow
   * repeated fields as elements of a map. So, we use a list
   * instead.
   *
   * @generated from field: repeated vschema.RoutingRule rules = 1;
   */
  rules?: RoutingRuleJson[];
};

/**
 * Describes the message vschema.RoutingRules.
 * Use `create(RoutingRulesSchema)` to create a new message.
 */
export const RoutingRulesSchema: GenMessage<RoutingRules, RoutingRulesJson> = /*@__PURE__*/
  messageDesc(file_vschema, 0);

/**
 * RoutingRule specifies a routing rule.
 *
 * @generated from message vschema.RoutingRule
 */
export type RoutingRule = Message<"vschema.RoutingRule"> & {
  /**
   * @generated from field: string from_table = 1;
   */
  fromTable: string;

  /**
   * @generated from field: repeated string to_tables = 2;
   */
  toTables: string[];
};

/**
 * RoutingRule specifies a routing rule.
 *
 * @generated from message vschema.RoutingRule
 */
export type RoutingRuleJson = {
  /**
   * @generated from field: string from_table = 1;
   */
  fromTable?: string;

  /**
   * @generated from field: repeated string to_tables = 2;
   */
  toTables?: string[];
};

/**
 * Describes the message vschema.RoutingRule.
 * Use `create(RoutingRuleSchema)` to create a new message.
 */
export const RoutingRuleSchema: GenMessage<RoutingRule, RoutingRuleJson> = /*@__PURE__*/
  messageDesc(file_vschema, 1);

/**
 * Keyspace is the vschema for a keyspace.
 *
 * @generated from message vschema.Keyspace
 */
export type Keyspace = Message<"vschema.Keyspace"> & {
  /**
   * If sharded is false, vindexes and tables are ignored.
   *
   * @generated from field: bool sharded = 1;
   */
  sharded: boolean;

  /**
   * @generated from field: map<string, vschema.Vindex> vindexes = 2;
   */
  vindexes: { [key: string]: Vindex };

  /**
   * @generated from field: map<string, vschema.Table> tables = 3;
   */
  tables: { [key: string]: Table };

  /**
   * If require_explicit_routing is true, vindexes and tables are not added to global routing
   *
   * @generated from field: bool require_explicit_routing = 4;
   */
  requireExplicitRouting: boolean;

  /**
   * foreign_key_mode dictates how Vitess should handle foreign keys for this keyspace.
   *
   * @generated from field: vschema.Keyspace.ForeignKeyMode foreign_key_mode = 5;
   */
  foreignKeyMode: Keyspace_ForeignKeyMode;

  /**
   * multi_tenant_mode specifies that the keyspace is multi-tenant. Currently used during migrations with MoveTables.
   *
   * @generated from field: vschema.MultiTenantSpec multi_tenant_spec = 6;
   */
  multiTenantSpec?: MultiTenantSpec;
};

/**
 * Keyspace is the vschema for a keyspace.
 *
 * @generated from message vschema.Keyspace
 */
export type KeyspaceJson = {
  /**
   * If sharded is false, vindexes and tables are ignored.
   *
   * @generated from field: bool sharded = 1;
   */
  sharded?: boolean;

  /**
   * @generated from field: map<string, vschema.Vindex> vindexes = 2;
   */
  vindexes?: { [key: string]: VindexJson };

  /**
   * @generated from field: map<string, vschema.Table> tables = 3;
   */
  tables?: { [key: string]: TableJson };

  /**
   * If require_explicit_routing is true, vindexes and tables are not added to global routing
   *
   * @generated from field: bool require_explicit_routing = 4;
   */
  requireExplicitRouting?: boolean;

  /**
   * foreign_key_mode dictates how Vitess should handle foreign keys for this keyspace.
   *
   * @generated from field: vschema.Keyspace.ForeignKeyMode foreign_key_mode = 5;
   */
  foreignKeyMode?: Keyspace_ForeignKeyModeJson;

  /**
   * multi_tenant_mode specifies that the keyspace is multi-tenant. Currently used during migrations with MoveTables.
   *
   * @generated from field: vschema.MultiTenantSpec multi_tenant_spec = 6;
   */
  multiTenantSpec?: MultiTenantSpecJson;
};

/**
 * Describes the message vschema.Keyspace.
 * Use `create(KeyspaceSchema)` to create a new message.
 */
export const KeyspaceSchema: GenMessage<Keyspace, KeyspaceJson> = /*@__PURE__*/
  messageDesc(file_vschema, 2);

/**
 * @generated from enum vschema.Keyspace.ForeignKeyMode
 */
export enum Keyspace_ForeignKeyMode {
  /**
   * @generated from enum value: unspecified = 0;
   */
  unspecified = 0,

  /**
   * @generated from enum value: disallow = 1;
   */
  disallow = 1,

  /**
   * @generated from enum value: unmanaged = 2;
   */
  unmanaged = 2,

  /**
   * @generated from enum value: managed = 3;
   */
  managed = 3,
}

/**
 * @generated from enum vschema.Keyspace.ForeignKeyMode
 */
export type Keyspace_ForeignKeyModeJson = "unspecified" | "disallow" | "unmanaged" | "managed";

/**
 * Describes the enum vschema.Keyspace.ForeignKeyMode.
 */
export const Keyspace_ForeignKeyModeSchema: GenEnum<Keyspace_ForeignKeyMode, Keyspace_ForeignKeyModeJson> = /*@__PURE__*/
  enumDesc(file_vschema, 2, 0);

/**
 * @generated from message vschema.MultiTenantSpec
 */
export type MultiTenantSpec = Message<"vschema.MultiTenantSpec"> & {
  /**
   * tenant_column is the name of the column that specifies the tenant id.
   *
   * @generated from field: string tenant_id_column_name = 1;
   */
  tenantIdColumnName: string;

  /**
   * tenant_column_type is the type of the column that specifies the tenant id.
   *
   * @generated from field: query.Type tenant_id_column_type = 2;
   */
  tenantIdColumnType: Type;
};

/**
 * @generated from message vschema.MultiTenantSpec
 */
export type MultiTenantSpecJson = {
  /**
   * tenant_column is the name of the column that specifies the tenant id.
   *
   * @generated from field: string tenant_id_column_name = 1;
   */
  tenantIdColumnName?: string;

  /**
   * tenant_column_type is the type of the column that specifies the tenant id.
   *
   * @generated from field: query.Type tenant_id_column_type = 2;
   */
  tenantIdColumnType?: TypeJson;
};

/**
 * Describes the message vschema.MultiTenantSpec.
 * Use `create(MultiTenantSpecSchema)` to create a new message.
 */
export const MultiTenantSpecSchema: GenMessage<MultiTenantSpec, MultiTenantSpecJson> = /*@__PURE__*/
  messageDesc(file_vschema, 3);

/**
 * Vindex is the vindex info for a Keyspace.
 *
 * @generated from message vschema.Vindex
 */
export type Vindex = Message<"vschema.Vindex"> & {
  /**
   * The type must match one of the predefined
   * (or plugged in) vindex names.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * params is a map of attribute value pairs
   * that must be defined as required by the
   * vindex constructors. The values can only
   * be strings.
   *
   * @generated from field: map<string, string> params = 2;
   */
  params: { [key: string]: string };

  /**
   * A lookup vindex can have an owner table defined.
   * If so, rows in the lookup table are created or
   * deleted in sync with corresponding rows in the
   * owner table.
   *
   * @generated from field: string owner = 3;
   */
  owner: string;
};

/**
 * Vindex is the vindex info for a Keyspace.
 *
 * @generated from message vschema.Vindex
 */
export type VindexJson = {
  /**
   * The type must match one of the predefined
   * (or plugged in) vindex names.
   *
   * @generated from field: string type = 1;
   */
  type?: string;

  /**
   * params is a map of attribute value pairs
   * that must be defined as required by the
   * vindex constructors. The values can only
   * be strings.
   *
   * @generated from field: map<string, string> params = 2;
   */
  params?: { [key: string]: string };

  /**
   * A lookup vindex can have an owner table defined.
   * If so, rows in the lookup table are created or
   * deleted in sync with corresponding rows in the
   * owner table.
   *
   * @generated from field: string owner = 3;
   */
  owner?: string;
};

/**
 * Describes the message vschema.Vindex.
 * Use `create(VindexSchema)` to create a new message.
 */
export const VindexSchema: GenMessage<Vindex, VindexJson> = /*@__PURE__*/
  messageDesc(file_vschema, 4);

/**
 * Table is the table info for a Keyspace.
 *
 * @generated from message vschema.Table
 */
export type Table = Message<"vschema.Table"> & {
  /**
   * If the table is a sequence, type must be
   * "sequence".
   *
   * If the table is a reference, type must be
   * "reference".
   * See https://vitess.io/docs/reference/features/vschema/#reference-tables.
   *
   * Otherwise, it should be empty.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * column_vindexes associates columns to vindexes.
   *
   * @generated from field: repeated vschema.ColumnVindex column_vindexes = 2;
   */
  columnVindexes: ColumnVindex[];

  /**
   * auto_increment is specified if a column needs
   * to be associated with a sequence.
   *
   * @generated from field: vschema.AutoIncrement auto_increment = 3;
   */
  autoIncrement?: AutoIncrement;

  /**
   * columns lists the columns for the table.
   *
   * @generated from field: repeated vschema.Column columns = 4;
   */
  columns: Column[];

  /**
   * pinned pins an unsharded table to a specific
   * shard, as dictated by the keyspace id.
   * The keyspace id is represented in hex form
   * like in keyranges.
   *
   * @generated from field: string pinned = 5;
   */
  pinned: string;

  /**
   * column_list_authoritative is set to true if columns is
   * an authoritative list for the table. This allows
   * us to expand 'select *' expressions.
   *
   * @generated from field: bool column_list_authoritative = 6;
   */
  columnListAuthoritative: boolean;

  /**
   * reference tables may optionally indicate their source table.
   *
   * @generated from field: string source = 7;
   */
  source: string;
};

/**
 * Table is the table info for a Keyspace.
 *
 * @generated from message vschema.Table
 */
export type TableJson = {
  /**
   * If the table is a sequence, type must be
   * "sequence".
   *
   * If the table is a reference, type must be
   * "reference".
   * See https://vitess.io/docs/reference/features/vschema/#reference-tables.
   *
   * Otherwise, it should be empty.
   *
   * @generated from field: string type = 1;
   */
  type?: string;

  /**
   * column_vindexes associates columns to vindexes.
   *
   * @generated from field: repeated vschema.ColumnVindex column_vindexes = 2;
   */
  columnVindexes?: ColumnVindexJson[];

  /**
   * auto_increment is specified if a column needs
   * to be associated with a sequence.
   *
   * @generated from field: vschema.AutoIncrement auto_increment = 3;
   */
  autoIncrement?: AutoIncrementJson;

  /**
   * columns lists the columns for the table.
   *
   * @generated from field: repeated vschema.Column columns = 4;
   */
  columns?: ColumnJson[];

  /**
   * pinned pins an unsharded table to a specific
   * shard, as dictated by the keyspace id.
   * The keyspace id is represented in hex form
   * like in keyranges.
   *
   * @generated from field: string pinned = 5;
   */
  pinned?: string;

  /**
   * column_list_authoritative is set to true if columns is
   * an authoritative list for the table. This allows
   * us to expand 'select *' expressions.
   *
   * @generated from field: bool column_list_authoritative = 6;
   */
  columnListAuthoritative?: boolean;

  /**
   * reference tables may optionally indicate their source table.
   *
   * @generated from field: string source = 7;
   */
  source?: string;
};

/**
 * Describes the message vschema.Table.
 * Use `create(TableSchema)` to create a new message.
 */
export const TableSchema: GenMessage<Table, TableJson> = /*@__PURE__*/
  messageDesc(file_vschema, 5);

/**
 * ColumnVindex is used to associate a column to a vindex.
 *
 * @generated from message vschema.ColumnVindex
 */
export type ColumnVindex = Message<"vschema.ColumnVindex"> & {
  /**
   * Legacy implementation, moving forward all vindexes should define a list of columns.
   *
   * @generated from field: string column = 1;
   */
  column: string;

  /**
   * The name must match a vindex defined in Keyspace.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * List of columns that define this Vindex
   *
   * @generated from field: repeated string columns = 3;
   */
  columns: string[];
};

/**
 * ColumnVindex is used to associate a column to a vindex.
 *
 * @generated from message vschema.ColumnVindex
 */
export type ColumnVindexJson = {
  /**
   * Legacy implementation, moving forward all vindexes should define a list of columns.
   *
   * @generated from field: string column = 1;
   */
  column?: string;

  /**
   * The name must match a vindex defined in Keyspace.
   *
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * List of columns that define this Vindex
   *
   * @generated from field: repeated string columns = 3;
   */
  columns?: string[];
};

/**
 * Describes the message vschema.ColumnVindex.
 * Use `create(ColumnVindexSchema)` to create a new message.
 */
export const ColumnVindexSchema: GenMessage<ColumnVindex, ColumnVindexJson> = /*@__PURE__*/
  messageDesc(file_vschema, 6);

/**
 * Autoincrement is used to designate a column as auto-inc.
 *
 * @generated from message vschema.AutoIncrement
 */
export type AutoIncrement = Message<"vschema.AutoIncrement"> & {
  /**
   * @generated from field: string column = 1;
   */
  column: string;

  /**
   * The sequence must match a table of type SEQUENCE.
   *
   * @generated from field: string sequence = 2;
   */
  sequence: string;
};

/**
 * Autoincrement is used to designate a column as auto-inc.
 *
 * @generated from message vschema.AutoIncrement
 */
export type AutoIncrementJson = {
  /**
   * @generated from field: string column = 1;
   */
  column?: string;

  /**
   * The sequence must match a table of type SEQUENCE.
   *
   * @generated from field: string sequence = 2;
   */
  sequence?: string;
};

/**
 * Describes the message vschema.AutoIncrement.
 * Use `create(AutoIncrementSchema)` to create a new message.
 */
export const AutoIncrementSchema: GenMessage<AutoIncrement, AutoIncrementJson> = /*@__PURE__*/
  messageDesc(file_vschema, 7);

/**
 * Column describes a column.
 *
 * @generated from message vschema.Column
 */
export type Column = Message<"vschema.Column"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: query.Type type = 2;
   */
  type: Type;

  /**
   * @generated from field: bool invisible = 3;
   */
  invisible: boolean;

  /**
   * @generated from field: string default = 4;
   */
  default: string;

  /**
   * @generated from field: string collation_name = 5;
   */
  collationName: string;

  /**
   * @generated from field: int32 size = 6;
   */
  size: number;

  /**
   * @generated from field: int32 scale = 7;
   */
  scale: number;

  /**
   * @generated from field: optional bool nullable = 8;
   */
  nullable?: boolean;

  /**
   * values contains the list of values for an enum or set column.
   *
   * @generated from field: repeated string values = 9;
   */
  values: string[];
};

/**
 * Column describes a column.
 *
 * @generated from message vschema.Column
 */
export type ColumnJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: query.Type type = 2;
   */
  type?: TypeJson;

  /**
   * @generated from field: bool invisible = 3;
   */
  invisible?: boolean;

  /**
   * @generated from field: string default = 4;
   */
  default?: string;

  /**
   * @generated from field: string collation_name = 5;
   */
  collationName?: string;

  /**
   * @generated from field: int32 size = 6;
   */
  size?: number;

  /**
   * @generated from field: int32 scale = 7;
   */
  scale?: number;

  /**
   * @generated from field: optional bool nullable = 8;
   */
  nullable?: boolean;

  /**
   * values contains the list of values for an enum or set column.
   *
   * @generated from field: repeated string values = 9;
   */
  values?: string[];
};

/**
 * Describes the message vschema.Column.
 * Use `create(ColumnSchema)` to create a new message.
 */
export const ColumnSchema: GenMessage<Column, ColumnJson> = /*@__PURE__*/
  messageDesc(file_vschema, 8);

/**
 * SrvVSchema is the roll-up of all the Keyspace schema for a cell.
 *
 * @generated from message vschema.SrvVSchema
 */
export type SrvVSchema = Message<"vschema.SrvVSchema"> & {
  /**
   * keyspaces is a map of keyspace name -> Keyspace object.
   *
   * @generated from field: map<string, vschema.Keyspace> keyspaces = 1;
   */
  keyspaces: { [key: string]: Keyspace };

  /**
   * table routing rules
   *
   * @generated from field: vschema.RoutingRules routing_rules = 2;
   */
  routingRules?: RoutingRules;

  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 3;
   */
  shardRoutingRules?: ShardRoutingRules;

  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 4;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRules;

  /**
   * mirror rules
   *
   * @generated from field: vschema.MirrorRules mirror_rules = 5;
   */
  mirrorRules?: MirrorRules;
};

/**
 * SrvVSchema is the roll-up of all the Keyspace schema for a cell.
 *
 * @generated from message vschema.SrvVSchema
 */
export type SrvVSchemaJson = {
  /**
   * keyspaces is a map of keyspace name -> Keyspace object.
   *
   * @generated from field: map<string, vschema.Keyspace> keyspaces = 1;
   */
  keyspaces?: { [key: string]: KeyspaceJson };

  /**
   * table routing rules
   *
   * @generated from field: vschema.RoutingRules routing_rules = 2;
   */
  routingRules?: RoutingRulesJson;

  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 3;
   */
  shardRoutingRules?: ShardRoutingRulesJson;

  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 4;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRulesJson;

  /**
   * mirror rules
   *
   * @generated from field: vschema.MirrorRules mirror_rules = 5;
   */
  mirrorRules?: MirrorRulesJson;
};

/**
 * Describes the message vschema.SrvVSchema.
 * Use `create(SrvVSchemaSchema)` to create a new message.
 */
export const SrvVSchemaSchema: GenMessage<SrvVSchema, SrvVSchemaJson> = /*@__PURE__*/
  messageDesc(file_vschema, 9);

/**
 * ShardRoutingRules specify the shard routing rules for the VSchema.
 *
 * @generated from message vschema.ShardRoutingRules
 */
export type ShardRoutingRules = Message<"vschema.ShardRoutingRules"> & {
  /**
   * @generated from field: repeated vschema.ShardRoutingRule rules = 1;
   */
  rules: ShardRoutingRule[];
};

/**
 * ShardRoutingRules specify the shard routing rules for the VSchema.
 *
 * @generated from message vschema.ShardRoutingRules
 */
export type ShardRoutingRulesJson = {
  /**
   * @generated from field: repeated vschema.ShardRoutingRule rules = 1;
   */
  rules?: ShardRoutingRuleJson[];
};

/**
 * Describes the message vschema.ShardRoutingRules.
 * Use `create(ShardRoutingRulesSchema)` to create a new message.
 */
export const ShardRoutingRulesSchema: GenMessage<ShardRoutingRules, ShardRoutingRulesJson> = /*@__PURE__*/
  messageDesc(file_vschema, 10);

/**
 * ShardRoutingRule specifies a routing rule.
 *
 * @generated from message vschema.ShardRoutingRule
 */
export type ShardRoutingRule = Message<"vschema.ShardRoutingRule"> & {
  /**
   * @generated from field: string from_keyspace = 1;
   */
  fromKeyspace: string;

  /**
   * @generated from field: string to_keyspace = 2;
   */
  toKeyspace: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard: string;
};

/**
 * ShardRoutingRule specifies a routing rule.
 *
 * @generated from message vschema.ShardRoutingRule
 */
export type ShardRoutingRuleJson = {
  /**
   * @generated from field: string from_keyspace = 1;
   */
  fromKeyspace?: string;

  /**
   * @generated from field: string to_keyspace = 2;
   */
  toKeyspace?: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard?: string;
};

/**
 * Describes the message vschema.ShardRoutingRule.
 * Use `create(ShardRoutingRuleSchema)` to create a new message.
 */
export const ShardRoutingRuleSchema: GenMessage<ShardRoutingRule, ShardRoutingRuleJson> = /*@__PURE__*/
  messageDesc(file_vschema, 11);

/**
 * @generated from message vschema.KeyspaceRoutingRules
 */
export type KeyspaceRoutingRules = Message<"vschema.KeyspaceRoutingRules"> & {
  /**
   * @generated from field: repeated vschema.KeyspaceRoutingRule rules = 1;
   */
  rules: KeyspaceRoutingRule[];
};

/**
 * @generated from message vschema.KeyspaceRoutingRules
 */
export type KeyspaceRoutingRulesJson = {
  /**
   * @generated from field: repeated vschema.KeyspaceRoutingRule rules = 1;
   */
  rules?: KeyspaceRoutingRuleJson[];
};

/**
 * Describes the message vschema.KeyspaceRoutingRules.
 * Use `create(KeyspaceRoutingRulesSchema)` to create a new message.
 */
export const KeyspaceRoutingRulesSchema: GenMessage<KeyspaceRoutingRules, KeyspaceRoutingRulesJson> = /*@__PURE__*/
  messageDesc(file_vschema, 12);

/**
 * @generated from message vschema.KeyspaceRoutingRule
 */
export type KeyspaceRoutingRule = Message<"vschema.KeyspaceRoutingRule"> & {
  /**
   * @generated from field: string from_keyspace = 1;
   */
  fromKeyspace: string;

  /**
   * @generated from field: string to_keyspace = 2;
   */
  toKeyspace: string;
};

/**
 * @generated from message vschema.KeyspaceRoutingRule
 */
export type KeyspaceRoutingRuleJson = {
  /**
   * @generated from field: string from_keyspace = 1;
   */
  fromKeyspace?: string;

  /**
   * @generated from field: string to_keyspace = 2;
   */
  toKeyspace?: string;
};

/**
 * Describes the message vschema.KeyspaceRoutingRule.
 * Use `create(KeyspaceRoutingRuleSchema)` to create a new message.
 */
export const KeyspaceRoutingRuleSchema: GenMessage<KeyspaceRoutingRule, KeyspaceRoutingRuleJson> = /*@__PURE__*/
  messageDesc(file_vschema, 13);

/**
 * MirrorRules specify the high level mirror rules for the VSchema.
 *
 * @generated from message vschema.MirrorRules
 */
export type MirrorRules = Message<"vschema.MirrorRules"> & {
  /**
   * rules should ideally be a map. However protos dont't allow
   * repeated fields as elements of a map. So, we use a list
   * instead.
   *
   * @generated from field: repeated vschema.MirrorRule rules = 1;
   */
  rules: MirrorRule[];
};

/**
 * MirrorRules specify the high level mirror rules for the VSchema.
 *
 * @generated from message vschema.MirrorRules
 */
export type MirrorRulesJson = {
  /**
   * rules should ideally be a map. However protos dont't allow
   * repeated fields as elements of a map. So, we use a list
   * instead.
   *
   * @generated from field: repeated vschema.MirrorRule rules = 1;
   */
  rules?: MirrorRuleJson[];
};

/**
 * Describes the message vschema.MirrorRules.
 * Use `create(MirrorRulesSchema)` to create a new message.
 */
export const MirrorRulesSchema: GenMessage<MirrorRules, MirrorRulesJson> = /*@__PURE__*/
  messageDesc(file_vschema, 14);

/**
 * MirrorRule specifies a mirror rule.
 *
 * @generated from message vschema.MirrorRule
 */
export type MirrorRule = Message<"vschema.MirrorRule"> & {
  /**
   * @generated from field: string from_table = 1;
   */
  fromTable: string;

  /**
   * @generated from field: string to_table = 2;
   */
  toTable: string;

  /**
   * @generated from field: float percent = 3;
   */
  percent: number;
};

/**
 * MirrorRule specifies a mirror rule.
 *
 * @generated from message vschema.MirrorRule
 */
export type MirrorRuleJson = {
  /**
   * @generated from field: string from_table = 1;
   */
  fromTable?: string;

  /**
   * @generated from field: string to_table = 2;
   */
  toTable?: string;

  /**
   * @generated from field: float percent = 3;
   */
  percent?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message vschema.MirrorRule.
 * Use `create(MirrorRuleSchema)` to create a new message.
 */
export const MirrorRuleSchema: GenMessage<MirrorRule, MirrorRuleJson> = /*@__PURE__*/
  messageDesc(file_vschema, 15);

