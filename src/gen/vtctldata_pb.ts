//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This package contains the data structures for a service allowing
// you to use vtctld as a server for vt commands.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file vtctldata.proto (package vtctldata, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { BinlogSource, BinlogSourceJson } from "./binlogdata_pb";
import { file_binlogdata } from "./binlogdata_pb";
import type { Event, EventJson } from "./logutil_pb";
import { file_logutil } from "./logutil_pb";
import type { BackupInfo, BackupInfoJson } from "./mysqlctl_pb";
import { file_mysqlctl } from "./mysqlctl_pb";
import type { QueryResult, QueryResultJson, Target, TargetJson, TransactionMetadata, TransactionMetadataJson } from "./query_pb";
import { file_query } from "./query_pb";
import type { FullStatus, FullStatusJson, Status, StatusJson } from "./replicationdata_pb";
import { file_replicationdata } from "./replicationdata_pb";
import type { CheckThrottlerResponse as CheckThrottlerResponse$1, CheckThrottlerResponseJson as CheckThrottlerResponseJson$1, ExecuteHookRequest as ExecuteHookRequest$1, ExecuteHookRequestJson as ExecuteHookRequestJson$1, ExecuteHookResponse as ExecuteHookResponse$1, ExecuteHookResponseJson as ExecuteHookResponseJson$1, GetThrottlerStatusResponse as GetThrottlerStatusResponse$1, GetThrottlerStatusResponseJson as GetThrottlerStatusResponseJson$1, Permissions, PermissionsJson, SchemaDefinition, SchemaDefinitionJson, TabletSelectionPreference, TabletSelectionPreferenceJson, UpdateVReplicationWorkflowRequest, UpdateVReplicationWorkflowRequestJson, VDiffResponse, VDiffResponseJson } from "./tabletmanagerdata_pb";
import { file_tabletmanagerdata } from "./tabletmanagerdata_pb";
import type { CellInfo, CellInfoJson, CellsAlias, CellsAliasJson, KeyRange, KeyRangeJson, Keyspace as Keyspace$1, KeyspaceJson as KeyspaceJson$1, KeyspaceType, KeyspaceTypeJson, Shard as Shard$1, Shard_TabletControl, Shard_TabletControlJson, ShardJson as ShardJson$1, ShardReplication, ShardReplicationError, ShardReplicationErrorJson, ShardReplicationJson, SrvKeyspace, SrvKeyspaceJson, Tablet, TabletAlias, TabletAliasJson, TabletJson, TabletType, TabletTypeJson, ThrottledAppRule, ThrottledAppRuleJson } from "./topodata_pb";
import { file_topodata } from "./topodata_pb";
import type { Keyspace as Keyspace$2, KeyspaceJson as KeyspaceJson$2, KeyspaceRoutingRules, KeyspaceRoutingRulesJson, MirrorRules, MirrorRulesJson, RoutingRules, RoutingRulesJson, ShardRoutingRules, ShardRoutingRulesJson, SrvVSchema, SrvVSchemaJson } from "./vschema_pb";
import { file_vschema } from "./vschema_pb";
import type { CallerID, CallerIDJson } from "./vtrpc_pb";
import { file_vtrpc } from "./vtrpc_pb";
import type { Duration, DurationJson, Time, TimeJson } from "./vttime_pb";
import { file_vttime } from "./vttime_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file vtctldata.proto.
 */
export const file_vtctldata: GenFile = /*@__PURE__*/
  fileDesc("Cg92dGN0bGRhdGEucHJvdG8SCXZ0Y3RsZGF0YSJCChpFeGVjdXRlVnRjdGxDb21tYW5kUmVxdWVzdBIMCgRhcmdzGAEgAygJEhYKDmFjdGlvbl90aW1lb3V0GAIgASgDIjwKG0V4ZWN1dGVWdGN0bENvbW1hbmRSZXNwb25zZRIdCgVldmVudBgBIAEoCzIOLmxvZ3V0aWwuRXZlbnQiXwoYVGFibGVNYXRlcmlhbGl6ZVNldHRpbmdzEhQKDHRhcmdldF90YWJsZRgBIAEoCRIZChFzb3VyY2VfZXhwcmVzc2lvbhgCIAEoCRISCgpjcmVhdGVfZGRsGAMgASgJIuAEChNNYXRlcmlhbGl6ZVNldHRpbmdzEhAKCHdvcmtmbG93GAEgASgJEhcKD3NvdXJjZV9rZXlzcGFjZRgCIAEoCRIXCg90YXJnZXRfa2V5c3BhY2UYAyABKAkSFwoPc3RvcF9hZnRlcl9jb3B5GAQgASgIEjsKDnRhYmxlX3NldHRpbmdzGAUgAygLMiMudnRjdGxkYXRhLlRhYmxlTWF0ZXJpYWxpemVTZXR0aW5ncxIMCgRjZWxsGAYgASgJEhQKDHRhYmxldF90eXBlcxgHIAEoCRIYChBleHRlcm5hbF9jbHVzdGVyGAggASgJEkAKFm1hdGVyaWFsaXphdGlvbl9pbnRlbnQYCSABKA4yIC52dGN0bGRhdGEuTWF0ZXJpYWxpemF0aW9uSW50ZW50EhgKEHNvdXJjZV90aW1lX3pvbmUYCiABKAkSGAoQdGFyZ2V0X3RpbWVfem9uZRgLIAEoCRIVCg1zb3VyY2Vfc2hhcmRzGAwgAygJEg4KBm9uX2RkbBgNIAEoCRIcChRkZWZlcl9zZWNvbmRhcnlfa2V5cxgOIAEoCBJRCht0YWJsZXRfc2VsZWN0aW9uX3ByZWZlcmVuY2UYDyABKA4yLC50YWJsZXRtYW5hZ2VyZGF0YS5UYWJsZXRTZWxlY3Rpb25QcmVmZXJlbmNlEhMKC2F0b21pY19jb3B5GBAgASgIEjQKEHdvcmtmbG93X29wdGlvbnMYESABKAsyGi52dGN0bGRhdGEuV29ya2Zsb3dPcHRpb25zEhgKEHJlZmVyZW5jZV90YWJsZXMYEiADKAkiPgoIS2V5c3BhY2USDAoEbmFtZRgBIAEoCRIkCghrZXlzcGFjZRgCIAEoCzISLnRvcG9kYXRhLktleXNwYWNlIscNCg9TY2hlbWFNaWdyYXRpb24SDAoEdXVpZBgBIAEoCRIQCghrZXlzcGFjZRgCIAEoCRINCgVzaGFyZBgDIAEoCRIOCgZzY2hlbWEYBCABKAkSDQoFdGFibGUYBSABKAkSGwoTbWlncmF0aW9uX3N0YXRlbWVudBgGIAEoCRI1CghzdHJhdGVneRgHIAEoDjIjLnZ0Y3RsZGF0YS5TY2hlbWFNaWdyYXRpb24uU3RyYXRlZ3kSDwoHb3B0aW9ucxgIIAEoCRIeCghhZGRlZF9hdBgJIAEoCzIMLnZ0dGltZS5UaW1lEiIKDHJlcXVlc3RlZF9hdBgKIAEoCzIMLnZ0dGltZS5UaW1lEh4KCHJlYWR5X2F0GAsgASgLMgwudnR0aW1lLlRpbWUSIAoKc3RhcnRlZF9hdBgMIAEoCzIMLnZ0dGltZS5UaW1lEigKEmxpdmVuZXNzX3RpbWVzdGFtcBgNIAEoCzIMLnZ0dGltZS5UaW1lEiIKDGNvbXBsZXRlZF9hdBgOIAEoCzIMLnZ0dGltZS5UaW1lEiMKDWNsZWFuZWRfdXBfYXQYDyABKAsyDC52dHRpbWUuVGltZRIxCgZzdGF0dXMYECABKA4yIS52dGN0bGRhdGEuU2NoZW1hTWlncmF0aW9uLlN0YXR1cxIQCghsb2dfcGF0aBgRIAEoCRIRCglhcnRpZmFjdHMYEiABKAkSDwoHcmV0cmllcxgTIAEoBBIlCgZ0YWJsZXQYFCABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIWCg50YWJsZXRfZmFpbHVyZRgVIAEoCBIQCghwcm9ncmVzcxgWIAEoAhIZChFtaWdyYXRpb25fY29udGV4dBgXIAEoCRISCgpkZGxfYWN0aW9uGBggASgJEg8KB21lc3NhZ2UYGSABKAkSEwoLZXRhX3NlY29uZHMYGiABKAMSEwoLcm93c19jb3BpZWQYGyABKAQSEgoKdGFibGVfcm93cxgcIAEoAxIZChFhZGRlZF91bmlxdWVfa2V5cxgdIAEoDRIbChNyZW1vdmVkX3VuaXF1ZV9rZXlzGB4gASgNEhAKCGxvZ19maWxlGB8gASgJEiwKEmFydGlmYWN0X3JldGVudGlvbhggIAEoCzIQLnZ0dGltZS5EdXJhdGlvbhIbChNwb3N0cG9uZV9jb21wbGV0aW9uGCEgASgIEiAKGHJlbW92ZWRfdW5pcXVlX2tleV9uYW1lcxgiIAEoCRInCh9kcm9wcGVkX25vX2RlZmF1bHRfY29sdW1uX25hbWVzGCMgASgJEh0KFWV4cGFuZGVkX2NvbHVtbl9uYW1lcxgkIAEoCRIYChByZXZlcnRpYmxlX25vdGVzGCUgASgJEhgKEGFsbG93X2NvbmN1cnJlbnQYJiABKAgSFQoNcmV2ZXJ0ZWRfdXVpZBgnIAEoCRIPCgdpc192aWV3GCggASgIEhkKEXJlYWR5X3RvX2NvbXBsZXRlGCkgASgIEiEKGXZpdGVzc19saXZlbmVzc19pbmRpY2F0b3IYKiABKAMSGwoTdXNlcl90aHJvdHRsZV9yYXRpbxgrIAEoAhIUCgxzcGVjaWFsX3BsYW4YLCABKAkSJwoRbGFzdF90aHJvdHRsZWRfYXQYLSABKAsyDC52dHRpbWUuVGltZRIbChNjb21wb25lbnRfdGhyb3R0bGVkGC4gASgJEiIKDGNhbmNlbGxlZF9hdBgvIAEoCzIMLnZ0dGltZS5UaW1lEhcKD3Bvc3Rwb25lX2xhdW5jaBgwIAEoCBINCgVzdGFnZRgxIAEoCRIYChBjdXRvdmVyX2F0dGVtcHRzGDIgASgNEh4KFmlzX2ltbWVkaWF0ZV9vcGVyYXRpb24YMyABKAgSIQoLcmV2aWV3ZWRfYXQYNCABKAsyDC52dHRpbWUuVGltZRIqChRyZWFkeV90b19jb21wbGV0ZV9hdBg1IAEoCzIMLnZ0dGltZS5UaW1lEiEKGXJlbW92ZWRfZm9yZWlnbl9rZXlfbmFtZXMYNiABKAkiUwoIU3RyYXRlZ3kSCgoGVklURVNTEAASCgoGT05MSU5FEAASCQoFR0hPU1QQARIJCgVQVE9TQxACEgoKBkRJUkVDVBADEgkKBU1ZU1FMEAQaAhABInEKBlN0YXR1cxILCgdVTktOT1dOEAASDQoJUkVRVUVTVEVEEAESDQoJQ0FOQ0VMTEVEEAISCgoGUVVFVUVEEAMSCQoFUkVBRFkQBBILCgdSVU5OSU5HEAUSDAoIQ09NUExFVEUQBhIKCgZGQUlMRUQQByJHCgVTaGFyZBIQCghrZXlzcGFjZRgBIAEoCRIMCgRuYW1lGAIgASgJEh4KBXNoYXJkGAMgASgLMg8udG9wb2RhdGEuU2hhcmQihgIKD1dvcmtmbG93T3B0aW9ucxIRCgl0ZW5hbnRfaWQYASABKAkSUAofc2hhcmRlZF9hdXRvX2luY3JlbWVudF9oYW5kbGluZxgCIAEoDjInLnZ0Y3RsZGF0YS5TaGFyZGVkQXV0b0luY3JlbWVudEhhbmRsaW5nEg4KBnNoYXJkcxgDIAMoCRI2CgZjb25maWcYBCADKAsyJi52dGN0bGRhdGEuV29ya2Zsb3dPcHRpb25zLkNvbmZpZ0VudHJ5EhcKD2dsb2JhbF9rZXlzcGFjZRgFIAEoCRotCgtDb25maWdFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIo8NCghXb3JrZmxvdxIMCgRuYW1lGAEgASgJEjcKBnNvdXJjZRgCIAEoCzInLnZ0Y3RsZGF0YS5Xb3JrZmxvdy5SZXBsaWNhdGlvbkxvY2F0aW9uEjcKBnRhcmdldBgDIAEoCzInLnZ0Y3RsZGF0YS5Xb3JrZmxvdy5SZXBsaWNhdGlvbkxvY2F0aW9uEh0KFW1heF92X3JlcGxpY2F0aW9uX2xhZxgEIAEoAxI8Cg1zaGFyZF9zdHJlYW1zGAUgAygLMiUudnRjdGxkYXRhLldvcmtmbG93LlNoYXJkU3RyZWFtc0VudHJ5EhUKDXdvcmtmbG93X3R5cGUYBiABKAkSGQoRd29ya2Zsb3dfc3ViX3R5cGUYByABKAkSKQohbWF4X3ZfcmVwbGljYXRpb25fdHJhbnNhY3Rpb25fbGFnGAggASgDEhwKFGRlZmVyX3NlY29uZGFyeV9rZXlzGAkgASgIEisKB29wdGlvbnMYCiABKAsyGi52dGN0bGRhdGEuV29ya2Zsb3dPcHRpb25zGlQKEVNoYXJkU3RyZWFtc0VudHJ5EgsKA2tleRgBIAEoCRIuCgV2YWx1ZRgCIAEoCzIfLnZ0Y3RsZGF0YS5Xb3JrZmxvdy5TaGFyZFN0cmVhbToCOAEaNwoTUmVwbGljYXRpb25Mb2NhdGlvbhIQCghrZXlzcGFjZRgBIAEoCRIOCgZzaGFyZHMYAiADKAkajgEKC1NoYXJkU3RyZWFtEisKB3N0cmVhbXMYASADKAsyGi52dGN0bGRhdGEuV29ya2Zsb3cuU3RyZWFtEjYKD3RhYmxldF9jb250cm9scxgCIAMoCzIdLnRvcG9kYXRhLlNoYXJkLlRhYmxldENvbnRyb2wSGgoSaXNfcHJpbWFyeV9zZXJ2aW5nGAMgASgIGt0HCgZTdHJlYW0SCgoCaWQYASABKAMSDQoFc2hhcmQYAiABKAkSJQoGdGFibGV0GAMgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSLwoNYmlubG9nX3NvdXJjZRgEIAEoCzIYLmJpbmxvZ2RhdGEuQmlubG9nU291cmNlEhAKCHBvc2l0aW9uGAUgASgJEhUKDXN0b3BfcG9zaXRpb24YBiABKAkSDQoFc3RhdGUYByABKAkSDwoHZGJfbmFtZRgIIAEoCRIrChV0cmFuc2FjdGlvbl90aW1lc3RhbXAYCSABKAsyDC52dHRpbWUuVGltZRIiCgx0aW1lX3VwZGF0ZWQYCiABKAsyDC52dHRpbWUuVGltZRIPCgdtZXNzYWdlGAsgASgJEjkKC2NvcHlfc3RhdGVzGAwgAygLMiQudnRjdGxkYXRhLldvcmtmbG93LlN0cmVhbS5Db3B5U3RhdGUSLAoEbG9ncxgNIAMoCzIeLnZ0Y3RsZGF0YS5Xb3JrZmxvdy5TdHJlYW0uTG9nEhcKD2xvZ19mZXRjaF9lcnJvchgOIAEoCRIMCgR0YWdzGA8gAygJEhMKC3Jvd3NfY29waWVkGBAgASgDEkQKEHRocm90dGxlcl9zdGF0dXMYESABKAsyKi52dGN0bGRhdGEuV29ya2Zsb3cuU3RyZWFtLlRocm90dGxlclN0YXR1cxIqCgx0YWJsZXRfdHlwZXMYEiADKA4yFC50b3BvZGF0YS5UYWJsZXRUeXBlElEKG3RhYmxldF9zZWxlY3Rpb25fcHJlZmVyZW5jZRgTIAEoDjIsLnRhYmxldG1hbmFnZXJkYXRhLlRhYmxldFNlbGVjdGlvblByZWZlcmVuY2USDQoFY2VsbHMYFCADKAkaPgoJQ29weVN0YXRlEg0KBXRhYmxlGAEgASgJEg8KB2xhc3RfcGsYAiABKAkSEQoJc3RyZWFtX2lkGAMgASgDGqUBCgNMb2cSCgoCaWQYASABKAMSEQoJc3RyZWFtX2lkGAIgASgDEgwKBHR5cGUYAyABKAkSDQoFc3RhdGUYBCABKAkSIAoKY3JlYXRlZF9hdBgFIAEoCzIMLnZ0dGltZS5UaW1lEiAKCnVwZGF0ZWRfYXQYBiABKAsyDC52dHRpbWUuVGltZRIPCgdtZXNzYWdlGAcgASgJEg0KBWNvdW50GAggASgDGlQKD1Rocm90dGxlclN0YXR1cxIbChNjb21wb25lbnRfdGhyb3R0bGVkGAEgASgJEiQKDnRpbWVfdGhyb3R0bGVkGAIgASgLMgwudnR0aW1lLlRpbWUiSQoSQWRkQ2VsbEluZm9SZXF1ZXN0EgwKBG5hbWUYASABKAkSJQoJY2VsbF9pbmZvGAIgASgLMhIudG9wb2RhdGEuQ2VsbEluZm8iFQoTQWRkQ2VsbEluZm9SZXNwb25zZSIzChRBZGRDZWxsc0FsaWFzUmVxdWVzdBIMCgRuYW1lGAEgASgJEg0KBWNlbGxzGAIgAygJIhcKFUFkZENlbGxzQWxpYXNSZXNwb25zZSKOAQogQXBwbHlLZXlzcGFjZVJvdXRpbmdSdWxlc1JlcXVlc3QSPQoWa2V5c3BhY2Vfcm91dGluZ19ydWxlcxgBIAEoCzIdLnZzY2hlbWEuS2V5c3BhY2VSb3V0aW5nUnVsZXMSFAoMc2tpcF9yZWJ1aWxkGAIgASgIEhUKDXJlYnVpbGRfY2VsbHMYAyADKAkiYgohQXBwbHlLZXlzcGFjZVJvdXRpbmdSdWxlc1Jlc3BvbnNlEj0KFmtleXNwYWNlX3JvdXRpbmdfcnVsZXMYASABKAsyHS52c2NoZW1hLktleXNwYWNlUm91dGluZ1J1bGVzInUKGEFwcGx5Um91dGluZ1J1bGVzUmVxdWVzdBIsCg1yb3V0aW5nX3J1bGVzGAEgASgLMhUudnNjaGVtYS5Sb3V0aW5nUnVsZXMSFAoMc2tpcF9yZWJ1aWxkGAIgASgIEhUKDXJlYnVpbGRfY2VsbHMYAyADKAkiGwoZQXBwbHlSb3V0aW5nUnVsZXNSZXNwb25zZSKFAQodQXBwbHlTaGFyZFJvdXRpbmdSdWxlc1JlcXVlc3QSNwoTc2hhcmRfcm91dGluZ19ydWxlcxgBIAEoCzIaLnZzY2hlbWEuU2hhcmRSb3V0aW5nUnVsZXMSFAoMc2tpcF9yZWJ1aWxkGAIgASgIEhUKDXJlYnVpbGRfY2VsbHMYAyADKAkiIAoeQXBwbHlTaGFyZFJvdXRpbmdSdWxlc1Jlc3BvbnNlIuwBChJBcHBseVNjaGVtYVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSCwoDc3FsGAMgAygJEhQKDGRkbF9zdHJhdGVneRgEIAEoCRIRCgl1dWlkX2xpc3QYBSADKAkSGQoRbWlncmF0aW9uX2NvbnRleHQYBiABKAkSLwoVd2FpdF9yZXBsaWNhc190aW1lb3V0GAcgASgLMhAudnR0aW1lLkR1cmF0aW9uEiIKCWNhbGxlcl9pZBgJIAEoCzIPLnZ0cnBjLkNhbGxlcklEEhIKCmJhdGNoX3NpemUYCiABKANKBAgCEANKBAgIEAkivQEKE0FwcGx5U2NoZW1hUmVzcG9uc2USEQoJdXVpZF9saXN0GAEgAygJElcKFnJvd3NfYWZmZWN0ZWRfYnlfc2hhcmQYAiADKAsyNy52dGN0bGRhdGEuQXBwbHlTY2hlbWFSZXNwb25zZS5Sb3dzQWZmZWN0ZWRCeVNoYXJkRW50cnkaOgoYUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoBDoCOAEinwEKE0FwcGx5VlNjaGVtYVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSFAoMc2tpcF9yZWJ1aWxkGAIgASgIEg8KB2RyeV9ydW4YAyABKAgSDQoFY2VsbHMYBCADKAkSIwoIdl9zY2hlbWEYBSABKAsyES52c2NoZW1hLktleXNwYWNlEgsKA3NxbBgGIAEoCRIOCgZzdHJpY3QYByABKAgimAIKFEFwcGx5VlNjaGVtYVJlc3BvbnNlEiMKCHZfc2NoZW1hGAEgASgLMhEudnNjaGVtYS5LZXlzcGFjZRJXChV1bmtub3duX3ZpbmRleF9wYXJhbXMYAiADKAsyOC52dGN0bGRhdGEuQXBwbHlWU2NoZW1hUmVzcG9uc2UuVW5rbm93blZpbmRleFBhcmFtc0VudHJ5GmUKGFVua25vd25WaW5kZXhQYXJhbXNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS52dGN0bGRhdGEuQXBwbHlWU2NoZW1hUmVzcG9uc2UuUGFyYW1MaXN0OgI4ARobCglQYXJhbUxpc3QSDgoGcGFyYW1zGAEgAygJIsoBCg1CYWNrdXBSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEhUKDWFsbG93X3ByaW1hcnkYAiABKAgSEwoLY29uY3VycmVuY3kYAyABKAUSHAoUaW5jcmVtZW50YWxfZnJvbV9wb3MYBCABKAkSFAoMdXBncmFkZV9zYWZlGAUgASgIEhoKDWJhY2t1cF9lbmdpbmUYBiABKAlIAIgBAUIQCg5fYmFja3VwX2VuZ2luZSJ9Cg5CYWNrdXBSZXNwb25zZRIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIQCghrZXlzcGFjZRgCIAEoCRINCgVzaGFyZBgDIAEoCRIdCgVldmVudBgEIAEoCzIOLmxvZ3V0aWwuRXZlbnQilQEKEkJhY2t1cFNoYXJkUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIVCg1hbGxvd19wcmltYXJ5GAMgASgIEhMKC2NvbmN1cnJlbmN5GAQgASgFEhQKDHVwZ3JhZGVfc2FmZRgFIAEoCBIcChRpbmNyZW1lbnRhbF9mcm9tX3BvcxgGIAEoCSI+ChxDYW5jZWxTY2hlbWFNaWdyYXRpb25SZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEgwKBHV1aWQYAiABKAkivgEKHUNhbmNlbFNjaGVtYU1pZ3JhdGlvblJlc3BvbnNlEmEKFnJvd3NfYWZmZWN0ZWRfYnlfc2hhcmQYASADKAsyQS52dGN0bGRhdGEuQ2FuY2VsU2NoZW1hTWlncmF0aW9uUmVzcG9uc2UuUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5GjoKGFJvd3NBZmZlY3RlZEJ5U2hhcmRFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAQ6AjgBIsABChdDaGFuZ2VUYWJsZXRUYWdzUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxI6CgR0YWdzGAIgAygLMiwudnRjdGxkYXRhLkNoYW5nZVRhYmxldFRhZ3NSZXF1ZXN0LlRhZ3NFbnRyeRIPCgdyZXBsYWNlGAMgASgIGisKCVRhZ3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIpECChhDaGFuZ2VUYWJsZXRUYWdzUmVzcG9uc2USSAoLYmVmb3JlX3RhZ3MYASADKAsyMy52dGN0bGRhdGEuQ2hhbmdlVGFibGV0VGFnc1Jlc3BvbnNlLkJlZm9yZVRhZ3NFbnRyeRJGCgphZnRlcl90YWdzGAIgAygLMjIudnRjdGxkYXRhLkNoYW5nZVRhYmxldFRhZ3NSZXNwb25zZS5BZnRlclRhZ3NFbnRyeRoxCg9CZWZvcmVUYWdzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARowCg5BZnRlclRhZ3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIn4KF0NoYW5nZVRhYmxldFR5cGVSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEiUKB2RiX3R5cGUYAiABKA4yFC50b3BvZGF0YS5UYWJsZXRUeXBlEg8KB2RyeV9ydW4YAyABKAgigAEKGENoYW5nZVRhYmxldFR5cGVSZXNwb25zZRInCg1iZWZvcmVfdGFibGV0GAEgASgLMhAudG9wb2RhdGEuVGFibGV0EiYKDGFmdGVyX3RhYmxldBgCIAEoCzIQLnRvcG9kYXRhLlRhYmxldBITCgt3YXNfZHJ5X3J1bhgDIAEoCCKgAQoVQ2hlY2tUaHJvdHRsZXJSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEhAKCGFwcF9uYW1lGAIgASgJEg0KBXNjb3BlGAMgASgJEh8KF3NraXBfcmVxdWVzdF9oZWFydGJlYXRzGAQgASgIEhgKEG9rX2lmX25vdF9leGlzdHMYBSABKAgifwoWQ2hlY2tUaHJvdHRsZXJSZXNwb25zZRIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxI4CgVDaGVjaxgCIAEoCzIpLnRhYmxldG1hbmFnZXJkYXRhLkNoZWNrVGhyb3R0bGVyUmVzcG9uc2UiPwodQ2xlYW51cFNjaGVtYU1pZ3JhdGlvblJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEdXVpZBgCIAEoCSLAAQoeQ2xlYW51cFNjaGVtYU1pZ3JhdGlvblJlc3BvbnNlEmIKFnJvd3NfYWZmZWN0ZWRfYnlfc2hhcmQYASADKAsyQi52dGN0bGRhdGEuQ2xlYW51cFNjaGVtYU1pZ3JhdGlvblJlc3BvbnNlLlJvd3NBZmZlY3RlZEJ5U2hhcmRFbnRyeRo6ChhSb3dzQWZmZWN0ZWRCeVNoYXJkRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgEOgI4ASJACh5Db21wbGV0ZVNjaGVtYU1pZ3JhdGlvblJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEdXVpZBgCIAEoCSLCAQofQ29tcGxldGVTY2hlbWFNaWdyYXRpb25SZXNwb25zZRJjChZyb3dzX2FmZmVjdGVkX2J5X3NoYXJkGAEgAygLMkMudnRjdGxkYXRhLkNvbXBsZXRlU2NoZW1hTWlncmF0aW9uUmVzcG9uc2UuUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5GjoKGFJvd3NBZmZlY3RlZEJ5U2hhcmRFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAQ6AjgBIvoBChVDcmVhdGVLZXlzcGFjZVJlcXVlc3QSDAoEbmFtZRgBIAEoCRINCgVmb3JjZRgCIAEoCBIcChRhbGxvd19lbXB0eV92X3NjaGVtYRgDIAEoCBIkCgR0eXBlGAcgASgOMhYudG9wb2RhdGEuS2V5c3BhY2VUeXBlEhUKDWJhc2Vfa2V5c3BhY2UYCCABKAkSIwoNc25hcHNob3RfdGltZRgJIAEoCzIMLnZ0dGltZS5UaW1lEhkKEWR1cmFiaWxpdHlfcG9saWN5GAogASgJEhcKD3NpZGVjYXJfZGJfbmFtZRgLIAEoCUoECAQQBUoECAUQBkoECAYQByI/ChZDcmVhdGVLZXlzcGFjZVJlc3BvbnNlEiUKCGtleXNwYWNlGAEgASgLMhMudnRjdGxkYXRhLktleXNwYWNlImEKEkNyZWF0ZVNoYXJkUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRISCgpzaGFyZF9uYW1lGAIgASgJEg0KBWZvcmNlGAMgASgIEhYKDmluY2x1ZGVfcGFyZW50GAQgASgIInsKE0NyZWF0ZVNoYXJkUmVzcG9uc2USJQoIa2V5c3BhY2UYASABKAsyEy52dGN0bGRhdGEuS2V5c3BhY2USHwoFc2hhcmQYAiABKAsyEC52dGN0bGRhdGEuU2hhcmQSHAoUc2hhcmRfYWxyZWFkeV9leGlzdHMYAyABKAgiNAoVRGVsZXRlQ2VsbEluZm9SZXF1ZXN0EgwKBG5hbWUYASABKAkSDQoFZm9yY2UYAiABKAgiGAoWRGVsZXRlQ2VsbEluZm9SZXNwb25zZSInChdEZWxldGVDZWxsc0FsaWFzUmVxdWVzdBIMCgRuYW1lGAEgASgJIhoKGERlbGV0ZUNlbGxzQWxpYXNSZXNwb25zZSJLChVEZWxldGVLZXlzcGFjZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSEQoJcmVjdXJzaXZlGAIgASgIEg0KBWZvcmNlGAMgASgIIhgKFkRlbGV0ZUtleXNwYWNlUmVzcG9uc2UicgoTRGVsZXRlU2hhcmRzUmVxdWVzdBIgCgZzaGFyZHMYASADKAsyEC52dGN0bGRhdGEuU2hhcmQSEQoJcmVjdXJzaXZlGAIgASgIEhcKD2V2ZW5faWZfc2VydmluZxgEIAEoCBINCgVmb3JjZRgFIAEoCCIWChREZWxldGVTaGFyZHNSZXNwb25zZSInChdEZWxldGVTcnZWU2NoZW1hUmVxdWVzdBIMCgRjZWxsGAEgASgJIhoKGERlbGV0ZVNydlZTY2hlbWFSZXNwb25zZSJcChREZWxldGVUYWJsZXRzUmVxdWVzdBItCg50YWJsZXRfYWxpYXNlcxgBIAMoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEhUKDWFsbG93X3ByaW1hcnkYAiABKAgiFwoVRGVsZXRlVGFibGV0c1Jlc3BvbnNlIsICCh1FbWVyZ2VuY3lSZXBhcmVudFNoYXJkUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIqCgtuZXdfcHJpbWFyeRgDIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEi4KD2lnbm9yZV9yZXBsaWNhcxgEIAMoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEi8KFXdhaXRfcmVwbGljYXNfdGltZW91dBgFIAEoCzIQLnZ0dGltZS5EdXJhdGlvbhIkChxwcmV2ZW50X2Nyb3NzX2NlbGxfcHJvbW90aW9uGAYgASgIEhwKFHdhaXRfZm9yX2FsbF90YWJsZXRzGAcgASgIEi8KEGV4cGVjdGVkX3ByaW1hcnkYCCABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyKSAQoeRW1lcmdlbmN5UmVwYXJlbnRTaGFyZFJlc3BvbnNlEhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEi8KEHByb21vdGVkX3ByaW1hcnkYAyABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIeCgZldmVudHMYBCADKAsyDi5sb2d1dGlsLkV2ZW50InoKGEV4ZWN1dGVGZXRjaEFzQXBwUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxINCgVxdWVyeRgCIAEoCRIQCghtYXhfcm93cxgDIAEoAxIQCgh1c2VfcG9vbBgEIAEoCCI/ChlFeGVjdXRlRmV0Y2hBc0FwcFJlc3BvbnNlEiIKBnJlc3VsdBgBIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0IpgBChhFeGVjdXRlRmV0Y2hBc0RCQVJlcXVlc3QSKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSDQoFcXVlcnkYAiABKAkSEAoIbWF4X3Jvd3MYAyABKAMSFwoPZGlzYWJsZV9iaW5sb2dzGAQgASgIEhUKDXJlbG9hZF9zY2hlbWEYBSABKAgiPwoZRXhlY3V0ZUZldGNoQXNEQkFSZXNwb25zZRIiCgZyZXN1bHQYASABKAsyEi5xdWVyeS5RdWVyeVJlc3VsdCKFAQoSRXhlY3V0ZUhvb2tSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEkIKE3RhYmxldF9ob29rX3JlcXVlc3QYAiABKAsyJS50YWJsZXRtYW5hZ2VyZGF0YS5FeGVjdXRlSG9va1JlcXVlc3QiUgoTRXhlY3V0ZUhvb2tSZXNwb25zZRI7Cgtob29rX3Jlc3VsdBgBIAEoCzImLnRhYmxldG1hbmFnZXJkYXRhLkV4ZWN1dGVIb29rUmVzcG9uc2UimwEKHUV4ZWN1dGVNdWx0aUZldGNoQXNEQkFSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEgsKA3NxbBgCIAEoCRIQCghtYXhfcm93cxgDIAEoAxIXCg9kaXNhYmxlX2JpbmxvZ3MYBCABKAgSFQoNcmVsb2FkX3NjaGVtYRgFIAEoCCJFCh5FeGVjdXRlTXVsdGlGZXRjaEFzREJBUmVzcG9uc2USIwoHcmVzdWx0cxgBIAMoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0IjIKHkZpbmRBbGxTaGFyZHNJbktleXNwYWNlUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCSKqAQofRmluZEFsbFNoYXJkc0luS2V5c3BhY2VSZXNwb25zZRJGCgZzaGFyZHMYASADKAsyNi52dGN0bGRhdGEuRmluZEFsbFNoYXJkc0luS2V5c3BhY2VSZXNwb25zZS5TaGFyZHNFbnRyeRo/CgtTaGFyZHNFbnRyeRILCgNrZXkYASABKAkSHwoFdmFsdWUYAiABKAsyEC52dGN0bGRhdGEuU2hhcmQ6AjgBIkQKIkZvcmNlQ3V0T3ZlclNjaGVtYU1pZ3JhdGlvblJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEdXVpZBgCIAEoCSLKAQojRm9yY2VDdXRPdmVyU2NoZW1hTWlncmF0aW9uUmVzcG9uc2USZwoWcm93c19hZmZlY3RlZF9ieV9zaGFyZBgBIAMoCzJHLnZ0Y3RsZGF0YS5Gb3JjZUN1dE92ZXJTY2hlbWFNaWdyYXRpb25SZXNwb25zZS5Sb3dzQWZmZWN0ZWRCeVNoYXJkRW50cnkaOgoYUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoBDoCOAEibQoRR2V0QmFja3Vwc1JlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSDQoFbGltaXQYAyABKA0SEAoIZGV0YWlsZWQYBCABKAgSFgoOZGV0YWlsZWRfbGltaXQYBSABKA0iOwoSR2V0QmFja3Vwc1Jlc3BvbnNlEiUKB2JhY2t1cHMYASADKAsyFC5teXNxbGN0bC5CYWNrdXBJbmZvIiIKEkdldENlbGxJbmZvUmVxdWVzdBIMCgRjZWxsGAEgASgJIjwKE0dldENlbGxJbmZvUmVzcG9uc2USJQoJY2VsbF9pbmZvGAEgASgLMhIudG9wb2RhdGEuQ2VsbEluZm8iGQoXR2V0Q2VsbEluZm9OYW1lc1JlcXVlc3QiKQoYR2V0Q2VsbEluZm9OYW1lc1Jlc3BvbnNlEg0KBW5hbWVzGAEgAygJIhgKFkdldENlbGxzQWxpYXNlc1JlcXVlc3QioQEKF0dldENlbGxzQWxpYXNlc1Jlc3BvbnNlEkAKB2FsaWFzZXMYASADKAsyLy52dGN0bGRhdGEuR2V0Q2VsbHNBbGlhc2VzUmVzcG9uc2UuQWxpYXNlc0VudHJ5GkQKDEFsaWFzZXNFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC50b3BvZGF0YS5DZWxsc0FsaWFzOgI4ASJDChRHZXRGdWxsU3RhdHVzUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyJEChVHZXRGdWxsU3RhdHVzUmVzcG9uc2USKwoGc3RhdHVzGAEgASgLMhsucmVwbGljYXRpb25kYXRhLkZ1bGxTdGF0dXMiFQoTR2V0S2V5c3BhY2VzUmVxdWVzdCI+ChRHZXRLZXlzcGFjZXNSZXNwb25zZRImCglrZXlzcGFjZXMYASADKAsyEy52dGN0bGRhdGEuS2V5c3BhY2UiJgoSR2V0S2V5c3BhY2VSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJIjwKE0dldEtleXNwYWNlUmVzcG9uc2USJQoIa2V5c3BhY2UYASABKAsyEy52dGN0bGRhdGEuS2V5c3BhY2UiRAoVR2V0UGVybWlzc2lvbnNSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIk0KFkdldFBlcm1pc3Npb25zUmVzcG9uc2USMwoLcGVybWlzc2lvbnMYASABKAsyHi50YWJsZXRtYW5hZ2VyZGF0YS5QZXJtaXNzaW9ucyIgCh5HZXRLZXlzcGFjZVJvdXRpbmdSdWxlc1JlcXVlc3QiYAofR2V0S2V5c3BhY2VSb3V0aW5nUnVsZXNSZXNwb25zZRI9ChZrZXlzcGFjZV9yb3V0aW5nX3J1bGVzGAEgASgLMh0udnNjaGVtYS5LZXlzcGFjZVJvdXRpbmdSdWxlcyIYChZHZXRSb3V0aW5nUnVsZXNSZXF1ZXN0IkcKF0dldFJvdXRpbmdSdWxlc1Jlc3BvbnNlEiwKDXJvdXRpbmdfcnVsZXMYASABKAsyFS52c2NoZW1hLlJvdXRpbmdSdWxlcyLNAQoQR2V0U2NoZW1hUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIOCgZ0YWJsZXMYAiADKAkSFgoOZXhjbHVkZV90YWJsZXMYAyADKAkSFQoNaW5jbHVkZV92aWV3cxgEIAEoCBIYChB0YWJsZV9uYW1lc19vbmx5GAUgASgIEhgKEHRhYmxlX3NpemVzX29ubHkYBiABKAgSGQoRdGFibGVfc2NoZW1hX29ubHkYByABKAgiSAoRR2V0U2NoZW1hUmVzcG9uc2USMwoGc2NoZW1hGAEgASgLMiMudGFibGV0bWFuYWdlcmRhdGEuU2NoZW1hRGVmaW5pdGlvbiLyAQoaR2V0U2NoZW1hTWlncmF0aW9uc1JlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEdXVpZBgCIAEoCRIZChFtaWdyYXRpb25fY29udGV4dBgDIAEoCRIxCgZzdGF0dXMYBCABKA4yIS52dGN0bGRhdGEuU2NoZW1hTWlncmF0aW9uLlN0YXR1cxIgCgZyZWNlbnQYBSABKAsyEC52dHRpbWUuRHVyYXRpb24SJwoFb3JkZXIYBiABKA4yGC52dGN0bGRhdGEuUXVlcnlPcmRlcmluZxINCgVsaW1pdBgHIAEoBBIMCgRza2lwGAggASgEIk0KG0dldFNjaGVtYU1pZ3JhdGlvbnNSZXNwb25zZRIuCgptaWdyYXRpb25zGAEgAygLMhoudnRjdGxkYXRhLlNjaGVtYU1pZ3JhdGlvbiJMChpHZXRTaGFyZFJlcGxpY2F0aW9uUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRINCgVjZWxscxgDIAMoCSLfAQobR2V0U2hhcmRSZXBsaWNhdGlvblJlc3BvbnNlEmUKGXNoYXJkX3JlcGxpY2F0aW9uX2J5X2NlbGwYASADKAsyQi52dGN0bGRhdGEuR2V0U2hhcmRSZXBsaWNhdGlvblJlc3BvbnNlLlNoYXJkUmVwbGljYXRpb25CeUNlbGxFbnRyeRpZChtTaGFyZFJlcGxpY2F0aW9uQnlDZWxsRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhoudG9wb2RhdGEuU2hhcmRSZXBsaWNhdGlvbjoCOAEiNwoPR2V0U2hhcmRSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEhIKCnNoYXJkX25hbWUYAiABKAkiMwoQR2V0U2hhcmRSZXNwb25zZRIfCgVzaGFyZBgBIAEoCzIQLnZ0Y3RsZGF0YS5TaGFyZCIdChtHZXRTaGFyZFJvdXRpbmdSdWxlc1JlcXVlc3QiVwocR2V0U2hhcmRSb3V0aW5nUnVsZXNSZXNwb25zZRI3ChNzaGFyZF9yb3V0aW5nX3J1bGVzGAEgASgLMhoudnNjaGVtYS5TaGFyZFJvdXRpbmdSdWxlcyIrChpHZXRTcnZLZXlzcGFjZU5hbWVzUmVxdWVzdBINCgVjZWxscxgBIAMoCSLZAQobR2V0U3J2S2V5c3BhY2VOYW1lc1Jlc3BvbnNlEkAKBW5hbWVzGAEgAygLMjEudnRjdGxkYXRhLkdldFNydktleXNwYWNlTmFtZXNSZXNwb25zZS5OYW1lc0VudHJ5Gl0KCk5hbWVzRW50cnkSCwoDa2V5GAEgASgJEj4KBXZhbHVlGAIgASgLMi8udnRjdGxkYXRhLkdldFNydktleXNwYWNlTmFtZXNSZXNwb25zZS5OYW1lTGlzdDoCOAEaGQoITmFtZUxpc3QSDQoFbmFtZXMYASADKAkiOQoWR2V0U3J2S2V5c3BhY2VzUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVjZWxscxgCIAMoCSKyAQoXR2V0U3J2S2V5c3BhY2VzUmVzcG9uc2USSwoNc3J2X2tleXNwYWNlcxgBIAMoCzI0LnZ0Y3RsZGF0YS5HZXRTcnZLZXlzcGFjZXNSZXNwb25zZS5TcnZLZXlzcGFjZXNFbnRyeRpKChFTcnZLZXlzcGFjZXNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFsdWUYAiABKAsyFS50b3BvZGF0YS5TcnZLZXlzcGFjZToCOAEixgIKHFVwZGF0ZVRocm90dGxlckNvbmZpZ1JlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDgoGZW5hYmxlGAIgASgIEg8KB2Rpc2FibGUYAyABKAgSEQoJdGhyZXNob2xkGAQgASgBEhQKDGN1c3RvbV9xdWVyeRgFIAEoCRIYChBjdXN0b21fcXVlcnlfc2V0GAYgASgIEhsKE2NoZWNrX2FzX2NoZWNrX3NlbGYYByABKAgSHAoUY2hlY2tfYXNfY2hlY2tfc2hhcmQYCCABKAgSMQoNdGhyb3R0bGVkX2FwcBgJIAEoCzIaLnRvcG9kYXRhLlRocm90dGxlZEFwcFJ1bGUSEwoLbWV0cmljX25hbWUYCiABKAkSEAoIYXBwX25hbWUYCyABKAkSGwoTYXBwX2NoZWNrZWRfbWV0cmljcxgMIAMoCSIfCh1VcGRhdGVUaHJvdHRsZXJDb25maWdSZXNwb25zZSIkChRHZXRTcnZWU2NoZW1hUmVxdWVzdBIMCgRjZWxsGAEgASgJIkIKFUdldFNydlZTY2hlbWFSZXNwb25zZRIpCgxzcnZfdl9zY2hlbWEYASABKAsyEy52c2NoZW1hLlNydlZTY2hlbWEiJgoVR2V0U3J2VlNjaGVtYXNSZXF1ZXN0Eg0KBWNlbGxzGAIgAygJIqwBChZHZXRTcnZWU2NoZW1hc1Jlc3BvbnNlEkkKDXNydl92X3NjaGVtYXMYASADKAsyMi52dGN0bGRhdGEuR2V0U3J2VlNjaGVtYXNSZXNwb25zZS5TcnZWU2NoZW1hc0VudHJ5GkcKEFNydlZTY2hlbWFzRW50cnkSCwoDa2V5GAEgASgJEiIKBXZhbHVlGAIgASgLMhMudnNjaGVtYS5TcnZWU2NoZW1hOgI4ASI/ChBHZXRUYWJsZXRSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIjUKEUdldFRhYmxldFJlc3BvbnNlEiAKBnRhYmxldBgBIAEoCzIQLnRvcG9kYXRhLlRhYmxldCKtAQoRR2V0VGFibGV0c1JlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSDQoFY2VsbHMYAyADKAkSDgoGc3RyaWN0GAQgASgIEi0KDnRhYmxldF9hbGlhc2VzGAUgAygLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSKQoLdGFibGV0X3R5cGUYBiABKA4yFC50b3BvZGF0YS5UYWJsZXRUeXBlIjcKEkdldFRhYmxldHNSZXNwb25zZRIhCgd0YWJsZXRzGAEgAygLMhAudG9wb2RhdGEuVGFibGV0IkgKGUdldFRocm90dGxlclN0YXR1c1JlcXVlc3QSKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMiWwoaR2V0VGhyb3R0bGVyU3RhdHVzUmVzcG9uc2USPQoGc3RhdHVzGAEgASgLMi0udGFibGV0bWFuYWdlcmRhdGEuR2V0VGhyb3R0bGVyU3RhdHVzUmVzcG9uc2UiSAoWR2V0VG9wb2xvZ3lQYXRoUmVxdWVzdBIMCgRwYXRoGAEgASgJEg8KB3ZlcnNpb24YAiABKAMSDwoHYXNfanNvbhgDIAEoCCJAChdHZXRUb3BvbG9neVBhdGhSZXNwb25zZRIlCgRjZWxsGAEgASgLMhcudnRjdGxkYXRhLlRvcG9sb2d5Q2VsbCJbCgxUb3BvbG9neUNlbGwSDAoEbmFtZRgBIAEoCRIMCgRwYXRoGAIgASgJEgwKBGRhdGEYAyABKAkSEAoIY2hpbGRyZW4YBCADKAkSDwoHdmVyc2lvbhgFIAEoAyJJCiBHZXRVbnJlc29sdmVkVHJhbnNhY3Rpb25zUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRITCgthYmFuZG9uX2FnZRgCIAEoAyJVCiFHZXRVbnJlc29sdmVkVHJhbnNhY3Rpb25zUmVzcG9uc2USMAoMdHJhbnNhY3Rpb25zGAEgAygLMhoucXVlcnkuVHJhbnNhY3Rpb25NZXRhZGF0YSJPChpDb25jbHVkZVRyYW5zYWN0aW9uUmVxdWVzdBIMCgRkdGlkGAEgASgJEiMKDHBhcnRpY2lwYW50cxgCIAMoCzINLnF1ZXJ5LlRhcmdldCIdChtDb25jbHVkZVRyYW5zYWN0aW9uUmVzcG9uc2UiJQoRR2V0VlNjaGVtYVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkiQAoRR2V0VmVyc2lvblJlcXVlc3QSKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMiJQoSR2V0VmVyc2lvblJlc3BvbnNlEg8KB3ZlcnNpb24YASABKAkiOQoSR2V0VlNjaGVtYVJlc3BvbnNlEiMKCHZfc2NoZW1hGAEgASgLMhEudnNjaGVtYS5LZXlzcGFjZSKHAQoTR2V0V29ya2Zsb3dzUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRITCgthY3RpdmVfb25seRgCIAEoCBIRCgluYW1lX29ubHkYAyABKAgSEAoId29ya2Zsb3cYBCABKAkSFAoMaW5jbHVkZV9sb2dzGAUgASgIEg4KBnNoYXJkcxgGIAMoCSI+ChRHZXRXb3JrZmxvd3NSZXNwb25zZRImCgl3b3JrZmxvd3MYASADKAsyEy52dGN0bGRhdGEuV29ya2Zsb3citQEKF0luaXRTaGFyZFByaW1hcnlSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEjkKGnByaW1hcnlfZWxlY3RfdGFibGV0X2FsaWFzGAMgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSDQoFZm9yY2UYBCABKAgSLwoVd2FpdF9yZXBsaWNhc190aW1lb3V0GAUgASgLMhAudnR0aW1lLkR1cmF0aW9uIjoKGEluaXRTaGFyZFByaW1hcnlSZXNwb25zZRIeCgZldmVudHMYASADKAsyDi5sb2d1dGlsLkV2ZW50Ij4KHExhdW5jaFNjaGVtYU1pZ3JhdGlvblJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEdXVpZBgCIAEoCSK+AQodTGF1bmNoU2NoZW1hTWlncmF0aW9uUmVzcG9uc2USYQoWcm93c19hZmZlY3RlZF9ieV9zaGFyZBgBIAMoCzJBLnZ0Y3RsZGF0YS5MYXVuY2hTY2hlbWFNaWdyYXRpb25SZXNwb25zZS5Sb3dzQWZmZWN0ZWRCeVNoYXJkRW50cnkaOgoYUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoBDoCOAEimAIKGUxvb2t1cFZpbmRleENyZWF0ZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSEAoId29ya2Zsb3cYAiABKAkSDQoFY2VsbHMYAyADKAkSIQoGdmluZGV4GAQgASgLMhEudnNjaGVtYS5LZXlzcGFjZRImCh5jb250aW51ZV9hZnRlcl9jb3B5X3dpdGhfb3duZXIYBSABKAgSKgoMdGFibGV0X3R5cGVzGAYgAygOMhQudG9wb2RhdGEuVGFibGV0VHlwZRJRCht0YWJsZXRfc2VsZWN0aW9uX3ByZWZlcmVuY2UYByABKA4yLC50YWJsZXRtYW5hZ2VyZGF0YS5UYWJsZXRTZWxlY3Rpb25QcmVmZXJlbmNlIhwKGkxvb2t1cFZpbmRleENyZWF0ZVJlc3BvbnNlIlgKHkxvb2t1cFZpbmRleEV4dGVybmFsaXplUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIMCgRuYW1lGAIgASgJEhYKDnRhYmxlX2tleXNwYWNlGAMgASgJIjsKH0xvb2t1cFZpbmRleEV4dGVybmFsaXplUmVzcG9uc2USGAoQd29ya2Zsb3dfZGVsZXRlZBgBIAEoCCJMChhNYXRlcmlhbGl6ZUNyZWF0ZVJlcXVlc3QSMAoIc2V0dGluZ3MYASABKAsyHi52dGN0bGRhdGEuTWF0ZXJpYWxpemVTZXR0aW5ncyIbChlNYXRlcmlhbGl6ZUNyZWF0ZVJlc3BvbnNlIuoDChRNaWdyYXRlQ3JlYXRlUmVxdWVzdBIQCgh3b3JrZmxvdxgBIAEoCRIXCg9zb3VyY2Vfa2V5c3BhY2UYAiABKAkSFwoPdGFyZ2V0X2tleXNwYWNlGAMgASgJEhIKCm1vdW50X25hbWUYBCABKAkSDQoFY2VsbHMYBSADKAkSKgoMdGFibGV0X3R5cGVzGAYgAygOMhQudG9wb2RhdGEuVGFibGV0VHlwZRJRCht0YWJsZXRfc2VsZWN0aW9uX3ByZWZlcmVuY2UYByABKA4yLC50YWJsZXRtYW5hZ2VyZGF0YS5UYWJsZXRTZWxlY3Rpb25QcmVmZXJlbmNlEhIKCmFsbF90YWJsZXMYCCABKAgSFgoOaW5jbHVkZV90YWJsZXMYCSADKAkSFgoOZXhjbHVkZV90YWJsZXMYCiADKAkSGAoQc291cmNlX3RpbWVfem9uZRgLIAEoCRIOCgZvbl9kZGwYDCABKAkSFwoPc3RvcF9hZnRlcl9jb3B5GA0gASgIEhkKEWRyb3BfZm9yZWlnbl9rZXlzGA4gASgIEhwKFGRlZmVyX3NlY29uZGFyeV9rZXlzGA8gASgIEhIKCmF1dG9fc3RhcnQYECABKAgSGAoQbm9fcm91dGluZ19ydWxlcxgRIAEoCCKaAQoWTWlncmF0ZUNvbXBsZXRlUmVxdWVzdBIQCgh3b3JrZmxvdxgBIAEoCRIXCg90YXJnZXRfa2V5c3BhY2UYAyABKAkSEQoJa2VlcF9kYXRhGAQgASgIEhoKEmtlZXBfcm91dGluZ19ydWxlcxgFIAEoCBIVCg1yZW5hbWVfdGFibGVzGAYgASgIEg8KB2RyeV9ydW4YByABKAgiQwoXTWlncmF0ZUNvbXBsZXRlUmVzcG9uc2USDwoHc3VtbWFyeRgBIAEoCRIXCg9kcnlfcnVuX3Jlc3VsdHMYAiADKAkiXwoUTW91bnRSZWdpc3RlclJlcXVlc3QSEQoJdG9wb190eXBlGAEgASgJEhMKC3RvcG9fc2VydmVyGAIgASgJEhEKCXRvcG9fcm9vdBgDIAEoCRIMCgRuYW1lGAQgASgJIhcKFU1vdW50UmVnaXN0ZXJSZXNwb25zZSImChZNb3VudFVucmVnaXN0ZXJSZXF1ZXN0EgwKBG5hbWUYBCABKAkiGQoXTW91bnRVbnJlZ2lzdGVyUmVzcG9uc2UiIAoQTW91bnRTaG93UmVxdWVzdBIMCgRuYW1lGAQgASgJIlwKEU1vdW50U2hvd1Jlc3BvbnNlEhEKCXRvcG9fdHlwZRgBIAEoCRITCgt0b3BvX3NlcnZlchgCIAEoCRIRCgl0b3BvX3Jvb3QYAyABKAkSDAoEbmFtZRgEIAEoCSISChBNb3VudExpc3RSZXF1ZXN0IiIKEU1vdW50TGlzdFJlc3BvbnNlEg0KBW5hbWVzGAEgAygJItoEChdNb3ZlVGFibGVzQ3JlYXRlUmVxdWVzdBIQCgh3b3JrZmxvdxgBIAEoCRIXCg9zb3VyY2Vfa2V5c3BhY2UYAiABKAkSFwoPdGFyZ2V0X2tleXNwYWNlGAMgASgJEg0KBWNlbGxzGAQgAygJEioKDHRhYmxldF90eXBlcxgFIAMoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSUQobdGFibGV0X3NlbGVjdGlvbl9wcmVmZXJlbmNlGAYgASgOMiwudGFibGV0bWFuYWdlcmRhdGEuVGFibGV0U2VsZWN0aW9uUHJlZmVyZW5jZRIVCg1zb3VyY2Vfc2hhcmRzGAcgAygJEhIKCmFsbF90YWJsZXMYCCABKAgSFgoOaW5jbHVkZV90YWJsZXMYCSADKAkSFgoOZXhjbHVkZV90YWJsZXMYCiADKAkSHQoVZXh0ZXJuYWxfY2x1c3Rlcl9uYW1lGAsgASgJEhgKEHNvdXJjZV90aW1lX3pvbmUYDCABKAkSDgoGb25fZGRsGA0gASgJEhcKD3N0b3BfYWZ0ZXJfY29weRgOIAEoCBIZChFkcm9wX2ZvcmVpZ25fa2V5cxgPIAEoCBIcChRkZWZlcl9zZWNvbmRhcnlfa2V5cxgQIAEoCBISCgphdXRvX3N0YXJ0GBEgASgIEhgKEG5vX3JvdXRpbmdfcnVsZXMYEiABKAgSEwoLYXRvbWljX2NvcHkYEyABKAgSNAoQd29ya2Zsb3dfb3B0aW9ucxgUIAEoCzIaLnZ0Y3RsZGF0YS5Xb3JrZmxvd09wdGlvbnMisgEKGE1vdmVUYWJsZXNDcmVhdGVSZXNwb25zZRIPCgdzdW1tYXJ5GAEgASgJEj8KB2RldGFpbHMYAiADKAsyLi52dGN0bGRhdGEuTW92ZVRhYmxlc0NyZWF0ZVJlc3BvbnNlLlRhYmxldEluZm8aRAoKVGFibGV0SW5mbxIlCgZ0YWJsZXQYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIPCgdjcmVhdGVkGAIgASgIIq0BChlNb3ZlVGFibGVzQ29tcGxldGVSZXF1ZXN0EhAKCHdvcmtmbG93GAEgASgJEhcKD3RhcmdldF9rZXlzcGFjZRgDIAEoCRIRCglrZWVwX2RhdGEYBCABKAgSGgoSa2VlcF9yb3V0aW5nX3J1bGVzGAUgASgIEhUKDXJlbmFtZV90YWJsZXMYBiABKAgSDwoHZHJ5X3J1bhgHIAEoCBIOCgZzaGFyZHMYCCADKAkiRgoaTW92ZVRhYmxlc0NvbXBsZXRlUmVzcG9uc2USDwoHc3VtbWFyeRgBIAEoCRIXCg9kcnlfcnVuX3Jlc3VsdHMYAiADKAkiQAoRUGluZ1RhYmxldFJlcXVlc3QSKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMiFAoSUGluZ1RhYmxldFJlc3BvbnNlItMCChtQbGFubmVkUmVwYXJlbnRTaGFyZFJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSKgoLbmV3X3ByaW1hcnkYAyABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIsCg1hdm9pZF9wcmltYXJ5GAQgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSLwoVd2FpdF9yZXBsaWNhc190aW1lb3V0GAUgASgLMhAudnR0aW1lLkR1cmF0aW9uEjMKGXRvbGVyYWJsZV9yZXBsaWNhdGlvbl9sYWcYBiABKAsyEC52dHRpbWUuRHVyYXRpb24SIgoaYWxsb3dfY3Jvc3NfY2VsbF9wcm9tb3Rpb24YByABKAgSLwoQZXhwZWN0ZWRfcHJpbWFyeRgIIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIpABChxQbGFubmVkUmVwYXJlbnRTaGFyZFJlc3BvbnNlEhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEi8KEHByb21vdGVkX3ByaW1hcnkYAyABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIeCgZldmVudHMYBCADKAsyDi5sb2d1dGlsLkV2ZW50IlUKG1JlYnVpbGRLZXlzcGFjZUdyYXBoUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVjZWxscxgCIAMoCRIVCg1hbGxvd19wYXJ0aWFsGAMgASgIIh4KHFJlYnVpbGRLZXlzcGFjZUdyYXBoUmVzcG9uc2UiKwoaUmVidWlsZFZTY2hlbWFHcmFwaFJlcXVlc3QSDQoFY2VsbHMYASADKAkiHQobUmVidWlsZFZTY2hlbWFHcmFwaFJlc3BvbnNlIkIKE1JlZnJlc2hTdGF0ZVJlcXVlc3QSKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMiFgoUUmVmcmVzaFN0YXRlUmVzcG9uc2UiTAoaUmVmcmVzaFN0YXRlQnlTaGFyZFJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSDQoFY2VsbHMYAyADKAkiWgobUmVmcmVzaFN0YXRlQnlTaGFyZFJlc3BvbnNlEhoKEmlzX3BhcnRpYWxfcmVmcmVzaBgBIAEoCBIfChdwYXJ0aWFsX3JlZnJlc2hfZGV0YWlscxgCIAEoCSJCChNSZWxvYWRTY2hlbWFSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIhYKFFJlbG9hZFNjaGVtYVJlc3BvbnNlInQKG1JlbG9hZFNjaGVtYUtleXNwYWNlUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIVCg13YWl0X3Bvc2l0aW9uGAIgASgJEhcKD2luY2x1ZGVfcHJpbWFyeRgDIAEoCBITCgtjb25jdXJyZW5jeRgEIAEoBSI+ChxSZWxvYWRTY2hlbWFLZXlzcGFjZVJlc3BvbnNlEh4KBmV2ZW50cxgBIAMoCzIOLmxvZ3V0aWwuRXZlbnQigAEKGFJlbG9hZFNjaGVtYVNoYXJkUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIVCg13YWl0X3Bvc2l0aW9uGAMgASgJEhcKD2luY2x1ZGVfcHJpbWFyeRgEIAEoCBITCgtjb25jdXJyZW5jeRgFIAEoBSI7ChlSZWxvYWRTY2hlbWFTaGFyZFJlc3BvbnNlEh4KBmV2ZW50cxgCIAMoCzIOLmxvZ3V0aWwuRXZlbnQiRAoTUmVtb3ZlQmFja3VwUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIMCgRuYW1lGAMgASgJIhYKFFJlbW92ZUJhY2t1cFJlc3BvbnNlIl0KGVJlbW92ZUtleXNwYWNlQ2VsbFJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDAoEY2VsbBgCIAEoCRINCgVmb3JjZRgDIAEoCBIRCglyZWN1cnNpdmUYBCABKAgiHAoaUmVtb3ZlS2V5c3BhY2VDZWxsUmVzcG9uc2UibgoWUmVtb3ZlU2hhcmRDZWxsUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRISCgpzaGFyZF9uYW1lGAIgASgJEgwKBGNlbGwYAyABKAkSDQoFZm9yY2UYBCABKAgSEQoJcmVjdXJzaXZlGAUgASgIIhkKF1JlbW92ZVNoYXJkQ2VsbFJlc3BvbnNlIj4KFVJlcGFyZW50VGFibGV0UmVxdWVzdBIlCgZ0YWJsZXQYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyJhChZSZXBhcmVudFRhYmxldFJlc3BvbnNlEhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEiYKB3ByaW1hcnkYAyABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyKhAwoUUmVzaGFyZENyZWF0ZVJlcXVlc3QSEAoId29ya2Zsb3cYASABKAkSEAoIa2V5c3BhY2UYAiABKAkSFQoNc291cmNlX3NoYXJkcxgDIAMoCRIVCg10YXJnZXRfc2hhcmRzGAQgAygJEg0KBWNlbGxzGAUgAygJEioKDHRhYmxldF90eXBlcxgGIAMoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSUQobdGFibGV0X3NlbGVjdGlvbl9wcmVmZXJlbmNlGAcgASgOMiwudGFibGV0bWFuYWdlcmRhdGEuVGFibGV0U2VsZWN0aW9uUHJlZmVyZW5jZRIYChBza2lwX3NjaGVtYV9jb3B5GAggASgIEg4KBm9uX2RkbBgJIAEoCRIXCg9zdG9wX2FmdGVyX2NvcHkYCiABKAgSHAoUZGVmZXJfc2Vjb25kYXJ5X2tleXMYCyABKAgSEgoKYXV0b19zdGFydBgMIAEoCBI0ChB3b3JrZmxvd19vcHRpb25zGA0gASgLMhoudnRjdGxkYXRhLldvcmtmbG93T3B0aW9ucyLfAQoYUmVzdG9yZUZyb21CYWNrdXBSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEiEKC2JhY2t1cF90aW1lGAIgASgLMgwudnR0aW1lLlRpbWUSFgoOcmVzdG9yZV90b19wb3MYAyABKAkSDwoHZHJ5X3J1bhgEIAEoCBIqChRyZXN0b3JlX3RvX3RpbWVzdGFtcBgFIAEoCzIMLnZ0dGltZS5UaW1lEh4KFmFsbG93ZWRfYmFja3VwX2VuZ2luZXMYBiADKAkiiAEKGVJlc3RvcmVGcm9tQmFja3VwUmVzcG9uc2USKwoMdGFibGV0X2FsaWFzGAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSEAoIa2V5c3BhY2UYAiABKAkSDQoFc2hhcmQYAyABKAkSHQoFZXZlbnQYBCABKAsyDi5sb2d1dGlsLkV2ZW50Ij0KG1JldHJ5U2NoZW1hTWlncmF0aW9uUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIMCgR1dWlkGAIgASgJIrwBChxSZXRyeVNjaGVtYU1pZ3JhdGlvblJlc3BvbnNlEmAKFnJvd3NfYWZmZWN0ZWRfYnlfc2hhcmQYASADKAsyQC52dGN0bGRhdGEuUmV0cnlTY2hlbWFNaWdyYXRpb25SZXNwb25zZS5Sb3dzQWZmZWN0ZWRCeVNoYXJkRW50cnkaOgoYUm93c0FmZmVjdGVkQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoBDoCOAEiRAoVUnVuSGVhbHRoQ2hlY2tSZXF1ZXN0EisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIhgKFlJ1bkhlYWx0aENoZWNrUmVzcG9uc2UiUQoiU2V0S2V5c3BhY2VEdXJhYmlsaXR5UG9saWN5UmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIZChFkdXJhYmlsaXR5X3BvbGljeRgCIAEoCSJLCiNTZXRLZXlzcGFjZUR1cmFiaWxpdHlQb2xpY3lSZXNwb25zZRIkCghrZXlzcGFjZRgBIAEoCzISLnRvcG9kYXRhLktleXNwYWNlIk0KHlNldEtleXNwYWNlU2hhcmRpbmdJbmZvUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVmb3JjZRgEIAEoCEoECAIQA0oECAMQBCJHCh9TZXRLZXlzcGFjZVNoYXJkaW5nSW5mb1Jlc3BvbnNlEiQKCGtleXNwYWNlGAEgASgLMhIudG9wb2RhdGEuS2V5c3BhY2UiVgofU2V0U2hhcmRJc1ByaW1hcnlTZXJ2aW5nUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRISCgppc19zZXJ2aW5nGAMgASgIIkIKIFNldFNoYXJkSXNQcmltYXJ5U2VydmluZ1Jlc3BvbnNlEh4KBXNoYXJkGAEgASgLMg8udG9wb2RhdGEuU2hhcmQivwEKHFNldFNoYXJkVGFibGV0Q29udHJvbFJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSKQoLdGFibGV0X3R5cGUYAyABKA4yFC50b3BvZGF0YS5UYWJsZXRUeXBlEg0KBWNlbGxzGAQgAygJEhUKDWRlbmllZF90YWJsZXMYBSADKAkSHQoVZGlzYWJsZV9xdWVyeV9zZXJ2aWNlGAYgASgIEg4KBnJlbW92ZRgHIAEoCCI/Ch1TZXRTaGFyZFRhYmxldENvbnRyb2xSZXNwb25zZRIeCgVzaGFyZBgBIAEoCzIPLnRvcG9kYXRhLlNoYXJkIlMKElNldFdyaXRhYmxlUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIQCgh3cml0YWJsZRgCIAEoCCIVChNTZXRXcml0YWJsZVJlc3BvbnNlImoKGlNoYXJkUmVwbGljYXRpb25BZGRSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEisKDHRhYmxldF9hbGlhcxgDIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIh0KG1NoYXJkUmVwbGljYXRpb25BZGRSZXNwb25zZSJLChpTaGFyZFJlcGxpY2F0aW9uRml4UmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIMCgRjZWxsGAMgASgJIk0KG1NoYXJkUmVwbGljYXRpb25GaXhSZXNwb25zZRIuCgVlcnJvchgBIAEoCzIfLnRvcG9kYXRhLlNoYXJkUmVwbGljYXRpb25FcnJvciJDCiBTaGFyZFJlcGxpY2F0aW9uUG9zaXRpb25zUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCSLyAgohU2hhcmRSZXBsaWNhdGlvblBvc2l0aW9uc1Jlc3BvbnNlEmMKFHJlcGxpY2F0aW9uX3N0YXR1c2VzGAEgAygLMkUudnRjdGxkYXRhLlNoYXJkUmVwbGljYXRpb25Qb3NpdGlvbnNSZXNwb25zZS5SZXBsaWNhdGlvblN0YXR1c2VzRW50cnkSTwoKdGFibGV0X21hcBgCIAMoCzI7LnZ0Y3RsZGF0YS5TaGFyZFJlcGxpY2F0aW9uUG9zaXRpb25zUmVzcG9uc2UuVGFibGV0TWFwRW50cnkaUwoYUmVwbGljYXRpb25TdGF0dXNlc0VudHJ5EgsKA2tleRgBIAEoCRImCgV2YWx1ZRgCIAEoCzIXLnJlcGxpY2F0aW9uZGF0YS5TdGF0dXM6AjgBGkIKDlRhYmxldE1hcEVudHJ5EgsKA2tleRgBIAEoCRIfCgV2YWx1ZRgCIAEoCzIQLnRvcG9kYXRhLlRhYmxldDoCOAEibQodU2hhcmRSZXBsaWNhdGlvblJlbW92ZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSKwoMdGFibGV0X2FsaWFzGAMgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMiIAoeU2hhcmRSZXBsaWNhdGlvblJlbW92ZVJlc3BvbnNlImUKElNsZWVwVGFibGV0UmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIiCghkdXJhdGlvbhgCIAEoCzIQLnZ0dGltZS5EdXJhdGlvbiIVChNTbGVlcFRhYmxldFJlc3BvbnNlIqsBChVTb3VyY2VTaGFyZEFkZFJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSCwoDdWlkGAMgASgFEhcKD3NvdXJjZV9rZXlzcGFjZRgEIAEoCRIUCgxzb3VyY2Vfc2hhcmQYBSABKAkSJQoJa2V5X3JhbmdlGAYgASgLMhIudG9wb2RhdGEuS2V5UmFuZ2USDgoGdGFibGVzGAcgAygJIjgKFlNvdXJjZVNoYXJkQWRkUmVzcG9uc2USHgoFc2hhcmQYASABKAsyDy50b3BvZGF0YS5TaGFyZCJIChhTb3VyY2VTaGFyZERlbGV0ZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSCwoDdWlkGAMgASgFIjsKGVNvdXJjZVNoYXJkRGVsZXRlUmVzcG9uc2USHgoFc2hhcmQYASABKAsyDy50b3BvZGF0YS5TaGFyZCJGChdTdGFydFJlcGxpY2F0aW9uUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyIaChhTdGFydFJlcGxpY2F0aW9uUmVzcG9uc2UiRQoWU3RvcFJlcGxpY2F0aW9uUmVxdWVzdBIrCgx0YWJsZXRfYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcyIZChdTdG9wUmVwbGljYXRpb25SZXNwb25zZSJKCiFUYWJsZXRFeHRlcm5hbGx5UmVwYXJlbnRlZFJlcXVlc3QSJQoGdGFibGV0GAEgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMinQEKIlRhYmxldEV4dGVybmFsbHlSZXBhcmVudGVkUmVzcG9uc2USEAoIa2V5c3BhY2UYASABKAkSDQoFc2hhcmQYAiABKAkSKgoLbmV3X3ByaW1hcnkYAyABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIqCgtvbGRfcHJpbWFyeRgEIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIkwKFVVwZGF0ZUNlbGxJbmZvUmVxdWVzdBIMCgRuYW1lGAEgASgJEiUKCWNlbGxfaW5mbxgCIAEoCzISLnRvcG9kYXRhLkNlbGxJbmZvIk0KFlVwZGF0ZUNlbGxJbmZvUmVzcG9uc2USDAoEbmFtZRgBIAEoCRIlCgljZWxsX2luZm8YAiABKAsyEi50b3BvZGF0YS5DZWxsSW5mbyJSChdVcGRhdGVDZWxsc0FsaWFzUmVxdWVzdBIMCgRuYW1lGAEgASgJEikKC2NlbGxzX2FsaWFzGAIgASgLMhQudG9wb2RhdGEuQ2VsbHNBbGlhcyJTChhVcGRhdGVDZWxsc0FsaWFzUmVzcG9uc2USDAoEbmFtZRgBIAEoCRIpCgtjZWxsc19hbGlhcxgCIAEoCzIULnRvcG9kYXRhLkNlbGxzQWxpYXMiJwoPVmFsaWRhdGVSZXF1ZXN0EhQKDHBpbmdfdGFibGV0cxgBIAEoCCLTAQoQVmFsaWRhdGVSZXNwb25zZRIPCgdyZXN1bHRzGAEgAygJEk8KE3Jlc3VsdHNfYnlfa2V5c3BhY2UYAiADKAsyMi52dGN0bGRhdGEuVmFsaWRhdGVSZXNwb25zZS5SZXN1bHRzQnlLZXlzcGFjZUVudHJ5Gl0KFlJlc3VsdHNCeUtleXNwYWNlRW50cnkSCwoDa2V5GAEgASgJEjIKBXZhbHVlGAIgASgLMiMudnRjdGxkYXRhLlZhbGlkYXRlS2V5c3BhY2VSZXNwb25zZToCOAEiQQoXVmFsaWRhdGVLZXlzcGFjZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSFAoMcGluZ190YWJsZXRzGAIgASgIItcBChhWYWxpZGF0ZUtleXNwYWNlUmVzcG9uc2USDwoHcmVzdWx0cxgBIAMoCRJRChByZXN1bHRzX2J5X3NoYXJkGAIgAygLMjcudnRjdGxkYXRhLlZhbGlkYXRlS2V5c3BhY2VSZXNwb25zZS5SZXN1bHRzQnlTaGFyZEVudHJ5GlcKE1Jlc3VsdHNCeVNoYXJkRW50cnkSCwoDa2V5GAEgASgJEi8KBXZhbHVlGAIgASgLMiAudnRjdGxkYXRhLlZhbGlkYXRlU2hhcmRSZXNwb25zZToCOAEikgEKHVZhbGlkYXRlU2NoZW1hS2V5c3BhY2VSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEhYKDmV4Y2x1ZGVfdGFibGVzGAIgAygJEhUKDWluY2x1ZGVfdmlld3MYAyABKAgSFwoPc2tpcF9ub19wcmltYXJ5GAQgASgIEhcKD2luY2x1ZGVfdnNjaGVtYRgFIAEoCCLjAQoeVmFsaWRhdGVTY2hlbWFLZXlzcGFjZVJlc3BvbnNlEg8KB3Jlc3VsdHMYASADKAkSVwoQcmVzdWx0c19ieV9zaGFyZBgCIAMoCzI9LnZ0Y3RsZGF0YS5WYWxpZGF0ZVNjaGVtYUtleXNwYWNlUmVzcG9uc2UuUmVzdWx0c0J5U2hhcmRFbnRyeRpXChNSZXN1bHRzQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRIvCgV2YWx1ZRgCIAEoCzIgLnZ0Y3RsZGF0YS5WYWxpZGF0ZVNoYXJkUmVzcG9uc2U6AjgBIk0KFFZhbGlkYXRlU2hhcmRSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEhQKDHBpbmdfdGFibGV0cxgDIAEoCCIoChVWYWxpZGF0ZVNoYXJkUmVzcG9uc2USDwoHcmVzdWx0cxgBIAMoCSIyCh5WYWxpZGF0ZVZlcnNpb25LZXlzcGFjZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAki5QEKH1ZhbGlkYXRlVmVyc2lvbktleXNwYWNlUmVzcG9uc2USDwoHcmVzdWx0cxgBIAMoCRJYChByZXN1bHRzX2J5X3NoYXJkGAIgAygLMj4udnRjdGxkYXRhLlZhbGlkYXRlVmVyc2lvbktleXNwYWNlUmVzcG9uc2UuUmVzdWx0c0J5U2hhcmRFbnRyeRpXChNSZXN1bHRzQnlTaGFyZEVudHJ5EgsKA2tleRgBIAEoCRIvCgV2YWx1ZRgCIAEoCzIgLnZ0Y3RsZGF0YS5WYWxpZGF0ZVNoYXJkUmVzcG9uc2U6AjgBIj4KG1ZhbGlkYXRlVmVyc2lvblNoYXJkUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCSIvChxWYWxpZGF0ZVZlcnNpb25TaGFyZFJlc3BvbnNlEg8KB3Jlc3VsdHMYASADKAkiaQoWVmFsaWRhdGVWU2NoZW1hUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIOCgZzaGFyZHMYAiADKAkSFgoOZXhjbHVkZV90YWJsZXMYAyADKAkSFQoNaW5jbHVkZV92aWV3cxgEIAEoCCLVAQoXVmFsaWRhdGVWU2NoZW1hUmVzcG9uc2USDwoHcmVzdWx0cxgBIAMoCRJQChByZXN1bHRzX2J5X3NoYXJkGAIgAygLMjYudnRjdGxkYXRhLlZhbGlkYXRlVlNjaGVtYVJlc3BvbnNlLlJlc3VsdHNCeVNoYXJkRW50cnkaVwoTUmVzdWx0c0J5U2hhcmRFbnRyeRILCgNrZXkYASABKAkSLwoFdmFsdWUYAiABKAsyIC52dGN0bGRhdGEuVmFsaWRhdGVTaGFyZFJlc3BvbnNlOgI4ASK1BQoSVkRpZmZDcmVhdGVSZXF1ZXN0EhAKCHdvcmtmbG93GAEgASgJEhcKD3RhcmdldF9rZXlzcGFjZRgCIAEoCRIMCgR1dWlkGAMgASgJEhQKDHNvdXJjZV9jZWxscxgEIAMoCRIUCgx0YXJnZXRfY2VsbHMYBSADKAkSKgoMdGFibGV0X3R5cGVzGAYgAygOMhQudG9wb2RhdGEuVGFibGV0VHlwZRJRCht0YWJsZXRfc2VsZWN0aW9uX3ByZWZlcmVuY2UYByABKA4yLC50YWJsZXRtYW5hZ2VyZGF0YS5UYWJsZXRTZWxlY3Rpb25QcmVmZXJlbmNlEg4KBnRhYmxlcxgIIAMoCRINCgVsaW1pdBgJIAEoAxI4Ch5maWx0ZXJlZF9yZXBsaWNhdGlvbl93YWl0X3RpbWUYCiABKAsyEC52dHRpbWUuRHVyYXRpb24SEwoLZGVidWdfcXVlcnkYCyABKAgSEQoJb25seV9wX2tzGAwgASgIEhoKEnVwZGF0ZV90YWJsZV9zdGF0cxgNIAEoCBIhChltYXhfZXh0cmFfcm93c190b19jb21wYXJlGA4gASgDEgwKBHdhaXQYDyABKAgSLgoUd2FpdF91cGRhdGVfaW50ZXJ2YWwYECABKAsyEC52dHRpbWUuRHVyYXRpb24SEgoKYXV0b19yZXRyeRgRIAEoCBIPCgd2ZXJib3NlGBIgASgIEh4KFm1heF9yZXBvcnRfc2FtcGxlX3Jvd3MYEyABKAMSKwoRbWF4X2RpZmZfZHVyYXRpb24YFCABKAsyEC52dHRpbWUuRHVyYXRpb24SIwobcm93X2RpZmZfY29sdW1uX3RydW5jYXRlX2F0GBUgASgDEhcKCmF1dG9fc3RhcnQYFiABKAhIAIgBAUINCgtfYXV0b19zdGFydCIjChNWRGlmZkNyZWF0ZVJlc3BvbnNlEgwKBFVVSUQYASABKAkiTAoSVkRpZmZEZWxldGVSZXF1ZXN0EhAKCHdvcmtmbG93GAEgASgJEhcKD3RhcmdldF9rZXlzcGFjZRgCIAEoCRILCgNhcmcYAyABKAkiFQoTVkRpZmZEZWxldGVSZXNwb25zZSJkChJWRGlmZlJlc3VtZVJlcXVlc3QSEAoId29ya2Zsb3cYASABKAkSFwoPdGFyZ2V0X2tleXNwYWNlGAIgASgJEgwKBHV1aWQYAyABKAkSFQoNdGFyZ2V0X3NoYXJkcxgEIAMoCSIVChNWRGlmZlJlc3VtZVJlc3BvbnNlIkoKEFZEaWZmU2hvd1JlcXVlc3QSEAoId29ya2Zsb3cYASABKAkSFwoPdGFyZ2V0X2tleXNwYWNlGAIgASgJEgsKA2FyZxgDIAEoCSK6AQoRVkRpZmZTaG93UmVzcG9uc2USSwoQdGFibGV0X3Jlc3BvbnNlcxgBIAMoCzIxLnZ0Y3RsZGF0YS5WRGlmZlNob3dSZXNwb25zZS5UYWJsZXRSZXNwb25zZXNFbnRyeRpYChRUYWJsZXRSZXNwb25zZXNFbnRyeRILCgNrZXkYASABKAkSLwoFdmFsdWUYAiABKAsyIC50YWJsZXRtYW5hZ2VyZGF0YS5WRGlmZlJlc3BvbnNlOgI4ASJiChBWRGlmZlN0b3BSZXF1ZXN0EhAKCHdvcmtmbG93GAEgASgJEhcKD3RhcmdldF9rZXlzcGFjZRgCIAEoCRIMCgR1dWlkGAMgASgJEhUKDXRhcmdldF9zaGFyZHMYBCADKAkiEwoRVkRpZmZTdG9wUmVzcG9uc2UiegoVV29ya2Zsb3dEZWxldGVSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEhAKCHdvcmtmbG93GAIgASgJEhEKCWtlZXBfZGF0YRgDIAEoCBIaChJrZWVwX3JvdXRpbmdfcnVsZXMYBCABKAgSDgoGc2hhcmRzGAUgAygJIq4BChZXb3JrZmxvd0RlbGV0ZVJlc3BvbnNlEg8KB3N1bW1hcnkYASABKAkSPQoHZGV0YWlscxgCIAMoCzIsLnZ0Y3RsZGF0YS5Xb3JrZmxvd0RlbGV0ZVJlc3BvbnNlLlRhYmxldEluZm8aRAoKVGFibGV0SW5mbxIlCgZ0YWJsZXQYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIPCgdkZWxldGVkGAIgASgIIksKFVdvcmtmbG93U3RhdHVzUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIQCgh3b3JrZmxvdxgCIAEoCRIOCgZzaGFyZHMYAyADKAkilwYKFldvcmtmbG93U3RhdHVzUmVzcG9uc2USTwoQdGFibGVfY29weV9zdGF0ZRgBIAMoCzI1LnZ0Y3RsZGF0YS5Xb3JrZmxvd1N0YXR1c1Jlc3BvbnNlLlRhYmxlQ29weVN0YXRlRW50cnkSSgoNc2hhcmRfc3RyZWFtcxgCIAMoCzIzLnZ0Y3RsZGF0YS5Xb3JrZmxvd1N0YXR1c1Jlc3BvbnNlLlNoYXJkU3RyZWFtc0VudHJ5EhUKDXRyYWZmaWNfc3RhdGUYAyABKAkalwEKDlRhYmxlQ29weVN0YXRlEhMKC3Jvd3NfY29waWVkGAEgASgDEhIKCnJvd3NfdG90YWwYAiABKAMSFwoPcm93c19wZXJjZW50YWdlGAMgASgCEhQKDGJ5dGVzX2NvcGllZBgEIAEoAxITCgtieXRlc190b3RhbBgFIAEoAxIYChBieXRlc19wZXJjZW50YWdlGAYgASgCGosBChBTaGFyZFN0cmVhbVN0YXRlEgoKAmlkGAEgASgFEiUKBnRhYmxldBgCIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEhQKDHNvdXJjZV9zaGFyZBgDIAEoCRIQCghwb3NpdGlvbhgEIAEoCRIOCgZzdGF0dXMYBSABKAkSDAoEaW5mbxgGIAEoCRpTCgxTaGFyZFN0cmVhbXMSQwoHc3RyZWFtcxgCIAMoCzIyLnZ0Y3RsZGF0YS5Xb3JrZmxvd1N0YXR1c1Jlc3BvbnNlLlNoYXJkU3RyZWFtU3RhdGUaZwoTVGFibGVDb3B5U3RhdGVFbnRyeRILCgNrZXkYASABKAkSPwoFdmFsdWUYAiABKAsyMC52dGN0bGRhdGEuV29ya2Zsb3dTdGF0dXNSZXNwb25zZS5UYWJsZUNvcHlTdGF0ZToCOAEaYwoRU2hhcmRTdHJlYW1zRW50cnkSCwoDa2V5GAEgASgJEj0KBXZhbHVlGAIgASgLMi4udnRjdGxkYXRhLldvcmtmbG93U3RhdHVzUmVzcG9uc2UuU2hhcmRTdHJlYW1zOgI4ASLjAgocV29ya2Zsb3dTd2l0Y2hUcmFmZmljUmVxdWVzdBIQCghrZXlzcGFjZRgBIAEoCRIQCgh3b3JrZmxvdxgCIAEoCRINCgVjZWxscxgDIAMoCRIqCgx0YWJsZXRfdHlwZXMYBCADKA4yFC50b3BvZGF0YS5UYWJsZXRUeXBlEjUKG21heF9yZXBsaWNhdGlvbl9sYWdfYWxsb3dlZBgFIAEoCzIQLnZ0dGltZS5EdXJhdGlvbhIiChplbmFibGVfcmV2ZXJzZV9yZXBsaWNhdGlvbhgGIAEoCBIRCglkaXJlY3Rpb24YByABKAUSIQoHdGltZW91dBgIIAEoCzIQLnZ0dGltZS5EdXJhdGlvbhIPCgdkcnlfcnVuGAkgASgIEiMKG2luaXRpYWxpemVfdGFyZ2V0X3NlcXVlbmNlcxgKIAEoCBIOCgZzaGFyZHMYCyADKAkSDQoFZm9yY2UYDCABKAgidQodV29ya2Zsb3dTd2l0Y2hUcmFmZmljUmVzcG9uc2USDwoHc3VtbWFyeRgBIAEoCRITCgtzdGFydF9zdGF0ZRgCIAEoCRIVCg1jdXJyZW50X3N0YXRlGAMgASgJEhcKD2RyeV9ydW5fcmVzdWx0cxgEIAMoCSJ3ChVXb3JrZmxvd1VwZGF0ZVJlcXVlc3QSEAoIa2V5c3BhY2UYASABKAkSTAoOdGFibGV0X3JlcXVlc3QYAiABKAsyNC50YWJsZXRtYW5hZ2VyZGF0YS5VcGRhdGVWUmVwbGljYXRpb25Xb3JrZmxvd1JlcXVlc3QirgEKFldvcmtmbG93VXBkYXRlUmVzcG9uc2USDwoHc3VtbWFyeRgBIAEoCRI9CgdkZXRhaWxzGAIgAygLMiwudnRjdGxkYXRhLldvcmtmbG93VXBkYXRlUmVzcG9uc2UuVGFibGV0SW5mbxpECgpUYWJsZXRJbmZvEiUKBnRhYmxldBgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEg8KB2NoYW5nZWQYAiABKAgiFwoVR2V0TWlycm9yUnVsZXNSZXF1ZXN0IkQKFkdldE1pcnJvclJ1bGVzUmVzcG9uc2USKgoMbWlycm9yX3J1bGVzGAEgASgLMhQudnNjaGVtYS5NaXJyb3JSdWxlcyJ/ChxXb3JrZmxvd01pcnJvclRyYWZmaWNSZXF1ZXN0EhAKCGtleXNwYWNlGAEgASgJEhAKCHdvcmtmbG93GAIgASgJEioKDHRhYmxldF90eXBlcxgDIAMoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSDwoHcGVyY2VudBgEIAEoAiJcCh1Xb3JrZmxvd01pcnJvclRyYWZmaWNSZXNwb25zZRIPCgdzdW1tYXJ5GAEgASgJEhMKC3N0YXJ0X3N0YXRlGAIgASgJEhUKDWN1cnJlbnRfc3RhdGUYAyABKAkqSgoVTWF0ZXJpYWxpemF0aW9uSW50ZW50EgoKBkNVU1RPTRAAEg4KCk1PVkVUQUJMRVMQARIVChFDUkVBVEVMT09LVVBJTkRFWBACKjgKDVF1ZXJ5T3JkZXJpbmcSCAoETk9ORRAAEg0KCUFTQ0VORElORxABEg4KCkRFU0NFTkRJTkcQAipCChxTaGFyZGVkQXV0b0luY3JlbWVudEhhbmRsaW5nEgkKBUxFQVZFEAASCgoGUkVNT1ZFEAESCwoHUkVQTEFDRRACQihaJnZpdGVzcy5pby92aXRlc3MvZ28vdnQvcHJvdG8vdnRjdGxkYXRhYgZwcm90bzM", [file_binlogdata, file_logutil, file_mysqlctl, file_query, file_replicationdata, file_tabletmanagerdata, file_topodata, file_vschema, file_vtrpc, file_vttime]);

/**
 * ExecuteVtctlCommandRequest is the payload for ExecuteVtctlCommand.
 * timeouts are in nanoseconds.
 *
 * @generated from message vtctldata.ExecuteVtctlCommandRequest
 */
export type ExecuteVtctlCommandRequest = Message<"vtctldata.ExecuteVtctlCommandRequest"> & {
  /**
   * @generated from field: repeated string args = 1;
   */
  args: string[];

  /**
   * @generated from field: int64 action_timeout = 2;
   */
  actionTimeout: bigint;
};

/**
 * ExecuteVtctlCommandRequest is the payload for ExecuteVtctlCommand.
 * timeouts are in nanoseconds.
 *
 * @generated from message vtctldata.ExecuteVtctlCommandRequest
 */
export type ExecuteVtctlCommandRequestJson = {
  /**
   * @generated from field: repeated string args = 1;
   */
  args?: string[];

  /**
   * @generated from field: int64 action_timeout = 2;
   */
  actionTimeout?: string;
};

/**
 * Describes the message vtctldata.ExecuteVtctlCommandRequest.
 * Use `create(ExecuteVtctlCommandRequestSchema)` to create a new message.
 */
export const ExecuteVtctlCommandRequestSchema: GenMessage<ExecuteVtctlCommandRequest, ExecuteVtctlCommandRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 0);

/**
 * ExecuteVtctlCommandResponse is streamed back by ExecuteVtctlCommand.
 *
 * @generated from message vtctldata.ExecuteVtctlCommandResponse
 */
export type ExecuteVtctlCommandResponse = Message<"vtctldata.ExecuteVtctlCommandResponse"> & {
  /**
   * @generated from field: logutil.Event event = 1;
   */
  event?: Event;
};

/**
 * ExecuteVtctlCommandResponse is streamed back by ExecuteVtctlCommand.
 *
 * @generated from message vtctldata.ExecuteVtctlCommandResponse
 */
export type ExecuteVtctlCommandResponseJson = {
  /**
   * @generated from field: logutil.Event event = 1;
   */
  event?: EventJson;
};

/**
 * Describes the message vtctldata.ExecuteVtctlCommandResponse.
 * Use `create(ExecuteVtctlCommandResponseSchema)` to create a new message.
 */
export const ExecuteVtctlCommandResponseSchema: GenMessage<ExecuteVtctlCommandResponse, ExecuteVtctlCommandResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 1);

/**
 * TableMaterializeSttings contains the settings for one table.
 *
 * @generated from message vtctldata.TableMaterializeSettings
 */
export type TableMaterializeSettings = Message<"vtctldata.TableMaterializeSettings"> & {
  /**
   * @generated from field: string target_table = 1;
   */
  targetTable: string;

  /**
   * source_expression is a select statement.
   *
   * @generated from field: string source_expression = 2;
   */
  sourceExpression: string;

  /**
   * create_ddl contains the DDL to create the target table.
   * If empty, the target table must already exist.
   * if "copy", the target table DDL is the same as the source table.
   *
   * @generated from field: string create_ddl = 3;
   */
  createDdl: string;
};

/**
 * TableMaterializeSttings contains the settings for one table.
 *
 * @generated from message vtctldata.TableMaterializeSettings
 */
export type TableMaterializeSettingsJson = {
  /**
   * @generated from field: string target_table = 1;
   */
  targetTable?: string;

  /**
   * source_expression is a select statement.
   *
   * @generated from field: string source_expression = 2;
   */
  sourceExpression?: string;

  /**
   * create_ddl contains the DDL to create the target table.
   * If empty, the target table must already exist.
   * if "copy", the target table DDL is the same as the source table.
   *
   * @generated from field: string create_ddl = 3;
   */
  createDdl?: string;
};

/**
 * Describes the message vtctldata.TableMaterializeSettings.
 * Use `create(TableMaterializeSettingsSchema)` to create a new message.
 */
export const TableMaterializeSettingsSchema: GenMessage<TableMaterializeSettings, TableMaterializeSettingsJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 2);

/**
 * MaterializeSettings contains the settings for the Materialize command.
 *
 * @generated from message vtctldata.MaterializeSettings
 */
export type MaterializeSettings = Message<"vtctldata.MaterializeSettings"> & {
  /**
   * workflow is the name of the workflow.
   *
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace: string;

  /**
   * stop_after_copy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 4;
   */
  stopAfterCopy: boolean;

  /**
   * @generated from field: repeated vtctldata.TableMaterializeSettings table_settings = 5;
   */
  tableSettings: TableMaterializeSettings[];

  /**
   * optional parameters.
   *
   * @generated from field: string cell = 6;
   */
  cell: string;

  /**
   * @generated from field: string tablet_types = 7;
   */
  tabletTypes: string;

  /**
   * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
   * it is of the type <cluster_type.cluster_name>
   *
   * @generated from field: string external_cluster = 8;
   */
  externalCluster: string;

  /**
   * MaterializationIntent is used to identify the reason behind the materialization workflow: eg. MoveTables, CreateLookupVindex
   *
   * @generated from field: vtctldata.MaterializationIntent materialization_intent = 9;
   */
  materializationIntent: MaterializationIntent;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTable
   *
   * @generated from field: string source_time_zone = 10;
   */
  sourceTimeZone: string;

  /**
   * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
   * and to the SourceTimeZone in reverse workflows
   *
   * @generated from field: string target_time_zone = 11;
   */
  targetTimeZone: string;

  /**
   * @generated from field: repeated string source_shards = 12;
   */
  sourceShards: string[];

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 13;
   */
  onDdl: string;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 14;
   */
  deferSecondaryKeys: boolean;

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 15;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * @generated from field: bool atomic_copy = 16;
   */
  atomicCopy: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 17;
   */
  workflowOptions?: WorkflowOptions;

  /**
   * ReferenceTables is set to a csv list of tables, if the materialization is for reference tables.
   *
   * @generated from field: repeated string reference_tables = 18;
   */
  referenceTables: string[];
};

/**
 * MaterializeSettings contains the settings for the Materialize command.
 *
 * @generated from message vtctldata.MaterializeSettings
 */
export type MaterializeSettingsJson = {
  /**
   * workflow is the name of the workflow.
   *
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace?: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace?: string;

  /**
   * stop_after_copy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 4;
   */
  stopAfterCopy?: boolean;

  /**
   * @generated from field: repeated vtctldata.TableMaterializeSettings table_settings = 5;
   */
  tableSettings?: TableMaterializeSettingsJson[];

  /**
   * optional parameters.
   *
   * @generated from field: string cell = 6;
   */
  cell?: string;

  /**
   * @generated from field: string tablet_types = 7;
   */
  tabletTypes?: string;

  /**
   * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
   * it is of the type <cluster_type.cluster_name>
   *
   * @generated from field: string external_cluster = 8;
   */
  externalCluster?: string;

  /**
   * MaterializationIntent is used to identify the reason behind the materialization workflow: eg. MoveTables, CreateLookupVindex
   *
   * @generated from field: vtctldata.MaterializationIntent materialization_intent = 9;
   */
  materializationIntent?: MaterializationIntentJson;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTable
   *
   * @generated from field: string source_time_zone = 10;
   */
  sourceTimeZone?: string;

  /**
   * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
   * and to the SourceTimeZone in reverse workflows
   *
   * @generated from field: string target_time_zone = 11;
   */
  targetTimeZone?: string;

  /**
   * @generated from field: repeated string source_shards = 12;
   */
  sourceShards?: string[];

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 13;
   */
  onDdl?: string;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 14;
   */
  deferSecondaryKeys?: boolean;

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 15;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * @generated from field: bool atomic_copy = 16;
   */
  atomicCopy?: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 17;
   */
  workflowOptions?: WorkflowOptionsJson;

  /**
   * ReferenceTables is set to a csv list of tables, if the materialization is for reference tables.
   *
   * @generated from field: repeated string reference_tables = 18;
   */
  referenceTables?: string[];
};

/**
 * Describes the message vtctldata.MaterializeSettings.
 * Use `create(MaterializeSettingsSchema)` to create a new message.
 */
export const MaterializeSettingsSchema: GenMessage<MaterializeSettings, MaterializeSettingsJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 3);

/**
 * @generated from message vtctldata.Keyspace
 */
export type Keyspace = Message<"vtctldata.Keyspace"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.Keyspace keyspace = 2;
   */
  keyspace?: Keyspace$1;
};

/**
 * @generated from message vtctldata.Keyspace
 */
export type KeyspaceJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.Keyspace keyspace = 2;
   */
  keyspace?: KeyspaceJson$1;
};

/**
 * Describes the message vtctldata.Keyspace.
 * Use `create(KeyspaceSchema)` to create a new message.
 */
export const KeyspaceSchema: GenMessage<Keyspace, KeyspaceJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 4);

/**
 * SchemaMigration represents a row in the schema_migrations sidecar table.
 *
 * @generated from message vtctldata.SchemaMigration
 */
export type SchemaMigration = Message<"vtctldata.SchemaMigration"> & {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid: string;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard: string;

  /**
   * @generated from field: string schema = 4;
   */
  schema: string;

  /**
   * @generated from field: string table = 5;
   */
  table: string;

  /**
   * @generated from field: string migration_statement = 6;
   */
  migrationStatement: string;

  /**
   * @generated from field: vtctldata.SchemaMigration.Strategy strategy = 7;
   */
  strategy: SchemaMigration_Strategy;

  /**
   * @generated from field: string options = 8;
   */
  options: string;

  /**
   * @generated from field: vttime.Time added_at = 9;
   */
  addedAt?: Time;

  /**
   * @generated from field: vttime.Time requested_at = 10;
   */
  requestedAt?: Time;

  /**
   * @generated from field: vttime.Time ready_at = 11;
   */
  readyAt?: Time;

  /**
   * @generated from field: vttime.Time started_at = 12;
   */
  startedAt?: Time;

  /**
   * @generated from field: vttime.Time liveness_timestamp = 13;
   */
  livenessTimestamp?: Time;

  /**
   * @generated from field: vttime.Time completed_at = 14;
   */
  completedAt?: Time;

  /**
   * @generated from field: vttime.Time cleaned_up_at = 15;
   */
  cleanedUpAt?: Time;

  /**
   * @generated from field: vtctldata.SchemaMigration.Status status = 16;
   */
  status: SchemaMigration_Status;

  /**
   * @generated from field: string log_path = 17;
   */
  logPath: string;

  /**
   * @generated from field: string artifacts = 18;
   */
  artifacts: string;

  /**
   * @generated from field: uint64 retries = 19;
   */
  retries: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet = 20;
   */
  tablet?: TabletAlias;

  /**
   * @generated from field: bool tablet_failure = 21;
   */
  tabletFailure: boolean;

  /**
   * @generated from field: float progress = 22;
   */
  progress: number;

  /**
   * @generated from field: string migration_context = 23;
   */
  migrationContext: string;

  /**
   * @generated from field: string ddl_action = 24;
   */
  ddlAction: string;

  /**
   * @generated from field: string message = 25;
   */
  message: string;

  /**
   * @generated from field: int64 eta_seconds = 26;
   */
  etaSeconds: bigint;

  /**
   * @generated from field: uint64 rows_copied = 27;
   */
  rowsCopied: bigint;

  /**
   * @generated from field: int64 table_rows = 28;
   */
  tableRows: bigint;

  /**
   * @generated from field: uint32 added_unique_keys = 29;
   */
  addedUniqueKeys: number;

  /**
   * @generated from field: uint32 removed_unique_keys = 30;
   */
  removedUniqueKeys: number;

  /**
   * @generated from field: string log_file = 31;
   */
  logFile: string;

  /**
   * @generated from field: vttime.Duration artifact_retention = 32;
   */
  artifactRetention?: Duration;

  /**
   * @generated from field: bool postpone_completion = 33;
   */
  postponeCompletion: boolean;

  /**
   * @generated from field: string removed_unique_key_names = 34;
   */
  removedUniqueKeyNames: string;

  /**
   * @generated from field: string dropped_no_default_column_names = 35;
   */
  droppedNoDefaultColumnNames: string;

  /**
   * @generated from field: string expanded_column_names = 36;
   */
  expandedColumnNames: string;

  /**
   * @generated from field: string revertible_notes = 37;
   */
  revertibleNotes: string;

  /**
   * @generated from field: bool allow_concurrent = 38;
   */
  allowConcurrent: boolean;

  /**
   * @generated from field: string reverted_uuid = 39;
   */
  revertedUuid: string;

  /**
   * @generated from field: bool is_view = 40;
   */
  isView: boolean;

  /**
   * @generated from field: bool ready_to_complete = 41;
   */
  readyToComplete: boolean;

  /**
   * @generated from field: int64 vitess_liveness_indicator = 42;
   */
  vitessLivenessIndicator: bigint;

  /**
   * @generated from field: float user_throttle_ratio = 43;
   */
  userThrottleRatio: number;

  /**
   * @generated from field: string special_plan = 44;
   */
  specialPlan: string;

  /**
   * @generated from field: vttime.Time last_throttled_at = 45;
   */
  lastThrottledAt?: Time;

  /**
   * @generated from field: string component_throttled = 46;
   */
  componentThrottled: string;

  /**
   * @generated from field: vttime.Time cancelled_at = 47;
   */
  cancelledAt?: Time;

  /**
   * @generated from field: bool postpone_launch = 48;
   */
  postponeLaunch: boolean;

  /**
   * enum?
   *
   * @generated from field: string stage = 49;
   */
  stage: string;

  /**
   * @generated from field: uint32 cutover_attempts = 50;
   */
  cutoverAttempts: number;

  /**
   * @generated from field: bool is_immediate_operation = 51;
   */
  isImmediateOperation: boolean;

  /**
   * @generated from field: vttime.Time reviewed_at = 52;
   */
  reviewedAt?: Time;

  /**
   * @generated from field: vttime.Time ready_to_complete_at = 53;
   */
  readyToCompleteAt?: Time;

  /**
   * @generated from field: string removed_foreign_key_names = 54;
   */
  removedForeignKeyNames: string;
};

/**
 * SchemaMigration represents a row in the schema_migrations sidecar table.
 *
 * @generated from message vtctldata.SchemaMigration
 */
export type SchemaMigrationJson = {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid?: string;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard?: string;

  /**
   * @generated from field: string schema = 4;
   */
  schema?: string;

  /**
   * @generated from field: string table = 5;
   */
  table?: string;

  /**
   * @generated from field: string migration_statement = 6;
   */
  migrationStatement?: string;

  /**
   * @generated from field: vtctldata.SchemaMigration.Strategy strategy = 7;
   */
  strategy?: SchemaMigration_StrategyJson;

  /**
   * @generated from field: string options = 8;
   */
  options?: string;

  /**
   * @generated from field: vttime.Time added_at = 9;
   */
  addedAt?: TimeJson;

  /**
   * @generated from field: vttime.Time requested_at = 10;
   */
  requestedAt?: TimeJson;

  /**
   * @generated from field: vttime.Time ready_at = 11;
   */
  readyAt?: TimeJson;

  /**
   * @generated from field: vttime.Time started_at = 12;
   */
  startedAt?: TimeJson;

  /**
   * @generated from field: vttime.Time liveness_timestamp = 13;
   */
  livenessTimestamp?: TimeJson;

  /**
   * @generated from field: vttime.Time completed_at = 14;
   */
  completedAt?: TimeJson;

  /**
   * @generated from field: vttime.Time cleaned_up_at = 15;
   */
  cleanedUpAt?: TimeJson;

  /**
   * @generated from field: vtctldata.SchemaMigration.Status status = 16;
   */
  status?: SchemaMigration_StatusJson;

  /**
   * @generated from field: string log_path = 17;
   */
  logPath?: string;

  /**
   * @generated from field: string artifacts = 18;
   */
  artifacts?: string;

  /**
   * @generated from field: uint64 retries = 19;
   */
  retries?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet = 20;
   */
  tablet?: TabletAliasJson;

  /**
   * @generated from field: bool tablet_failure = 21;
   */
  tabletFailure?: boolean;

  /**
   * @generated from field: float progress = 22;
   */
  progress?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: string migration_context = 23;
   */
  migrationContext?: string;

  /**
   * @generated from field: string ddl_action = 24;
   */
  ddlAction?: string;

  /**
   * @generated from field: string message = 25;
   */
  message?: string;

  /**
   * @generated from field: int64 eta_seconds = 26;
   */
  etaSeconds?: string;

  /**
   * @generated from field: uint64 rows_copied = 27;
   */
  rowsCopied?: string;

  /**
   * @generated from field: int64 table_rows = 28;
   */
  tableRows?: string;

  /**
   * @generated from field: uint32 added_unique_keys = 29;
   */
  addedUniqueKeys?: number;

  /**
   * @generated from field: uint32 removed_unique_keys = 30;
   */
  removedUniqueKeys?: number;

  /**
   * @generated from field: string log_file = 31;
   */
  logFile?: string;

  /**
   * @generated from field: vttime.Duration artifact_retention = 32;
   */
  artifactRetention?: DurationJson;

  /**
   * @generated from field: bool postpone_completion = 33;
   */
  postponeCompletion?: boolean;

  /**
   * @generated from field: string removed_unique_key_names = 34;
   */
  removedUniqueKeyNames?: string;

  /**
   * @generated from field: string dropped_no_default_column_names = 35;
   */
  droppedNoDefaultColumnNames?: string;

  /**
   * @generated from field: string expanded_column_names = 36;
   */
  expandedColumnNames?: string;

  /**
   * @generated from field: string revertible_notes = 37;
   */
  revertibleNotes?: string;

  /**
   * @generated from field: bool allow_concurrent = 38;
   */
  allowConcurrent?: boolean;

  /**
   * @generated from field: string reverted_uuid = 39;
   */
  revertedUuid?: string;

  /**
   * @generated from field: bool is_view = 40;
   */
  isView?: boolean;

  /**
   * @generated from field: bool ready_to_complete = 41;
   */
  readyToComplete?: boolean;

  /**
   * @generated from field: int64 vitess_liveness_indicator = 42;
   */
  vitessLivenessIndicator?: string;

  /**
   * @generated from field: float user_throttle_ratio = 43;
   */
  userThrottleRatio?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: string special_plan = 44;
   */
  specialPlan?: string;

  /**
   * @generated from field: vttime.Time last_throttled_at = 45;
   */
  lastThrottledAt?: TimeJson;

  /**
   * @generated from field: string component_throttled = 46;
   */
  componentThrottled?: string;

  /**
   * @generated from field: vttime.Time cancelled_at = 47;
   */
  cancelledAt?: TimeJson;

  /**
   * @generated from field: bool postpone_launch = 48;
   */
  postponeLaunch?: boolean;

  /**
   * enum?
   *
   * @generated from field: string stage = 49;
   */
  stage?: string;

  /**
   * @generated from field: uint32 cutover_attempts = 50;
   */
  cutoverAttempts?: number;

  /**
   * @generated from field: bool is_immediate_operation = 51;
   */
  isImmediateOperation?: boolean;

  /**
   * @generated from field: vttime.Time reviewed_at = 52;
   */
  reviewedAt?: TimeJson;

  /**
   * @generated from field: vttime.Time ready_to_complete_at = 53;
   */
  readyToCompleteAt?: TimeJson;

  /**
   * @generated from field: string removed_foreign_key_names = 54;
   */
  removedForeignKeyNames?: string;
};

/**
 * Describes the message vtctldata.SchemaMigration.
 * Use `create(SchemaMigrationSchema)` to create a new message.
 */
export const SchemaMigrationSchema: GenMessage<SchemaMigration, SchemaMigrationJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 5);

/**
 * @generated from enum vtctldata.SchemaMigration.Strategy
 */
export enum SchemaMigration_Strategy {
  /**
   * SchemaMigration_VITESS uses vreplication to run the schema migration. It is
   * the default strategy for OnlineDDL requests.
   *
   * SchemaMigration_VITESS was also formerly called "ONLINE".
   *
   * @generated from enum value: VITESS = 0;
   */
  VITESS = 0,

  /**
   * @generated from enum value: ONLINE = 0;
   */
  ONLINE = 0,

  /**
   * @generated from enum value: GHOST = 1;
   */
  GHOST = 1,

  /**
   * @generated from enum value: PTOSC = 2;
   */
  PTOSC = 2,

  /**
   * SchemaMigration_DIRECT runs the migration directly against MySQL (e.g. `ALTER TABLE ...`),
   * meaning it is not actually an "online" DDL migration.
   *
   * @generated from enum value: DIRECT = 3;
   */
  DIRECT = 3,

  /**
   * SchemaMigration_MYSQL is a managed migration (queued and executed by the
   * scheduler) but runs through a MySQL `ALTER TABLE`.
   *
   * @generated from enum value: MYSQL = 4;
   */
  MYSQL = 4,
}

/**
 * @generated from enum vtctldata.SchemaMigration.Strategy
 */
export type SchemaMigration_StrategyJson = "VITESS" | "ONLINE" | "GHOST" | "PTOSC" | "DIRECT" | "MYSQL";

/**
 * Describes the enum vtctldata.SchemaMigration.Strategy.
 */
export const SchemaMigration_StrategySchema: GenEnum<SchemaMigration_Strategy, SchemaMigration_StrategyJson> = /*@__PURE__*/
  enumDesc(file_vtctldata, 5, 0);

/**
 * @generated from enum vtctldata.SchemaMigration.Status
 */
export enum SchemaMigration_Status {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: REQUESTED = 1;
   */
  REQUESTED = 1,

  /**
   * @generated from enum value: CANCELLED = 2;
   */
  CANCELLED = 2,

  /**
   * @generated from enum value: QUEUED = 3;
   */
  QUEUED = 3,

  /**
   * @generated from enum value: READY = 4;
   */
  READY = 4,

  /**
   * @generated from enum value: RUNNING = 5;
   */
  RUNNING = 5,

  /**
   * @generated from enum value: COMPLETE = 6;
   */
  COMPLETE = 6,

  /**
   * @generated from enum value: FAILED = 7;
   */
  FAILED = 7,
}

/**
 * @generated from enum vtctldata.SchemaMigration.Status
 */
export type SchemaMigration_StatusJson = "UNKNOWN" | "REQUESTED" | "CANCELLED" | "QUEUED" | "READY" | "RUNNING" | "COMPLETE" | "FAILED";

/**
 * Describes the enum vtctldata.SchemaMigration.Status.
 */
export const SchemaMigration_StatusSchema: GenEnum<SchemaMigration_Status, SchemaMigration_StatusJson> = /*@__PURE__*/
  enumDesc(file_vtctldata, 5, 1);

/**
 * @generated from message vtctldata.Shard
 */
export type Shard = Message<"vtctldata.Shard"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: topodata.Shard shard = 3;
   */
  shard?: Shard$1;
};

/**
 * @generated from message vtctldata.Shard
 */
export type ShardJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * @generated from field: topodata.Shard shard = 3;
   */
  shard?: ShardJson$1;
};

/**
 * Describes the message vtctldata.Shard.
 * Use `create(ShardSchema)` to create a new message.
 */
export const ShardSchema: GenMessage<Shard, ShardJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 6);

/**
 * @generated from message vtctldata.WorkflowOptions
 */
export type WorkflowOptions = Message<"vtctldata.WorkflowOptions"> & {
  /**
   * @generated from field: string tenant_id = 1;
   */
  tenantId: string;

  /**
   * Remove auto_increment clauses on tables when moving them to a sharded
   * keyspace and optionally replace them with vschema AutoIncrement
   * definitions.
   *
   * @generated from field: vtctldata.ShardedAutoIncrementHandling sharded_auto_increment_handling = 2;
   */
  shardedAutoIncrementHandling: ShardedAutoIncrementHandling;

  /**
   * Shards on which vreplication streams in the target keyspace are created for this workflow and to which the data
   * from the source will be vreplicated.
   *
   * @generated from field: repeated string shards = 3;
   */
  shards: string[];

  /**
   * @generated from field: map<string, string> config = 4;
   */
  config: { [key: string]: string };

  /**
   * Where to create any related schema and vschema objects such as
   * sequence tables.
   *
   * @generated from field: string global_keyspace = 5;
   */
  globalKeyspace: string;
};

/**
 * @generated from message vtctldata.WorkflowOptions
 */
export type WorkflowOptionsJson = {
  /**
   * @generated from field: string tenant_id = 1;
   */
  tenantId?: string;

  /**
   * Remove auto_increment clauses on tables when moving them to a sharded
   * keyspace and optionally replace them with vschema AutoIncrement
   * definitions.
   *
   * @generated from field: vtctldata.ShardedAutoIncrementHandling sharded_auto_increment_handling = 2;
   */
  shardedAutoIncrementHandling?: ShardedAutoIncrementHandlingJson;

  /**
   * Shards on which vreplication streams in the target keyspace are created for this workflow and to which the data
   * from the source will be vreplicated.
   *
   * @generated from field: repeated string shards = 3;
   */
  shards?: string[];

  /**
   * @generated from field: map<string, string> config = 4;
   */
  config?: { [key: string]: string };

  /**
   * Where to create any related schema and vschema objects such as
   * sequence tables.
   *
   * @generated from field: string global_keyspace = 5;
   */
  globalKeyspace?: string;
};

/**
 * Describes the message vtctldata.WorkflowOptions.
 * Use `create(WorkflowOptionsSchema)` to create a new message.
 */
export const WorkflowOptionsSchema: GenMessage<WorkflowOptions, WorkflowOptionsJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 7);

/**
 * TODO: comment the hell out of this.
 *
 * @generated from message vtctldata.Workflow
 */
export type Workflow = Message<"vtctldata.Workflow"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: vtctldata.Workflow.ReplicationLocation source = 2;
   */
  source?: Workflow_ReplicationLocation;

  /**
   * @generated from field: vtctldata.Workflow.ReplicationLocation target = 3;
   */
  target?: Workflow_ReplicationLocation;

  /**
   * This represents how long it's been since we processed any event in the
   * stream.
   *
   * @generated from field: int64 max_v_replication_lag = 4;
   */
  maxVReplicationLag: bigint;

  /**
   * @generated from field: map<string, vtctldata.Workflow.ShardStream> shard_streams = 5;
   */
  shardStreams: { [key: string]: Workflow_ShardStream };

  /**
   * @generated from field: string workflow_type = 6;
   */
  workflowType: string;

  /**
   * @generated from field: string workflow_sub_type = 7;
   */
  workflowSubType: string;

  /**
   * This represents the lag across all shards, between the current time and
   * the timestamp of the last transaction OR heartbeat timestamp (if there
   * have been no writes to replicate from the source).
   *
   * @generated from field: int64 max_v_replication_transaction_lag = 8;
   */
  maxVReplicationTransactionLag: bigint;

  /**
   * This specifies whether to defer the creation of secondary keys.
   *
   * @generated from field: bool defer_secondary_keys = 9;
   */
  deferSecondaryKeys: boolean;

  /**
   * These are additional (optional) settings for vreplication workflows. Previously we used to add it to the
   * binlogdata.BinlogSource proto object. More details in go/vt/sidecardb/schema/vreplication.sql.
   *
   * @generated from field: vtctldata.WorkflowOptions options = 10;
   */
  options?: WorkflowOptions;
};

/**
 * TODO: comment the hell out of this.
 *
 * @generated from message vtctldata.Workflow
 */
export type WorkflowJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: vtctldata.Workflow.ReplicationLocation source = 2;
   */
  source?: Workflow_ReplicationLocationJson;

  /**
   * @generated from field: vtctldata.Workflow.ReplicationLocation target = 3;
   */
  target?: Workflow_ReplicationLocationJson;

  /**
   * This represents how long it's been since we processed any event in the
   * stream.
   *
   * @generated from field: int64 max_v_replication_lag = 4;
   */
  maxVReplicationLag?: string;

  /**
   * @generated from field: map<string, vtctldata.Workflow.ShardStream> shard_streams = 5;
   */
  shardStreams?: { [key: string]: Workflow_ShardStreamJson };

  /**
   * @generated from field: string workflow_type = 6;
   */
  workflowType?: string;

  /**
   * @generated from field: string workflow_sub_type = 7;
   */
  workflowSubType?: string;

  /**
   * This represents the lag across all shards, between the current time and
   * the timestamp of the last transaction OR heartbeat timestamp (if there
   * have been no writes to replicate from the source).
   *
   * @generated from field: int64 max_v_replication_transaction_lag = 8;
   */
  maxVReplicationTransactionLag?: string;

  /**
   * This specifies whether to defer the creation of secondary keys.
   *
   * @generated from field: bool defer_secondary_keys = 9;
   */
  deferSecondaryKeys?: boolean;

  /**
   * These are additional (optional) settings for vreplication workflows. Previously we used to add it to the
   * binlogdata.BinlogSource proto object. More details in go/vt/sidecardb/schema/vreplication.sql.
   *
   * @generated from field: vtctldata.WorkflowOptions options = 10;
   */
  options?: WorkflowOptionsJson;
};

/**
 * Describes the message vtctldata.Workflow.
 * Use `create(WorkflowSchema)` to create a new message.
 */
export const WorkflowSchema: GenMessage<Workflow, WorkflowJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8);

/**
 * @generated from message vtctldata.Workflow.ReplicationLocation
 */
export type Workflow_ReplicationLocation = Message<"vtctldata.Workflow.ReplicationLocation"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: repeated string shards = 2;
   */
  shards: string[];
};

/**
 * @generated from message vtctldata.Workflow.ReplicationLocation
 */
export type Workflow_ReplicationLocationJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: repeated string shards = 2;
   */
  shards?: string[];
};

/**
 * Describes the message vtctldata.Workflow.ReplicationLocation.
 * Use `create(Workflow_ReplicationLocationSchema)` to create a new message.
 */
export const Workflow_ReplicationLocationSchema: GenMessage<Workflow_ReplicationLocation, Workflow_ReplicationLocationJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 0);

/**
 * @generated from message vtctldata.Workflow.ShardStream
 */
export type Workflow_ShardStream = Message<"vtctldata.Workflow.ShardStream"> & {
  /**
   * @generated from field: repeated vtctldata.Workflow.Stream streams = 1;
   */
  streams: Workflow_Stream[];

  /**
   * @generated from field: repeated topodata.Shard.TabletControl tablet_controls = 2;
   */
  tabletControls: Shard_TabletControl[];

  /**
   * @generated from field: bool is_primary_serving = 3;
   */
  isPrimaryServing: boolean;
};

/**
 * @generated from message vtctldata.Workflow.ShardStream
 */
export type Workflow_ShardStreamJson = {
  /**
   * @generated from field: repeated vtctldata.Workflow.Stream streams = 1;
   */
  streams?: Workflow_StreamJson[];

  /**
   * @generated from field: repeated topodata.Shard.TabletControl tablet_controls = 2;
   */
  tabletControls?: Shard_TabletControlJson[];

  /**
   * @generated from field: bool is_primary_serving = 3;
   */
  isPrimaryServing?: boolean;
};

/**
 * Describes the message vtctldata.Workflow.ShardStream.
 * Use `create(Workflow_ShardStreamSchema)` to create a new message.
 */
export const Workflow_ShardStreamSchema: GenMessage<Workflow_ShardStream, Workflow_ShardStreamJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 1);

/**
 * @generated from message vtctldata.Workflow.Stream
 */
export type Workflow_Stream = Message<"vtctldata.Workflow.Stream"> & {
  /**
   * @generated from field: int64 id = 1;
   */
  id: bigint;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletAlias tablet = 3;
   */
  tablet?: TabletAlias;

  /**
   * @generated from field: binlogdata.BinlogSource binlog_source = 4;
   */
  binlogSource?: BinlogSource;

  /**
   * @generated from field: string position = 5;
   */
  position: string;

  /**
   * @generated from field: string stop_position = 6;
   */
  stopPosition: string;

  /**
   * @generated from field: string state = 7;
   */
  state: string;

  /**
   * @generated from field: string db_name = 8;
   */
  dbName: string;

  /**
   * @generated from field: vttime.Time transaction_timestamp = 9;
   */
  transactionTimestamp?: Time;

  /**
   * @generated from field: vttime.Time time_updated = 10;
   */
  timeUpdated?: Time;

  /**
   * @generated from field: string message = 11;
   */
  message: string;

  /**
   * @generated from field: repeated vtctldata.Workflow.Stream.CopyState copy_states = 12;
   */
  copyStates: Workflow_Stream_CopyState[];

  /**
   * @generated from field: repeated vtctldata.Workflow.Stream.Log logs = 13;
   */
  logs: Workflow_Stream_Log[];

  /**
   * LogFetchError is set if we fail to fetch some logs for this stream. We
   * will never fail to fetch workflows because we cannot fetch the logs, but
   * we will still forward log-fetch errors to the caller, should that be
   * relevant to the context in which they are fetching workflows.
   *
   * Note that this field being set does not necessarily mean that Logs is nil;
   * if there are N logs that exist for the stream, and we fail to fetch the
   * ith log, we will still return logs in [0, i) + (i, N].
   *
   * @generated from field: string log_fetch_error = 14;
   */
  logFetchError: string;

  /**
   * @generated from field: repeated string tags = 15;
   */
  tags: string[];

  /**
   * @generated from field: int64 rows_copied = 16;
   */
  rowsCopied: bigint;

  /**
   * @generated from field: vtctldata.Workflow.Stream.ThrottlerStatus throttler_status = 17;
   */
  throttlerStatus?: Workflow_Stream_ThrottlerStatus;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 18;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 19;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * @generated from field: repeated string cells = 20;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.Workflow.Stream
 */
export type Workflow_StreamJson = {
  /**
   * @generated from field: int64 id = 1;
   */
  id?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet = 3;
   */
  tablet?: TabletAliasJson;

  /**
   * @generated from field: binlogdata.BinlogSource binlog_source = 4;
   */
  binlogSource?: BinlogSourceJson;

  /**
   * @generated from field: string position = 5;
   */
  position?: string;

  /**
   * @generated from field: string stop_position = 6;
   */
  stopPosition?: string;

  /**
   * @generated from field: string state = 7;
   */
  state?: string;

  /**
   * @generated from field: string db_name = 8;
   */
  dbName?: string;

  /**
   * @generated from field: vttime.Time transaction_timestamp = 9;
   */
  transactionTimestamp?: TimeJson;

  /**
   * @generated from field: vttime.Time time_updated = 10;
   */
  timeUpdated?: TimeJson;

  /**
   * @generated from field: string message = 11;
   */
  message?: string;

  /**
   * @generated from field: repeated vtctldata.Workflow.Stream.CopyState copy_states = 12;
   */
  copyStates?: Workflow_Stream_CopyStateJson[];

  /**
   * @generated from field: repeated vtctldata.Workflow.Stream.Log logs = 13;
   */
  logs?: Workflow_Stream_LogJson[];

  /**
   * LogFetchError is set if we fail to fetch some logs for this stream. We
   * will never fail to fetch workflows because we cannot fetch the logs, but
   * we will still forward log-fetch errors to the caller, should that be
   * relevant to the context in which they are fetching workflows.
   *
   * Note that this field being set does not necessarily mean that Logs is nil;
   * if there are N logs that exist for the stream, and we fail to fetch the
   * ith log, we will still return logs in [0, i) + (i, N].
   *
   * @generated from field: string log_fetch_error = 14;
   */
  logFetchError?: string;

  /**
   * @generated from field: repeated string tags = 15;
   */
  tags?: string[];

  /**
   * @generated from field: int64 rows_copied = 16;
   */
  rowsCopied?: string;

  /**
   * @generated from field: vtctldata.Workflow.Stream.ThrottlerStatus throttler_status = 17;
   */
  throttlerStatus?: Workflow_Stream_ThrottlerStatusJson;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 18;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 19;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * @generated from field: repeated string cells = 20;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.Workflow.Stream.
 * Use `create(Workflow_StreamSchema)` to create a new message.
 */
export const Workflow_StreamSchema: GenMessage<Workflow_Stream, Workflow_StreamJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 2);

/**
 * @generated from message vtctldata.Workflow.Stream.CopyState
 */
export type Workflow_Stream_CopyState = Message<"vtctldata.Workflow.Stream.CopyState"> & {
  /**
   * @generated from field: string table = 1;
   */
  table: string;

  /**
   * @generated from field: string last_pk = 2;
   */
  lastPk: string;

  /**
   * @generated from field: int64 stream_id = 3;
   */
  streamId: bigint;
};

/**
 * @generated from message vtctldata.Workflow.Stream.CopyState
 */
export type Workflow_Stream_CopyStateJson = {
  /**
   * @generated from field: string table = 1;
   */
  table?: string;

  /**
   * @generated from field: string last_pk = 2;
   */
  lastPk?: string;

  /**
   * @generated from field: int64 stream_id = 3;
   */
  streamId?: string;
};

/**
 * Describes the message vtctldata.Workflow.Stream.CopyState.
 * Use `create(Workflow_Stream_CopyStateSchema)` to create a new message.
 */
export const Workflow_Stream_CopyStateSchema: GenMessage<Workflow_Stream_CopyState, Workflow_Stream_CopyStateJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 2, 0);

/**
 * @generated from message vtctldata.Workflow.Stream.Log
 */
export type Workflow_Stream_Log = Message<"vtctldata.Workflow.Stream.Log"> & {
  /**
   * @generated from field: int64 id = 1;
   */
  id: bigint;

  /**
   * @generated from field: int64 stream_id = 2;
   */
  streamId: bigint;

  /**
   * @generated from field: string type = 3;
   */
  type: string;

  /**
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * @generated from field: vttime.Time created_at = 5;
   */
  createdAt?: Time;

  /**
   * @generated from field: vttime.Time updated_at = 6;
   */
  updatedAt?: Time;

  /**
   * @generated from field: string message = 7;
   */
  message: string;

  /**
   * @generated from field: int64 count = 8;
   */
  count: bigint;
};

/**
 * @generated from message vtctldata.Workflow.Stream.Log
 */
export type Workflow_Stream_LogJson = {
  /**
   * @generated from field: int64 id = 1;
   */
  id?: string;

  /**
   * @generated from field: int64 stream_id = 2;
   */
  streamId?: string;

  /**
   * @generated from field: string type = 3;
   */
  type?: string;

  /**
   * @generated from field: string state = 4;
   */
  state?: string;

  /**
   * @generated from field: vttime.Time created_at = 5;
   */
  createdAt?: TimeJson;

  /**
   * @generated from field: vttime.Time updated_at = 6;
   */
  updatedAt?: TimeJson;

  /**
   * @generated from field: string message = 7;
   */
  message?: string;

  /**
   * @generated from field: int64 count = 8;
   */
  count?: string;
};

/**
 * Describes the message vtctldata.Workflow.Stream.Log.
 * Use `create(Workflow_Stream_LogSchema)` to create a new message.
 */
export const Workflow_Stream_LogSchema: GenMessage<Workflow_Stream_Log, Workflow_Stream_LogJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 2, 1);

/**
 * @generated from message vtctldata.Workflow.Stream.ThrottlerStatus
 */
export type Workflow_Stream_ThrottlerStatus = Message<"vtctldata.Workflow.Stream.ThrottlerStatus"> & {
  /**
   * @generated from field: string component_throttled = 1;
   */
  componentThrottled: string;

  /**
   * @generated from field: vttime.Time time_throttled = 2;
   */
  timeThrottled?: Time;
};

/**
 * @generated from message vtctldata.Workflow.Stream.ThrottlerStatus
 */
export type Workflow_Stream_ThrottlerStatusJson = {
  /**
   * @generated from field: string component_throttled = 1;
   */
  componentThrottled?: string;

  /**
   * @generated from field: vttime.Time time_throttled = 2;
   */
  timeThrottled?: TimeJson;
};

/**
 * Describes the message vtctldata.Workflow.Stream.ThrottlerStatus.
 * Use `create(Workflow_Stream_ThrottlerStatusSchema)` to create a new message.
 */
export const Workflow_Stream_ThrottlerStatusSchema: GenMessage<Workflow_Stream_ThrottlerStatus, Workflow_Stream_ThrottlerStatusJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 8, 2, 2);

/**
 * @generated from message vtctldata.AddCellInfoRequest
 */
export type AddCellInfoRequest = Message<"vtctldata.AddCellInfoRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfo;
};

/**
 * @generated from message vtctldata.AddCellInfoRequest
 */
export type AddCellInfoRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfoJson;
};

/**
 * Describes the message vtctldata.AddCellInfoRequest.
 * Use `create(AddCellInfoRequestSchema)` to create a new message.
 */
export const AddCellInfoRequestSchema: GenMessage<AddCellInfoRequest, AddCellInfoRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 9);

/**
 * @generated from message vtctldata.AddCellInfoResponse
 */
export type AddCellInfoResponse = Message<"vtctldata.AddCellInfoResponse"> & {
};

/**
 * @generated from message vtctldata.AddCellInfoResponse
 */
export type AddCellInfoResponseJson = {
};

/**
 * Describes the message vtctldata.AddCellInfoResponse.
 * Use `create(AddCellInfoResponseSchema)` to create a new message.
 */
export const AddCellInfoResponseSchema: GenMessage<AddCellInfoResponse, AddCellInfoResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 10);

/**
 * @generated from message vtctldata.AddCellsAliasRequest
 */
export type AddCellsAliasRequest = Message<"vtctldata.AddCellsAliasRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.AddCellsAliasRequest
 */
export type AddCellsAliasRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.AddCellsAliasRequest.
 * Use `create(AddCellsAliasRequestSchema)` to create a new message.
 */
export const AddCellsAliasRequestSchema: GenMessage<AddCellsAliasRequest, AddCellsAliasRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 11);

/**
 * @generated from message vtctldata.AddCellsAliasResponse
 */
export type AddCellsAliasResponse = Message<"vtctldata.AddCellsAliasResponse"> & {
};

/**
 * @generated from message vtctldata.AddCellsAliasResponse
 */
export type AddCellsAliasResponseJson = {
};

/**
 * Describes the message vtctldata.AddCellsAliasResponse.
 * Use `create(AddCellsAliasResponseSchema)` to create a new message.
 */
export const AddCellsAliasResponseSchema: GenMessage<AddCellsAliasResponse, AddCellsAliasResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 12);

/**
 * @generated from message vtctldata.ApplyKeyspaceRoutingRulesRequest
 */
export type ApplyKeyspaceRoutingRulesRequest = Message<"vtctldata.ApplyKeyspaceRoutingRulesRequest"> & {
  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRules;

  /**
   * SkipRebuild, if set, will cause ApplyKeyspaceRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells: string[];
};

/**
 * @generated from message vtctldata.ApplyKeyspaceRoutingRulesRequest
 */
export type ApplyKeyspaceRoutingRulesRequestJson = {
  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRulesJson;

  /**
   * SkipRebuild, if set, will cause ApplyKeyspaceRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild?: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells?: string[];
};

/**
 * Describes the message vtctldata.ApplyKeyspaceRoutingRulesRequest.
 * Use `create(ApplyKeyspaceRoutingRulesRequestSchema)` to create a new message.
 */
export const ApplyKeyspaceRoutingRulesRequestSchema: GenMessage<ApplyKeyspaceRoutingRulesRequest, ApplyKeyspaceRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 13);

/**
 * @generated from message vtctldata.ApplyKeyspaceRoutingRulesResponse
 */
export type ApplyKeyspaceRoutingRulesResponse = Message<"vtctldata.ApplyKeyspaceRoutingRulesResponse"> & {
  /**
   * KeyspaceRoutingRules returns the current set of rules.
   *
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRules;
};

/**
 * @generated from message vtctldata.ApplyKeyspaceRoutingRulesResponse
 */
export type ApplyKeyspaceRoutingRulesResponseJson = {
  /**
   * KeyspaceRoutingRules returns the current set of rules.
   *
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRulesJson;
};

/**
 * Describes the message vtctldata.ApplyKeyspaceRoutingRulesResponse.
 * Use `create(ApplyKeyspaceRoutingRulesResponseSchema)` to create a new message.
 */
export const ApplyKeyspaceRoutingRulesResponseSchema: GenMessage<ApplyKeyspaceRoutingRulesResponse, ApplyKeyspaceRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 14);

/**
 * @generated from message vtctldata.ApplyRoutingRulesRequest
 */
export type ApplyRoutingRulesRequest = Message<"vtctldata.ApplyRoutingRulesRequest"> & {
  /**
   * @generated from field: vschema.RoutingRules routing_rules = 1;
   */
  routingRules?: RoutingRules;

  /**
   * SkipRebuild, if set, will cause ApplyRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells: string[];
};

/**
 * @generated from message vtctldata.ApplyRoutingRulesRequest
 */
export type ApplyRoutingRulesRequestJson = {
  /**
   * @generated from field: vschema.RoutingRules routing_rules = 1;
   */
  routingRules?: RoutingRulesJson;

  /**
   * SkipRebuild, if set, will cause ApplyRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild?: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells?: string[];
};

/**
 * Describes the message vtctldata.ApplyRoutingRulesRequest.
 * Use `create(ApplyRoutingRulesRequestSchema)` to create a new message.
 */
export const ApplyRoutingRulesRequestSchema: GenMessage<ApplyRoutingRulesRequest, ApplyRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 15);

/**
 * @generated from message vtctldata.ApplyRoutingRulesResponse
 */
export type ApplyRoutingRulesResponse = Message<"vtctldata.ApplyRoutingRulesResponse"> & {
};

/**
 * @generated from message vtctldata.ApplyRoutingRulesResponse
 */
export type ApplyRoutingRulesResponseJson = {
};

/**
 * Describes the message vtctldata.ApplyRoutingRulesResponse.
 * Use `create(ApplyRoutingRulesResponseSchema)` to create a new message.
 */
export const ApplyRoutingRulesResponseSchema: GenMessage<ApplyRoutingRulesResponse, ApplyRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 16);

/**
 * @generated from message vtctldata.ApplyShardRoutingRulesRequest
 */
export type ApplyShardRoutingRulesRequest = Message<"vtctldata.ApplyShardRoutingRulesRequest"> & {
  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 1;
   */
  shardRoutingRules?: ShardRoutingRules;

  /**
   * SkipRebuild, if set, will cause ApplyShardRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells: string[];
};

/**
 * @generated from message vtctldata.ApplyShardRoutingRulesRequest
 */
export type ApplyShardRoutingRulesRequestJson = {
  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 1;
   */
  shardRoutingRules?: ShardRoutingRulesJson;

  /**
   * SkipRebuild, if set, will cause ApplyShardRoutingRules to skip rebuilding the
   * SrvVSchema objects in each cell in RebuildCells.
   *
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild?: boolean;

  /**
   * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
   * provided the SrvVSchema will be rebuilt in every cell in the topology.
   *
   * Ignored if SkipRebuild is set.
   *
   * @generated from field: repeated string rebuild_cells = 3;
   */
  rebuildCells?: string[];
};

/**
 * Describes the message vtctldata.ApplyShardRoutingRulesRequest.
 * Use `create(ApplyShardRoutingRulesRequestSchema)` to create a new message.
 */
export const ApplyShardRoutingRulesRequestSchema: GenMessage<ApplyShardRoutingRulesRequest, ApplyShardRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 17);

/**
 * @generated from message vtctldata.ApplyShardRoutingRulesResponse
 */
export type ApplyShardRoutingRulesResponse = Message<"vtctldata.ApplyShardRoutingRulesResponse"> & {
};

/**
 * @generated from message vtctldata.ApplyShardRoutingRulesResponse
 */
export type ApplyShardRoutingRulesResponseJson = {
};

/**
 * Describes the message vtctldata.ApplyShardRoutingRulesResponse.
 * Use `create(ApplyShardRoutingRulesResponseSchema)` to create a new message.
 */
export const ApplyShardRoutingRulesResponseSchema: GenMessage<ApplyShardRoutingRulesResponse, ApplyShardRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 18);

/**
 * @generated from message vtctldata.ApplySchemaRequest
 */
export type ApplySchemaRequest = Message<"vtctldata.ApplySchemaRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * SQL commands to run.
   *
   * @generated from field: repeated string sql = 3;
   */
  sql: string[];

  /**
   * Online DDL strategy, compatible with @@ddl_strategy session variable (examples: 'gh-ost', 'pt-osc', 'gh-ost --max-load=Threads_running=100'")
   *
   * @generated from field: string ddl_strategy = 4;
   */
  ddlStrategy: string;

  /**
   * Optional: explicit UUIDs for migration.
   * If given, must match number of DDL changes
   *
   * @generated from field: repeated string uuid_list = 5;
   */
  uuidList: string[];

  /**
   * For Online DDL, optionally supply a custom unique string used as context for the migration(s) in this command.
   * By default a unique context is auto-generated by Vitess
   *
   * @generated from field: string migration_context = 6;
   */
  migrationContext: string;

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in reparenting.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 7;
   */
  waitReplicasTimeout?: Duration;

  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 9;
   */
  callerId?: CallerID;

  /**
   * BatchSize indicates how many queries to apply together
   *
   * @generated from field: int64 batch_size = 10;
   */
  batchSize: bigint;
};

/**
 * @generated from message vtctldata.ApplySchemaRequest
 */
export type ApplySchemaRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * SQL commands to run.
   *
   * @generated from field: repeated string sql = 3;
   */
  sql?: string[];

  /**
   * Online DDL strategy, compatible with @@ddl_strategy session variable (examples: 'gh-ost', 'pt-osc', 'gh-ost --max-load=Threads_running=100'")
   *
   * @generated from field: string ddl_strategy = 4;
   */
  ddlStrategy?: string;

  /**
   * Optional: explicit UUIDs for migration.
   * If given, must match number of DDL changes
   *
   * @generated from field: repeated string uuid_list = 5;
   */
  uuidList?: string[];

  /**
   * For Online DDL, optionally supply a custom unique string used as context for the migration(s) in this command.
   * By default a unique context is auto-generated by Vitess
   *
   * @generated from field: string migration_context = 6;
   */
  migrationContext?: string;

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in reparenting.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 7;
   */
  waitReplicasTimeout?: DurationJson;

  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 9;
   */
  callerId?: CallerIDJson;

  /**
   * BatchSize indicates how many queries to apply together
   *
   * @generated from field: int64 batch_size = 10;
   */
  batchSize?: string;
};

/**
 * Describes the message vtctldata.ApplySchemaRequest.
 * Use `create(ApplySchemaRequestSchema)` to create a new message.
 */
export const ApplySchemaRequestSchema: GenMessage<ApplySchemaRequest, ApplySchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 19);

/**
 * @generated from message vtctldata.ApplySchemaResponse
 */
export type ApplySchemaResponse = Message<"vtctldata.ApplySchemaResponse"> & {
  /**
   * @generated from field: repeated string uuid_list = 1;
   */
  uuidList: string[];

  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 2;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.ApplySchemaResponse
 */
export type ApplySchemaResponseJson = {
  /**
   * @generated from field: repeated string uuid_list = 1;
   */
  uuidList?: string[];

  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 2;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.ApplySchemaResponse.
 * Use `create(ApplySchemaResponseSchema)` to create a new message.
 */
export const ApplySchemaResponseSchema: GenMessage<ApplySchemaResponse, ApplySchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 20);

/**
 * @generated from message vtctldata.ApplyVSchemaRequest
 */
export type ApplyVSchemaRequest = Message<"vtctldata.ApplyVSchemaRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild: boolean;

  /**
   * @generated from field: bool dry_run = 3;
   */
  dryRun: boolean;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells: string[];

  /**
   * @generated from field: vschema.Keyspace v_schema = 5;
   */
  vSchema?: Keyspace$2;

  /**
   * @generated from field: string sql = 6;
   */
  sql: string;

  /**
   * Strict returns an error if there are unknown vindex params.
   *
   * @generated from field: bool strict = 7;
   */
  strict: boolean;
};

/**
 * @generated from message vtctldata.ApplyVSchemaRequest
 */
export type ApplyVSchemaRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: bool skip_rebuild = 2;
   */
  skipRebuild?: boolean;

  /**
   * @generated from field: bool dry_run = 3;
   */
  dryRun?: boolean;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells?: string[];

  /**
   * @generated from field: vschema.Keyspace v_schema = 5;
   */
  vSchema?: KeyspaceJson$2;

  /**
   * @generated from field: string sql = 6;
   */
  sql?: string;

  /**
   * Strict returns an error if there are unknown vindex params.
   *
   * @generated from field: bool strict = 7;
   */
  strict?: boolean;
};

/**
 * Describes the message vtctldata.ApplyVSchemaRequest.
 * Use `create(ApplyVSchemaRequestSchema)` to create a new message.
 */
export const ApplyVSchemaRequestSchema: GenMessage<ApplyVSchemaRequest, ApplyVSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 21);

/**
 * @generated from message vtctldata.ApplyVSchemaResponse
 */
export type ApplyVSchemaResponse = Message<"vtctldata.ApplyVSchemaResponse"> & {
  /**
   * @generated from field: vschema.Keyspace v_schema = 1;
   */
  vSchema?: Keyspace$2;

  /**
   * UnknownVindexParams is a map of vindex name to params that were not recognized by the vindex
   * type. E.g.:
   *
   * {
   *   "lookup_vdx": {
   *     "params": ["raed_lock", "not_verify"]
   *   }
   * }
   *
   * @generated from field: map<string, vtctldata.ApplyVSchemaResponse.ParamList> unknown_vindex_params = 2;
   */
  unknownVindexParams: { [key: string]: ApplyVSchemaResponse_ParamList };
};

/**
 * @generated from message vtctldata.ApplyVSchemaResponse
 */
export type ApplyVSchemaResponseJson = {
  /**
   * @generated from field: vschema.Keyspace v_schema = 1;
   */
  vSchema?: KeyspaceJson$2;

  /**
   * UnknownVindexParams is a map of vindex name to params that were not recognized by the vindex
   * type. E.g.:
   *
   * {
   *   "lookup_vdx": {
   *     "params": ["raed_lock", "not_verify"]
   *   }
   * }
   *
   * @generated from field: map<string, vtctldata.ApplyVSchemaResponse.ParamList> unknown_vindex_params = 2;
   */
  unknownVindexParams?: { [key: string]: ApplyVSchemaResponse_ParamListJson };
};

/**
 * Describes the message vtctldata.ApplyVSchemaResponse.
 * Use `create(ApplyVSchemaResponseSchema)` to create a new message.
 */
export const ApplyVSchemaResponseSchema: GenMessage<ApplyVSchemaResponse, ApplyVSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 22);

/**
 * @generated from message vtctldata.ApplyVSchemaResponse.ParamList
 */
export type ApplyVSchemaResponse_ParamList = Message<"vtctldata.ApplyVSchemaResponse.ParamList"> & {
  /**
   * @generated from field: repeated string params = 1;
   */
  params: string[];
};

/**
 * @generated from message vtctldata.ApplyVSchemaResponse.ParamList
 */
export type ApplyVSchemaResponse_ParamListJson = {
  /**
   * @generated from field: repeated string params = 1;
   */
  params?: string[];
};

/**
 * Describes the message vtctldata.ApplyVSchemaResponse.ParamList.
 * Use `create(ApplyVSchemaResponse_ParamListSchema)` to create a new message.
 */
export const ApplyVSchemaResponse_ParamListSchema: GenMessage<ApplyVSchemaResponse_ParamList, ApplyVSchemaResponse_ParamListJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 22, 0);

/**
 * @generated from message vtctldata.BackupRequest
 */
export type BackupRequest = Message<"vtctldata.BackupRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * AllowPrimary allows the backup to proceed if TabletAlias is a PRIMARY.
   *
   * WARNING: If using the builtin backup engine, this will shutdown mysqld on
   * the primary for the duration of the backup, and no writes will be possible.
   *
   * @generated from field: bool allow_primary = 2;
   */
  allowPrimary: boolean;

  /**
   * Concurrency specifies the number of compression/checksum jobs to run
   * simultaneously.
   *
   * @generated from field: int32 concurrency = 3;
   */
  concurrency: number;

  /**
   * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
   * then the backup becomes incremental and applies as of given position.
   *
   * @generated from field: string incremental_from_pos = 4;
   */
  incrementalFromPos: string;

  /**
   * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
   * so that it's a backup that can be used for an upgrade.
   *
   * @generated from field: bool upgrade_safe = 5;
   */
  upgradeSafe: boolean;

  /**
   * BackupEngine specifies if we want to use a particular backup engine for this backup request
   *
   * @generated from field: optional string backup_engine = 6;
   */
  backupEngine?: string;
};

/**
 * @generated from message vtctldata.BackupRequest
 */
export type BackupRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * AllowPrimary allows the backup to proceed if TabletAlias is a PRIMARY.
   *
   * WARNING: If using the builtin backup engine, this will shutdown mysqld on
   * the primary for the duration of the backup, and no writes will be possible.
   *
   * @generated from field: bool allow_primary = 2;
   */
  allowPrimary?: boolean;

  /**
   * Concurrency specifies the number of compression/checksum jobs to run
   * simultaneously.
   *
   * @generated from field: int32 concurrency = 3;
   */
  concurrency?: number;

  /**
   * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
   * then the backup becomes incremental and applies as of given position.
   *
   * @generated from field: string incremental_from_pos = 4;
   */
  incrementalFromPos?: string;

  /**
   * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
   * so that it's a backup that can be used for an upgrade.
   *
   * @generated from field: bool upgrade_safe = 5;
   */
  upgradeSafe?: boolean;

  /**
   * BackupEngine specifies if we want to use a particular backup engine for this backup request
   *
   * @generated from field: optional string backup_engine = 6;
   */
  backupEngine?: string;
};

/**
 * Describes the message vtctldata.BackupRequest.
 * Use `create(BackupRequestSchema)` to create a new message.
 */
export const BackupRequestSchema: GenMessage<BackupRequest, BackupRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 23);

/**
 * @generated from message vtctldata.BackupResponse
 */
export type BackupResponse = Message<"vtctldata.BackupResponse"> & {
  /**
   * TabletAlias is the alias being used for the backup.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard: string;

  /**
   * @generated from field: logutil.Event event = 4;
   */
  event?: Event;
};

/**
 * @generated from message vtctldata.BackupResponse
 */
export type BackupResponseJson = {
  /**
   * TabletAlias is the alias being used for the backup.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard?: string;

  /**
   * @generated from field: logutil.Event event = 4;
   */
  event?: EventJson;
};

/**
 * Describes the message vtctldata.BackupResponse.
 * Use `create(BackupResponseSchema)` to create a new message.
 */
export const BackupResponseSchema: GenMessage<BackupResponse, BackupResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 24);

/**
 * @generated from message vtctldata.BackupShardRequest
 */
export type BackupShardRequest = Message<"vtctldata.BackupShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * AllowPrimary allows the backup to occur on a PRIMARY tablet. See
   * BackupRequest.AllowPrimary for warnings and caveats.
   *
   * @generated from field: bool allow_primary = 3;
   */
  allowPrimary: boolean;

  /**
   * Concurrency specifies the number of compression/checksum jobs to run
   * simultaneously.
   *
   * @generated from field: int32 concurrency = 4;
   */
  concurrency: number;

  /**
   * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
   * so that it's a backup that can be used for an upgrade.
   *
   * @generated from field: bool upgrade_safe = 5;
   */
  upgradeSafe: boolean;

  /**
   * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
   * then the backup becomes incremental and applies as of given position.
   *
   * @generated from field: string incremental_from_pos = 6;
   */
  incrementalFromPos: string;
};

/**
 * @generated from message vtctldata.BackupShardRequest
 */
export type BackupShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * AllowPrimary allows the backup to occur on a PRIMARY tablet. See
   * BackupRequest.AllowPrimary for warnings and caveats.
   *
   * @generated from field: bool allow_primary = 3;
   */
  allowPrimary?: boolean;

  /**
   * Concurrency specifies the number of compression/checksum jobs to run
   * simultaneously.
   *
   * @generated from field: int32 concurrency = 4;
   */
  concurrency?: number;

  /**
   * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
   * so that it's a backup that can be used for an upgrade.
   *
   * @generated from field: bool upgrade_safe = 5;
   */
  upgradeSafe?: boolean;

  /**
   * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
   * then the backup becomes incremental and applies as of given position.
   *
   * @generated from field: string incremental_from_pos = 6;
   */
  incrementalFromPos?: string;
};

/**
 * Describes the message vtctldata.BackupShardRequest.
 * Use `create(BackupShardRequestSchema)` to create a new message.
 */
export const BackupShardRequestSchema: GenMessage<BackupShardRequest, BackupShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 25);

/**
 * @generated from message vtctldata.CancelSchemaMigrationRequest
 */
export type CancelSchemaMigrationRequest = Message<"vtctldata.CancelSchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.CancelSchemaMigrationRequest
 */
export type CancelSchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.CancelSchemaMigrationRequest.
 * Use `create(CancelSchemaMigrationRequestSchema)` to create a new message.
 */
export const CancelSchemaMigrationRequestSchema: GenMessage<CancelSchemaMigrationRequest, CancelSchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 26);

/**
 * @generated from message vtctldata.CancelSchemaMigrationResponse
 */
export type CancelSchemaMigrationResponse = Message<"vtctldata.CancelSchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.CancelSchemaMigrationResponse
 */
export type CancelSchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.CancelSchemaMigrationResponse.
 * Use `create(CancelSchemaMigrationResponseSchema)` to create a new message.
 */
export const CancelSchemaMigrationResponseSchema: GenMessage<CancelSchemaMigrationResponse, CancelSchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 27);

/**
 * @generated from message vtctldata.ChangeTabletTagsRequest
 */
export type ChangeTabletTagsRequest = Message<"vtctldata.ChangeTabletTagsRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: map<string, string> tags = 2;
   */
  tags: { [key: string]: string };

  /**
   * @generated from field: bool replace = 3;
   */
  replace: boolean;
};

/**
 * @generated from message vtctldata.ChangeTabletTagsRequest
 */
export type ChangeTabletTagsRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: map<string, string> tags = 2;
   */
  tags?: { [key: string]: string };

  /**
   * @generated from field: bool replace = 3;
   */
  replace?: boolean;
};

/**
 * Describes the message vtctldata.ChangeTabletTagsRequest.
 * Use `create(ChangeTabletTagsRequestSchema)` to create a new message.
 */
export const ChangeTabletTagsRequestSchema: GenMessage<ChangeTabletTagsRequest, ChangeTabletTagsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 28);

/**
 * @generated from message vtctldata.ChangeTabletTagsResponse
 */
export type ChangeTabletTagsResponse = Message<"vtctldata.ChangeTabletTagsResponse"> & {
  /**
   * @generated from field: map<string, string> before_tags = 1;
   */
  beforeTags: { [key: string]: string };

  /**
   * @generated from field: map<string, string> after_tags = 2;
   */
  afterTags: { [key: string]: string };
};

/**
 * @generated from message vtctldata.ChangeTabletTagsResponse
 */
export type ChangeTabletTagsResponseJson = {
  /**
   * @generated from field: map<string, string> before_tags = 1;
   */
  beforeTags?: { [key: string]: string };

  /**
   * @generated from field: map<string, string> after_tags = 2;
   */
  afterTags?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.ChangeTabletTagsResponse.
 * Use `create(ChangeTabletTagsResponseSchema)` to create a new message.
 */
export const ChangeTabletTagsResponseSchema: GenMessage<ChangeTabletTagsResponse, ChangeTabletTagsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 29);

/**
 * @generated from message vtctldata.ChangeTabletTypeRequest
 */
export type ChangeTabletTypeRequest = Message<"vtctldata.ChangeTabletTypeRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: topodata.TabletType db_type = 2;
   */
  dbType: TabletType;

  /**
   * @generated from field: bool dry_run = 3;
   */
  dryRun: boolean;
};

/**
 * @generated from message vtctldata.ChangeTabletTypeRequest
 */
export type ChangeTabletTypeRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: topodata.TabletType db_type = 2;
   */
  dbType?: TabletTypeJson;

  /**
   * @generated from field: bool dry_run = 3;
   */
  dryRun?: boolean;
};

/**
 * Describes the message vtctldata.ChangeTabletTypeRequest.
 * Use `create(ChangeTabletTypeRequestSchema)` to create a new message.
 */
export const ChangeTabletTypeRequestSchema: GenMessage<ChangeTabletTypeRequest, ChangeTabletTypeRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 30);

/**
 * @generated from message vtctldata.ChangeTabletTypeResponse
 */
export type ChangeTabletTypeResponse = Message<"vtctldata.ChangeTabletTypeResponse"> & {
  /**
   * @generated from field: topodata.Tablet before_tablet = 1;
   */
  beforeTablet?: Tablet;

  /**
   * @generated from field: topodata.Tablet after_tablet = 2;
   */
  afterTablet?: Tablet;

  /**
   * @generated from field: bool was_dry_run = 3;
   */
  wasDryRun: boolean;
};

/**
 * @generated from message vtctldata.ChangeTabletTypeResponse
 */
export type ChangeTabletTypeResponseJson = {
  /**
   * @generated from field: topodata.Tablet before_tablet = 1;
   */
  beforeTablet?: TabletJson;

  /**
   * @generated from field: topodata.Tablet after_tablet = 2;
   */
  afterTablet?: TabletJson;

  /**
   * @generated from field: bool was_dry_run = 3;
   */
  wasDryRun?: boolean;
};

/**
 * Describes the message vtctldata.ChangeTabletTypeResponse.
 * Use `create(ChangeTabletTypeResponseSchema)` to create a new message.
 */
export const ChangeTabletTypeResponseSchema: GenMessage<ChangeTabletTypeResponse, ChangeTabletTypeResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 31);

/**
 * @generated from message vtctldata.CheckThrottlerRequest
 */
export type CheckThrottlerRequest = Message<"vtctldata.CheckThrottlerRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: string app_name = 2;
   */
  appName: string;

  /**
   * @generated from field: string scope = 3;
   */
  scope: string;

  /**
   * SkipRequestHeartbeats ensures this check does not renew heartbeat lease
   *
   * @generated from field: bool skip_request_heartbeats = 4;
   */
  skipRequestHeartbeats: boolean;

  /**
   * OKIfNotExists asks the throttler to return OK even if the metric does not exist
   *
   * @generated from field: bool ok_if_not_exists = 5;
   */
  okIfNotExists: boolean;
};

/**
 * @generated from message vtctldata.CheckThrottlerRequest
 */
export type CheckThrottlerRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: string app_name = 2;
   */
  appName?: string;

  /**
   * @generated from field: string scope = 3;
   */
  scope?: string;

  /**
   * SkipRequestHeartbeats ensures this check does not renew heartbeat lease
   *
   * @generated from field: bool skip_request_heartbeats = 4;
   */
  skipRequestHeartbeats?: boolean;

  /**
   * OKIfNotExists asks the throttler to return OK even if the metric does not exist
   *
   * @generated from field: bool ok_if_not_exists = 5;
   */
  okIfNotExists?: boolean;
};

/**
 * Describes the message vtctldata.CheckThrottlerRequest.
 * Use `create(CheckThrottlerRequestSchema)` to create a new message.
 */
export const CheckThrottlerRequestSchema: GenMessage<CheckThrottlerRequest, CheckThrottlerRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 32);

/**
 * @generated from message vtctldata.CheckThrottlerResponse
 */
export type CheckThrottlerResponse = Message<"vtctldata.CheckThrottlerResponse"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: tabletmanagerdata.CheckThrottlerResponse Check = 2;
   */
  Check?: CheckThrottlerResponse$1;
};

/**
 * @generated from message vtctldata.CheckThrottlerResponse
 */
export type CheckThrottlerResponseJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: tabletmanagerdata.CheckThrottlerResponse Check = 2;
   */
  Check?: CheckThrottlerResponseJson$1;
};

/**
 * Describes the message vtctldata.CheckThrottlerResponse.
 * Use `create(CheckThrottlerResponseSchema)` to create a new message.
 */
export const CheckThrottlerResponseSchema: GenMessage<CheckThrottlerResponse, CheckThrottlerResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 33);

/**
 * @generated from message vtctldata.CleanupSchemaMigrationRequest
 */
export type CleanupSchemaMigrationRequest = Message<"vtctldata.CleanupSchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.CleanupSchemaMigrationRequest
 */
export type CleanupSchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.CleanupSchemaMigrationRequest.
 * Use `create(CleanupSchemaMigrationRequestSchema)` to create a new message.
 */
export const CleanupSchemaMigrationRequestSchema: GenMessage<CleanupSchemaMigrationRequest, CleanupSchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 34);

/**
 * @generated from message vtctldata.CleanupSchemaMigrationResponse
 */
export type CleanupSchemaMigrationResponse = Message<"vtctldata.CleanupSchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.CleanupSchemaMigrationResponse
 */
export type CleanupSchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.CleanupSchemaMigrationResponse.
 * Use `create(CleanupSchemaMigrationResponseSchema)` to create a new message.
 */
export const CleanupSchemaMigrationResponseSchema: GenMessage<CleanupSchemaMigrationResponse, CleanupSchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 35);

/**
 * @generated from message vtctldata.CompleteSchemaMigrationRequest
 */
export type CompleteSchemaMigrationRequest = Message<"vtctldata.CompleteSchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.CompleteSchemaMigrationRequest
 */
export type CompleteSchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.CompleteSchemaMigrationRequest.
 * Use `create(CompleteSchemaMigrationRequestSchema)` to create a new message.
 */
export const CompleteSchemaMigrationRequestSchema: GenMessage<CompleteSchemaMigrationRequest, CompleteSchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 36);

/**
 * @generated from message vtctldata.CompleteSchemaMigrationResponse
 */
export type CompleteSchemaMigrationResponse = Message<"vtctldata.CompleteSchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.CompleteSchemaMigrationResponse
 */
export type CompleteSchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.CompleteSchemaMigrationResponse.
 * Use `create(CompleteSchemaMigrationResponseSchema)` to create a new message.
 */
export const CompleteSchemaMigrationResponseSchema: GenMessage<CompleteSchemaMigrationResponse, CompleteSchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 37);

/**
 * @generated from message vtctldata.CreateKeyspaceRequest
 */
export type CreateKeyspaceRequest = Message<"vtctldata.CreateKeyspaceRequest"> & {
  /**
   * Name is the name of the keyspace.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Force proceeds with the request even if the keyspace already exists.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;

  /**
   * AllowEmptyVSchema allows a keyspace to be created with no vschema.
   *
   * @generated from field: bool allow_empty_v_schema = 3;
   */
  allowEmptyVSchema: boolean;

  /**
   * Type is the type of the keyspace to create.
   *
   * @generated from field: topodata.KeyspaceType type = 7;
   */
  type: KeyspaceType;

  /**
   * BaseKeyspace specifies the base keyspace for SNAPSHOT keyspaces. It is
   * required to create a SNAPSHOT keyspace.
   *
   * @generated from field: string base_keyspace = 8;
   */
  baseKeyspace: string;

  /**
   * SnapshotTime specifies the snapshot time for this keyspace. It is required
   * to create a SNAPSHOT keyspace.
   *
   * @generated from field: vttime.Time snapshot_time = 9;
   */
  snapshotTime?: Time;

  /**
   * DurabilityPolicy is the durability policy to be
   * used for this keyspace.
   *
   * @generated from field: string durability_policy = 10;
   */
  durabilityPolicy: string;

  /**
   * SidecarDBName is the name of the sidecar database that
   * each vttablet in the keyspace will use.
   *
   * @generated from field: string sidecar_db_name = 11;
   */
  sidecarDbName: string;
};

/**
 * @generated from message vtctldata.CreateKeyspaceRequest
 */
export type CreateKeyspaceRequestJson = {
  /**
   * Name is the name of the keyspace.
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * Force proceeds with the request even if the keyspace already exists.
   *
   * @generated from field: bool force = 2;
   */
  force?: boolean;

  /**
   * AllowEmptyVSchema allows a keyspace to be created with no vschema.
   *
   * @generated from field: bool allow_empty_v_schema = 3;
   */
  allowEmptyVSchema?: boolean;

  /**
   * Type is the type of the keyspace to create.
   *
   * @generated from field: topodata.KeyspaceType type = 7;
   */
  type?: KeyspaceTypeJson;

  /**
   * BaseKeyspace specifies the base keyspace for SNAPSHOT keyspaces. It is
   * required to create a SNAPSHOT keyspace.
   *
   * @generated from field: string base_keyspace = 8;
   */
  baseKeyspace?: string;

  /**
   * SnapshotTime specifies the snapshot time for this keyspace. It is required
   * to create a SNAPSHOT keyspace.
   *
   * @generated from field: vttime.Time snapshot_time = 9;
   */
  snapshotTime?: TimeJson;

  /**
   * DurabilityPolicy is the durability policy to be
   * used for this keyspace.
   *
   * @generated from field: string durability_policy = 10;
   */
  durabilityPolicy?: string;

  /**
   * SidecarDBName is the name of the sidecar database that
   * each vttablet in the keyspace will use.
   *
   * @generated from field: string sidecar_db_name = 11;
   */
  sidecarDbName?: string;
};

/**
 * Describes the message vtctldata.CreateKeyspaceRequest.
 * Use `create(CreateKeyspaceRequestSchema)` to create a new message.
 */
export const CreateKeyspaceRequestSchema: GenMessage<CreateKeyspaceRequest, CreateKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 38);

/**
 * @generated from message vtctldata.CreateKeyspaceResponse
 */
export type CreateKeyspaceResponse = Message<"vtctldata.CreateKeyspaceResponse"> & {
  /**
   * Keyspace is the newly-created keyspace.
   *
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: Keyspace;
};

/**
 * @generated from message vtctldata.CreateKeyspaceResponse
 */
export type CreateKeyspaceResponseJson = {
  /**
   * Keyspace is the newly-created keyspace.
   *
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: KeyspaceJson;
};

/**
 * Describes the message vtctldata.CreateKeyspaceResponse.
 * Use `create(CreateKeyspaceResponseSchema)` to create a new message.
 */
export const CreateKeyspaceResponseSchema: GenMessage<CreateKeyspaceResponse, CreateKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 39);

/**
 * @generated from message vtctldata.CreateShardRequest
 */
export type CreateShardRequest = Message<"vtctldata.CreateShardRequest"> & {
  /**
   * Keyspace is the name of the keyspace to create the shard in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * ShardName is the name of the shard to create. E.g. "-" or "-80".
   *
   * @generated from field: string shard_name = 2;
   */
  shardName: string;

  /**
   * Force treats an attempt to create a shard that already exists as a
   * non-error.
   *
   * @generated from field: bool force = 3;
   */
  force: boolean;

  /**
   * IncludeParent creates the parent keyspace as an empty BASE keyspace, if it
   * doesn't already exist.
   *
   * @generated from field: bool include_parent = 4;
   */
  includeParent: boolean;
};

/**
 * @generated from message vtctldata.CreateShardRequest
 */
export type CreateShardRequestJson = {
  /**
   * Keyspace is the name of the keyspace to create the shard in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * ShardName is the name of the shard to create. E.g. "-" or "-80".
   *
   * @generated from field: string shard_name = 2;
   */
  shardName?: string;

  /**
   * Force treats an attempt to create a shard that already exists as a
   * non-error.
   *
   * @generated from field: bool force = 3;
   */
  force?: boolean;

  /**
   * IncludeParent creates the parent keyspace as an empty BASE keyspace, if it
   * doesn't already exist.
   *
   * @generated from field: bool include_parent = 4;
   */
  includeParent?: boolean;
};

/**
 * Describes the message vtctldata.CreateShardRequest.
 * Use `create(CreateShardRequestSchema)` to create a new message.
 */
export const CreateShardRequestSchema: GenMessage<CreateShardRequest, CreateShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 40);

/**
 * @generated from message vtctldata.CreateShardResponse
 */
export type CreateShardResponse = Message<"vtctldata.CreateShardResponse"> & {
  /**
   * Keyspace is the created keyspace. It is set only if IncludeParent was
   * specified in the request and the parent keyspace needed to be created.
   *
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: Keyspace;

  /**
   * Shard is the newly-created shard object.
   *
   * @generated from field: vtctldata.Shard shard = 2;
   */
  shard?: Shard;

  /**
   * ShardAlreadyExists is set if Force was specified in the request and the
   * shard already existed.
   *
   * @generated from field: bool shard_already_exists = 3;
   */
  shardAlreadyExists: boolean;
};

/**
 * @generated from message vtctldata.CreateShardResponse
 */
export type CreateShardResponseJson = {
  /**
   * Keyspace is the created keyspace. It is set only if IncludeParent was
   * specified in the request and the parent keyspace needed to be created.
   *
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: KeyspaceJson;

  /**
   * Shard is the newly-created shard object.
   *
   * @generated from field: vtctldata.Shard shard = 2;
   */
  shard?: ShardJson;

  /**
   * ShardAlreadyExists is set if Force was specified in the request and the
   * shard already existed.
   *
   * @generated from field: bool shard_already_exists = 3;
   */
  shardAlreadyExists?: boolean;
};

/**
 * Describes the message vtctldata.CreateShardResponse.
 * Use `create(CreateShardResponseSchema)` to create a new message.
 */
export const CreateShardResponseSchema: GenMessage<CreateShardResponse, CreateShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 41);

/**
 * @generated from message vtctldata.DeleteCellInfoRequest
 */
export type DeleteCellInfoRequest = Message<"vtctldata.DeleteCellInfoRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bool force = 2;
   */
  force: boolean;
};

/**
 * @generated from message vtctldata.DeleteCellInfoRequest
 */
export type DeleteCellInfoRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: bool force = 2;
   */
  force?: boolean;
};

/**
 * Describes the message vtctldata.DeleteCellInfoRequest.
 * Use `create(DeleteCellInfoRequestSchema)` to create a new message.
 */
export const DeleteCellInfoRequestSchema: GenMessage<DeleteCellInfoRequest, DeleteCellInfoRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 42);

/**
 * @generated from message vtctldata.DeleteCellInfoResponse
 */
export type DeleteCellInfoResponse = Message<"vtctldata.DeleteCellInfoResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteCellInfoResponse
 */
export type DeleteCellInfoResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteCellInfoResponse.
 * Use `create(DeleteCellInfoResponseSchema)` to create a new message.
 */
export const DeleteCellInfoResponseSchema: GenMessage<DeleteCellInfoResponse, DeleteCellInfoResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 43);

/**
 * @generated from message vtctldata.DeleteCellsAliasRequest
 */
export type DeleteCellsAliasRequest = Message<"vtctldata.DeleteCellsAliasRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * @generated from message vtctldata.DeleteCellsAliasRequest
 */
export type DeleteCellsAliasRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.DeleteCellsAliasRequest.
 * Use `create(DeleteCellsAliasRequestSchema)` to create a new message.
 */
export const DeleteCellsAliasRequestSchema: GenMessage<DeleteCellsAliasRequest, DeleteCellsAliasRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 44);

/**
 * @generated from message vtctldata.DeleteCellsAliasResponse
 */
export type DeleteCellsAliasResponse = Message<"vtctldata.DeleteCellsAliasResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteCellsAliasResponse
 */
export type DeleteCellsAliasResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteCellsAliasResponse.
 * Use `create(DeleteCellsAliasResponseSchema)` to create a new message.
 */
export const DeleteCellsAliasResponseSchema: GenMessage<DeleteCellsAliasResponse, DeleteCellsAliasResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 45);

/**
 * @generated from message vtctldata.DeleteKeyspaceRequest
 */
export type DeleteKeyspaceRequest = Message<"vtctldata.DeleteKeyspaceRequest"> & {
  /**
   * Keyspace is the name of the keyspace to delete.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Recursive causes all shards in the keyspace to be recursively deleted
   * before deleting the keyspace. It is an error to call DeleteKeyspace on a
   * non-empty keyspace without also specifying Recursive.
   *
   * @generated from field: bool recursive = 2;
   */
  recursive: boolean;

  /**
   * Force allows a keyspace to be deleted even if the keyspace lock cannot be
   * obtained. This should only be used to force-clean a keyspace.
   *
   * @generated from field: bool force = 3;
   */
  force: boolean;
};

/**
 * @generated from message vtctldata.DeleteKeyspaceRequest
 */
export type DeleteKeyspaceRequestJson = {
  /**
   * Keyspace is the name of the keyspace to delete.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Recursive causes all shards in the keyspace to be recursively deleted
   * before deleting the keyspace. It is an error to call DeleteKeyspace on a
   * non-empty keyspace without also specifying Recursive.
   *
   * @generated from field: bool recursive = 2;
   */
  recursive?: boolean;

  /**
   * Force allows a keyspace to be deleted even if the keyspace lock cannot be
   * obtained. This should only be used to force-clean a keyspace.
   *
   * @generated from field: bool force = 3;
   */
  force?: boolean;
};

/**
 * Describes the message vtctldata.DeleteKeyspaceRequest.
 * Use `create(DeleteKeyspaceRequestSchema)` to create a new message.
 */
export const DeleteKeyspaceRequestSchema: GenMessage<DeleteKeyspaceRequest, DeleteKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 46);

/**
 * @generated from message vtctldata.DeleteKeyspaceResponse
 */
export type DeleteKeyspaceResponse = Message<"vtctldata.DeleteKeyspaceResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteKeyspaceResponse
 */
export type DeleteKeyspaceResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteKeyspaceResponse.
 * Use `create(DeleteKeyspaceResponseSchema)` to create a new message.
 */
export const DeleteKeyspaceResponseSchema: GenMessage<DeleteKeyspaceResponse, DeleteKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 47);

/**
 * @generated from message vtctldata.DeleteShardsRequest
 */
export type DeleteShardsRequest = Message<"vtctldata.DeleteShardsRequest"> & {
  /**
   * Shards is the list of shards to delete. The nested topodatapb.Shard field
   * is not required for DeleteShard, but the Keyspace and Shard fields are.
   *
   * @generated from field: repeated vtctldata.Shard shards = 1;
   */
  shards: Shard[];

  /**
   * Recursive also deletes all tablets belonging to the shard(s). It is an
   * error to call DeleteShard on a non-empty shard without also specificying
   * Recursive.
   *
   * @generated from field: bool recursive = 2;
   */
  recursive: boolean;

  /**
   * EvenIfServing allows a shard to be deleted even if it is serving, which is
   * normally an error. Use with caution.
   *
   * @generated from field: bool even_if_serving = 4;
   */
  evenIfServing: boolean;

  /**
   * Force allows a shard to be deleted even if the shard lock cannot be
   * obtained. This should only be used to force-clean a shard.
   *
   * @generated from field: bool force = 5;
   */
  force: boolean;
};

/**
 * @generated from message vtctldata.DeleteShardsRequest
 */
export type DeleteShardsRequestJson = {
  /**
   * Shards is the list of shards to delete. The nested topodatapb.Shard field
   * is not required for DeleteShard, but the Keyspace and Shard fields are.
   *
   * @generated from field: repeated vtctldata.Shard shards = 1;
   */
  shards?: ShardJson[];

  /**
   * Recursive also deletes all tablets belonging to the shard(s). It is an
   * error to call DeleteShard on a non-empty shard without also specificying
   * Recursive.
   *
   * @generated from field: bool recursive = 2;
   */
  recursive?: boolean;

  /**
   * EvenIfServing allows a shard to be deleted even if it is serving, which is
   * normally an error. Use with caution.
   *
   * @generated from field: bool even_if_serving = 4;
   */
  evenIfServing?: boolean;

  /**
   * Force allows a shard to be deleted even if the shard lock cannot be
   * obtained. This should only be used to force-clean a shard.
   *
   * @generated from field: bool force = 5;
   */
  force?: boolean;
};

/**
 * Describes the message vtctldata.DeleteShardsRequest.
 * Use `create(DeleteShardsRequestSchema)` to create a new message.
 */
export const DeleteShardsRequestSchema: GenMessage<DeleteShardsRequest, DeleteShardsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 48);

/**
 * @generated from message vtctldata.DeleteShardsResponse
 */
export type DeleteShardsResponse = Message<"vtctldata.DeleteShardsResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteShardsResponse
 */
export type DeleteShardsResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteShardsResponse.
 * Use `create(DeleteShardsResponseSchema)` to create a new message.
 */
export const DeleteShardsResponseSchema: GenMessage<DeleteShardsResponse, DeleteShardsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 49);

/**
 * @generated from message vtctldata.DeleteSrvVSchemaRequest
 */
export type DeleteSrvVSchemaRequest = Message<"vtctldata.DeleteSrvVSchemaRequest"> & {
  /**
   * @generated from field: string cell = 1;
   */
  cell: string;
};

/**
 * @generated from message vtctldata.DeleteSrvVSchemaRequest
 */
export type DeleteSrvVSchemaRequestJson = {
  /**
   * @generated from field: string cell = 1;
   */
  cell?: string;
};

/**
 * Describes the message vtctldata.DeleteSrvVSchemaRequest.
 * Use `create(DeleteSrvVSchemaRequestSchema)` to create a new message.
 */
export const DeleteSrvVSchemaRequestSchema: GenMessage<DeleteSrvVSchemaRequest, DeleteSrvVSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 50);

/**
 * @generated from message vtctldata.DeleteSrvVSchemaResponse
 */
export type DeleteSrvVSchemaResponse = Message<"vtctldata.DeleteSrvVSchemaResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteSrvVSchemaResponse
 */
export type DeleteSrvVSchemaResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteSrvVSchemaResponse.
 * Use `create(DeleteSrvVSchemaResponseSchema)` to create a new message.
 */
export const DeleteSrvVSchemaResponseSchema: GenMessage<DeleteSrvVSchemaResponse, DeleteSrvVSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 51);

/**
 * @generated from message vtctldata.DeleteTabletsRequest
 */
export type DeleteTabletsRequest = Message<"vtctldata.DeleteTabletsRequest"> & {
  /**
   * TabletAliases is the list of tablets to delete.
   *
   * @generated from field: repeated topodata.TabletAlias tablet_aliases = 1;
   */
  tabletAliases: TabletAlias[];

  /**
   * AllowPrimary allows for the primary tablet of a shard to be deleted.
   * Use with caution.
   *
   * @generated from field: bool allow_primary = 2;
   */
  allowPrimary: boolean;
};

/**
 * @generated from message vtctldata.DeleteTabletsRequest
 */
export type DeleteTabletsRequestJson = {
  /**
   * TabletAliases is the list of tablets to delete.
   *
   * @generated from field: repeated topodata.TabletAlias tablet_aliases = 1;
   */
  tabletAliases?: TabletAliasJson[];

  /**
   * AllowPrimary allows for the primary tablet of a shard to be deleted.
   * Use with caution.
   *
   * @generated from field: bool allow_primary = 2;
   */
  allowPrimary?: boolean;
};

/**
 * Describes the message vtctldata.DeleteTabletsRequest.
 * Use `create(DeleteTabletsRequestSchema)` to create a new message.
 */
export const DeleteTabletsRequestSchema: GenMessage<DeleteTabletsRequest, DeleteTabletsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 52);

/**
 * @generated from message vtctldata.DeleteTabletsResponse
 */
export type DeleteTabletsResponse = Message<"vtctldata.DeleteTabletsResponse"> & {
};

/**
 * @generated from message vtctldata.DeleteTabletsResponse
 */
export type DeleteTabletsResponseJson = {
};

/**
 * Describes the message vtctldata.DeleteTabletsResponse.
 * Use `create(DeleteTabletsResponseSchema)` to create a new message.
 */
export const DeleteTabletsResponseSchema: GenMessage<DeleteTabletsResponse, DeleteTabletsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 53);

/**
 * @generated from message vtctldata.EmergencyReparentShardRequest
 */
export type EmergencyReparentShardRequest = Message<"vtctldata.EmergencyReparentShardRequest"> & {
  /**
   * Keyspace is the name of the keyspace to perform the Emergency Reparent in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard to perform the Emergency Reparent in.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * Optional alias of a tablet that should become the new shard primary. If not
   * not specified, the vtctld will select the most up-to-date canditate to
   * promote.
   *
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAlias;

  /**
   * List of replica aliases to ignore during the Emergency Reparent. The vtctld
   * will not attempt to stop replication on these tablets, nor attempt to
   * demote any that may think they are the shard primary.
   *
   * @generated from field: repeated topodata.TabletAlias ignore_replicas = 4;
   */
  ignoreReplicas: TabletAlias[];

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in reparenting.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: Duration;

  /**
   * PreventCrossCellPromotion is used to only promote the new primary from the same cell
   * as the failed primary.
   *
   * @generated from field: bool prevent_cross_cell_promotion = 6;
   */
  preventCrossCellPromotion: boolean;

  /**
   * WaitForAllTablets makes ERS wait for a response from all the tablets before proceeding.
   * Useful when all the tablets are up and reachable.
   *
   * @generated from field: bool wait_for_all_tablets = 7;
   */
  waitForAllTablets: boolean;

  /**
   * ExpectedPrimary is the optional alias we expect to be the current primary in order for
   * the reparent operation to succeed.
   *
   * @generated from field: topodata.TabletAlias expected_primary = 8;
   */
  expectedPrimary?: TabletAlias;
};

/**
 * @generated from message vtctldata.EmergencyReparentShardRequest
 */
export type EmergencyReparentShardRequestJson = {
  /**
   * Keyspace is the name of the keyspace to perform the Emergency Reparent in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard to perform the Emergency Reparent in.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * Optional alias of a tablet that should become the new shard primary. If not
   * not specified, the vtctld will select the most up-to-date canditate to
   * promote.
   *
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAliasJson;

  /**
   * List of replica aliases to ignore during the Emergency Reparent. The vtctld
   * will not attempt to stop replication on these tablets, nor attempt to
   * demote any that may think they are the shard primary.
   *
   * @generated from field: repeated topodata.TabletAlias ignore_replicas = 4;
   */
  ignoreReplicas?: TabletAliasJson[];

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in reparenting.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: DurationJson;

  /**
   * PreventCrossCellPromotion is used to only promote the new primary from the same cell
   * as the failed primary.
   *
   * @generated from field: bool prevent_cross_cell_promotion = 6;
   */
  preventCrossCellPromotion?: boolean;

  /**
   * WaitForAllTablets makes ERS wait for a response from all the tablets before proceeding.
   * Useful when all the tablets are up and reachable.
   *
   * @generated from field: bool wait_for_all_tablets = 7;
   */
  waitForAllTablets?: boolean;

  /**
   * ExpectedPrimary is the optional alias we expect to be the current primary in order for
   * the reparent operation to succeed.
   *
   * @generated from field: topodata.TabletAlias expected_primary = 8;
   */
  expectedPrimary?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.EmergencyReparentShardRequest.
 * Use `create(EmergencyReparentShardRequestSchema)` to create a new message.
 */
export const EmergencyReparentShardRequestSchema: GenMessage<EmergencyReparentShardRequest, EmergencyReparentShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 54);

/**
 * @generated from message vtctldata.EmergencyReparentShardResponse
 */
export type EmergencyReparentShardResponse = Message<"vtctldata.EmergencyReparentShardResponse"> & {
  /**
   * Keyspace is the name of the keyspace the Emergency Reparent took place in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard the Emergency Reparent took place in.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * PromotedPrimary is the alias of the tablet that was promoted to shard
   * primary. If NewPrimary was set in the request, then this will be the same
   * alias. Otherwise, it will be the alias of the tablet found to be most
   * up-to-date.
   *
   * @generated from field: topodata.TabletAlias promoted_primary = 3;
   */
  promotedPrimary?: TabletAlias;

  /**
   * @generated from field: repeated logutil.Event events = 4;
   */
  events: Event[];
};

/**
 * @generated from message vtctldata.EmergencyReparentShardResponse
 */
export type EmergencyReparentShardResponseJson = {
  /**
   * Keyspace is the name of the keyspace the Emergency Reparent took place in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard the Emergency Reparent took place in.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * PromotedPrimary is the alias of the tablet that was promoted to shard
   * primary. If NewPrimary was set in the request, then this will be the same
   * alias. Otherwise, it will be the alias of the tablet found to be most
   * up-to-date.
   *
   * @generated from field: topodata.TabletAlias promoted_primary = 3;
   */
  promotedPrimary?: TabletAliasJson;

  /**
   * @generated from field: repeated logutil.Event events = 4;
   */
  events?: EventJson[];
};

/**
 * Describes the message vtctldata.EmergencyReparentShardResponse.
 * Use `create(EmergencyReparentShardResponseSchema)` to create a new message.
 */
export const EmergencyReparentShardResponseSchema: GenMessage<EmergencyReparentShardResponse, EmergencyReparentShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 55);

/**
 * @generated from message vtctldata.ExecuteFetchAsAppRequest
 */
export type ExecuteFetchAsAppRequest = Message<"vtctldata.ExecuteFetchAsAppRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: string query = 2;
   */
  query: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to the query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows: bigint;

  /**
   * UsePool causes the query to be run with a pooled connection to the tablet.
   *
   * @generated from field: bool use_pool = 4;
   */
  usePool: boolean;
};

/**
 * @generated from message vtctldata.ExecuteFetchAsAppRequest
 */
export type ExecuteFetchAsAppRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: string query = 2;
   */
  query?: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to the query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows?: string;

  /**
   * UsePool causes the query to be run with a pooled connection to the tablet.
   *
   * @generated from field: bool use_pool = 4;
   */
  usePool?: boolean;
};

/**
 * Describes the message vtctldata.ExecuteFetchAsAppRequest.
 * Use `create(ExecuteFetchAsAppRequestSchema)` to create a new message.
 */
export const ExecuteFetchAsAppRequestSchema: GenMessage<ExecuteFetchAsAppRequest, ExecuteFetchAsAppRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 56);

/**
 * @generated from message vtctldata.ExecuteFetchAsAppResponse
 */
export type ExecuteFetchAsAppResponse = Message<"vtctldata.ExecuteFetchAsAppResponse"> & {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * @generated from message vtctldata.ExecuteFetchAsAppResponse
 */
export type ExecuteFetchAsAppResponseJson = {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message vtctldata.ExecuteFetchAsAppResponse.
 * Use `create(ExecuteFetchAsAppResponseSchema)` to create a new message.
 */
export const ExecuteFetchAsAppResponseSchema: GenMessage<ExecuteFetchAsAppResponse, ExecuteFetchAsAppResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 57);

/**
 * @generated from message vtctldata.ExecuteFetchAsDBARequest
 */
export type ExecuteFetchAsDBARequest = Message<"vtctldata.ExecuteFetchAsDBARequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: string query = 2;
   */
  query: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to the query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows: bigint;

  /**
   * DisableBinlogs instructs the tablet not to use binary logging when
   * executing the query.
   *
   * @generated from field: bool disable_binlogs = 4;
   */
  disableBinlogs: boolean;

  /**
   * ReloadSchema instructs the tablet to reload its schema after executing the
   * query.
   *
   * @generated from field: bool reload_schema = 5;
   */
  reloadSchema: boolean;
};

/**
 * @generated from message vtctldata.ExecuteFetchAsDBARequest
 */
export type ExecuteFetchAsDBARequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: string query = 2;
   */
  query?: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to the query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows?: string;

  /**
   * DisableBinlogs instructs the tablet not to use binary logging when
   * executing the query.
   *
   * @generated from field: bool disable_binlogs = 4;
   */
  disableBinlogs?: boolean;

  /**
   * ReloadSchema instructs the tablet to reload its schema after executing the
   * query.
   *
   * @generated from field: bool reload_schema = 5;
   */
  reloadSchema?: boolean;
};

/**
 * Describes the message vtctldata.ExecuteFetchAsDBARequest.
 * Use `create(ExecuteFetchAsDBARequestSchema)` to create a new message.
 */
export const ExecuteFetchAsDBARequestSchema: GenMessage<ExecuteFetchAsDBARequest, ExecuteFetchAsDBARequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 58);

/**
 * @generated from message vtctldata.ExecuteFetchAsDBAResponse
 */
export type ExecuteFetchAsDBAResponse = Message<"vtctldata.ExecuteFetchAsDBAResponse"> & {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * @generated from message vtctldata.ExecuteFetchAsDBAResponse
 */
export type ExecuteFetchAsDBAResponseJson = {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message vtctldata.ExecuteFetchAsDBAResponse.
 * Use `create(ExecuteFetchAsDBAResponseSchema)` to create a new message.
 */
export const ExecuteFetchAsDBAResponseSchema: GenMessage<ExecuteFetchAsDBAResponse, ExecuteFetchAsDBAResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 59);

/**
 * @generated from message vtctldata.ExecuteHookRequest
 */
export type ExecuteHookRequest = Message<"vtctldata.ExecuteHookRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: tabletmanagerdata.ExecuteHookRequest tablet_hook_request = 2;
   */
  tabletHookRequest?: ExecuteHookRequest$1;
};

/**
 * @generated from message vtctldata.ExecuteHookRequest
 */
export type ExecuteHookRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: tabletmanagerdata.ExecuteHookRequest tablet_hook_request = 2;
   */
  tabletHookRequest?: ExecuteHookRequestJson$1;
};

/**
 * Describes the message vtctldata.ExecuteHookRequest.
 * Use `create(ExecuteHookRequestSchema)` to create a new message.
 */
export const ExecuteHookRequestSchema: GenMessage<ExecuteHookRequest, ExecuteHookRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 60);

/**
 * @generated from message vtctldata.ExecuteHookResponse
 */
export type ExecuteHookResponse = Message<"vtctldata.ExecuteHookResponse"> & {
  /**
   * @generated from field: tabletmanagerdata.ExecuteHookResponse hook_result = 1;
   */
  hookResult?: ExecuteHookResponse$1;
};

/**
 * @generated from message vtctldata.ExecuteHookResponse
 */
export type ExecuteHookResponseJson = {
  /**
   * @generated from field: tabletmanagerdata.ExecuteHookResponse hook_result = 1;
   */
  hookResult?: ExecuteHookResponseJson$1;
};

/**
 * Describes the message vtctldata.ExecuteHookResponse.
 * Use `create(ExecuteHookResponseSchema)` to create a new message.
 */
export const ExecuteHookResponseSchema: GenMessage<ExecuteHookResponse, ExecuteHookResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 61);

/**
 * @generated from message vtctldata.ExecuteMultiFetchAsDBARequest
 */
export type ExecuteMultiFetchAsDBARequest = Message<"vtctldata.ExecuteMultiFetchAsDBARequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * SQL could have potentially multiple queries separated by semicolons.
   *
   * @generated from field: string sql = 2;
   */
  sql: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to a query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows: bigint;

  /**
   * DisableBinlogs instructs the tablet not to use binary logging when
   * executing the query.
   *
   * @generated from field: bool disable_binlogs = 4;
   */
  disableBinlogs: boolean;

  /**
   * ReloadSchema instructs the tablet to reload its schema after executing the
   * query.
   *
   * @generated from field: bool reload_schema = 5;
   */
  reloadSchema: boolean;
};

/**
 * @generated from message vtctldata.ExecuteMultiFetchAsDBARequest
 */
export type ExecuteMultiFetchAsDBARequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * SQL could have potentially multiple queries separated by semicolons.
   *
   * @generated from field: string sql = 2;
   */
  sql?: string;

  /**
   * MaxRows is an optional parameter to limit the number of rows read into the
   * QueryResult. Note that this does not apply a LIMIT to a query, just how
   * many rows are read from the MySQL server on the tablet side.
   *
   * This field is optional. Specifying a non-positive value will use whatever
   * default is configured in the VtctldService.
   *
   * @generated from field: int64 max_rows = 3;
   */
  maxRows?: string;

  /**
   * DisableBinlogs instructs the tablet not to use binary logging when
   * executing the query.
   *
   * @generated from field: bool disable_binlogs = 4;
   */
  disableBinlogs?: boolean;

  /**
   * ReloadSchema instructs the tablet to reload its schema after executing the
   * query.
   *
   * @generated from field: bool reload_schema = 5;
   */
  reloadSchema?: boolean;
};

/**
 * Describes the message vtctldata.ExecuteMultiFetchAsDBARequest.
 * Use `create(ExecuteMultiFetchAsDBARequestSchema)` to create a new message.
 */
export const ExecuteMultiFetchAsDBARequestSchema: GenMessage<ExecuteMultiFetchAsDBARequest, ExecuteMultiFetchAsDBARequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 62);

/**
 * @generated from message vtctldata.ExecuteMultiFetchAsDBAResponse
 */
export type ExecuteMultiFetchAsDBAResponse = Message<"vtctldata.ExecuteMultiFetchAsDBAResponse"> & {
  /**
   * @generated from field: repeated query.QueryResult results = 1;
   */
  results: QueryResult[];
};

/**
 * @generated from message vtctldata.ExecuteMultiFetchAsDBAResponse
 */
export type ExecuteMultiFetchAsDBAResponseJson = {
  /**
   * @generated from field: repeated query.QueryResult results = 1;
   */
  results?: QueryResultJson[];
};

/**
 * Describes the message vtctldata.ExecuteMultiFetchAsDBAResponse.
 * Use `create(ExecuteMultiFetchAsDBAResponseSchema)` to create a new message.
 */
export const ExecuteMultiFetchAsDBAResponseSchema: GenMessage<ExecuteMultiFetchAsDBAResponse, ExecuteMultiFetchAsDBAResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 63);

/**
 * @generated from message vtctldata.FindAllShardsInKeyspaceRequest
 */
export type FindAllShardsInKeyspaceRequest = Message<"vtctldata.FindAllShardsInKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;
};

/**
 * @generated from message vtctldata.FindAllShardsInKeyspaceRequest
 */
export type FindAllShardsInKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;
};

/**
 * Describes the message vtctldata.FindAllShardsInKeyspaceRequest.
 * Use `create(FindAllShardsInKeyspaceRequestSchema)` to create a new message.
 */
export const FindAllShardsInKeyspaceRequestSchema: GenMessage<FindAllShardsInKeyspaceRequest, FindAllShardsInKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 64);

/**
 * @generated from message vtctldata.FindAllShardsInKeyspaceResponse
 */
export type FindAllShardsInKeyspaceResponse = Message<"vtctldata.FindAllShardsInKeyspaceResponse"> & {
  /**
   * @generated from field: map<string, vtctldata.Shard> shards = 1;
   */
  shards: { [key: string]: Shard };
};

/**
 * @generated from message vtctldata.FindAllShardsInKeyspaceResponse
 */
export type FindAllShardsInKeyspaceResponseJson = {
  /**
   * @generated from field: map<string, vtctldata.Shard> shards = 1;
   */
  shards?: { [key: string]: ShardJson };
};

/**
 * Describes the message vtctldata.FindAllShardsInKeyspaceResponse.
 * Use `create(FindAllShardsInKeyspaceResponseSchema)` to create a new message.
 */
export const FindAllShardsInKeyspaceResponseSchema: GenMessage<FindAllShardsInKeyspaceResponse, FindAllShardsInKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 65);

/**
 * @generated from message vtctldata.ForceCutOverSchemaMigrationRequest
 */
export type ForceCutOverSchemaMigrationRequest = Message<"vtctldata.ForceCutOverSchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.ForceCutOverSchemaMigrationRequest
 */
export type ForceCutOverSchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.ForceCutOverSchemaMigrationRequest.
 * Use `create(ForceCutOverSchemaMigrationRequestSchema)` to create a new message.
 */
export const ForceCutOverSchemaMigrationRequestSchema: GenMessage<ForceCutOverSchemaMigrationRequest, ForceCutOverSchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 66);

/**
 * @generated from message vtctldata.ForceCutOverSchemaMigrationResponse
 */
export type ForceCutOverSchemaMigrationResponse = Message<"vtctldata.ForceCutOverSchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.ForceCutOverSchemaMigrationResponse
 */
export type ForceCutOverSchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.ForceCutOverSchemaMigrationResponse.
 * Use `create(ForceCutOverSchemaMigrationResponseSchema)` to create a new message.
 */
export const ForceCutOverSchemaMigrationResponseSchema: GenMessage<ForceCutOverSchemaMigrationResponse, ForceCutOverSchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 67);

/**
 * @generated from message vtctldata.GetBackupsRequest
 */
export type GetBackupsRequest = Message<"vtctldata.GetBackupsRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * Limit, if nonzero, will return only the most N recent backups.
   *
   * @generated from field: uint32 limit = 3;
   */
  limit: number;

  /**
   * Detailed indicates whether to use the backupengine, if supported, to
   * populate additional fields, such as Engine and Status, on BackupInfo
   * objects in the response. If not set, or if the backupengine does not
   * support populating these fields, Engine will always be empty, and Status
   * will always be UNKNOWN.
   *
   * @generated from field: bool detailed = 4;
   */
  detailed: boolean;

  /**
   * DetailedLimit, if nonzero, will only populate additional fields (see Detailed)
   * on the N most recent backups. The Limit field still dictates the total
   * number of backup info objects returned, so, in reality, min(Limit, DetailedLimit)
   * backup infos will have additional fields set, and any remaining backups
   * will not.
   *
   * @generated from field: uint32 detailed_limit = 5;
   */
  detailedLimit: number;
};

/**
 * @generated from message vtctldata.GetBackupsRequest
 */
export type GetBackupsRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * Limit, if nonzero, will return only the most N recent backups.
   *
   * @generated from field: uint32 limit = 3;
   */
  limit?: number;

  /**
   * Detailed indicates whether to use the backupengine, if supported, to
   * populate additional fields, such as Engine and Status, on BackupInfo
   * objects in the response. If not set, or if the backupengine does not
   * support populating these fields, Engine will always be empty, and Status
   * will always be UNKNOWN.
   *
   * @generated from field: bool detailed = 4;
   */
  detailed?: boolean;

  /**
   * DetailedLimit, if nonzero, will only populate additional fields (see Detailed)
   * on the N most recent backups. The Limit field still dictates the total
   * number of backup info objects returned, so, in reality, min(Limit, DetailedLimit)
   * backup infos will have additional fields set, and any remaining backups
   * will not.
   *
   * @generated from field: uint32 detailed_limit = 5;
   */
  detailedLimit?: number;
};

/**
 * Describes the message vtctldata.GetBackupsRequest.
 * Use `create(GetBackupsRequestSchema)` to create a new message.
 */
export const GetBackupsRequestSchema: GenMessage<GetBackupsRequest, GetBackupsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 68);

/**
 * @generated from message vtctldata.GetBackupsResponse
 */
export type GetBackupsResponse = Message<"vtctldata.GetBackupsResponse"> & {
  /**
   * @generated from field: repeated mysqlctl.BackupInfo backups = 1;
   */
  backups: BackupInfo[];
};

/**
 * @generated from message vtctldata.GetBackupsResponse
 */
export type GetBackupsResponseJson = {
  /**
   * @generated from field: repeated mysqlctl.BackupInfo backups = 1;
   */
  backups?: BackupInfoJson[];
};

/**
 * Describes the message vtctldata.GetBackupsResponse.
 * Use `create(GetBackupsResponseSchema)` to create a new message.
 */
export const GetBackupsResponseSchema: GenMessage<GetBackupsResponse, GetBackupsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 69);

/**
 * @generated from message vtctldata.GetCellInfoRequest
 */
export type GetCellInfoRequest = Message<"vtctldata.GetCellInfoRequest"> & {
  /**
   * @generated from field: string cell = 1;
   */
  cell: string;
};

/**
 * @generated from message vtctldata.GetCellInfoRequest
 */
export type GetCellInfoRequestJson = {
  /**
   * @generated from field: string cell = 1;
   */
  cell?: string;
};

/**
 * Describes the message vtctldata.GetCellInfoRequest.
 * Use `create(GetCellInfoRequestSchema)` to create a new message.
 */
export const GetCellInfoRequestSchema: GenMessage<GetCellInfoRequest, GetCellInfoRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 70);

/**
 * @generated from message vtctldata.GetCellInfoResponse
 */
export type GetCellInfoResponse = Message<"vtctldata.GetCellInfoResponse"> & {
  /**
   * @generated from field: topodata.CellInfo cell_info = 1;
   */
  cellInfo?: CellInfo;
};

/**
 * @generated from message vtctldata.GetCellInfoResponse
 */
export type GetCellInfoResponseJson = {
  /**
   * @generated from field: topodata.CellInfo cell_info = 1;
   */
  cellInfo?: CellInfoJson;
};

/**
 * Describes the message vtctldata.GetCellInfoResponse.
 * Use `create(GetCellInfoResponseSchema)` to create a new message.
 */
export const GetCellInfoResponseSchema: GenMessage<GetCellInfoResponse, GetCellInfoResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 71);

/**
 * @generated from message vtctldata.GetCellInfoNamesRequest
 */
export type GetCellInfoNamesRequest = Message<"vtctldata.GetCellInfoNamesRequest"> & {
};

/**
 * @generated from message vtctldata.GetCellInfoNamesRequest
 */
export type GetCellInfoNamesRequestJson = {
};

/**
 * Describes the message vtctldata.GetCellInfoNamesRequest.
 * Use `create(GetCellInfoNamesRequestSchema)` to create a new message.
 */
export const GetCellInfoNamesRequestSchema: GenMessage<GetCellInfoNamesRequest, GetCellInfoNamesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 72);

/**
 * @generated from message vtctldata.GetCellInfoNamesResponse
 */
export type GetCellInfoNamesResponse = Message<"vtctldata.GetCellInfoNamesResponse"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * @generated from message vtctldata.GetCellInfoNamesResponse
 */
export type GetCellInfoNamesResponseJson = {
  /**
   * @generated from field: repeated string names = 1;
   */
  names?: string[];
};

/**
 * Describes the message vtctldata.GetCellInfoNamesResponse.
 * Use `create(GetCellInfoNamesResponseSchema)` to create a new message.
 */
export const GetCellInfoNamesResponseSchema: GenMessage<GetCellInfoNamesResponse, GetCellInfoNamesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 73);

/**
 * @generated from message vtctldata.GetCellsAliasesRequest
 */
export type GetCellsAliasesRequest = Message<"vtctldata.GetCellsAliasesRequest"> & {
};

/**
 * @generated from message vtctldata.GetCellsAliasesRequest
 */
export type GetCellsAliasesRequestJson = {
};

/**
 * Describes the message vtctldata.GetCellsAliasesRequest.
 * Use `create(GetCellsAliasesRequestSchema)` to create a new message.
 */
export const GetCellsAliasesRequestSchema: GenMessage<GetCellsAliasesRequest, GetCellsAliasesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 74);

/**
 * @generated from message vtctldata.GetCellsAliasesResponse
 */
export type GetCellsAliasesResponse = Message<"vtctldata.GetCellsAliasesResponse"> & {
  /**
   * @generated from field: map<string, topodata.CellsAlias> aliases = 1;
   */
  aliases: { [key: string]: CellsAlias };
};

/**
 * @generated from message vtctldata.GetCellsAliasesResponse
 */
export type GetCellsAliasesResponseJson = {
  /**
   * @generated from field: map<string, topodata.CellsAlias> aliases = 1;
   */
  aliases?: { [key: string]: CellsAliasJson };
};

/**
 * Describes the message vtctldata.GetCellsAliasesResponse.
 * Use `create(GetCellsAliasesResponseSchema)` to create a new message.
 */
export const GetCellsAliasesResponseSchema: GenMessage<GetCellsAliasesResponse, GetCellsAliasesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 75);

/**
 * @generated from message vtctldata.GetFullStatusRequest
 */
export type GetFullStatusRequest = Message<"vtctldata.GetFullStatusRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.GetFullStatusRequest
 */
export type GetFullStatusRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.GetFullStatusRequest.
 * Use `create(GetFullStatusRequestSchema)` to create a new message.
 */
export const GetFullStatusRequestSchema: GenMessage<GetFullStatusRequest, GetFullStatusRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 76);

/**
 * @generated from message vtctldata.GetFullStatusResponse
 */
export type GetFullStatusResponse = Message<"vtctldata.GetFullStatusResponse"> & {
  /**
   * @generated from field: replicationdata.FullStatus status = 1;
   */
  status?: FullStatus;
};

/**
 * @generated from message vtctldata.GetFullStatusResponse
 */
export type GetFullStatusResponseJson = {
  /**
   * @generated from field: replicationdata.FullStatus status = 1;
   */
  status?: FullStatusJson;
};

/**
 * Describes the message vtctldata.GetFullStatusResponse.
 * Use `create(GetFullStatusResponseSchema)` to create a new message.
 */
export const GetFullStatusResponseSchema: GenMessage<GetFullStatusResponse, GetFullStatusResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 77);

/**
 * @generated from message vtctldata.GetKeyspacesRequest
 */
export type GetKeyspacesRequest = Message<"vtctldata.GetKeyspacesRequest"> & {
};

/**
 * @generated from message vtctldata.GetKeyspacesRequest
 */
export type GetKeyspacesRequestJson = {
};

/**
 * Describes the message vtctldata.GetKeyspacesRequest.
 * Use `create(GetKeyspacesRequestSchema)` to create a new message.
 */
export const GetKeyspacesRequestSchema: GenMessage<GetKeyspacesRequest, GetKeyspacesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 78);

/**
 * @generated from message vtctldata.GetKeyspacesResponse
 */
export type GetKeyspacesResponse = Message<"vtctldata.GetKeyspacesResponse"> & {
  /**
   * @generated from field: repeated vtctldata.Keyspace keyspaces = 1;
   */
  keyspaces: Keyspace[];
};

/**
 * @generated from message vtctldata.GetKeyspacesResponse
 */
export type GetKeyspacesResponseJson = {
  /**
   * @generated from field: repeated vtctldata.Keyspace keyspaces = 1;
   */
  keyspaces?: KeyspaceJson[];
};

/**
 * Describes the message vtctldata.GetKeyspacesResponse.
 * Use `create(GetKeyspacesResponseSchema)` to create a new message.
 */
export const GetKeyspacesResponseSchema: GenMessage<GetKeyspacesResponse, GetKeyspacesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 79);

/**
 * @generated from message vtctldata.GetKeyspaceRequest
 */
export type GetKeyspaceRequest = Message<"vtctldata.GetKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;
};

/**
 * @generated from message vtctldata.GetKeyspaceRequest
 */
export type GetKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;
};

/**
 * Describes the message vtctldata.GetKeyspaceRequest.
 * Use `create(GetKeyspaceRequestSchema)` to create a new message.
 */
export const GetKeyspaceRequestSchema: GenMessage<GetKeyspaceRequest, GetKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 80);

/**
 * @generated from message vtctldata.GetKeyspaceResponse
 */
export type GetKeyspaceResponse = Message<"vtctldata.GetKeyspaceResponse"> & {
  /**
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: Keyspace;
};

/**
 * @generated from message vtctldata.GetKeyspaceResponse
 */
export type GetKeyspaceResponseJson = {
  /**
   * @generated from field: vtctldata.Keyspace keyspace = 1;
   */
  keyspace?: KeyspaceJson;
};

/**
 * Describes the message vtctldata.GetKeyspaceResponse.
 * Use `create(GetKeyspaceResponseSchema)` to create a new message.
 */
export const GetKeyspaceResponseSchema: GenMessage<GetKeyspaceResponse, GetKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 81);

/**
 * @generated from message vtctldata.GetPermissionsRequest
 */
export type GetPermissionsRequest = Message<"vtctldata.GetPermissionsRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.GetPermissionsRequest
 */
export type GetPermissionsRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.GetPermissionsRequest.
 * Use `create(GetPermissionsRequestSchema)` to create a new message.
 */
export const GetPermissionsRequestSchema: GenMessage<GetPermissionsRequest, GetPermissionsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 82);

/**
 * @generated from message vtctldata.GetPermissionsResponse
 */
export type GetPermissionsResponse = Message<"vtctldata.GetPermissionsResponse"> & {
  /**
   * @generated from field: tabletmanagerdata.Permissions permissions = 1;
   */
  permissions?: Permissions;
};

/**
 * @generated from message vtctldata.GetPermissionsResponse
 */
export type GetPermissionsResponseJson = {
  /**
   * @generated from field: tabletmanagerdata.Permissions permissions = 1;
   */
  permissions?: PermissionsJson;
};

/**
 * Describes the message vtctldata.GetPermissionsResponse.
 * Use `create(GetPermissionsResponseSchema)` to create a new message.
 */
export const GetPermissionsResponseSchema: GenMessage<GetPermissionsResponse, GetPermissionsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 83);

/**
 * @generated from message vtctldata.GetKeyspaceRoutingRulesRequest
 */
export type GetKeyspaceRoutingRulesRequest = Message<"vtctldata.GetKeyspaceRoutingRulesRequest"> & {
};

/**
 * @generated from message vtctldata.GetKeyspaceRoutingRulesRequest
 */
export type GetKeyspaceRoutingRulesRequestJson = {
};

/**
 * Describes the message vtctldata.GetKeyspaceRoutingRulesRequest.
 * Use `create(GetKeyspaceRoutingRulesRequestSchema)` to create a new message.
 */
export const GetKeyspaceRoutingRulesRequestSchema: GenMessage<GetKeyspaceRoutingRulesRequest, GetKeyspaceRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 84);

/**
 * @generated from message vtctldata.GetKeyspaceRoutingRulesResponse
 */
export type GetKeyspaceRoutingRulesResponse = Message<"vtctldata.GetKeyspaceRoutingRulesResponse"> & {
  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRules;
};

/**
 * @generated from message vtctldata.GetKeyspaceRoutingRulesResponse
 */
export type GetKeyspaceRoutingRulesResponseJson = {
  /**
   * @generated from field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
   */
  keyspaceRoutingRules?: KeyspaceRoutingRulesJson;
};

/**
 * Describes the message vtctldata.GetKeyspaceRoutingRulesResponse.
 * Use `create(GetKeyspaceRoutingRulesResponseSchema)` to create a new message.
 */
export const GetKeyspaceRoutingRulesResponseSchema: GenMessage<GetKeyspaceRoutingRulesResponse, GetKeyspaceRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 85);

/**
 * @generated from message vtctldata.GetRoutingRulesRequest
 */
export type GetRoutingRulesRequest = Message<"vtctldata.GetRoutingRulesRequest"> & {
};

/**
 * @generated from message vtctldata.GetRoutingRulesRequest
 */
export type GetRoutingRulesRequestJson = {
};

/**
 * Describes the message vtctldata.GetRoutingRulesRequest.
 * Use `create(GetRoutingRulesRequestSchema)` to create a new message.
 */
export const GetRoutingRulesRequestSchema: GenMessage<GetRoutingRulesRequest, GetRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 86);

/**
 * @generated from message vtctldata.GetRoutingRulesResponse
 */
export type GetRoutingRulesResponse = Message<"vtctldata.GetRoutingRulesResponse"> & {
  /**
   * @generated from field: vschema.RoutingRules routing_rules = 1;
   */
  routingRules?: RoutingRules;
};

/**
 * @generated from message vtctldata.GetRoutingRulesResponse
 */
export type GetRoutingRulesResponseJson = {
  /**
   * @generated from field: vschema.RoutingRules routing_rules = 1;
   */
  routingRules?: RoutingRulesJson;
};

/**
 * Describes the message vtctldata.GetRoutingRulesResponse.
 * Use `create(GetRoutingRulesResponseSchema)` to create a new message.
 */
export const GetRoutingRulesResponseSchema: GenMessage<GetRoutingRulesResponse, GetRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 87);

/**
 * @generated from message vtctldata.GetSchemaRequest
 */
export type GetSchemaRequest = Message<"vtctldata.GetSchemaRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * Tables is a list of tables for which we should gather information. Each is
   * either an exact match, or a regular expression of the form /regexp/.
   *
   * @generated from field: repeated string tables = 2;
   */
  tables: string[];

  /**
   * ExcludeTables is a list of tables to exclude from the result. Each is
   * either an exact match, or a regular expression of the form /regexp/.
   *
   * @generated from field: repeated string exclude_tables = 3;
   */
  excludeTables: string[];

  /**
   * IncludeViews specifies whether to include views in the result.
   *
   * @generated from field: bool include_views = 4;
   */
  includeViews: boolean;

  /**
   * TableNamesOnly specifies whether to limit the results to just table names,
   * rather than full schema information for each table.
   *
   * @generated from field: bool table_names_only = 5;
   */
  tableNamesOnly: boolean;

  /**
   * TableSizesOnly specifies whether to limit the results to just table sizes,
   * rather than full schema information for each table. It is ignored if
   * TableNamesOnly is set to true.
   *
   * @generated from field: bool table_sizes_only = 6;
   */
  tableSizesOnly: boolean;

  /**
   * TableSchemaOnly specifies whether to limit the results to just table/view
   * schema definition (CREATE TABLE/VIEW statements) and skip column/field information
   *
   * @generated from field: bool table_schema_only = 7;
   */
  tableSchemaOnly: boolean;
};

/**
 * @generated from message vtctldata.GetSchemaRequest
 */
export type GetSchemaRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * Tables is a list of tables for which we should gather information. Each is
   * either an exact match, or a regular expression of the form /regexp/.
   *
   * @generated from field: repeated string tables = 2;
   */
  tables?: string[];

  /**
   * ExcludeTables is a list of tables to exclude from the result. Each is
   * either an exact match, or a regular expression of the form /regexp/.
   *
   * @generated from field: repeated string exclude_tables = 3;
   */
  excludeTables?: string[];

  /**
   * IncludeViews specifies whether to include views in the result.
   *
   * @generated from field: bool include_views = 4;
   */
  includeViews?: boolean;

  /**
   * TableNamesOnly specifies whether to limit the results to just table names,
   * rather than full schema information for each table.
   *
   * @generated from field: bool table_names_only = 5;
   */
  tableNamesOnly?: boolean;

  /**
   * TableSizesOnly specifies whether to limit the results to just table sizes,
   * rather than full schema information for each table. It is ignored if
   * TableNamesOnly is set to true.
   *
   * @generated from field: bool table_sizes_only = 6;
   */
  tableSizesOnly?: boolean;

  /**
   * TableSchemaOnly specifies whether to limit the results to just table/view
   * schema definition (CREATE TABLE/VIEW statements) and skip column/field information
   *
   * @generated from field: bool table_schema_only = 7;
   */
  tableSchemaOnly?: boolean;
};

/**
 * Describes the message vtctldata.GetSchemaRequest.
 * Use `create(GetSchemaRequestSchema)` to create a new message.
 */
export const GetSchemaRequestSchema: GenMessage<GetSchemaRequest, GetSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 88);

/**
 * @generated from message vtctldata.GetSchemaResponse
 */
export type GetSchemaResponse = Message<"vtctldata.GetSchemaResponse"> & {
  /**
   * @generated from field: tabletmanagerdata.SchemaDefinition schema = 1;
   */
  schema?: SchemaDefinition;
};

/**
 * @generated from message vtctldata.GetSchemaResponse
 */
export type GetSchemaResponseJson = {
  /**
   * @generated from field: tabletmanagerdata.SchemaDefinition schema = 1;
   */
  schema?: SchemaDefinitionJson;
};

/**
 * Describes the message vtctldata.GetSchemaResponse.
 * Use `create(GetSchemaResponseSchema)` to create a new message.
 */
export const GetSchemaResponseSchema: GenMessage<GetSchemaResponse, GetSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 89);

/**
 * GetSchemaMigrationsRequest controls the behavior of the GetSchemaMigrations
 * rpc.
 *
 * Keyspace is a required field, while all other fields are optional.
 *
 * If UUID is set, other optional fields will be ignored, since there will be at
 * most one migration with that UUID. Furthermore, if no migration with that
 * UUID exists, an empty response, not an error, is returned.
 *
 * MigrationContext, Status, and Recent are mutually exclusive.
 *
 * @generated from message vtctldata.GetSchemaMigrationsRequest
 */
export type GetSchemaMigrationsRequest = Message<"vtctldata.GetSchemaMigrationsRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Uuid, if set, will cause GetSchemaMigrations to return exactly 1 migration,
   * namely the one with that UUID. If no migration exists, the response will
   * be an empty slice, not an error.
   *
   * If this field is set, other fields (status filters, limit, skip, order) are
   * ignored.
   *
   * @generated from field: string uuid = 2;
   */
  uuid: string;

  /**
   * @generated from field: string migration_context = 3;
   */
  migrationContext: string;

  /**
   * @generated from field: vtctldata.SchemaMigration.Status status = 4;
   */
  status: SchemaMigration_Status;

  /**
   * Recent, if set, returns migrations requested between now and the provided
   * value.
   *
   * @generated from field: vttime.Duration recent = 5;
   */
  recent?: Duration;

  /**
   * @generated from field: vtctldata.QueryOrdering order = 6;
   */
  order: QueryOrdering;

  /**
   * @generated from field: uint64 limit = 7;
   */
  limit: bigint;

  /**
   * @generated from field: uint64 skip = 8;
   */
  skip: bigint;
};

/**
 * GetSchemaMigrationsRequest controls the behavior of the GetSchemaMigrations
 * rpc.
 *
 * Keyspace is a required field, while all other fields are optional.
 *
 * If UUID is set, other optional fields will be ignored, since there will be at
 * most one migration with that UUID. Furthermore, if no migration with that
 * UUID exists, an empty response, not an error, is returned.
 *
 * MigrationContext, Status, and Recent are mutually exclusive.
 *
 * @generated from message vtctldata.GetSchemaMigrationsRequest
 */
export type GetSchemaMigrationsRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Uuid, if set, will cause GetSchemaMigrations to return exactly 1 migration,
   * namely the one with that UUID. If no migration exists, the response will
   * be an empty slice, not an error.
   *
   * If this field is set, other fields (status filters, limit, skip, order) are
   * ignored.
   *
   * @generated from field: string uuid = 2;
   */
  uuid?: string;

  /**
   * @generated from field: string migration_context = 3;
   */
  migrationContext?: string;

  /**
   * @generated from field: vtctldata.SchemaMigration.Status status = 4;
   */
  status?: SchemaMigration_StatusJson;

  /**
   * Recent, if set, returns migrations requested between now and the provided
   * value.
   *
   * @generated from field: vttime.Duration recent = 5;
   */
  recent?: DurationJson;

  /**
   * @generated from field: vtctldata.QueryOrdering order = 6;
   */
  order?: QueryOrderingJson;

  /**
   * @generated from field: uint64 limit = 7;
   */
  limit?: string;

  /**
   * @generated from field: uint64 skip = 8;
   */
  skip?: string;
};

/**
 * Describes the message vtctldata.GetSchemaMigrationsRequest.
 * Use `create(GetSchemaMigrationsRequestSchema)` to create a new message.
 */
export const GetSchemaMigrationsRequestSchema: GenMessage<GetSchemaMigrationsRequest, GetSchemaMigrationsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 90);

/**
 * @generated from message vtctldata.GetSchemaMigrationsResponse
 */
export type GetSchemaMigrationsResponse = Message<"vtctldata.GetSchemaMigrationsResponse"> & {
  /**
   * @generated from field: repeated vtctldata.SchemaMigration migrations = 1;
   */
  migrations: SchemaMigration[];
};

/**
 * @generated from message vtctldata.GetSchemaMigrationsResponse
 */
export type GetSchemaMigrationsResponseJson = {
  /**
   * @generated from field: repeated vtctldata.SchemaMigration migrations = 1;
   */
  migrations?: SchemaMigrationJson[];
};

/**
 * Describes the message vtctldata.GetSchemaMigrationsResponse.
 * Use `create(GetSchemaMigrationsResponseSchema)` to create a new message.
 */
export const GetSchemaMigrationsResponseSchema: GenMessage<GetSchemaMigrationsResponse, GetSchemaMigrationsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 91);

/**
 * @generated from message vtctldata.GetShardReplicationRequest
 */
export type GetShardReplicationRequest = Message<"vtctldata.GetShardReplicationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * Cells is the list of cells to fetch data for. Omit to fetch data from all
   * cells.
   *
   * @generated from field: repeated string cells = 3;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.GetShardReplicationRequest
 */
export type GetShardReplicationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * Cells is the list of cells to fetch data for. Omit to fetch data from all
   * cells.
   *
   * @generated from field: repeated string cells = 3;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.GetShardReplicationRequest.
 * Use `create(GetShardReplicationRequestSchema)` to create a new message.
 */
export const GetShardReplicationRequestSchema: GenMessage<GetShardReplicationRequest, GetShardReplicationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 92);

/**
 * @generated from message vtctldata.GetShardReplicationResponse
 */
export type GetShardReplicationResponse = Message<"vtctldata.GetShardReplicationResponse"> & {
  /**
   * @generated from field: map<string, topodata.ShardReplication> shard_replication_by_cell = 1;
   */
  shardReplicationByCell: { [key: string]: ShardReplication };
};

/**
 * @generated from message vtctldata.GetShardReplicationResponse
 */
export type GetShardReplicationResponseJson = {
  /**
   * @generated from field: map<string, topodata.ShardReplication> shard_replication_by_cell = 1;
   */
  shardReplicationByCell?: { [key: string]: ShardReplicationJson };
};

/**
 * Describes the message vtctldata.GetShardReplicationResponse.
 * Use `create(GetShardReplicationResponseSchema)` to create a new message.
 */
export const GetShardReplicationResponseSchema: GenMessage<GetShardReplicationResponse, GetShardReplicationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 93);

/**
 * @generated from message vtctldata.GetShardRequest
 */
export type GetShardRequest = Message<"vtctldata.GetShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard_name = 2;
   */
  shardName: string;
};

/**
 * @generated from message vtctldata.GetShardRequest
 */
export type GetShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard_name = 2;
   */
  shardName?: string;
};

/**
 * Describes the message vtctldata.GetShardRequest.
 * Use `create(GetShardRequestSchema)` to create a new message.
 */
export const GetShardRequestSchema: GenMessage<GetShardRequest, GetShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 94);

/**
 * @generated from message vtctldata.GetShardResponse
 */
export type GetShardResponse = Message<"vtctldata.GetShardResponse"> & {
  /**
   * @generated from field: vtctldata.Shard shard = 1;
   */
  shard?: Shard;
};

/**
 * @generated from message vtctldata.GetShardResponse
 */
export type GetShardResponseJson = {
  /**
   * @generated from field: vtctldata.Shard shard = 1;
   */
  shard?: ShardJson;
};

/**
 * Describes the message vtctldata.GetShardResponse.
 * Use `create(GetShardResponseSchema)` to create a new message.
 */
export const GetShardResponseSchema: GenMessage<GetShardResponse, GetShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 95);

/**
 * @generated from message vtctldata.GetShardRoutingRulesRequest
 */
export type GetShardRoutingRulesRequest = Message<"vtctldata.GetShardRoutingRulesRequest"> & {
};

/**
 * @generated from message vtctldata.GetShardRoutingRulesRequest
 */
export type GetShardRoutingRulesRequestJson = {
};

/**
 * Describes the message vtctldata.GetShardRoutingRulesRequest.
 * Use `create(GetShardRoutingRulesRequestSchema)` to create a new message.
 */
export const GetShardRoutingRulesRequestSchema: GenMessage<GetShardRoutingRulesRequest, GetShardRoutingRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 96);

/**
 * @generated from message vtctldata.GetShardRoutingRulesResponse
 */
export type GetShardRoutingRulesResponse = Message<"vtctldata.GetShardRoutingRulesResponse"> & {
  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 1;
   */
  shardRoutingRules?: ShardRoutingRules;
};

/**
 * @generated from message vtctldata.GetShardRoutingRulesResponse
 */
export type GetShardRoutingRulesResponseJson = {
  /**
   * @generated from field: vschema.ShardRoutingRules shard_routing_rules = 1;
   */
  shardRoutingRules?: ShardRoutingRulesJson;
};

/**
 * Describes the message vtctldata.GetShardRoutingRulesResponse.
 * Use `create(GetShardRoutingRulesResponseSchema)` to create a new message.
 */
export const GetShardRoutingRulesResponseSchema: GenMessage<GetShardRoutingRulesResponse, GetShardRoutingRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 97);

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesRequest
 */
export type GetSrvKeyspaceNamesRequest = Message<"vtctldata.GetSrvKeyspaceNamesRequest"> & {
  /**
   * @generated from field: repeated string cells = 1;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesRequest
 */
export type GetSrvKeyspaceNamesRequestJson = {
  /**
   * @generated from field: repeated string cells = 1;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.GetSrvKeyspaceNamesRequest.
 * Use `create(GetSrvKeyspaceNamesRequestSchema)` to create a new message.
 */
export const GetSrvKeyspaceNamesRequestSchema: GenMessage<GetSrvKeyspaceNamesRequest, GetSrvKeyspaceNamesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 98);

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesResponse
 */
export type GetSrvKeyspaceNamesResponse = Message<"vtctldata.GetSrvKeyspaceNamesResponse"> & {
  /**
   * Names is a mapping of cell name to a list of SrvKeyspace names.
   *
   * @generated from field: map<string, vtctldata.GetSrvKeyspaceNamesResponse.NameList> names = 1;
   */
  names: { [key: string]: GetSrvKeyspaceNamesResponse_NameList };
};

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesResponse
 */
export type GetSrvKeyspaceNamesResponseJson = {
  /**
   * Names is a mapping of cell name to a list of SrvKeyspace names.
   *
   * @generated from field: map<string, vtctldata.GetSrvKeyspaceNamesResponse.NameList> names = 1;
   */
  names?: { [key: string]: GetSrvKeyspaceNamesResponse_NameListJson };
};

/**
 * Describes the message vtctldata.GetSrvKeyspaceNamesResponse.
 * Use `create(GetSrvKeyspaceNamesResponseSchema)` to create a new message.
 */
export const GetSrvKeyspaceNamesResponseSchema: GenMessage<GetSrvKeyspaceNamesResponse, GetSrvKeyspaceNamesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 99);

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesResponse.NameList
 */
export type GetSrvKeyspaceNamesResponse_NameList = Message<"vtctldata.GetSrvKeyspaceNamesResponse.NameList"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * @generated from message vtctldata.GetSrvKeyspaceNamesResponse.NameList
 */
export type GetSrvKeyspaceNamesResponse_NameListJson = {
  /**
   * @generated from field: repeated string names = 1;
   */
  names?: string[];
};

/**
 * Describes the message vtctldata.GetSrvKeyspaceNamesResponse.NameList.
 * Use `create(GetSrvKeyspaceNamesResponse_NameListSchema)` to create a new message.
 */
export const GetSrvKeyspaceNamesResponse_NameListSchema: GenMessage<GetSrvKeyspaceNamesResponse_NameList, GetSrvKeyspaceNamesResponse_NameListJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 99, 0);

/**
 * @generated from message vtctldata.GetSrvKeyspacesRequest
 */
export type GetSrvKeyspacesRequest = Message<"vtctldata.GetSrvKeyspacesRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
   * equivalent to specifying all cells in the topo.
   *
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.GetSrvKeyspacesRequest
 */
export type GetSrvKeyspacesRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
   * equivalent to specifying all cells in the topo.
   *
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.GetSrvKeyspacesRequest.
 * Use `create(GetSrvKeyspacesRequestSchema)` to create a new message.
 */
export const GetSrvKeyspacesRequestSchema: GenMessage<GetSrvKeyspacesRequest, GetSrvKeyspacesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 100);

/**
 * @generated from message vtctldata.GetSrvKeyspacesResponse
 */
export type GetSrvKeyspacesResponse = Message<"vtctldata.GetSrvKeyspacesResponse"> & {
  /**
   * SrvKeyspaces is a mapping of cell name to SrvKeyspace.
   *
   * @generated from field: map<string, topodata.SrvKeyspace> srv_keyspaces = 1;
   */
  srvKeyspaces: { [key: string]: SrvKeyspace };
};

/**
 * @generated from message vtctldata.GetSrvKeyspacesResponse
 */
export type GetSrvKeyspacesResponseJson = {
  /**
   * SrvKeyspaces is a mapping of cell name to SrvKeyspace.
   *
   * @generated from field: map<string, topodata.SrvKeyspace> srv_keyspaces = 1;
   */
  srvKeyspaces?: { [key: string]: SrvKeyspaceJson };
};

/**
 * Describes the message vtctldata.GetSrvKeyspacesResponse.
 * Use `create(GetSrvKeyspacesResponseSchema)` to create a new message.
 */
export const GetSrvKeyspacesResponseSchema: GenMessage<GetSrvKeyspacesResponse, GetSrvKeyspacesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 101);

/**
 * @generated from message vtctldata.UpdateThrottlerConfigRequest
 */
export type UpdateThrottlerConfigRequest = Message<"vtctldata.UpdateThrottlerConfigRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Enable instructs to enable the throttler
   *
   * @generated from field: bool enable = 2;
   */
  enable: boolean;

  /**
   * Disable instructs to disable the throttler
   *
   * @generated from field: bool disable = 3;
   */
  disable: boolean;

  /**
   * Threshold for throttler (with no custom query, ie using default query, only positive values are considered)
   *
   * @generated from field: double threshold = 4;
   */
  threshold: number;

  /**
   * CustomQuery replaces the default replication lag query
   *
   * @generated from field: string custom_query = 5;
   */
  customQuery: string;

  /**
   * CustomQuerySet indicates that the value of CustomQuery has changed
   *
   * @generated from field: bool custom_query_set = 6;
   */
  customQuerySet: boolean;

  /**
   * CheckAsCheckSelf instructs the throttler to respond to /check requests by checking the tablet's own health
   *
   * @generated from field: bool check_as_check_self = 7;
   */
  checkAsCheckSelf: boolean;

  /**
   * CheckAsCheckShard instructs the throttler to respond to /check requests by checking the shard's health (this is the default behavior)
   *
   * @generated from field: bool check_as_check_shard = 8;
   */
  checkAsCheckShard: boolean;

  /**
   * ThrottledApp indicates a single throttled app rule (ignored if name is empty)
   *
   * @generated from field: topodata.ThrottledAppRule throttled_app = 9;
   */
  throttledApp?: ThrottledAppRule;

  /**
   * MetricName is the name of the metric for which we apply a new threshold
   *
   * @generated from field: string metric_name = 10;
   */
  metricName: string;

  /**
   * AppName is the name of the app for which we assign metrics
   *
   * @generated from field: string app_name = 11;
   */
  appName: string;

  /**
   * AppCheckedMetrics are the metrics to be checked got the given AppName. These can be scoped. For example:
   * ["lag", "self/loadvg", "shard/threads_running"]
   *
   * @generated from field: repeated string app_checked_metrics = 12;
   */
  appCheckedMetrics: string[];
};

/**
 * @generated from message vtctldata.UpdateThrottlerConfigRequest
 */
export type UpdateThrottlerConfigRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Enable instructs to enable the throttler
   *
   * @generated from field: bool enable = 2;
   */
  enable?: boolean;

  /**
   * Disable instructs to disable the throttler
   *
   * @generated from field: bool disable = 3;
   */
  disable?: boolean;

  /**
   * Threshold for throttler (with no custom query, ie using default query, only positive values are considered)
   *
   * @generated from field: double threshold = 4;
   */
  threshold?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * CustomQuery replaces the default replication lag query
   *
   * @generated from field: string custom_query = 5;
   */
  customQuery?: string;

  /**
   * CustomQuerySet indicates that the value of CustomQuery has changed
   *
   * @generated from field: bool custom_query_set = 6;
   */
  customQuerySet?: boolean;

  /**
   * CheckAsCheckSelf instructs the throttler to respond to /check requests by checking the tablet's own health
   *
   * @generated from field: bool check_as_check_self = 7;
   */
  checkAsCheckSelf?: boolean;

  /**
   * CheckAsCheckShard instructs the throttler to respond to /check requests by checking the shard's health (this is the default behavior)
   *
   * @generated from field: bool check_as_check_shard = 8;
   */
  checkAsCheckShard?: boolean;

  /**
   * ThrottledApp indicates a single throttled app rule (ignored if name is empty)
   *
   * @generated from field: topodata.ThrottledAppRule throttled_app = 9;
   */
  throttledApp?: ThrottledAppRuleJson;

  /**
   * MetricName is the name of the metric for which we apply a new threshold
   *
   * @generated from field: string metric_name = 10;
   */
  metricName?: string;

  /**
   * AppName is the name of the app for which we assign metrics
   *
   * @generated from field: string app_name = 11;
   */
  appName?: string;

  /**
   * AppCheckedMetrics are the metrics to be checked got the given AppName. These can be scoped. For example:
   * ["lag", "self/loadvg", "shard/threads_running"]
   *
   * @generated from field: repeated string app_checked_metrics = 12;
   */
  appCheckedMetrics?: string[];
};

/**
 * Describes the message vtctldata.UpdateThrottlerConfigRequest.
 * Use `create(UpdateThrottlerConfigRequestSchema)` to create a new message.
 */
export const UpdateThrottlerConfigRequestSchema: GenMessage<UpdateThrottlerConfigRequest, UpdateThrottlerConfigRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 102);

/**
 * @generated from message vtctldata.UpdateThrottlerConfigResponse
 */
export type UpdateThrottlerConfigResponse = Message<"vtctldata.UpdateThrottlerConfigResponse"> & {
};

/**
 * @generated from message vtctldata.UpdateThrottlerConfigResponse
 */
export type UpdateThrottlerConfigResponseJson = {
};

/**
 * Describes the message vtctldata.UpdateThrottlerConfigResponse.
 * Use `create(UpdateThrottlerConfigResponseSchema)` to create a new message.
 */
export const UpdateThrottlerConfigResponseSchema: GenMessage<UpdateThrottlerConfigResponse, UpdateThrottlerConfigResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 103);

/**
 * @generated from message vtctldata.GetSrvVSchemaRequest
 */
export type GetSrvVSchemaRequest = Message<"vtctldata.GetSrvVSchemaRequest"> & {
  /**
   * @generated from field: string cell = 1;
   */
  cell: string;
};

/**
 * @generated from message vtctldata.GetSrvVSchemaRequest
 */
export type GetSrvVSchemaRequestJson = {
  /**
   * @generated from field: string cell = 1;
   */
  cell?: string;
};

/**
 * Describes the message vtctldata.GetSrvVSchemaRequest.
 * Use `create(GetSrvVSchemaRequestSchema)` to create a new message.
 */
export const GetSrvVSchemaRequestSchema: GenMessage<GetSrvVSchemaRequest, GetSrvVSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 104);

/**
 * @generated from message vtctldata.GetSrvVSchemaResponse
 */
export type GetSrvVSchemaResponse = Message<"vtctldata.GetSrvVSchemaResponse"> & {
  /**
   * @generated from field: vschema.SrvVSchema srv_v_schema = 1;
   */
  srvVSchema?: SrvVSchema;
};

/**
 * @generated from message vtctldata.GetSrvVSchemaResponse
 */
export type GetSrvVSchemaResponseJson = {
  /**
   * @generated from field: vschema.SrvVSchema srv_v_schema = 1;
   */
  srvVSchema?: SrvVSchemaJson;
};

/**
 * Describes the message vtctldata.GetSrvVSchemaResponse.
 * Use `create(GetSrvVSchemaResponseSchema)` to create a new message.
 */
export const GetSrvVSchemaResponseSchema: GenMessage<GetSrvVSchemaResponse, GetSrvVSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 105);

/**
 * @generated from message vtctldata.GetSrvVSchemasRequest
 */
export type GetSrvVSchemasRequest = Message<"vtctldata.GetSrvVSchemasRequest"> & {
  /**
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.GetSrvVSchemasRequest
 */
export type GetSrvVSchemasRequestJson = {
  /**
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.GetSrvVSchemasRequest.
 * Use `create(GetSrvVSchemasRequestSchema)` to create a new message.
 */
export const GetSrvVSchemasRequestSchema: GenMessage<GetSrvVSchemasRequest, GetSrvVSchemasRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 106);

/**
 * @generated from message vtctldata.GetSrvVSchemasResponse
 */
export type GetSrvVSchemasResponse = Message<"vtctldata.GetSrvVSchemasResponse"> & {
  /**
   * SrvVSchemas is a mapping of cell name to SrvVSchema
   *
   * @generated from field: map<string, vschema.SrvVSchema> srv_v_schemas = 1;
   */
  srvVSchemas: { [key: string]: SrvVSchema };
};

/**
 * @generated from message vtctldata.GetSrvVSchemasResponse
 */
export type GetSrvVSchemasResponseJson = {
  /**
   * SrvVSchemas is a mapping of cell name to SrvVSchema
   *
   * @generated from field: map<string, vschema.SrvVSchema> srv_v_schemas = 1;
   */
  srvVSchemas?: { [key: string]: SrvVSchemaJson };
};

/**
 * Describes the message vtctldata.GetSrvVSchemasResponse.
 * Use `create(GetSrvVSchemasResponseSchema)` to create a new message.
 */
export const GetSrvVSchemasResponseSchema: GenMessage<GetSrvVSchemasResponse, GetSrvVSchemasResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 107);

/**
 * @generated from message vtctldata.GetTabletRequest
 */
export type GetTabletRequest = Message<"vtctldata.GetTabletRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.GetTabletRequest
 */
export type GetTabletRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.GetTabletRequest.
 * Use `create(GetTabletRequestSchema)` to create a new message.
 */
export const GetTabletRequestSchema: GenMessage<GetTabletRequest, GetTabletRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 108);

/**
 * @generated from message vtctldata.GetTabletResponse
 */
export type GetTabletResponse = Message<"vtctldata.GetTabletResponse"> & {
  /**
   * @generated from field: topodata.Tablet tablet = 1;
   */
  tablet?: Tablet;
};

/**
 * @generated from message vtctldata.GetTabletResponse
 */
export type GetTabletResponseJson = {
  /**
   * @generated from field: topodata.Tablet tablet = 1;
   */
  tablet?: TabletJson;
};

/**
 * Describes the message vtctldata.GetTabletResponse.
 * Use `create(GetTabletResponseSchema)` to create a new message.
 */
export const GetTabletResponseSchema: GenMessage<GetTabletResponse, GetTabletResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 109);

/**
 * @generated from message vtctldata.GetTabletsRequest
 */
export type GetTabletsRequest = Message<"vtctldata.GetTabletsRequest"> & {
  /**
   * Keyspace is the name of the keyspace to return tablets for. Omit to return
   * tablets from all keyspaces.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard to return tablets for. This field is ignored
   * if Keyspace is not set.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * Cells is an optional set of cells to return tablets for.
   *
   * @generated from field: repeated string cells = 3;
   */
  cells: string[];

  /**
   * Strict specifies how the server should treat failures from individual
   * cells.
   *
   * When false (the default), GetTablets will return data from any cells that
   * return successfully, but will fail the request if all cells fail. When
   * true, any individual cell can fail the full request.
   *
   * @generated from field: bool strict = 4;
   */
  strict: boolean;

  /**
   * TabletAliases is an optional list of tablet aliases to fetch Tablet objects
   * for. If specified, Keyspace, Shard, and Cells are ignored, and tablets are
   * looked up by their respective aliases' Cells directly.
   *
   * @generated from field: repeated topodata.TabletAlias tablet_aliases = 5;
   */
  tabletAliases: TabletAlias[];

  /**
   * tablet_type specifies the type of tablets to return. Omit to return all
   * tablet types.
   *
   * @generated from field: topodata.TabletType tablet_type = 6;
   */
  tabletType: TabletType;
};

/**
 * @generated from message vtctldata.GetTabletsRequest
 */
export type GetTabletsRequestJson = {
  /**
   * Keyspace is the name of the keyspace to return tablets for. Omit to return
   * tablets from all keyspaces.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard to return tablets for. This field is ignored
   * if Keyspace is not set.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * Cells is an optional set of cells to return tablets for.
   *
   * @generated from field: repeated string cells = 3;
   */
  cells?: string[];

  /**
   * Strict specifies how the server should treat failures from individual
   * cells.
   *
   * When false (the default), GetTablets will return data from any cells that
   * return successfully, but will fail the request if all cells fail. When
   * true, any individual cell can fail the full request.
   *
   * @generated from field: bool strict = 4;
   */
  strict?: boolean;

  /**
   * TabletAliases is an optional list of tablet aliases to fetch Tablet objects
   * for. If specified, Keyspace, Shard, and Cells are ignored, and tablets are
   * looked up by their respective aliases' Cells directly.
   *
   * @generated from field: repeated topodata.TabletAlias tablet_aliases = 5;
   */
  tabletAliases?: TabletAliasJson[];

  /**
   * tablet_type specifies the type of tablets to return. Omit to return all
   * tablet types.
   *
   * @generated from field: topodata.TabletType tablet_type = 6;
   */
  tabletType?: TabletTypeJson;
};

/**
 * Describes the message vtctldata.GetTabletsRequest.
 * Use `create(GetTabletsRequestSchema)` to create a new message.
 */
export const GetTabletsRequestSchema: GenMessage<GetTabletsRequest, GetTabletsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 110);

/**
 * @generated from message vtctldata.GetTabletsResponse
 */
export type GetTabletsResponse = Message<"vtctldata.GetTabletsResponse"> & {
  /**
   * @generated from field: repeated topodata.Tablet tablets = 1;
   */
  tablets: Tablet[];
};

/**
 * @generated from message vtctldata.GetTabletsResponse
 */
export type GetTabletsResponseJson = {
  /**
   * @generated from field: repeated topodata.Tablet tablets = 1;
   */
  tablets?: TabletJson[];
};

/**
 * Describes the message vtctldata.GetTabletsResponse.
 * Use `create(GetTabletsResponseSchema)` to create a new message.
 */
export const GetTabletsResponseSchema: GenMessage<GetTabletsResponse, GetTabletsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 111);

/**
 * @generated from message vtctldata.GetThrottlerStatusRequest
 */
export type GetThrottlerStatusRequest = Message<"vtctldata.GetThrottlerStatusRequest"> & {
  /**
   * TabletAlias is the alias of the tablet to probe
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.GetThrottlerStatusRequest
 */
export type GetThrottlerStatusRequestJson = {
  /**
   * TabletAlias is the alias of the tablet to probe
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.GetThrottlerStatusRequest.
 * Use `create(GetThrottlerStatusRequestSchema)` to create a new message.
 */
export const GetThrottlerStatusRequestSchema: GenMessage<GetThrottlerStatusRequest, GetThrottlerStatusRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 112);

/**
 * @generated from message vtctldata.GetThrottlerStatusResponse
 */
export type GetThrottlerStatusResponse = Message<"vtctldata.GetThrottlerStatusResponse"> & {
  /**
   * @generated from field: tabletmanagerdata.GetThrottlerStatusResponse status = 1;
   */
  status?: GetThrottlerStatusResponse$1;
};

/**
 * @generated from message vtctldata.GetThrottlerStatusResponse
 */
export type GetThrottlerStatusResponseJson = {
  /**
   * @generated from field: tabletmanagerdata.GetThrottlerStatusResponse status = 1;
   */
  status?: GetThrottlerStatusResponseJson$1;
};

/**
 * Describes the message vtctldata.GetThrottlerStatusResponse.
 * Use `create(GetThrottlerStatusResponseSchema)` to create a new message.
 */
export const GetThrottlerStatusResponseSchema: GenMessage<GetThrottlerStatusResponse, GetThrottlerStatusResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 113);

/**
 * @generated from message vtctldata.GetTopologyPathRequest
 */
export type GetTopologyPathRequest = Message<"vtctldata.GetTopologyPathRequest"> & {
  /**
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * @generated from field: int64 version = 2;
   */
  version: bigint;

  /**
   * @generated from field: bool as_json = 3;
   */
  asJson: boolean;
};

/**
 * @generated from message vtctldata.GetTopologyPathRequest
 */
export type GetTopologyPathRequestJson = {
  /**
   * @generated from field: string path = 1;
   */
  path?: string;

  /**
   * @generated from field: int64 version = 2;
   */
  version?: string;

  /**
   * @generated from field: bool as_json = 3;
   */
  asJson?: boolean;
};

/**
 * Describes the message vtctldata.GetTopologyPathRequest.
 * Use `create(GetTopologyPathRequestSchema)` to create a new message.
 */
export const GetTopologyPathRequestSchema: GenMessage<GetTopologyPathRequest, GetTopologyPathRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 114);

/**
 * @generated from message vtctldata.GetTopologyPathResponse
 */
export type GetTopologyPathResponse = Message<"vtctldata.GetTopologyPathResponse"> & {
  /**
   * @generated from field: vtctldata.TopologyCell cell = 1;
   */
  cell?: TopologyCell;
};

/**
 * @generated from message vtctldata.GetTopologyPathResponse
 */
export type GetTopologyPathResponseJson = {
  /**
   * @generated from field: vtctldata.TopologyCell cell = 1;
   */
  cell?: TopologyCellJson;
};

/**
 * Describes the message vtctldata.GetTopologyPathResponse.
 * Use `create(GetTopologyPathResponseSchema)` to create a new message.
 */
export const GetTopologyPathResponseSchema: GenMessage<GetTopologyPathResponse, GetTopologyPathResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 115);

/**
 * @generated from message vtctldata.TopologyCell
 */
export type TopologyCell = Message<"vtctldata.TopologyCell"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Data is the file contents of the cell located at path.
   * It is only populated if the cell is a terminal node.
   *
   * @generated from field: string data = 3;
   */
  data: string;

  /**
   * @generated from field: repeated string children = 4;
   */
  children: string[];

  /**
   * @generated from field: int64 version = 5;
   */
  version: bigint;
};

/**
 * @generated from message vtctldata.TopologyCell
 */
export type TopologyCellJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: string path = 2;
   */
  path?: string;

  /**
   * Data is the file contents of the cell located at path.
   * It is only populated if the cell is a terminal node.
   *
   * @generated from field: string data = 3;
   */
  data?: string;

  /**
   * @generated from field: repeated string children = 4;
   */
  children?: string[];

  /**
   * @generated from field: int64 version = 5;
   */
  version?: string;
};

/**
 * Describes the message vtctldata.TopologyCell.
 * Use `create(TopologyCellSchema)` to create a new message.
 */
export const TopologyCellSchema: GenMessage<TopologyCell, TopologyCellJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 116);

/**
 * @generated from message vtctldata.GetUnresolvedTransactionsRequest
 */
export type GetUnresolvedTransactionsRequest = Message<"vtctldata.GetUnresolvedTransactionsRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * in seconds
   *
   * @generated from field: int64 abandon_age = 2;
   */
  abandonAge: bigint;
};

/**
 * @generated from message vtctldata.GetUnresolvedTransactionsRequest
 */
export type GetUnresolvedTransactionsRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * in seconds
   *
   * @generated from field: int64 abandon_age = 2;
   */
  abandonAge?: string;
};

/**
 * Describes the message vtctldata.GetUnresolvedTransactionsRequest.
 * Use `create(GetUnresolvedTransactionsRequestSchema)` to create a new message.
 */
export const GetUnresolvedTransactionsRequestSchema: GenMessage<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 117);

/**
 * @generated from message vtctldata.GetUnresolvedTransactionsResponse
 */
export type GetUnresolvedTransactionsResponse = Message<"vtctldata.GetUnresolvedTransactionsResponse"> & {
  /**
   * @generated from field: repeated query.TransactionMetadata transactions = 1;
   */
  transactions: TransactionMetadata[];
};

/**
 * @generated from message vtctldata.GetUnresolvedTransactionsResponse
 */
export type GetUnresolvedTransactionsResponseJson = {
  /**
   * @generated from field: repeated query.TransactionMetadata transactions = 1;
   */
  transactions?: TransactionMetadataJson[];
};

/**
 * Describes the message vtctldata.GetUnresolvedTransactionsResponse.
 * Use `create(GetUnresolvedTransactionsResponseSchema)` to create a new message.
 */
export const GetUnresolvedTransactionsResponseSchema: GenMessage<GetUnresolvedTransactionsResponse, GetUnresolvedTransactionsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 118);

/**
 * @generated from message vtctldata.ConcludeTransactionRequest
 */
export type ConcludeTransactionRequest = Message<"vtctldata.ConcludeTransactionRequest"> & {
  /**
   * @generated from field: string dtid = 1;
   */
  dtid: string;

  /**
   * @generated from field: repeated query.Target participants = 2;
   */
  participants: Target[];
};

/**
 * @generated from message vtctldata.ConcludeTransactionRequest
 */
export type ConcludeTransactionRequestJson = {
  /**
   * @generated from field: string dtid = 1;
   */
  dtid?: string;

  /**
   * @generated from field: repeated query.Target participants = 2;
   */
  participants?: TargetJson[];
};

/**
 * Describes the message vtctldata.ConcludeTransactionRequest.
 * Use `create(ConcludeTransactionRequestSchema)` to create a new message.
 */
export const ConcludeTransactionRequestSchema: GenMessage<ConcludeTransactionRequest, ConcludeTransactionRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 119);

/**
 * @generated from message vtctldata.ConcludeTransactionResponse
 */
export type ConcludeTransactionResponse = Message<"vtctldata.ConcludeTransactionResponse"> & {
};

/**
 * @generated from message vtctldata.ConcludeTransactionResponse
 */
export type ConcludeTransactionResponseJson = {
};

/**
 * Describes the message vtctldata.ConcludeTransactionResponse.
 * Use `create(ConcludeTransactionResponseSchema)` to create a new message.
 */
export const ConcludeTransactionResponseSchema: GenMessage<ConcludeTransactionResponse, ConcludeTransactionResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 120);

/**
 * @generated from message vtctldata.GetVSchemaRequest
 */
export type GetVSchemaRequest = Message<"vtctldata.GetVSchemaRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;
};

/**
 * @generated from message vtctldata.GetVSchemaRequest
 */
export type GetVSchemaRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;
};

/**
 * Describes the message vtctldata.GetVSchemaRequest.
 * Use `create(GetVSchemaRequestSchema)` to create a new message.
 */
export const GetVSchemaRequestSchema: GenMessage<GetVSchemaRequest, GetVSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 121);

/**
 * @generated from message vtctldata.GetVersionRequest
 */
export type GetVersionRequest = Message<"vtctldata.GetVersionRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.GetVersionRequest
 */
export type GetVersionRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.GetVersionRequest.
 * Use `create(GetVersionRequestSchema)` to create a new message.
 */
export const GetVersionRequestSchema: GenMessage<GetVersionRequest, GetVersionRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 122);

/**
 * @generated from message vtctldata.GetVersionResponse
 */
export type GetVersionResponse = Message<"vtctldata.GetVersionResponse"> & {
  /**
   * @generated from field: string version = 1;
   */
  version: string;
};

/**
 * @generated from message vtctldata.GetVersionResponse
 */
export type GetVersionResponseJson = {
  /**
   * @generated from field: string version = 1;
   */
  version?: string;
};

/**
 * Describes the message vtctldata.GetVersionResponse.
 * Use `create(GetVersionResponseSchema)` to create a new message.
 */
export const GetVersionResponseSchema: GenMessage<GetVersionResponse, GetVersionResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 123);

/**
 * @generated from message vtctldata.GetVSchemaResponse
 */
export type GetVSchemaResponse = Message<"vtctldata.GetVSchemaResponse"> & {
  /**
   * @generated from field: vschema.Keyspace v_schema = 1;
   */
  vSchema?: Keyspace$2;
};

/**
 * @generated from message vtctldata.GetVSchemaResponse
 */
export type GetVSchemaResponseJson = {
  /**
   * @generated from field: vschema.Keyspace v_schema = 1;
   */
  vSchema?: KeyspaceJson$2;
};

/**
 * Describes the message vtctldata.GetVSchemaResponse.
 * Use `create(GetVSchemaResponseSchema)` to create a new message.
 */
export const GetVSchemaResponseSchema: GenMessage<GetVSchemaResponse, GetVSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 124);

/**
 * @generated from message vtctldata.GetWorkflowsRequest
 */
export type GetWorkflowsRequest = Message<"vtctldata.GetWorkflowsRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: bool active_only = 2;
   */
  activeOnly: boolean;

  /**
   * @generated from field: bool name_only = 3;
   */
  nameOnly: boolean;

  /**
   * If you only want a specific workflow then set this field.
   *
   * @generated from field: string workflow = 4;
   */
  workflow: string;

  /**
   * @generated from field: bool include_logs = 5;
   */
  includeLogs: boolean;

  /**
   * @generated from field: repeated string shards = 6;
   */
  shards: string[];
};

/**
 * @generated from message vtctldata.GetWorkflowsRequest
 */
export type GetWorkflowsRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: bool active_only = 2;
   */
  activeOnly?: boolean;

  /**
   * @generated from field: bool name_only = 3;
   */
  nameOnly?: boolean;

  /**
   * If you only want a specific workflow then set this field.
   *
   * @generated from field: string workflow = 4;
   */
  workflow?: string;

  /**
   * @generated from field: bool include_logs = 5;
   */
  includeLogs?: boolean;

  /**
   * @generated from field: repeated string shards = 6;
   */
  shards?: string[];
};

/**
 * Describes the message vtctldata.GetWorkflowsRequest.
 * Use `create(GetWorkflowsRequestSchema)` to create a new message.
 */
export const GetWorkflowsRequestSchema: GenMessage<GetWorkflowsRequest, GetWorkflowsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 125);

/**
 * @generated from message vtctldata.GetWorkflowsResponse
 */
export type GetWorkflowsResponse = Message<"vtctldata.GetWorkflowsResponse"> & {
  /**
   * @generated from field: repeated vtctldata.Workflow workflows = 1;
   */
  workflows: Workflow[];
};

/**
 * @generated from message vtctldata.GetWorkflowsResponse
 */
export type GetWorkflowsResponseJson = {
  /**
   * @generated from field: repeated vtctldata.Workflow workflows = 1;
   */
  workflows?: WorkflowJson[];
};

/**
 * Describes the message vtctldata.GetWorkflowsResponse.
 * Use `create(GetWorkflowsResponseSchema)` to create a new message.
 */
export const GetWorkflowsResponseSchema: GenMessage<GetWorkflowsResponse, GetWorkflowsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 126);

/**
 * @generated from message vtctldata.InitShardPrimaryRequest
 */
export type InitShardPrimaryRequest = Message<"vtctldata.InitShardPrimaryRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletAlias primary_elect_tablet_alias = 3;
   */
  primaryElectTabletAlias?: TabletAlias;

  /**
   * @generated from field: bool force = 4;
   */
  force: boolean;

  /**
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: Duration;
};

/**
 * @generated from message vtctldata.InitShardPrimaryRequest
 */
export type InitShardPrimaryRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletAlias primary_elect_tablet_alias = 3;
   */
  primaryElectTabletAlias?: TabletAliasJson;

  /**
   * @generated from field: bool force = 4;
   */
  force?: boolean;

  /**
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: DurationJson;
};

/**
 * Describes the message vtctldata.InitShardPrimaryRequest.
 * Use `create(InitShardPrimaryRequestSchema)` to create a new message.
 */
export const InitShardPrimaryRequestSchema: GenMessage<InitShardPrimaryRequest, InitShardPrimaryRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 127);

/**
 * @generated from message vtctldata.InitShardPrimaryResponse
 */
export type InitShardPrimaryResponse = Message<"vtctldata.InitShardPrimaryResponse"> & {
  /**
   * @generated from field: repeated logutil.Event events = 1;
   */
  events: Event[];
};

/**
 * @generated from message vtctldata.InitShardPrimaryResponse
 */
export type InitShardPrimaryResponseJson = {
  /**
   * @generated from field: repeated logutil.Event events = 1;
   */
  events?: EventJson[];
};

/**
 * Describes the message vtctldata.InitShardPrimaryResponse.
 * Use `create(InitShardPrimaryResponseSchema)` to create a new message.
 */
export const InitShardPrimaryResponseSchema: GenMessage<InitShardPrimaryResponse, InitShardPrimaryResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 128);

/**
 * @generated from message vtctldata.LaunchSchemaMigrationRequest
 */
export type LaunchSchemaMigrationRequest = Message<"vtctldata.LaunchSchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.LaunchSchemaMigrationRequest
 */
export type LaunchSchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.LaunchSchemaMigrationRequest.
 * Use `create(LaunchSchemaMigrationRequestSchema)` to create a new message.
 */
export const LaunchSchemaMigrationRequestSchema: GenMessage<LaunchSchemaMigrationRequest, LaunchSchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 129);

/**
 * @generated from message vtctldata.LaunchSchemaMigrationResponse
 */
export type LaunchSchemaMigrationResponse = Message<"vtctldata.LaunchSchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.LaunchSchemaMigrationResponse
 */
export type LaunchSchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.LaunchSchemaMigrationResponse.
 * Use `create(LaunchSchemaMigrationResponseSchema)` to create a new message.
 */
export const LaunchSchemaMigrationResponseSchema: GenMessage<LaunchSchemaMigrationResponse, LaunchSchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 130);

/**
 * @generated from message vtctldata.LookupVindexCreateRequest
 */
export type LookupVindexCreateRequest = Message<"vtctldata.LookupVindexCreateRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells: string[];

  /**
   * @generated from field: vschema.Keyspace vindex = 4;
   */
  vindex?: Keyspace$2;

  /**
   * @generated from field: bool continue_after_copy_with_owner = 5;
   */
  continueAfterCopyWithOwner: boolean;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference: TabletSelectionPreference;
};

/**
 * @generated from message vtctldata.LookupVindexCreateRequest
 */
export type LookupVindexCreateRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow?: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells?: string[];

  /**
   * @generated from field: vschema.Keyspace vindex = 4;
   */
  vindex?: KeyspaceJson$2;

  /**
   * @generated from field: bool continue_after_copy_with_owner = 5;
   */
  continueAfterCopyWithOwner?: boolean;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;
};

/**
 * Describes the message vtctldata.LookupVindexCreateRequest.
 * Use `create(LookupVindexCreateRequestSchema)` to create a new message.
 */
export const LookupVindexCreateRequestSchema: GenMessage<LookupVindexCreateRequest, LookupVindexCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 131);

/**
 * @generated from message vtctldata.LookupVindexCreateResponse
 */
export type LookupVindexCreateResponse = Message<"vtctldata.LookupVindexCreateResponse"> & {
};

/**
 * @generated from message vtctldata.LookupVindexCreateResponse
 */
export type LookupVindexCreateResponseJson = {
};

/**
 * Describes the message vtctldata.LookupVindexCreateResponse.
 * Use `create(LookupVindexCreateResponseSchema)` to create a new message.
 */
export const LookupVindexCreateResponseSchema: GenMessage<LookupVindexCreateResponse, LookupVindexCreateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 132);

/**
 * @generated from message vtctldata.LookupVindexExternalizeRequest
 */
export type LookupVindexExternalizeRequest = Message<"vtctldata.LookupVindexExternalizeRequest"> & {
  /**
   * Where the lookup vindex lives.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * This is the name of the lookup vindex and the vreplication workflow.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Where the vreplication workflow lives.
   *
   * @generated from field: string table_keyspace = 3;
   */
  tableKeyspace: string;
};

/**
 * @generated from message vtctldata.LookupVindexExternalizeRequest
 */
export type LookupVindexExternalizeRequestJson = {
  /**
   * Where the lookup vindex lives.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * This is the name of the lookup vindex and the vreplication workflow.
   *
   * @generated from field: string name = 2;
   */
  name?: string;

  /**
   * Where the vreplication workflow lives.
   *
   * @generated from field: string table_keyspace = 3;
   */
  tableKeyspace?: string;
};

/**
 * Describes the message vtctldata.LookupVindexExternalizeRequest.
 * Use `create(LookupVindexExternalizeRequestSchema)` to create a new message.
 */
export const LookupVindexExternalizeRequestSchema: GenMessage<LookupVindexExternalizeRequest, LookupVindexExternalizeRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 133);

/**
 * @generated from message vtctldata.LookupVindexExternalizeResponse
 */
export type LookupVindexExternalizeResponse = Message<"vtctldata.LookupVindexExternalizeResponse"> & {
  /**
   * Was the workflow also deleted.
   *
   * @generated from field: bool workflow_deleted = 1;
   */
  workflowDeleted: boolean;
};

/**
 * @generated from message vtctldata.LookupVindexExternalizeResponse
 */
export type LookupVindexExternalizeResponseJson = {
  /**
   * Was the workflow also deleted.
   *
   * @generated from field: bool workflow_deleted = 1;
   */
  workflowDeleted?: boolean;
};

/**
 * Describes the message vtctldata.LookupVindexExternalizeResponse.
 * Use `create(LookupVindexExternalizeResponseSchema)` to create a new message.
 */
export const LookupVindexExternalizeResponseSchema: GenMessage<LookupVindexExternalizeResponse, LookupVindexExternalizeResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 134);

/**
 * @generated from message vtctldata.MaterializeCreateRequest
 */
export type MaterializeCreateRequest = Message<"vtctldata.MaterializeCreateRequest"> & {
  /**
   * @generated from field: vtctldata.MaterializeSettings settings = 1;
   */
  settings?: MaterializeSettings;
};

/**
 * @generated from message vtctldata.MaterializeCreateRequest
 */
export type MaterializeCreateRequestJson = {
  /**
   * @generated from field: vtctldata.MaterializeSettings settings = 1;
   */
  settings?: MaterializeSettingsJson;
};

/**
 * Describes the message vtctldata.MaterializeCreateRequest.
 * Use `create(MaterializeCreateRequestSchema)` to create a new message.
 */
export const MaterializeCreateRequestSchema: GenMessage<MaterializeCreateRequest, MaterializeCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 135);

/**
 * @generated from message vtctldata.MaterializeCreateResponse
 */
export type MaterializeCreateResponse = Message<"vtctldata.MaterializeCreateResponse"> & {
};

/**
 * @generated from message vtctldata.MaterializeCreateResponse
 */
export type MaterializeCreateResponseJson = {
};

/**
 * Describes the message vtctldata.MaterializeCreateResponse.
 * Use `create(MaterializeCreateResponseSchema)` to create a new message.
 */
export const MaterializeCreateResponseSchema: GenMessage<MaterializeCreateResponse, MaterializeCreateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 136);

/**
 * @generated from message vtctldata.MigrateCreateRequest
 */
export type MigrateCreateRequest = Message<"vtctldata.MigrateCreateRequest"> & {
  /**
   * The necessary info gets passed on to each primary tablet involved
   * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace: string;

  /**
   * @generated from field: string mount_name = 4;
   */
  mountName: string;

  /**
   * @generated from field: repeated string cells = 5;
   */
  cells: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * @generated from field: bool all_tables = 8;
   */
  allTables: boolean;

  /**
   * @generated from field: repeated string include_tables = 9;
   */
  includeTables: string[];

  /**
   * @generated from field: repeated string exclude_tables = 10;
   */
  excludeTables: string[];

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 11;
   */
  sourceTimeZone: string;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 12;
   */
  onDdl: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 13;
   */
  stopAfterCopy: boolean;

  /**
   * DropForeignKeys specifies if foreign key constraints should be elided on the target.
   *
   * @generated from field: bool drop_foreign_keys = 14;
   */
  dropForeignKeys: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 15;
   */
  deferSecondaryKeys: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 16;
   */
  autoStart: boolean;

  /**
   * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
   *
   * @generated from field: bool no_routing_rules = 17;
   */
  noRoutingRules: boolean;
};

/**
 * @generated from message vtctldata.MigrateCreateRequest
 */
export type MigrateCreateRequestJson = {
  /**
   * The necessary info gets passed on to each primary tablet involved
   * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace?: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: string mount_name = 4;
   */
  mountName?: string;

  /**
   * @generated from field: repeated string cells = 5;
   */
  cells?: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * @generated from field: bool all_tables = 8;
   */
  allTables?: boolean;

  /**
   * @generated from field: repeated string include_tables = 9;
   */
  includeTables?: string[];

  /**
   * @generated from field: repeated string exclude_tables = 10;
   */
  excludeTables?: string[];

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 11;
   */
  sourceTimeZone?: string;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 12;
   */
  onDdl?: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 13;
   */
  stopAfterCopy?: boolean;

  /**
   * DropForeignKeys specifies if foreign key constraints should be elided on the target.
   *
   * @generated from field: bool drop_foreign_keys = 14;
   */
  dropForeignKeys?: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 15;
   */
  deferSecondaryKeys?: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 16;
   */
  autoStart?: boolean;

  /**
   * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
   *
   * @generated from field: bool no_routing_rules = 17;
   */
  noRoutingRules?: boolean;
};

/**
 * Describes the message vtctldata.MigrateCreateRequest.
 * Use `create(MigrateCreateRequestSchema)` to create a new message.
 */
export const MigrateCreateRequestSchema: GenMessage<MigrateCreateRequest, MigrateCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 137);

/**
 * @generated from message vtctldata.MigrateCompleteRequest
 */
export type MigrateCompleteRequest = Message<"vtctldata.MigrateCompleteRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace: string;

  /**
   * @generated from field: bool keep_data = 4;
   */
  keepData: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 5;
   */
  keepRoutingRules: boolean;

  /**
   * @generated from field: bool rename_tables = 6;
   */
  renameTables: boolean;

  /**
   * @generated from field: bool dry_run = 7;
   */
  dryRun: boolean;
};

/**
 * @generated from message vtctldata.MigrateCompleteRequest
 */
export type MigrateCompleteRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: bool keep_data = 4;
   */
  keepData?: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 5;
   */
  keepRoutingRules?: boolean;

  /**
   * @generated from field: bool rename_tables = 6;
   */
  renameTables?: boolean;

  /**
   * @generated from field: bool dry_run = 7;
   */
  dryRun?: boolean;
};

/**
 * Describes the message vtctldata.MigrateCompleteRequest.
 * Use `create(MigrateCompleteRequestSchema)` to create a new message.
 */
export const MigrateCompleteRequestSchema: GenMessage<MigrateCompleteRequest, MigrateCompleteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 138);

/**
 * @generated from message vtctldata.MigrateCompleteResponse
 */
export type MigrateCompleteResponse = Message<"vtctldata.MigrateCompleteResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: repeated string dry_run_results = 2;
   */
  dryRunResults: string[];
};

/**
 * @generated from message vtctldata.MigrateCompleteResponse
 */
export type MigrateCompleteResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: repeated string dry_run_results = 2;
   */
  dryRunResults?: string[];
};

/**
 * Describes the message vtctldata.MigrateCompleteResponse.
 * Use `create(MigrateCompleteResponseSchema)` to create a new message.
 */
export const MigrateCompleteResponseSchema: GenMessage<MigrateCompleteResponse, MigrateCompleteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 139);

/**
 * @generated from message vtctldata.MountRegisterRequest
 */
export type MountRegisterRequest = Message<"vtctldata.MountRegisterRequest"> & {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType: string;

  /**
   * @generated from field: string topo_server = 2;
   */
  topoServer: string;

  /**
   * @generated from field: string topo_root = 3;
   */
  topoRoot: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * @generated from message vtctldata.MountRegisterRequest
 */
export type MountRegisterRequestJson = {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType?: string;

  /**
   * @generated from field: string topo_server = 2;
   */
  topoServer?: string;

  /**
   * @generated from field: string topo_root = 3;
   */
  topoRoot?: string;

  /**
   * @generated from field: string name = 4;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.MountRegisterRequest.
 * Use `create(MountRegisterRequestSchema)` to create a new message.
 */
export const MountRegisterRequestSchema: GenMessage<MountRegisterRequest, MountRegisterRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 140);

/**
 * @generated from message vtctldata.MountRegisterResponse
 */
export type MountRegisterResponse = Message<"vtctldata.MountRegisterResponse"> & {
};

/**
 * @generated from message vtctldata.MountRegisterResponse
 */
export type MountRegisterResponseJson = {
};

/**
 * Describes the message vtctldata.MountRegisterResponse.
 * Use `create(MountRegisterResponseSchema)` to create a new message.
 */
export const MountRegisterResponseSchema: GenMessage<MountRegisterResponse, MountRegisterResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 141);

/**
 * @generated from message vtctldata.MountUnregisterRequest
 */
export type MountUnregisterRequest = Message<"vtctldata.MountUnregisterRequest"> & {
  /**
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * @generated from message vtctldata.MountUnregisterRequest
 */
export type MountUnregisterRequestJson = {
  /**
   * @generated from field: string name = 4;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.MountUnregisterRequest.
 * Use `create(MountUnregisterRequestSchema)` to create a new message.
 */
export const MountUnregisterRequestSchema: GenMessage<MountUnregisterRequest, MountUnregisterRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 142);

/**
 * @generated from message vtctldata.MountUnregisterResponse
 */
export type MountUnregisterResponse = Message<"vtctldata.MountUnregisterResponse"> & {
};

/**
 * @generated from message vtctldata.MountUnregisterResponse
 */
export type MountUnregisterResponseJson = {
};

/**
 * Describes the message vtctldata.MountUnregisterResponse.
 * Use `create(MountUnregisterResponseSchema)` to create a new message.
 */
export const MountUnregisterResponseSchema: GenMessage<MountUnregisterResponse, MountUnregisterResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 143);

/**
 * @generated from message vtctldata.MountShowRequest
 */
export type MountShowRequest = Message<"vtctldata.MountShowRequest"> & {
  /**
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * @generated from message vtctldata.MountShowRequest
 */
export type MountShowRequestJson = {
  /**
   * @generated from field: string name = 4;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.MountShowRequest.
 * Use `create(MountShowRequestSchema)` to create a new message.
 */
export const MountShowRequestSchema: GenMessage<MountShowRequest, MountShowRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 144);

/**
 * @generated from message vtctldata.MountShowResponse
 */
export type MountShowResponse = Message<"vtctldata.MountShowResponse"> & {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType: string;

  /**
   * @generated from field: string topo_server = 2;
   */
  topoServer: string;

  /**
   * @generated from field: string topo_root = 3;
   */
  topoRoot: string;

  /**
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * @generated from message vtctldata.MountShowResponse
 */
export type MountShowResponseJson = {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType?: string;

  /**
   * @generated from field: string topo_server = 2;
   */
  topoServer?: string;

  /**
   * @generated from field: string topo_root = 3;
   */
  topoRoot?: string;

  /**
   * @generated from field: string name = 4;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.MountShowResponse.
 * Use `create(MountShowResponseSchema)` to create a new message.
 */
export const MountShowResponseSchema: GenMessage<MountShowResponse, MountShowResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 145);

/**
 * @generated from message vtctldata.MountListRequest
 */
export type MountListRequest = Message<"vtctldata.MountListRequest"> & {
};

/**
 * @generated from message vtctldata.MountListRequest
 */
export type MountListRequestJson = {
};

/**
 * Describes the message vtctldata.MountListRequest.
 * Use `create(MountListRequestSchema)` to create a new message.
 */
export const MountListRequestSchema: GenMessage<MountListRequest, MountListRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 146);

/**
 * @generated from message vtctldata.MountListResponse
 */
export type MountListResponse = Message<"vtctldata.MountListResponse"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * @generated from message vtctldata.MountListResponse
 */
export type MountListResponseJson = {
  /**
   * @generated from field: repeated string names = 1;
   */
  names?: string[];
};

/**
 * Describes the message vtctldata.MountListResponse.
 * Use `create(MountListResponseSchema)` to create a new message.
 */
export const MountListResponseSchema: GenMessage<MountListResponse, MountListResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 147);

/**
 * @generated from message vtctldata.MoveTablesCreateRequest
 */
export type MoveTablesCreateRequest = Message<"vtctldata.MoveTablesCreateRequest"> & {
  /**
   * The necessary info gets passed on to each primary tablet involved
   * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace: string;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 5;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 6;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * @generated from field: repeated string source_shards = 7;
   */
  sourceShards: string[];

  /**
   * @generated from field: bool all_tables = 8;
   */
  allTables: boolean;

  /**
   * @generated from field: repeated string include_tables = 9;
   */
  includeTables: string[];

  /**
   * @generated from field: repeated string exclude_tables = 10;
   */
  excludeTables: string[];

  /**
   * The name of the external cluster mounted in topo server.
   *
   * @generated from field: string external_cluster_name = 11;
   */
  externalClusterName: string;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 12;
   */
  sourceTimeZone: string;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 13;
   */
  onDdl: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 14;
   */
  stopAfterCopy: boolean;

  /**
   * DropForeignKeys specifies if foreign key constraints should be elided on the target.
   *
   * @generated from field: bool drop_foreign_keys = 15;
   */
  dropForeignKeys: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 16;
   */
  deferSecondaryKeys: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 17;
   */
  autoStart: boolean;

  /**
   * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
   *
   * @generated from field: bool no_routing_rules = 18;
   */
  noRoutingRules: boolean;

  /**
   * Run a single copy phase for the entire database.
   *
   * @generated from field: bool atomic_copy = 19;
   */
  atomicCopy: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 20;
   */
  workflowOptions?: WorkflowOptions;
};

/**
 * @generated from message vtctldata.MoveTablesCreateRequest
 */
export type MoveTablesCreateRequestJson = {
  /**
   * The necessary info gets passed on to each primary tablet involved
   * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string source_keyspace = 2;
   */
  sourceKeyspace?: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells?: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 5;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 6;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * @generated from field: repeated string source_shards = 7;
   */
  sourceShards?: string[];

  /**
   * @generated from field: bool all_tables = 8;
   */
  allTables?: boolean;

  /**
   * @generated from field: repeated string include_tables = 9;
   */
  includeTables?: string[];

  /**
   * @generated from field: repeated string exclude_tables = 10;
   */
  excludeTables?: string[];

  /**
   * The name of the external cluster mounted in topo server.
   *
   * @generated from field: string external_cluster_name = 11;
   */
  externalClusterName?: string;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 12;
   */
  sourceTimeZone?: string;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 13;
   */
  onDdl?: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 14;
   */
  stopAfterCopy?: boolean;

  /**
   * DropForeignKeys specifies if foreign key constraints should be elided on the target.
   *
   * @generated from field: bool drop_foreign_keys = 15;
   */
  dropForeignKeys?: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 16;
   */
  deferSecondaryKeys?: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 17;
   */
  autoStart?: boolean;

  /**
   * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
   *
   * @generated from field: bool no_routing_rules = 18;
   */
  noRoutingRules?: boolean;

  /**
   * Run a single copy phase for the entire database.
   *
   * @generated from field: bool atomic_copy = 19;
   */
  atomicCopy?: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 20;
   */
  workflowOptions?: WorkflowOptionsJson;
};

/**
 * Describes the message vtctldata.MoveTablesCreateRequest.
 * Use `create(MoveTablesCreateRequestSchema)` to create a new message.
 */
export const MoveTablesCreateRequestSchema: GenMessage<MoveTablesCreateRequest, MoveTablesCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 148);

/**
 * @generated from message vtctldata.MoveTablesCreateResponse
 */
export type MoveTablesCreateResponse = Message<"vtctldata.MoveTablesCreateResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: repeated vtctldata.MoveTablesCreateResponse.TabletInfo details = 2;
   */
  details: MoveTablesCreateResponse_TabletInfo[];
};

/**
 * @generated from message vtctldata.MoveTablesCreateResponse
 */
export type MoveTablesCreateResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: repeated vtctldata.MoveTablesCreateResponse.TabletInfo details = 2;
   */
  details?: MoveTablesCreateResponse_TabletInfoJson[];
};

/**
 * Describes the message vtctldata.MoveTablesCreateResponse.
 * Use `create(MoveTablesCreateResponseSchema)` to create a new message.
 */
export const MoveTablesCreateResponseSchema: GenMessage<MoveTablesCreateResponse, MoveTablesCreateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 149);

/**
 * @generated from message vtctldata.MoveTablesCreateResponse.TabletInfo
 */
export type MoveTablesCreateResponse_TabletInfo = Message<"vtctldata.MoveTablesCreateResponse.TabletInfo"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAlias;

  /**
   * Created is set if the workflow was created on this tablet or not.
   *
   * @generated from field: bool created = 2;
   */
  created: boolean;
};

/**
 * @generated from message vtctldata.MoveTablesCreateResponse.TabletInfo
 */
export type MoveTablesCreateResponse_TabletInfoJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAliasJson;

  /**
   * Created is set if the workflow was created on this tablet or not.
   *
   * @generated from field: bool created = 2;
   */
  created?: boolean;
};

/**
 * Describes the message vtctldata.MoveTablesCreateResponse.TabletInfo.
 * Use `create(MoveTablesCreateResponse_TabletInfoSchema)` to create a new message.
 */
export const MoveTablesCreateResponse_TabletInfoSchema: GenMessage<MoveTablesCreateResponse_TabletInfo, MoveTablesCreateResponse_TabletInfoJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 149, 0);

/**
 * @generated from message vtctldata.MoveTablesCompleteRequest
 */
export type MoveTablesCompleteRequest = Message<"vtctldata.MoveTablesCompleteRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace: string;

  /**
   * @generated from field: bool keep_data = 4;
   */
  keepData: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 5;
   */
  keepRoutingRules: boolean;

  /**
   * @generated from field: bool rename_tables = 6;
   */
  renameTables: boolean;

  /**
   * @generated from field: bool dry_run = 7;
   */
  dryRun: boolean;

  /**
   * @generated from field: repeated string shards = 8;
   */
  shards: string[];
};

/**
 * @generated from message vtctldata.MoveTablesCompleteRequest
 */
export type MoveTablesCompleteRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 3;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: bool keep_data = 4;
   */
  keepData?: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 5;
   */
  keepRoutingRules?: boolean;

  /**
   * @generated from field: bool rename_tables = 6;
   */
  renameTables?: boolean;

  /**
   * @generated from field: bool dry_run = 7;
   */
  dryRun?: boolean;

  /**
   * @generated from field: repeated string shards = 8;
   */
  shards?: string[];
};

/**
 * Describes the message vtctldata.MoveTablesCompleteRequest.
 * Use `create(MoveTablesCompleteRequestSchema)` to create a new message.
 */
export const MoveTablesCompleteRequestSchema: GenMessage<MoveTablesCompleteRequest, MoveTablesCompleteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 150);

/**
 * @generated from message vtctldata.MoveTablesCompleteResponse
 */
export type MoveTablesCompleteResponse = Message<"vtctldata.MoveTablesCompleteResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: repeated string dry_run_results = 2;
   */
  dryRunResults: string[];
};

/**
 * @generated from message vtctldata.MoveTablesCompleteResponse
 */
export type MoveTablesCompleteResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: repeated string dry_run_results = 2;
   */
  dryRunResults?: string[];
};

/**
 * Describes the message vtctldata.MoveTablesCompleteResponse.
 * Use `create(MoveTablesCompleteResponseSchema)` to create a new message.
 */
export const MoveTablesCompleteResponseSchema: GenMessage<MoveTablesCompleteResponse, MoveTablesCompleteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 151);

/**
 * @generated from message vtctldata.PingTabletRequest
 */
export type PingTabletRequest = Message<"vtctldata.PingTabletRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.PingTabletRequest
 */
export type PingTabletRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.PingTabletRequest.
 * Use `create(PingTabletRequestSchema)` to create a new message.
 */
export const PingTabletRequestSchema: GenMessage<PingTabletRequest, PingTabletRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 152);

/**
 * @generated from message vtctldata.PingTabletResponse
 */
export type PingTabletResponse = Message<"vtctldata.PingTabletResponse"> & {
};

/**
 * @generated from message vtctldata.PingTabletResponse
 */
export type PingTabletResponseJson = {
};

/**
 * Describes the message vtctldata.PingTabletResponse.
 * Use `create(PingTabletResponseSchema)` to create a new message.
 */
export const PingTabletResponseSchema: GenMessage<PingTabletResponse, PingTabletResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 153);

/**
 * @generated from message vtctldata.PlannedReparentShardRequest
 */
export type PlannedReparentShardRequest = Message<"vtctldata.PlannedReparentShardRequest"> & {
  /**
   * Keyspace is the name of the keyspace to perform the Planned Reparent in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard to perform teh Planned Reparent in.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * NewPrimary is the alias of the tablet to promote to shard primary. If not
   * specified, the vtctld will select the most up-to-date candidate to promote.
   *
   * It is an error to set NewPrimary and AvoidPrimary to the same alias.
   *
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAlias;

  /**
   * AvoidPrimary is the alias of the tablet to demote. In other words,
   * specifying an AvoidPrimary alias tells the vtctld to promote any replica
   * other than this one. A shard whose current primary is not this one is then
   * a no-op.
   *
   * It is an error to set NewPrimary and AvoidPrimary to the same alias.
   *
   * @generated from field: topodata.TabletAlias avoid_primary = 4;
   */
  avoidPrimary?: TabletAlias;

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in replication both before and after the reparent. The timeout is not
   * cumulative across both wait periods, meaning that the replicas have
   * WaitReplicasTimeout time to catch up before the reparent, and an additional
   * WaitReplicasTimeout time to catch up after the reparent.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: Duration;

  /**
   * TolerableReplicationLag is the amount of replication lag that is considered
   * acceptable for a tablet to be eligible for promotion when Vitess makes the choice of a new primary.
   * A value of 0 indicates that Vitess shouldn't consider the replication lag at all.
   *
   * @generated from field: vttime.Duration tolerable_replication_lag = 6;
   */
  tolerableReplicationLag?: Duration;

  /**
   * AllowCrossCellPromotion allows cross cell promotion,
   *
   * @generated from field: bool allow_cross_cell_promotion = 7;
   */
  allowCrossCellPromotion: boolean;

  /**
   * ExpectedPrimary is the optional alias we expect to be the current primary in order for
   * the reparent operation to succeed.
   *
   * @generated from field: topodata.TabletAlias expected_primary = 8;
   */
  expectedPrimary?: TabletAlias;
};

/**
 * @generated from message vtctldata.PlannedReparentShardRequest
 */
export type PlannedReparentShardRequestJson = {
  /**
   * Keyspace is the name of the keyspace to perform the Planned Reparent in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard to perform teh Planned Reparent in.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * NewPrimary is the alias of the tablet to promote to shard primary. If not
   * specified, the vtctld will select the most up-to-date candidate to promote.
   *
   * It is an error to set NewPrimary and AvoidPrimary to the same alias.
   *
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAliasJson;

  /**
   * AvoidPrimary is the alias of the tablet to demote. In other words,
   * specifying an AvoidPrimary alias tells the vtctld to promote any replica
   * other than this one. A shard whose current primary is not this one is then
   * a no-op.
   *
   * It is an error to set NewPrimary and AvoidPrimary to the same alias.
   *
   * @generated from field: topodata.TabletAlias avoid_primary = 4;
   */
  avoidPrimary?: TabletAliasJson;

  /**
   * WaitReplicasTimeout is the duration of time to wait for replicas to catch
   * up in replication both before and after the reparent. The timeout is not
   * cumulative across both wait periods, meaning that the replicas have
   * WaitReplicasTimeout time to catch up before the reparent, and an additional
   * WaitReplicasTimeout time to catch up after the reparent.
   *
   * @generated from field: vttime.Duration wait_replicas_timeout = 5;
   */
  waitReplicasTimeout?: DurationJson;

  /**
   * TolerableReplicationLag is the amount of replication lag that is considered
   * acceptable for a tablet to be eligible for promotion when Vitess makes the choice of a new primary.
   * A value of 0 indicates that Vitess shouldn't consider the replication lag at all.
   *
   * @generated from field: vttime.Duration tolerable_replication_lag = 6;
   */
  tolerableReplicationLag?: DurationJson;

  /**
   * AllowCrossCellPromotion allows cross cell promotion,
   *
   * @generated from field: bool allow_cross_cell_promotion = 7;
   */
  allowCrossCellPromotion?: boolean;

  /**
   * ExpectedPrimary is the optional alias we expect to be the current primary in order for
   * the reparent operation to succeed.
   *
   * @generated from field: topodata.TabletAlias expected_primary = 8;
   */
  expectedPrimary?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.PlannedReparentShardRequest.
 * Use `create(PlannedReparentShardRequestSchema)` to create a new message.
 */
export const PlannedReparentShardRequestSchema: GenMessage<PlannedReparentShardRequest, PlannedReparentShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 154);

/**
 * @generated from message vtctldata.PlannedReparentShardResponse
 */
export type PlannedReparentShardResponse = Message<"vtctldata.PlannedReparentShardResponse"> & {
  /**
   * Keyspace is the name of the keyspace the Planned Reparent took place in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard the Planned Reparent took place in.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * PromotedPrimary is the alias of the tablet that was promoted to shard
   * primary. If NewPrimary was set in the request, then this will be the same
   * alias. Otherwise, it will be the alias of the tablet found to be most
   * up-to-date.
   *
   * @generated from field: topodata.TabletAlias promoted_primary = 3;
   */
  promotedPrimary?: TabletAlias;

  /**
   * @generated from field: repeated logutil.Event events = 4;
   */
  events: Event[];
};

/**
 * @generated from message vtctldata.PlannedReparentShardResponse
 */
export type PlannedReparentShardResponseJson = {
  /**
   * Keyspace is the name of the keyspace the Planned Reparent took place in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard the Planned Reparent took place in.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * PromotedPrimary is the alias of the tablet that was promoted to shard
   * primary. If NewPrimary was set in the request, then this will be the same
   * alias. Otherwise, it will be the alias of the tablet found to be most
   * up-to-date.
   *
   * @generated from field: topodata.TabletAlias promoted_primary = 3;
   */
  promotedPrimary?: TabletAliasJson;

  /**
   * @generated from field: repeated logutil.Event events = 4;
   */
  events?: EventJson[];
};

/**
 * Describes the message vtctldata.PlannedReparentShardResponse.
 * Use `create(PlannedReparentShardResponseSchema)` to create a new message.
 */
export const PlannedReparentShardResponseSchema: GenMessage<PlannedReparentShardResponse, PlannedReparentShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 155);

/**
 * @generated from message vtctldata.RebuildKeyspaceGraphRequest
 */
export type RebuildKeyspaceGraphRequest = Message<"vtctldata.RebuildKeyspaceGraphRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];

  /**
   * AllowPartial, when set, allows a SNAPSHOT keyspace to serve with an
   * incomplete set of shards. It is ignored for all other keyspace types.
   *
   * @generated from field: bool allow_partial = 3;
   */
  allowPartial: boolean;
};

/**
 * @generated from message vtctldata.RebuildKeyspaceGraphRequest
 */
export type RebuildKeyspaceGraphRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];

  /**
   * AllowPartial, when set, allows a SNAPSHOT keyspace to serve with an
   * incomplete set of shards. It is ignored for all other keyspace types.
   *
   * @generated from field: bool allow_partial = 3;
   */
  allowPartial?: boolean;
};

/**
 * Describes the message vtctldata.RebuildKeyspaceGraphRequest.
 * Use `create(RebuildKeyspaceGraphRequestSchema)` to create a new message.
 */
export const RebuildKeyspaceGraphRequestSchema: GenMessage<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 156);

/**
 * @generated from message vtctldata.RebuildKeyspaceGraphResponse
 */
export type RebuildKeyspaceGraphResponse = Message<"vtctldata.RebuildKeyspaceGraphResponse"> & {
};

/**
 * @generated from message vtctldata.RebuildKeyspaceGraphResponse
 */
export type RebuildKeyspaceGraphResponseJson = {
};

/**
 * Describes the message vtctldata.RebuildKeyspaceGraphResponse.
 * Use `create(RebuildKeyspaceGraphResponseSchema)` to create a new message.
 */
export const RebuildKeyspaceGraphResponseSchema: GenMessage<RebuildKeyspaceGraphResponse, RebuildKeyspaceGraphResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 157);

/**
 * @generated from message vtctldata.RebuildVSchemaGraphRequest
 */
export type RebuildVSchemaGraphRequest = Message<"vtctldata.RebuildVSchemaGraphRequest"> & {
  /**
   * Cells specifies the cells to rebuild the SrvVSchema objects for. If empty,
   * RebuildVSchemaGraph rebuilds the SrvVSchema for every cell in the topo.
   *
   * @generated from field: repeated string cells = 1;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.RebuildVSchemaGraphRequest
 */
export type RebuildVSchemaGraphRequestJson = {
  /**
   * Cells specifies the cells to rebuild the SrvVSchema objects for. If empty,
   * RebuildVSchemaGraph rebuilds the SrvVSchema for every cell in the topo.
   *
   * @generated from field: repeated string cells = 1;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.RebuildVSchemaGraphRequest.
 * Use `create(RebuildVSchemaGraphRequestSchema)` to create a new message.
 */
export const RebuildVSchemaGraphRequestSchema: GenMessage<RebuildVSchemaGraphRequest, RebuildVSchemaGraphRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 158);

/**
 * @generated from message vtctldata.RebuildVSchemaGraphResponse
 */
export type RebuildVSchemaGraphResponse = Message<"vtctldata.RebuildVSchemaGraphResponse"> & {
};

/**
 * @generated from message vtctldata.RebuildVSchemaGraphResponse
 */
export type RebuildVSchemaGraphResponseJson = {
};

/**
 * Describes the message vtctldata.RebuildVSchemaGraphResponse.
 * Use `create(RebuildVSchemaGraphResponseSchema)` to create a new message.
 */
export const RebuildVSchemaGraphResponseSchema: GenMessage<RebuildVSchemaGraphResponse, RebuildVSchemaGraphResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 159);

/**
 * @generated from message vtctldata.RefreshStateRequest
 */
export type RefreshStateRequest = Message<"vtctldata.RefreshStateRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.RefreshStateRequest
 */
export type RefreshStateRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.RefreshStateRequest.
 * Use `create(RefreshStateRequestSchema)` to create a new message.
 */
export const RefreshStateRequestSchema: GenMessage<RefreshStateRequest, RefreshStateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 160);

/**
 * @generated from message vtctldata.RefreshStateResponse
 */
export type RefreshStateResponse = Message<"vtctldata.RefreshStateResponse"> & {
};

/**
 * @generated from message vtctldata.RefreshStateResponse
 */
export type RefreshStateResponseJson = {
};

/**
 * Describes the message vtctldata.RefreshStateResponse.
 * Use `create(RefreshStateResponseSchema)` to create a new message.
 */
export const RefreshStateResponseSchema: GenMessage<RefreshStateResponse, RefreshStateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 161);

/**
 * @generated from message vtctldata.RefreshStateByShardRequest
 */
export type RefreshStateByShardRequest = Message<"vtctldata.RefreshStateByShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells: string[];
};

/**
 * @generated from message vtctldata.RefreshStateByShardRequest
 */
export type RefreshStateByShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells?: string[];
};

/**
 * Describes the message vtctldata.RefreshStateByShardRequest.
 * Use `create(RefreshStateByShardRequestSchema)` to create a new message.
 */
export const RefreshStateByShardRequestSchema: GenMessage<RefreshStateByShardRequest, RefreshStateByShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 162);

/**
 * @generated from message vtctldata.RefreshStateByShardResponse
 */
export type RefreshStateByShardResponse = Message<"vtctldata.RefreshStateByShardResponse"> & {
  /**
   * @generated from field: bool is_partial_refresh = 1;
   */
  isPartialRefresh: boolean;

  /**
   * This explains why we had a partial refresh (if we did)
   *
   * @generated from field: string partial_refresh_details = 2;
   */
  partialRefreshDetails: string;
};

/**
 * @generated from message vtctldata.RefreshStateByShardResponse
 */
export type RefreshStateByShardResponseJson = {
  /**
   * @generated from field: bool is_partial_refresh = 1;
   */
  isPartialRefresh?: boolean;

  /**
   * This explains why we had a partial refresh (if we did)
   *
   * @generated from field: string partial_refresh_details = 2;
   */
  partialRefreshDetails?: string;
};

/**
 * Describes the message vtctldata.RefreshStateByShardResponse.
 * Use `create(RefreshStateByShardResponseSchema)` to create a new message.
 */
export const RefreshStateByShardResponseSchema: GenMessage<RefreshStateByShardResponse, RefreshStateByShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 163);

/**
 * @generated from message vtctldata.ReloadSchemaRequest
 */
export type ReloadSchemaRequest = Message<"vtctldata.ReloadSchemaRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.ReloadSchemaRequest
 */
export type ReloadSchemaRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.ReloadSchemaRequest.
 * Use `create(ReloadSchemaRequestSchema)` to create a new message.
 */
export const ReloadSchemaRequestSchema: GenMessage<ReloadSchemaRequest, ReloadSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 164);

/**
 * @generated from message vtctldata.ReloadSchemaResponse
 */
export type ReloadSchemaResponse = Message<"vtctldata.ReloadSchemaResponse"> & {
};

/**
 * @generated from message vtctldata.ReloadSchemaResponse
 */
export type ReloadSchemaResponseJson = {
};

/**
 * Describes the message vtctldata.ReloadSchemaResponse.
 * Use `create(ReloadSchemaResponseSchema)` to create a new message.
 */
export const ReloadSchemaResponseSchema: GenMessage<ReloadSchemaResponse, ReloadSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 165);

/**
 * @generated from message vtctldata.ReloadSchemaKeyspaceRequest
 */
export type ReloadSchemaKeyspaceRequest = Message<"vtctldata.ReloadSchemaKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string wait_position = 2;
   */
  waitPosition: string;

  /**
   * @generated from field: bool include_primary = 3;
   */
  includePrimary: boolean;

  /**
   * Concurrency is the global concurrency across all shards in the keyspace
   * (so, at most this many tablets will be reloaded across the keyspace at any
   * given point).
   *
   * @generated from field: int32 concurrency = 4;
   */
  concurrency: number;
};

/**
 * @generated from message vtctldata.ReloadSchemaKeyspaceRequest
 */
export type ReloadSchemaKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string wait_position = 2;
   */
  waitPosition?: string;

  /**
   * @generated from field: bool include_primary = 3;
   */
  includePrimary?: boolean;

  /**
   * Concurrency is the global concurrency across all shards in the keyspace
   * (so, at most this many tablets will be reloaded across the keyspace at any
   * given point).
   *
   * @generated from field: int32 concurrency = 4;
   */
  concurrency?: number;
};

/**
 * Describes the message vtctldata.ReloadSchemaKeyspaceRequest.
 * Use `create(ReloadSchemaKeyspaceRequestSchema)` to create a new message.
 */
export const ReloadSchemaKeyspaceRequestSchema: GenMessage<ReloadSchemaKeyspaceRequest, ReloadSchemaKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 166);

/**
 * @generated from message vtctldata.ReloadSchemaKeyspaceResponse
 */
export type ReloadSchemaKeyspaceResponse = Message<"vtctldata.ReloadSchemaKeyspaceResponse"> & {
  /**
   * @generated from field: repeated logutil.Event events = 1;
   */
  events: Event[];
};

/**
 * @generated from message vtctldata.ReloadSchemaKeyspaceResponse
 */
export type ReloadSchemaKeyspaceResponseJson = {
  /**
   * @generated from field: repeated logutil.Event events = 1;
   */
  events?: EventJson[];
};

/**
 * Describes the message vtctldata.ReloadSchemaKeyspaceResponse.
 * Use `create(ReloadSchemaKeyspaceResponseSchema)` to create a new message.
 */
export const ReloadSchemaKeyspaceResponseSchema: GenMessage<ReloadSchemaKeyspaceResponse, ReloadSchemaKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 167);

/**
 * @generated from message vtctldata.ReloadSchemaShardRequest
 */
export type ReloadSchemaShardRequest = Message<"vtctldata.ReloadSchemaShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: string wait_position = 3;
   */
  waitPosition: string;

  /**
   * @generated from field: bool include_primary = 4;
   */
  includePrimary: boolean;

  /**
   * Concurrency is the maximum number of tablets to reload at one time.
   *
   * @generated from field: int32 concurrency = 5;
   */
  concurrency: number;
};

/**
 * @generated from message vtctldata.ReloadSchemaShardRequest
 */
export type ReloadSchemaShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: string wait_position = 3;
   */
  waitPosition?: string;

  /**
   * @generated from field: bool include_primary = 4;
   */
  includePrimary?: boolean;

  /**
   * Concurrency is the maximum number of tablets to reload at one time.
   *
   * @generated from field: int32 concurrency = 5;
   */
  concurrency?: number;
};

/**
 * Describes the message vtctldata.ReloadSchemaShardRequest.
 * Use `create(ReloadSchemaShardRequestSchema)` to create a new message.
 */
export const ReloadSchemaShardRequestSchema: GenMessage<ReloadSchemaShardRequest, ReloadSchemaShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 168);

/**
 * @generated from message vtctldata.ReloadSchemaShardResponse
 */
export type ReloadSchemaShardResponse = Message<"vtctldata.ReloadSchemaShardResponse"> & {
  /**
   * @generated from field: repeated logutil.Event events = 2;
   */
  events: Event[];
};

/**
 * @generated from message vtctldata.ReloadSchemaShardResponse
 */
export type ReloadSchemaShardResponseJson = {
  /**
   * @generated from field: repeated logutil.Event events = 2;
   */
  events?: EventJson[];
};

/**
 * Describes the message vtctldata.ReloadSchemaShardResponse.
 * Use `create(ReloadSchemaShardResponseSchema)` to create a new message.
 */
export const ReloadSchemaShardResponseSchema: GenMessage<ReloadSchemaShardResponse, ReloadSchemaShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 169);

/**
 * @generated from message vtctldata.RemoveBackupRequest
 */
export type RemoveBackupRequest = Message<"vtctldata.RemoveBackupRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * @generated from message vtctldata.RemoveBackupRequest
 */
export type RemoveBackupRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: string name = 3;
   */
  name?: string;
};

/**
 * Describes the message vtctldata.RemoveBackupRequest.
 * Use `create(RemoveBackupRequestSchema)` to create a new message.
 */
export const RemoveBackupRequestSchema: GenMessage<RemoveBackupRequest, RemoveBackupRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 170);

/**
 * @generated from message vtctldata.RemoveBackupResponse
 */
export type RemoveBackupResponse = Message<"vtctldata.RemoveBackupResponse"> & {
};

/**
 * @generated from message vtctldata.RemoveBackupResponse
 */
export type RemoveBackupResponseJson = {
};

/**
 * Describes the message vtctldata.RemoveBackupResponse.
 * Use `create(RemoveBackupResponseSchema)` to create a new message.
 */
export const RemoveBackupResponseSchema: GenMessage<RemoveBackupResponse, RemoveBackupResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 171);

/**
 * @generated from message vtctldata.RemoveKeyspaceCellRequest
 */
export type RemoveKeyspaceCellRequest = Message<"vtctldata.RemoveKeyspaceCellRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string cell = 2;
   */
  cell: string;

  /**
   * Force proceeds even if the cell's topology server cannot be reached. This
   * should only be set if a cell has been shut down entirely, and the global
   * topology data just needs to be updated.
   *
   * @generated from field: bool force = 3;
   */
  force: boolean;

  /**
   * Recursive also deletes all tablets in that cell belonging to the specified
   * keyspace.
   *
   * @generated from field: bool recursive = 4;
   */
  recursive: boolean;
};

/**
 * @generated from message vtctldata.RemoveKeyspaceCellRequest
 */
export type RemoveKeyspaceCellRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string cell = 2;
   */
  cell?: string;

  /**
   * Force proceeds even if the cell's topology server cannot be reached. This
   * should only be set if a cell has been shut down entirely, and the global
   * topology data just needs to be updated.
   *
   * @generated from field: bool force = 3;
   */
  force?: boolean;

  /**
   * Recursive also deletes all tablets in that cell belonging to the specified
   * keyspace.
   *
   * @generated from field: bool recursive = 4;
   */
  recursive?: boolean;
};

/**
 * Describes the message vtctldata.RemoveKeyspaceCellRequest.
 * Use `create(RemoveKeyspaceCellRequestSchema)` to create a new message.
 */
export const RemoveKeyspaceCellRequestSchema: GenMessage<RemoveKeyspaceCellRequest, RemoveKeyspaceCellRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 172);

/**
 * (TODO:@amason) Consider including the deleted SrvKeyspace object and any
 * deleted Tablet objects here.
 *
 * @generated from message vtctldata.RemoveKeyspaceCellResponse
 */
export type RemoveKeyspaceCellResponse = Message<"vtctldata.RemoveKeyspaceCellResponse"> & {
};

/**
 * (TODO:@amason) Consider including the deleted SrvKeyspace object and any
 * deleted Tablet objects here.
 *
 * @generated from message vtctldata.RemoveKeyspaceCellResponse
 */
export type RemoveKeyspaceCellResponseJson = {
};

/**
 * Describes the message vtctldata.RemoveKeyspaceCellResponse.
 * Use `create(RemoveKeyspaceCellResponseSchema)` to create a new message.
 */
export const RemoveKeyspaceCellResponseSchema: GenMessage<RemoveKeyspaceCellResponse, RemoveKeyspaceCellResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 173);

/**
 * @generated from message vtctldata.RemoveShardCellRequest
 */
export type RemoveShardCellRequest = Message<"vtctldata.RemoveShardCellRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard_name = 2;
   */
  shardName: string;

  /**
   * @generated from field: string cell = 3;
   */
  cell: string;

  /**
   * Force proceeds even if the cell's topology server cannot be reached. This
   * should only be set if a cell has been shut down entirely, and the global
   * topology data just needs to be updated.
   *
   * @generated from field: bool force = 4;
   */
  force: boolean;

  /**
   * Recursive also deletes all tablets in that cell belonging to the specified
   * keyspace and shard.
   *
   * @generated from field: bool recursive = 5;
   */
  recursive: boolean;
};

/**
 * @generated from message vtctldata.RemoveShardCellRequest
 */
export type RemoveShardCellRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard_name = 2;
   */
  shardName?: string;

  /**
   * @generated from field: string cell = 3;
   */
  cell?: string;

  /**
   * Force proceeds even if the cell's topology server cannot be reached. This
   * should only be set if a cell has been shut down entirely, and the global
   * topology data just needs to be updated.
   *
   * @generated from field: bool force = 4;
   */
  force?: boolean;

  /**
   * Recursive also deletes all tablets in that cell belonging to the specified
   * keyspace and shard.
   *
   * @generated from field: bool recursive = 5;
   */
  recursive?: boolean;
};

/**
 * Describes the message vtctldata.RemoveShardCellRequest.
 * Use `create(RemoveShardCellRequestSchema)` to create a new message.
 */
export const RemoveShardCellRequestSchema: GenMessage<RemoveShardCellRequest, RemoveShardCellRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 174);

/**
 * (TODO:@amason) Consider including the deleted SrvKeyspacePartitions objects
 * and any deleted Tablet objects here.
 *
 * @generated from message vtctldata.RemoveShardCellResponse
 */
export type RemoveShardCellResponse = Message<"vtctldata.RemoveShardCellResponse"> & {
};

/**
 * (TODO:@amason) Consider including the deleted SrvKeyspacePartitions objects
 * and any deleted Tablet objects here.
 *
 * @generated from message vtctldata.RemoveShardCellResponse
 */
export type RemoveShardCellResponseJson = {
};

/**
 * Describes the message vtctldata.RemoveShardCellResponse.
 * Use `create(RemoveShardCellResponseSchema)` to create a new message.
 */
export const RemoveShardCellResponseSchema: GenMessage<RemoveShardCellResponse, RemoveShardCellResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 175);

/**
 * @generated from message vtctldata.ReparentTabletRequest
 */
export type ReparentTabletRequest = Message<"vtctldata.ReparentTabletRequest"> & {
  /**
   * Tablet is the alias of the tablet that should be reparented under the
   * current shard primary.
   *
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAlias;
};

/**
 * @generated from message vtctldata.ReparentTabletRequest
 */
export type ReparentTabletRequestJson = {
  /**
   * Tablet is the alias of the tablet that should be reparented under the
   * current shard primary.
   *
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.ReparentTabletRequest.
 * Use `create(ReparentTabletRequestSchema)` to create a new message.
 */
export const ReparentTabletRequestSchema: GenMessage<ReparentTabletRequest, ReparentTabletRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 176);

/**
 * @generated from message vtctldata.ReparentTabletResponse
 */
export type ReparentTabletResponse = Message<"vtctldata.ReparentTabletResponse"> & {
  /**
   * Keyspace is the name of the keyspace the tablet was reparented in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * Shard is the name of the shard the tablet was reparented in.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * Primary is the alias of the tablet that the tablet was reparented under.
   *
   * @generated from field: topodata.TabletAlias primary = 3;
   */
  primary?: TabletAlias;
};

/**
 * @generated from message vtctldata.ReparentTabletResponse
 */
export type ReparentTabletResponseJson = {
  /**
   * Keyspace is the name of the keyspace the tablet was reparented in.
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * Shard is the name of the shard the tablet was reparented in.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * Primary is the alias of the tablet that the tablet was reparented under.
   *
   * @generated from field: topodata.TabletAlias primary = 3;
   */
  primary?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.ReparentTabletResponse.
 * Use `create(ReparentTabletResponseSchema)` to create a new message.
 */
export const ReparentTabletResponseSchema: GenMessage<ReparentTabletResponse, ReparentTabletResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 177);

/**
 * @generated from message vtctldata.ReshardCreateRequest
 */
export type ReshardCreateRequest = Message<"vtctldata.ReshardCreateRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace: string;

  /**
   * @generated from field: repeated string source_shards = 3;
   */
  sourceShards: string[];

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards: string[];

  /**
   * @generated from field: repeated string cells = 5;
   */
  cells: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * SkipSchemaCopy specifies if the schema should be copied from the source shard, set false if
   * schema is already created on the target shard before Reshard is invoked.
   *
   * @generated from field: bool skip_schema_copy = 8;
   */
  skipSchemaCopy: boolean;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 9;
   */
  onDdl: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 10;
   */
  stopAfterCopy: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 11;
   */
  deferSecondaryKeys: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 12;
   */
  autoStart: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 13;
   */
  workflowOptions?: WorkflowOptions;
};

/**
 * @generated from message vtctldata.ReshardCreateRequest
 */
export type ReshardCreateRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace?: string;

  /**
   * @generated from field: repeated string source_shards = 3;
   */
  sourceShards?: string[];

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards?: string[];

  /**
   * @generated from field: repeated string cells = 5;
   */
  cells?: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * SkipSchemaCopy specifies if the schema should be copied from the source shard, set false if
   * schema is already created on the target shard before Reshard is invoked.
   *
   * @generated from field: bool skip_schema_copy = 8;
   */
  skipSchemaCopy?: boolean;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: string on_ddl = 9;
   */
  onDdl?: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped after copying.
   *
   * @generated from field: bool stop_after_copy = 10;
   */
  stopAfterCopy?: boolean;

  /**
   * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
   *
   * @generated from field: bool defer_secondary_keys = 11;
   */
  deferSecondaryKeys?: boolean;

  /**
   * Start the workflow after creating it.
   *
   * @generated from field: bool auto_start = 12;
   */
  autoStart?: boolean;

  /**
   * @generated from field: vtctldata.WorkflowOptions workflow_options = 13;
   */
  workflowOptions?: WorkflowOptionsJson;
};

/**
 * Describes the message vtctldata.ReshardCreateRequest.
 * Use `create(ReshardCreateRequestSchema)` to create a new message.
 */
export const ReshardCreateRequestSchema: GenMessage<ReshardCreateRequest, ReshardCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 178);

/**
 * @generated from message vtctldata.RestoreFromBackupRequest
 */
export type RestoreFromBackupRequest = Message<"vtctldata.RestoreFromBackupRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * BackupTime, if set, will use the backup taken most closely at or before
   * this time. If nil, the latest backup will be restored on the tablet.
   *
   * @generated from field: vttime.Time backup_time = 2;
   */
  backupTime?: Time;

  /**
   * RestoreToPos indicates a position for a point-in-time recovery. The recovery
   * is expected to utilize one full backup, followed by zero or more incremental backups,
   * that reach the precise desired position
   *
   * @generated from field: string restore_to_pos = 3;
   */
  restoreToPos: string;

  /**
   * Dry run does not actually performs the restore, but validates the steps and availability of backups
   *
   * @generated from field: bool dry_run = 4;
   */
  dryRun: boolean;

  /**
   * RestoreToTimestamp, if given, requested an inremental restore up to (and excluding) the given timestamp.
   * RestoreToTimestamp and RestoreToPos are mutually exclusive.
   *
   * @generated from field: vttime.Time restore_to_timestamp = 5;
   */
  restoreToTimestamp?: Time;

  /**
   * AllowedBackupEngines, if present will filter out any backups taken with engines not included in the list
   *
   * @generated from field: repeated string allowed_backup_engines = 6;
   */
  allowedBackupEngines: string[];
};

/**
 * @generated from message vtctldata.RestoreFromBackupRequest
 */
export type RestoreFromBackupRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * BackupTime, if set, will use the backup taken most closely at or before
   * this time. If nil, the latest backup will be restored on the tablet.
   *
   * @generated from field: vttime.Time backup_time = 2;
   */
  backupTime?: TimeJson;

  /**
   * RestoreToPos indicates a position for a point-in-time recovery. The recovery
   * is expected to utilize one full backup, followed by zero or more incremental backups,
   * that reach the precise desired position
   *
   * @generated from field: string restore_to_pos = 3;
   */
  restoreToPos?: string;

  /**
   * Dry run does not actually performs the restore, but validates the steps and availability of backups
   *
   * @generated from field: bool dry_run = 4;
   */
  dryRun?: boolean;

  /**
   * RestoreToTimestamp, if given, requested an inremental restore up to (and excluding) the given timestamp.
   * RestoreToTimestamp and RestoreToPos are mutually exclusive.
   *
   * @generated from field: vttime.Time restore_to_timestamp = 5;
   */
  restoreToTimestamp?: TimeJson;

  /**
   * AllowedBackupEngines, if present will filter out any backups taken with engines not included in the list
   *
   * @generated from field: repeated string allowed_backup_engines = 6;
   */
  allowedBackupEngines?: string[];
};

/**
 * Describes the message vtctldata.RestoreFromBackupRequest.
 * Use `create(RestoreFromBackupRequestSchema)` to create a new message.
 */
export const RestoreFromBackupRequestSchema: GenMessage<RestoreFromBackupRequest, RestoreFromBackupRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 179);

/**
 * @generated from message vtctldata.RestoreFromBackupResponse
 */
export type RestoreFromBackupResponse = Message<"vtctldata.RestoreFromBackupResponse"> & {
  /**
   * TabletAlias is the alias of the tablet doing the restore.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard: string;

  /**
   * @generated from field: logutil.Event event = 4;
   */
  event?: Event;
};

/**
 * @generated from message vtctldata.RestoreFromBackupResponse
 */
export type RestoreFromBackupResponseJson = {
  /**
   * TabletAlias is the alias of the tablet doing the restore.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: string keyspace = 2;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 3;
   */
  shard?: string;

  /**
   * @generated from field: logutil.Event event = 4;
   */
  event?: EventJson;
};

/**
 * Describes the message vtctldata.RestoreFromBackupResponse.
 * Use `create(RestoreFromBackupResponseSchema)` to create a new message.
 */
export const RestoreFromBackupResponseSchema: GenMessage<RestoreFromBackupResponse, RestoreFromBackupResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 180);

/**
 * @generated from message vtctldata.RetrySchemaMigrationRequest
 */
export type RetrySchemaMigrationRequest = Message<"vtctldata.RetrySchemaMigrationRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid: string;
};

/**
 * @generated from message vtctldata.RetrySchemaMigrationRequest
 */
export type RetrySchemaMigrationRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string uuid = 2;
   */
  uuid?: string;
};

/**
 * Describes the message vtctldata.RetrySchemaMigrationRequest.
 * Use `create(RetrySchemaMigrationRequestSchema)` to create a new message.
 */
export const RetrySchemaMigrationRequestSchema: GenMessage<RetrySchemaMigrationRequest, RetrySchemaMigrationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 181);

/**
 * @generated from message vtctldata.RetrySchemaMigrationResponse
 */
export type RetrySchemaMigrationResponse = Message<"vtctldata.RetrySchemaMigrationResponse"> & {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard: { [key: string]: bigint };
};

/**
 * @generated from message vtctldata.RetrySchemaMigrationResponse
 */
export type RetrySchemaMigrationResponseJson = {
  /**
   * @generated from field: map<string, uint64> rows_affected_by_shard = 1;
   */
  rowsAffectedByShard?: { [key: string]: string };
};

/**
 * Describes the message vtctldata.RetrySchemaMigrationResponse.
 * Use `create(RetrySchemaMigrationResponseSchema)` to create a new message.
 */
export const RetrySchemaMigrationResponseSchema: GenMessage<RetrySchemaMigrationResponse, RetrySchemaMigrationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 182);

/**
 * @generated from message vtctldata.RunHealthCheckRequest
 */
export type RunHealthCheckRequest = Message<"vtctldata.RunHealthCheckRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.RunHealthCheckRequest
 */
export type RunHealthCheckRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.RunHealthCheckRequest.
 * Use `create(RunHealthCheckRequestSchema)` to create a new message.
 */
export const RunHealthCheckRequestSchema: GenMessage<RunHealthCheckRequest, RunHealthCheckRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 183);

/**
 * @generated from message vtctldata.RunHealthCheckResponse
 */
export type RunHealthCheckResponse = Message<"vtctldata.RunHealthCheckResponse"> & {
};

/**
 * @generated from message vtctldata.RunHealthCheckResponse
 */
export type RunHealthCheckResponseJson = {
};

/**
 * Describes the message vtctldata.RunHealthCheckResponse.
 * Use `create(RunHealthCheckResponseSchema)` to create a new message.
 */
export const RunHealthCheckResponseSchema: GenMessage<RunHealthCheckResponse, RunHealthCheckResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 184);

/**
 * @generated from message vtctldata.SetKeyspaceDurabilityPolicyRequest
 */
export type SetKeyspaceDurabilityPolicyRequest = Message<"vtctldata.SetKeyspaceDurabilityPolicyRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string durability_policy = 2;
   */
  durabilityPolicy: string;
};

/**
 * @generated from message vtctldata.SetKeyspaceDurabilityPolicyRequest
 */
export type SetKeyspaceDurabilityPolicyRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string durability_policy = 2;
   */
  durabilityPolicy?: string;
};

/**
 * Describes the message vtctldata.SetKeyspaceDurabilityPolicyRequest.
 * Use `create(SetKeyspaceDurabilityPolicyRequestSchema)` to create a new message.
 */
export const SetKeyspaceDurabilityPolicyRequestSchema: GenMessage<SetKeyspaceDurabilityPolicyRequest, SetKeyspaceDurabilityPolicyRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 185);

/**
 * @generated from message vtctldata.SetKeyspaceDurabilityPolicyResponse
 */
export type SetKeyspaceDurabilityPolicyResponse = Message<"vtctldata.SetKeyspaceDurabilityPolicyResponse"> & {
  /**
   * Keyspace is the updated keyspace record.
   *
   * @generated from field: topodata.Keyspace keyspace = 1;
   */
  keyspace?: Keyspace$1;
};

/**
 * @generated from message vtctldata.SetKeyspaceDurabilityPolicyResponse
 */
export type SetKeyspaceDurabilityPolicyResponseJson = {
  /**
   * Keyspace is the updated keyspace record.
   *
   * @generated from field: topodata.Keyspace keyspace = 1;
   */
  keyspace?: KeyspaceJson$1;
};

/**
 * Describes the message vtctldata.SetKeyspaceDurabilityPolicyResponse.
 * Use `create(SetKeyspaceDurabilityPolicyResponseSchema)` to create a new message.
 */
export const SetKeyspaceDurabilityPolicyResponseSchema: GenMessage<SetKeyspaceDurabilityPolicyResponse, SetKeyspaceDurabilityPolicyResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 186);

/**
 * @generated from message vtctldata.SetKeyspaceShardingInfoRequest
 */
export type SetKeyspaceShardingInfoRequest = Message<"vtctldata.SetKeyspaceShardingInfoRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: bool force = 4;
   */
  force: boolean;
};

/**
 * @generated from message vtctldata.SetKeyspaceShardingInfoRequest
 */
export type SetKeyspaceShardingInfoRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: bool force = 4;
   */
  force?: boolean;
};

/**
 * Describes the message vtctldata.SetKeyspaceShardingInfoRequest.
 * Use `create(SetKeyspaceShardingInfoRequestSchema)` to create a new message.
 */
export const SetKeyspaceShardingInfoRequestSchema: GenMessage<SetKeyspaceShardingInfoRequest, SetKeyspaceShardingInfoRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 187);

/**
 * @generated from message vtctldata.SetKeyspaceShardingInfoResponse
 */
export type SetKeyspaceShardingInfoResponse = Message<"vtctldata.SetKeyspaceShardingInfoResponse"> & {
  /**
   * Keyspace is the updated keyspace record.
   *
   * @generated from field: topodata.Keyspace keyspace = 1;
   */
  keyspace?: Keyspace$1;
};

/**
 * @generated from message vtctldata.SetKeyspaceShardingInfoResponse
 */
export type SetKeyspaceShardingInfoResponseJson = {
  /**
   * Keyspace is the updated keyspace record.
   *
   * @generated from field: topodata.Keyspace keyspace = 1;
   */
  keyspace?: KeyspaceJson$1;
};

/**
 * Describes the message vtctldata.SetKeyspaceShardingInfoResponse.
 * Use `create(SetKeyspaceShardingInfoResponseSchema)` to create a new message.
 */
export const SetKeyspaceShardingInfoResponseSchema: GenMessage<SetKeyspaceShardingInfoResponse, SetKeyspaceShardingInfoResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 188);

/**
 * @generated from message vtctldata.SetShardIsPrimaryServingRequest
 */
export type SetShardIsPrimaryServingRequest = Message<"vtctldata.SetShardIsPrimaryServingRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: bool is_serving = 3;
   */
  isServing: boolean;
};

/**
 * @generated from message vtctldata.SetShardIsPrimaryServingRequest
 */
export type SetShardIsPrimaryServingRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: bool is_serving = 3;
   */
  isServing?: boolean;
};

/**
 * Describes the message vtctldata.SetShardIsPrimaryServingRequest.
 * Use `create(SetShardIsPrimaryServingRequestSchema)` to create a new message.
 */
export const SetShardIsPrimaryServingRequestSchema: GenMessage<SetShardIsPrimaryServingRequest, SetShardIsPrimaryServingRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 189);

/**
 * @generated from message vtctldata.SetShardIsPrimaryServingResponse
 */
export type SetShardIsPrimaryServingResponse = Message<"vtctldata.SetShardIsPrimaryServingResponse"> & {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: Shard$1;
};

/**
 * @generated from message vtctldata.SetShardIsPrimaryServingResponse
 */
export type SetShardIsPrimaryServingResponseJson = {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: ShardJson$1;
};

/**
 * Describes the message vtctldata.SetShardIsPrimaryServingResponse.
 * Use `create(SetShardIsPrimaryServingResponseSchema)` to create a new message.
 */
export const SetShardIsPrimaryServingResponseSchema: GenMessage<SetShardIsPrimaryServingResponse, SetShardIsPrimaryServingResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 190);

/**
 * @generated from message vtctldata.SetShardTabletControlRequest
 */
export type SetShardTabletControlRequest = Message<"vtctldata.SetShardTabletControlRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType: TabletType;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells: string[];

  /**
   * DeniedTables updates the list of denied tables the shard will serve for
   * the given tablet type. This is useful to fix tables that are being blocked
   * after a MoveTables operation.
   *
   * NOTE: Setting this field will cause DisableQueryService to be ignored.
   *
   * @generated from field: repeated string denied_tables = 5;
   */
  deniedTables: string[];

  /**
   * DisableQueryService instructs whether to enable the query service on
   * tablets of the given type in the shard. This is useful to fix Reshard
   * operations gone awry.
   *
   * NOTE: this is ignored if DeniedTables is not empty.
   *
   * @generated from field: bool disable_query_service = 6;
   */
  disableQueryService: boolean;

  /**
   * Remove removes the ShardTabletControl record entirely. If set, this takes
   * precedence over DeniedTables and DisableQueryService fields, and is useful
   * to manually remove serving restrictions after a completed MoveTables
   * operation.
   *
   * @generated from field: bool remove = 7;
   */
  remove: boolean;
};

/**
 * @generated from message vtctldata.SetShardTabletControlRequest
 */
export type SetShardTabletControlRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType?: TabletTypeJson;

  /**
   * @generated from field: repeated string cells = 4;
   */
  cells?: string[];

  /**
   * DeniedTables updates the list of denied tables the shard will serve for
   * the given tablet type. This is useful to fix tables that are being blocked
   * after a MoveTables operation.
   *
   * NOTE: Setting this field will cause DisableQueryService to be ignored.
   *
   * @generated from field: repeated string denied_tables = 5;
   */
  deniedTables?: string[];

  /**
   * DisableQueryService instructs whether to enable the query service on
   * tablets of the given type in the shard. This is useful to fix Reshard
   * operations gone awry.
   *
   * NOTE: this is ignored if DeniedTables is not empty.
   *
   * @generated from field: bool disable_query_service = 6;
   */
  disableQueryService?: boolean;

  /**
   * Remove removes the ShardTabletControl record entirely. If set, this takes
   * precedence over DeniedTables and DisableQueryService fields, and is useful
   * to manually remove serving restrictions after a completed MoveTables
   * operation.
   *
   * @generated from field: bool remove = 7;
   */
  remove?: boolean;
};

/**
 * Describes the message vtctldata.SetShardTabletControlRequest.
 * Use `create(SetShardTabletControlRequestSchema)` to create a new message.
 */
export const SetShardTabletControlRequestSchema: GenMessage<SetShardTabletControlRequest, SetShardTabletControlRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 191);

/**
 * @generated from message vtctldata.SetShardTabletControlResponse
 */
export type SetShardTabletControlResponse = Message<"vtctldata.SetShardTabletControlResponse"> & {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: Shard$1;
};

/**
 * @generated from message vtctldata.SetShardTabletControlResponse
 */
export type SetShardTabletControlResponseJson = {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: ShardJson$1;
};

/**
 * Describes the message vtctldata.SetShardTabletControlResponse.
 * Use `create(SetShardTabletControlResponseSchema)` to create a new message.
 */
export const SetShardTabletControlResponseSchema: GenMessage<SetShardTabletControlResponse, SetShardTabletControlResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 192);

/**
 * @generated from message vtctldata.SetWritableRequest
 */
export type SetWritableRequest = Message<"vtctldata.SetWritableRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: bool writable = 2;
   */
  writable: boolean;
};

/**
 * @generated from message vtctldata.SetWritableRequest
 */
export type SetWritableRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: bool writable = 2;
   */
  writable?: boolean;
};

/**
 * Describes the message vtctldata.SetWritableRequest.
 * Use `create(SetWritableRequestSchema)` to create a new message.
 */
export const SetWritableRequestSchema: GenMessage<SetWritableRequest, SetWritableRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 193);

/**
 * @generated from message vtctldata.SetWritableResponse
 */
export type SetWritableResponse = Message<"vtctldata.SetWritableResponse"> & {
};

/**
 * @generated from message vtctldata.SetWritableResponse
 */
export type SetWritableResponseJson = {
};

/**
 * Describes the message vtctldata.SetWritableResponse.
 * Use `create(SetWritableResponseSchema)` to create a new message.
 */
export const SetWritableResponseSchema: GenMessage<SetWritableResponse, SetWritableResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 194);

/**
 * @generated from message vtctldata.ShardReplicationAddRequest
 */
export type ShardReplicationAddRequest = Message<"vtctldata.ShardReplicationAddRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.ShardReplicationAddRequest
 */
export type ShardReplicationAddRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.ShardReplicationAddRequest.
 * Use `create(ShardReplicationAddRequestSchema)` to create a new message.
 */
export const ShardReplicationAddRequestSchema: GenMessage<ShardReplicationAddRequest, ShardReplicationAddRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 195);

/**
 * @generated from message vtctldata.ShardReplicationAddResponse
 */
export type ShardReplicationAddResponse = Message<"vtctldata.ShardReplicationAddResponse"> & {
};

/**
 * @generated from message vtctldata.ShardReplicationAddResponse
 */
export type ShardReplicationAddResponseJson = {
};

/**
 * Describes the message vtctldata.ShardReplicationAddResponse.
 * Use `create(ShardReplicationAddResponseSchema)` to create a new message.
 */
export const ShardReplicationAddResponseSchema: GenMessage<ShardReplicationAddResponse, ShardReplicationAddResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 196);

/**
 * @generated from message vtctldata.ShardReplicationFixRequest
 */
export type ShardReplicationFixRequest = Message<"vtctldata.ShardReplicationFixRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: string cell = 3;
   */
  cell: string;
};

/**
 * @generated from message vtctldata.ShardReplicationFixRequest
 */
export type ShardReplicationFixRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: string cell = 3;
   */
  cell?: string;
};

/**
 * Describes the message vtctldata.ShardReplicationFixRequest.
 * Use `create(ShardReplicationFixRequestSchema)` to create a new message.
 */
export const ShardReplicationFixRequestSchema: GenMessage<ShardReplicationFixRequest, ShardReplicationFixRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 197);

/**
 * @generated from message vtctldata.ShardReplicationFixResponse
 */
export type ShardReplicationFixResponse = Message<"vtctldata.ShardReplicationFixResponse"> & {
  /**
   * Error contains information about the error fixed by a
   * ShardReplicationFix RPC. If there were no errors to fix (i.e. all nodes
   * in the replication graph are valid), this field is nil.
   *
   * @generated from field: topodata.ShardReplicationError error = 1;
   */
  error?: ShardReplicationError;
};

/**
 * @generated from message vtctldata.ShardReplicationFixResponse
 */
export type ShardReplicationFixResponseJson = {
  /**
   * Error contains information about the error fixed by a
   * ShardReplicationFix RPC. If there were no errors to fix (i.e. all nodes
   * in the replication graph are valid), this field is nil.
   *
   * @generated from field: topodata.ShardReplicationError error = 1;
   */
  error?: ShardReplicationErrorJson;
};

/**
 * Describes the message vtctldata.ShardReplicationFixResponse.
 * Use `create(ShardReplicationFixResponseSchema)` to create a new message.
 */
export const ShardReplicationFixResponseSchema: GenMessage<ShardReplicationFixResponse, ShardReplicationFixResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 198);

/**
 * @generated from message vtctldata.ShardReplicationPositionsRequest
 */
export type ShardReplicationPositionsRequest = Message<"vtctldata.ShardReplicationPositionsRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;
};

/**
 * @generated from message vtctldata.ShardReplicationPositionsRequest
 */
export type ShardReplicationPositionsRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;
};

/**
 * Describes the message vtctldata.ShardReplicationPositionsRequest.
 * Use `create(ShardReplicationPositionsRequestSchema)` to create a new message.
 */
export const ShardReplicationPositionsRequestSchema: GenMessage<ShardReplicationPositionsRequest, ShardReplicationPositionsRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 199);

/**
 * @generated from message vtctldata.ShardReplicationPositionsResponse
 */
export type ShardReplicationPositionsResponse = Message<"vtctldata.ShardReplicationPositionsResponse"> & {
  /**
   * ReplicationStatuses is a mapping of tablet alias string to replication
   * status for that tablet.
   *
   * @generated from field: map<string, replicationdata.Status> replication_statuses = 1;
   */
  replicationStatuses: { [key: string]: Status };

  /**
   * TabletMap is the set of tablets whose replication statuses were queried,
   * keyed by tablet alias.
   *
   * @generated from field: map<string, topodata.Tablet> tablet_map = 2;
   */
  tabletMap: { [key: string]: Tablet };
};

/**
 * @generated from message vtctldata.ShardReplicationPositionsResponse
 */
export type ShardReplicationPositionsResponseJson = {
  /**
   * ReplicationStatuses is a mapping of tablet alias string to replication
   * status for that tablet.
   *
   * @generated from field: map<string, replicationdata.Status> replication_statuses = 1;
   */
  replicationStatuses?: { [key: string]: StatusJson };

  /**
   * TabletMap is the set of tablets whose replication statuses were queried,
   * keyed by tablet alias.
   *
   * @generated from field: map<string, topodata.Tablet> tablet_map = 2;
   */
  tabletMap?: { [key: string]: TabletJson };
};

/**
 * Describes the message vtctldata.ShardReplicationPositionsResponse.
 * Use `create(ShardReplicationPositionsResponseSchema)` to create a new message.
 */
export const ShardReplicationPositionsResponseSchema: GenMessage<ShardReplicationPositionsResponse, ShardReplicationPositionsResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 200);

/**
 * @generated from message vtctldata.ShardReplicationRemoveRequest
 */
export type ShardReplicationRemoveRequest = Message<"vtctldata.ShardReplicationRemoveRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.ShardReplicationRemoveRequest
 */
export type ShardReplicationRemoveRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.ShardReplicationRemoveRequest.
 * Use `create(ShardReplicationRemoveRequestSchema)` to create a new message.
 */
export const ShardReplicationRemoveRequestSchema: GenMessage<ShardReplicationRemoveRequest, ShardReplicationRemoveRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 201);

/**
 * @generated from message vtctldata.ShardReplicationRemoveResponse
 */
export type ShardReplicationRemoveResponse = Message<"vtctldata.ShardReplicationRemoveResponse"> & {
};

/**
 * @generated from message vtctldata.ShardReplicationRemoveResponse
 */
export type ShardReplicationRemoveResponseJson = {
};

/**
 * Describes the message vtctldata.ShardReplicationRemoveResponse.
 * Use `create(ShardReplicationRemoveResponseSchema)` to create a new message.
 */
export const ShardReplicationRemoveResponseSchema: GenMessage<ShardReplicationRemoveResponse, ShardReplicationRemoveResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 202);

/**
 * @generated from message vtctldata.SleepTabletRequest
 */
export type SleepTabletRequest = Message<"vtctldata.SleepTabletRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;

  /**
   * @generated from field: vttime.Duration duration = 2;
   */
  duration?: Duration;
};

/**
 * @generated from message vtctldata.SleepTabletRequest
 */
export type SleepTabletRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * @generated from field: vttime.Duration duration = 2;
   */
  duration?: DurationJson;
};

/**
 * Describes the message vtctldata.SleepTabletRequest.
 * Use `create(SleepTabletRequestSchema)` to create a new message.
 */
export const SleepTabletRequestSchema: GenMessage<SleepTabletRequest, SleepTabletRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 203);

/**
 * @generated from message vtctldata.SleepTabletResponse
 */
export type SleepTabletResponse = Message<"vtctldata.SleepTabletResponse"> & {
};

/**
 * @generated from message vtctldata.SleepTabletResponse
 */
export type SleepTabletResponseJson = {
};

/**
 * Describes the message vtctldata.SleepTabletResponse.
 * Use `create(SleepTabletResponseSchema)` to create a new message.
 */
export const SleepTabletResponseSchema: GenMessage<SleepTabletResponse, SleepTabletResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 204);

/**
 * @generated from message vtctldata.SourceShardAddRequest
 */
export type SourceShardAddRequest = Message<"vtctldata.SourceShardAddRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: int32 uid = 3;
   */
  uid: number;

  /**
   * @generated from field: string source_keyspace = 4;
   */
  sourceKeyspace: string;

  /**
   * @generated from field: string source_shard = 5;
   */
  sourceShard: string;

  /**
   * KeyRange identifies the key range to use for the SourceShard. This field is
   * optional.
   *
   * @generated from field: topodata.KeyRange key_range = 6;
   */
  keyRange?: KeyRange;

  /**
   * Tables is a list of tables replicate (for MoveTables). Each "table" can be
   * either an exact match or a regular expression of the form "/regexp/".
   *
   * @generated from field: repeated string tables = 7;
   */
  tables: string[];
};

/**
 * @generated from message vtctldata.SourceShardAddRequest
 */
export type SourceShardAddRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: int32 uid = 3;
   */
  uid?: number;

  /**
   * @generated from field: string source_keyspace = 4;
   */
  sourceKeyspace?: string;

  /**
   * @generated from field: string source_shard = 5;
   */
  sourceShard?: string;

  /**
   * KeyRange identifies the key range to use for the SourceShard. This field is
   * optional.
   *
   * @generated from field: topodata.KeyRange key_range = 6;
   */
  keyRange?: KeyRangeJson;

  /**
   * Tables is a list of tables replicate (for MoveTables). Each "table" can be
   * either an exact match or a regular expression of the form "/regexp/".
   *
   * @generated from field: repeated string tables = 7;
   */
  tables?: string[];
};

/**
 * Describes the message vtctldata.SourceShardAddRequest.
 * Use `create(SourceShardAddRequestSchema)` to create a new message.
 */
export const SourceShardAddRequestSchema: GenMessage<SourceShardAddRequest, SourceShardAddRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 205);

/**
 * @generated from message vtctldata.SourceShardAddResponse
 */
export type SourceShardAddResponse = Message<"vtctldata.SourceShardAddResponse"> & {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: Shard$1;
};

/**
 * @generated from message vtctldata.SourceShardAddResponse
 */
export type SourceShardAddResponseJson = {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: ShardJson$1;
};

/**
 * Describes the message vtctldata.SourceShardAddResponse.
 * Use `create(SourceShardAddResponseSchema)` to create a new message.
 */
export const SourceShardAddResponseSchema: GenMessage<SourceShardAddResponse, SourceShardAddResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 206);

/**
 * @generated from message vtctldata.SourceShardDeleteRequest
 */
export type SourceShardDeleteRequest = Message<"vtctldata.SourceShardDeleteRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: int32 uid = 3;
   */
  uid: number;
};

/**
 * @generated from message vtctldata.SourceShardDeleteRequest
 */
export type SourceShardDeleteRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: int32 uid = 3;
   */
  uid?: number;
};

/**
 * Describes the message vtctldata.SourceShardDeleteRequest.
 * Use `create(SourceShardDeleteRequestSchema)` to create a new message.
 */
export const SourceShardDeleteRequestSchema: GenMessage<SourceShardDeleteRequest, SourceShardDeleteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 207);

/**
 * @generated from message vtctldata.SourceShardDeleteResponse
 */
export type SourceShardDeleteResponse = Message<"vtctldata.SourceShardDeleteResponse"> & {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: Shard$1;
};

/**
 * @generated from message vtctldata.SourceShardDeleteResponse
 */
export type SourceShardDeleteResponseJson = {
  /**
   * Shard is the updated shard record.
   *
   * @generated from field: topodata.Shard shard = 1;
   */
  shard?: ShardJson$1;
};

/**
 * Describes the message vtctldata.SourceShardDeleteResponse.
 * Use `create(SourceShardDeleteResponseSchema)` to create a new message.
 */
export const SourceShardDeleteResponseSchema: GenMessage<SourceShardDeleteResponse, SourceShardDeleteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 208);

/**
 * @generated from message vtctldata.StartReplicationRequest
 */
export type StartReplicationRequest = Message<"vtctldata.StartReplicationRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.StartReplicationRequest
 */
export type StartReplicationRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.StartReplicationRequest.
 * Use `create(StartReplicationRequestSchema)` to create a new message.
 */
export const StartReplicationRequestSchema: GenMessage<StartReplicationRequest, StartReplicationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 209);

/**
 * @generated from message vtctldata.StartReplicationResponse
 */
export type StartReplicationResponse = Message<"vtctldata.StartReplicationResponse"> & {
};

/**
 * @generated from message vtctldata.StartReplicationResponse
 */
export type StartReplicationResponseJson = {
};

/**
 * Describes the message vtctldata.StartReplicationResponse.
 * Use `create(StartReplicationResponseSchema)` to create a new message.
 */
export const StartReplicationResponseSchema: GenMessage<StartReplicationResponse, StartReplicationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 210);

/**
 * @generated from message vtctldata.StopReplicationRequest
 */
export type StopReplicationRequest = Message<"vtctldata.StopReplicationRequest"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * @generated from message vtctldata.StopReplicationRequest
 */
export type StopReplicationRequestJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.StopReplicationRequest.
 * Use `create(StopReplicationRequestSchema)` to create a new message.
 */
export const StopReplicationRequestSchema: GenMessage<StopReplicationRequest, StopReplicationRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 211);

/**
 * @generated from message vtctldata.StopReplicationResponse
 */
export type StopReplicationResponse = Message<"vtctldata.StopReplicationResponse"> & {
};

/**
 * @generated from message vtctldata.StopReplicationResponse
 */
export type StopReplicationResponseJson = {
};

/**
 * Describes the message vtctldata.StopReplicationResponse.
 * Use `create(StopReplicationResponseSchema)` to create a new message.
 */
export const StopReplicationResponseSchema: GenMessage<StopReplicationResponse, StopReplicationResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 212);

/**
 * @generated from message vtctldata.TabletExternallyReparentedRequest
 */
export type TabletExternallyReparentedRequest = Message<"vtctldata.TabletExternallyReparentedRequest"> & {
  /**
   * Tablet is the alias of the tablet that was promoted externally and should
   * be updated to the shard primary in the topo.
   *
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAlias;
};

/**
 * @generated from message vtctldata.TabletExternallyReparentedRequest
 */
export type TabletExternallyReparentedRequestJson = {
  /**
   * Tablet is the alias of the tablet that was promoted externally and should
   * be updated to the shard primary in the topo.
   *
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.TabletExternallyReparentedRequest.
 * Use `create(TabletExternallyReparentedRequestSchema)` to create a new message.
 */
export const TabletExternallyReparentedRequestSchema: GenMessage<TabletExternallyReparentedRequest, TabletExternallyReparentedRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 213);

/**
 * @generated from message vtctldata.TabletExternallyReparentedResponse
 */
export type TabletExternallyReparentedResponse = Message<"vtctldata.TabletExternallyReparentedResponse"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAlias;

  /**
   * @generated from field: topodata.TabletAlias old_primary = 4;
   */
  oldPrimary?: TabletAlias;
};

/**
 * @generated from message vtctldata.TabletExternallyReparentedResponse
 */
export type TabletExternallyReparentedResponseJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletAlias new_primary = 3;
   */
  newPrimary?: TabletAliasJson;

  /**
   * @generated from field: topodata.TabletAlias old_primary = 4;
   */
  oldPrimary?: TabletAliasJson;
};

/**
 * Describes the message vtctldata.TabletExternallyReparentedResponse.
 * Use `create(TabletExternallyReparentedResponseSchema)` to create a new message.
 */
export const TabletExternallyReparentedResponseSchema: GenMessage<TabletExternallyReparentedResponse, TabletExternallyReparentedResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 214);

/**
 * @generated from message vtctldata.UpdateCellInfoRequest
 */
export type UpdateCellInfoRequest = Message<"vtctldata.UpdateCellInfoRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfo;
};

/**
 * @generated from message vtctldata.UpdateCellInfoRequest
 */
export type UpdateCellInfoRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfoJson;
};

/**
 * Describes the message vtctldata.UpdateCellInfoRequest.
 * Use `create(UpdateCellInfoRequestSchema)` to create a new message.
 */
export const UpdateCellInfoRequestSchema: GenMessage<UpdateCellInfoRequest, UpdateCellInfoRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 215);

/**
 * @generated from message vtctldata.UpdateCellInfoResponse
 */
export type UpdateCellInfoResponse = Message<"vtctldata.UpdateCellInfoResponse"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfo;
};

/**
 * @generated from message vtctldata.UpdateCellInfoResponse
 */
export type UpdateCellInfoResponseJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.CellInfo cell_info = 2;
   */
  cellInfo?: CellInfoJson;
};

/**
 * Describes the message vtctldata.UpdateCellInfoResponse.
 * Use `create(UpdateCellInfoResponseSchema)` to create a new message.
 */
export const UpdateCellInfoResponseSchema: GenMessage<UpdateCellInfoResponse, UpdateCellInfoResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 216);

/**
 * @generated from message vtctldata.UpdateCellsAliasRequest
 */
export type UpdateCellsAliasRequest = Message<"vtctldata.UpdateCellsAliasRequest"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.CellsAlias cells_alias = 2;
   */
  cellsAlias?: CellsAlias;
};

/**
 * @generated from message vtctldata.UpdateCellsAliasRequest
 */
export type UpdateCellsAliasRequestJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.CellsAlias cells_alias = 2;
   */
  cellsAlias?: CellsAliasJson;
};

/**
 * Describes the message vtctldata.UpdateCellsAliasRequest.
 * Use `create(UpdateCellsAliasRequestSchema)` to create a new message.
 */
export const UpdateCellsAliasRequestSchema: GenMessage<UpdateCellsAliasRequest, UpdateCellsAliasRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 217);

/**
 * @generated from message vtctldata.UpdateCellsAliasResponse
 */
export type UpdateCellsAliasResponse = Message<"vtctldata.UpdateCellsAliasResponse"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.CellsAlias cells_alias = 2;
   */
  cellsAlias?: CellsAlias;
};

/**
 * @generated from message vtctldata.UpdateCellsAliasResponse
 */
export type UpdateCellsAliasResponseJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.CellsAlias cells_alias = 2;
   */
  cellsAlias?: CellsAliasJson;
};

/**
 * Describes the message vtctldata.UpdateCellsAliasResponse.
 * Use `create(UpdateCellsAliasResponseSchema)` to create a new message.
 */
export const UpdateCellsAliasResponseSchema: GenMessage<UpdateCellsAliasResponse, UpdateCellsAliasResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 218);

/**
 * @generated from message vtctldata.ValidateRequest
 */
export type ValidateRequest = Message<"vtctldata.ValidateRequest"> & {
  /**
   * @generated from field: bool ping_tablets = 1;
   */
  pingTablets: boolean;
};

/**
 * @generated from message vtctldata.ValidateRequest
 */
export type ValidateRequestJson = {
  /**
   * @generated from field: bool ping_tablets = 1;
   */
  pingTablets?: boolean;
};

/**
 * Describes the message vtctldata.ValidateRequest.
 * Use `create(ValidateRequestSchema)` to create a new message.
 */
export const ValidateRequestSchema: GenMessage<ValidateRequest, ValidateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 219);

/**
 * @generated from message vtctldata.ValidateResponse
 */
export type ValidateResponse = Message<"vtctldata.ValidateResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateKeyspaceResponse> results_by_keyspace = 2;
   */
  resultsByKeyspace: { [key: string]: ValidateKeyspaceResponse };
};

/**
 * @generated from message vtctldata.ValidateResponse
 */
export type ValidateResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateKeyspaceResponse> results_by_keyspace = 2;
   */
  resultsByKeyspace?: { [key: string]: ValidateKeyspaceResponseJson };
};

/**
 * Describes the message vtctldata.ValidateResponse.
 * Use `create(ValidateResponseSchema)` to create a new message.
 */
export const ValidateResponseSchema: GenMessage<ValidateResponse, ValidateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 220);

/**
 * @generated from message vtctldata.ValidateKeyspaceRequest
 */
export type ValidateKeyspaceRequest = Message<"vtctldata.ValidateKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: bool ping_tablets = 2;
   */
  pingTablets: boolean;
};

/**
 * @generated from message vtctldata.ValidateKeyspaceRequest
 */
export type ValidateKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: bool ping_tablets = 2;
   */
  pingTablets?: boolean;
};

/**
 * Describes the message vtctldata.ValidateKeyspaceRequest.
 * Use `create(ValidateKeyspaceRequestSchema)` to create a new message.
 */
export const ValidateKeyspaceRequestSchema: GenMessage<ValidateKeyspaceRequest, ValidateKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 221);

/**
 * @generated from message vtctldata.ValidateKeyspaceResponse
 */
export type ValidateKeyspaceResponse = Message<"vtctldata.ValidateKeyspaceResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard: { [key: string]: ValidateShardResponse };
};

/**
 * @generated from message vtctldata.ValidateKeyspaceResponse
 */
export type ValidateKeyspaceResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard?: { [key: string]: ValidateShardResponseJson };
};

/**
 * Describes the message vtctldata.ValidateKeyspaceResponse.
 * Use `create(ValidateKeyspaceResponseSchema)` to create a new message.
 */
export const ValidateKeyspaceResponseSchema: GenMessage<ValidateKeyspaceResponse, ValidateKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 222);

/**
 * @generated from message vtctldata.ValidateSchemaKeyspaceRequest
 */
export type ValidateSchemaKeyspaceRequest = Message<"vtctldata.ValidateSchemaKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: repeated string exclude_tables = 2;
   */
  excludeTables: string[];

  /**
   * @generated from field: bool include_views = 3;
   */
  includeViews: boolean;

  /**
   * @generated from field: bool skip_no_primary = 4;
   */
  skipNoPrimary: boolean;

  /**
   * @generated from field: bool include_vschema = 5;
   */
  includeVschema: boolean;
};

/**
 * @generated from message vtctldata.ValidateSchemaKeyspaceRequest
 */
export type ValidateSchemaKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: repeated string exclude_tables = 2;
   */
  excludeTables?: string[];

  /**
   * @generated from field: bool include_views = 3;
   */
  includeViews?: boolean;

  /**
   * @generated from field: bool skip_no_primary = 4;
   */
  skipNoPrimary?: boolean;

  /**
   * @generated from field: bool include_vschema = 5;
   */
  includeVschema?: boolean;
};

/**
 * Describes the message vtctldata.ValidateSchemaKeyspaceRequest.
 * Use `create(ValidateSchemaKeyspaceRequestSchema)` to create a new message.
 */
export const ValidateSchemaKeyspaceRequestSchema: GenMessage<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 223);

/**
 * @generated from message vtctldata.ValidateSchemaKeyspaceResponse
 */
export type ValidateSchemaKeyspaceResponse = Message<"vtctldata.ValidateSchemaKeyspaceResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard: { [key: string]: ValidateShardResponse };
};

/**
 * @generated from message vtctldata.ValidateSchemaKeyspaceResponse
 */
export type ValidateSchemaKeyspaceResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard?: { [key: string]: ValidateShardResponseJson };
};

/**
 * Describes the message vtctldata.ValidateSchemaKeyspaceResponse.
 * Use `create(ValidateSchemaKeyspaceResponseSchema)` to create a new message.
 */
export const ValidateSchemaKeyspaceResponseSchema: GenMessage<ValidateSchemaKeyspaceResponse, ValidateSchemaKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 224);

/**
 * @generated from message vtctldata.ValidateShardRequest
 */
export type ValidateShardRequest = Message<"vtctldata.ValidateShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: bool ping_tablets = 3;
   */
  pingTablets: boolean;
};

/**
 * @generated from message vtctldata.ValidateShardRequest
 */
export type ValidateShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: bool ping_tablets = 3;
   */
  pingTablets?: boolean;
};

/**
 * Describes the message vtctldata.ValidateShardRequest.
 * Use `create(ValidateShardRequestSchema)` to create a new message.
 */
export const ValidateShardRequestSchema: GenMessage<ValidateShardRequest, ValidateShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 225);

/**
 * @generated from message vtctldata.ValidateShardResponse
 */
export type ValidateShardResponse = Message<"vtctldata.ValidateShardResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];
};

/**
 * @generated from message vtctldata.ValidateShardResponse
 */
export type ValidateShardResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];
};

/**
 * Describes the message vtctldata.ValidateShardResponse.
 * Use `create(ValidateShardResponseSchema)` to create a new message.
 */
export const ValidateShardResponseSchema: GenMessage<ValidateShardResponse, ValidateShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 226);

/**
 * @generated from message vtctldata.ValidateVersionKeyspaceRequest
 */
export type ValidateVersionKeyspaceRequest = Message<"vtctldata.ValidateVersionKeyspaceRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;
};

/**
 * @generated from message vtctldata.ValidateVersionKeyspaceRequest
 */
export type ValidateVersionKeyspaceRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;
};

/**
 * Describes the message vtctldata.ValidateVersionKeyspaceRequest.
 * Use `create(ValidateVersionKeyspaceRequestSchema)` to create a new message.
 */
export const ValidateVersionKeyspaceRequestSchema: GenMessage<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 227);

/**
 * @generated from message vtctldata.ValidateVersionKeyspaceResponse
 */
export type ValidateVersionKeyspaceResponse = Message<"vtctldata.ValidateVersionKeyspaceResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard: { [key: string]: ValidateShardResponse };
};

/**
 * @generated from message vtctldata.ValidateVersionKeyspaceResponse
 */
export type ValidateVersionKeyspaceResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard?: { [key: string]: ValidateShardResponseJson };
};

/**
 * Describes the message vtctldata.ValidateVersionKeyspaceResponse.
 * Use `create(ValidateVersionKeyspaceResponseSchema)` to create a new message.
 */
export const ValidateVersionKeyspaceResponseSchema: GenMessage<ValidateVersionKeyspaceResponse, ValidateVersionKeyspaceResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 228);

/**
 * @generated from message vtctldata.ValidateVersionShardRequest
 */
export type ValidateVersionShardRequest = Message<"vtctldata.ValidateVersionShardRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;
};

/**
 * @generated from message vtctldata.ValidateVersionShardRequest
 */
export type ValidateVersionShardRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;
};

/**
 * Describes the message vtctldata.ValidateVersionShardRequest.
 * Use `create(ValidateVersionShardRequestSchema)` to create a new message.
 */
export const ValidateVersionShardRequestSchema: GenMessage<ValidateVersionShardRequest, ValidateVersionShardRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 229);

/**
 * @generated from message vtctldata.ValidateVersionShardResponse
 */
export type ValidateVersionShardResponse = Message<"vtctldata.ValidateVersionShardResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];
};

/**
 * @generated from message vtctldata.ValidateVersionShardResponse
 */
export type ValidateVersionShardResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];
};

/**
 * Describes the message vtctldata.ValidateVersionShardResponse.
 * Use `create(ValidateVersionShardResponseSchema)` to create a new message.
 */
export const ValidateVersionShardResponseSchema: GenMessage<ValidateVersionShardResponse, ValidateVersionShardResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 230);

/**
 * @generated from message vtctldata.ValidateVSchemaRequest
 */
export type ValidateVSchemaRequest = Message<"vtctldata.ValidateVSchemaRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: repeated string shards = 2;
   */
  shards: string[];

  /**
   * @generated from field: repeated string exclude_tables = 3;
   */
  excludeTables: string[];

  /**
   * @generated from field: bool include_views = 4;
   */
  includeViews: boolean;
};

/**
 * @generated from message vtctldata.ValidateVSchemaRequest
 */
export type ValidateVSchemaRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: repeated string shards = 2;
   */
  shards?: string[];

  /**
   * @generated from field: repeated string exclude_tables = 3;
   */
  excludeTables?: string[];

  /**
   * @generated from field: bool include_views = 4;
   */
  includeViews?: boolean;
};

/**
 * Describes the message vtctldata.ValidateVSchemaRequest.
 * Use `create(ValidateVSchemaRequestSchema)` to create a new message.
 */
export const ValidateVSchemaRequestSchema: GenMessage<ValidateVSchemaRequest, ValidateVSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 231);

/**
 * @generated from message vtctldata.ValidateVSchemaResponse
 */
export type ValidateVSchemaResponse = Message<"vtctldata.ValidateVSchemaResponse"> & {
  /**
   * @generated from field: repeated string results = 1;
   */
  results: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard: { [key: string]: ValidateShardResponse };
};

/**
 * @generated from message vtctldata.ValidateVSchemaResponse
 */
export type ValidateVSchemaResponseJson = {
  /**
   * @generated from field: repeated string results = 1;
   */
  results?: string[];

  /**
   * @generated from field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
   */
  resultsByShard?: { [key: string]: ValidateShardResponseJson };
};

/**
 * Describes the message vtctldata.ValidateVSchemaResponse.
 * Use `create(ValidateVSchemaResponseSchema)` to create a new message.
 */
export const ValidateVSchemaResponseSchema: GenMessage<ValidateVSchemaResponse, ValidateVSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 232);

/**
 * @generated from message vtctldata.VDiffCreateRequest
 */
export type VDiffCreateRequest = Message<"vtctldata.VDiffCreateRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid: string;

  /**
   * @generated from field: repeated string source_cells = 4;
   */
  sourceCells: string[];

  /**
   * @generated from field: repeated string target_cells = 5;
   */
  targetCells: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference: TabletSelectionPreference;

  /**
   * @generated from field: repeated string tables = 8;
   */
  tables: string[];

  /**
   * @generated from field: int64 limit = 9;
   */
  limit: bigint;

  /**
   * @generated from field: vttime.Duration filtered_replication_wait_time = 10;
   */
  filteredReplicationWaitTime?: Duration;

  /**
   * @generated from field: bool debug_query = 11;
   */
  debugQuery: boolean;

  /**
   * @generated from field: bool only_p_ks = 12;
   */
  onlyPKs: boolean;

  /**
   * @generated from field: bool update_table_stats = 13;
   */
  updateTableStats: boolean;

  /**
   * @generated from field: int64 max_extra_rows_to_compare = 14;
   */
  maxExtraRowsToCompare: bigint;

  /**
   * @generated from field: bool wait = 15;
   */
  wait: boolean;

  /**
   * @generated from field: vttime.Duration wait_update_interval = 16;
   */
  waitUpdateInterval?: Duration;

  /**
   * @generated from field: bool auto_retry = 17;
   */
  autoRetry: boolean;

  /**
   * @generated from field: bool verbose = 18;
   */
  verbose: boolean;

  /**
   * @generated from field: int64 max_report_sample_rows = 19;
   */
  maxReportSampleRows: bigint;

  /**
   * @generated from field: vttime.Duration max_diff_duration = 20;
   */
  maxDiffDuration?: Duration;

  /**
   * @generated from field: int64 row_diff_column_truncate_at = 21;
   */
  rowDiffColumnTruncateAt: bigint;

  /**
   * @generated from field: optional bool auto_start = 22;
   */
  autoStart?: boolean;
};

/**
 * @generated from message vtctldata.VDiffCreateRequest
 */
export type VDiffCreateRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid?: string;

  /**
   * @generated from field: repeated string source_cells = 4;
   */
  sourceCells?: string[];

  /**
   * @generated from field: repeated string target_cells = 5;
   */
  targetCells?: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 6;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
   */
  tabletSelectionPreference?: TabletSelectionPreferenceJson;

  /**
   * @generated from field: repeated string tables = 8;
   */
  tables?: string[];

  /**
   * @generated from field: int64 limit = 9;
   */
  limit?: string;

  /**
   * @generated from field: vttime.Duration filtered_replication_wait_time = 10;
   */
  filteredReplicationWaitTime?: DurationJson;

  /**
   * @generated from field: bool debug_query = 11;
   */
  debugQuery?: boolean;

  /**
   * @generated from field: bool only_p_ks = 12;
   */
  onlyPKs?: boolean;

  /**
   * @generated from field: bool update_table_stats = 13;
   */
  updateTableStats?: boolean;

  /**
   * @generated from field: int64 max_extra_rows_to_compare = 14;
   */
  maxExtraRowsToCompare?: string;

  /**
   * @generated from field: bool wait = 15;
   */
  wait?: boolean;

  /**
   * @generated from field: vttime.Duration wait_update_interval = 16;
   */
  waitUpdateInterval?: DurationJson;

  /**
   * @generated from field: bool auto_retry = 17;
   */
  autoRetry?: boolean;

  /**
   * @generated from field: bool verbose = 18;
   */
  verbose?: boolean;

  /**
   * @generated from field: int64 max_report_sample_rows = 19;
   */
  maxReportSampleRows?: string;

  /**
   * @generated from field: vttime.Duration max_diff_duration = 20;
   */
  maxDiffDuration?: DurationJson;

  /**
   * @generated from field: int64 row_diff_column_truncate_at = 21;
   */
  rowDiffColumnTruncateAt?: string;

  /**
   * @generated from field: optional bool auto_start = 22;
   */
  autoStart?: boolean;
};

/**
 * Describes the message vtctldata.VDiffCreateRequest.
 * Use `create(VDiffCreateRequestSchema)` to create a new message.
 */
export const VDiffCreateRequestSchema: GenMessage<VDiffCreateRequest, VDiffCreateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 233);

/**
 * @generated from message vtctldata.VDiffCreateResponse
 */
export type VDiffCreateResponse = Message<"vtctldata.VDiffCreateResponse"> & {
  /**
   * Intentionally upper case to maintain compatibility with
   * vtctlclient and other VDiff client command output.
   *
   * @generated from field: string UUID = 1;
   */
  UUID: string;
};

/**
 * @generated from message vtctldata.VDiffCreateResponse
 */
export type VDiffCreateResponseJson = {
  /**
   * Intentionally upper case to maintain compatibility with
   * vtctlclient and other VDiff client command output.
   *
   * @generated from field: string UUID = 1;
   */
  UUID?: string;
};

/**
 * Describes the message vtctldata.VDiffCreateResponse.
 * Use `create(VDiffCreateResponseSchema)` to create a new message.
 */
export const VDiffCreateResponseSchema: GenMessage<VDiffCreateResponse, VDiffCreateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 234);

/**
 * @generated from message vtctldata.VDiffDeleteRequest
 */
export type VDiffDeleteRequest = Message<"vtctldata.VDiffDeleteRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace: string;

  /**
   * This will be 'all' or a UUID.
   *
   * @generated from field: string arg = 3;
   */
  arg: string;
};

/**
 * @generated from message vtctldata.VDiffDeleteRequest
 */
export type VDiffDeleteRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace?: string;

  /**
   * This will be 'all' or a UUID.
   *
   * @generated from field: string arg = 3;
   */
  arg?: string;
};

/**
 * Describes the message vtctldata.VDiffDeleteRequest.
 * Use `create(VDiffDeleteRequestSchema)` to create a new message.
 */
export const VDiffDeleteRequestSchema: GenMessage<VDiffDeleteRequest, VDiffDeleteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 235);

/**
 * @generated from message vtctldata.VDiffDeleteResponse
 */
export type VDiffDeleteResponse = Message<"vtctldata.VDiffDeleteResponse"> & {
};

/**
 * @generated from message vtctldata.VDiffDeleteResponse
 */
export type VDiffDeleteResponseJson = {
};

/**
 * Describes the message vtctldata.VDiffDeleteResponse.
 * Use `create(VDiffDeleteResponseSchema)` to create a new message.
 */
export const VDiffDeleteResponseSchema: GenMessage<VDiffDeleteResponse, VDiffDeleteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 236);

/**
 * @generated from message vtctldata.VDiffResumeRequest
 */
export type VDiffResumeRequest = Message<"vtctldata.VDiffResumeRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid: string;

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards: string[];
};

/**
 * @generated from message vtctldata.VDiffResumeRequest
 */
export type VDiffResumeRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid?: string;

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards?: string[];
};

/**
 * Describes the message vtctldata.VDiffResumeRequest.
 * Use `create(VDiffResumeRequestSchema)` to create a new message.
 */
export const VDiffResumeRequestSchema: GenMessage<VDiffResumeRequest, VDiffResumeRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 237);

/**
 * @generated from message vtctldata.VDiffResumeResponse
 */
export type VDiffResumeResponse = Message<"vtctldata.VDiffResumeResponse"> & {
};

/**
 * @generated from message vtctldata.VDiffResumeResponse
 */
export type VDiffResumeResponseJson = {
};

/**
 * Describes the message vtctldata.VDiffResumeResponse.
 * Use `create(VDiffResumeResponseSchema)` to create a new message.
 */
export const VDiffResumeResponseSchema: GenMessage<VDiffResumeResponse, VDiffResumeResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 238);

/**
 * @generated from message vtctldata.VDiffShowRequest
 */
export type VDiffShowRequest = Message<"vtctldata.VDiffShowRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace: string;

  /**
   * This will be 'all', 'last', or a UUID.
   *
   * @generated from field: string arg = 3;
   */
  arg: string;
};

/**
 * @generated from message vtctldata.VDiffShowRequest
 */
export type VDiffShowRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace?: string;

  /**
   * This will be 'all', 'last', or a UUID.
   *
   * @generated from field: string arg = 3;
   */
  arg?: string;
};

/**
 * Describes the message vtctldata.VDiffShowRequest.
 * Use `create(VDiffShowRequestSchema)` to create a new message.
 */
export const VDiffShowRequestSchema: GenMessage<VDiffShowRequest, VDiffShowRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 239);

/**
 * @generated from message vtctldata.VDiffShowResponse
 */
export type VDiffShowResponse = Message<"vtctldata.VDiffShowResponse"> & {
  /**
   * The key is keyspace/shard.
   *
   * @generated from field: map<string, tabletmanagerdata.VDiffResponse> tablet_responses = 1;
   */
  tabletResponses: { [key: string]: VDiffResponse };
};

/**
 * @generated from message vtctldata.VDiffShowResponse
 */
export type VDiffShowResponseJson = {
  /**
   * The key is keyspace/shard.
   *
   * @generated from field: map<string, tabletmanagerdata.VDiffResponse> tablet_responses = 1;
   */
  tabletResponses?: { [key: string]: VDiffResponseJson };
};

/**
 * Describes the message vtctldata.VDiffShowResponse.
 * Use `create(VDiffShowResponseSchema)` to create a new message.
 */
export const VDiffShowResponseSchema: GenMessage<VDiffShowResponse, VDiffShowResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 240);

/**
 * @generated from message vtctldata.VDiffStopRequest
 */
export type VDiffStopRequest = Message<"vtctldata.VDiffStopRequest"> & {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid: string;

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards: string[];
};

/**
 * @generated from message vtctldata.VDiffStopRequest
 */
export type VDiffStopRequestJson = {
  /**
   * @generated from field: string workflow = 1;
   */
  workflow?: string;

  /**
   * @generated from field: string target_keyspace = 2;
   */
  targetKeyspace?: string;

  /**
   * @generated from field: string uuid = 3;
   */
  uuid?: string;

  /**
   * @generated from field: repeated string target_shards = 4;
   */
  targetShards?: string[];
};

/**
 * Describes the message vtctldata.VDiffStopRequest.
 * Use `create(VDiffStopRequestSchema)` to create a new message.
 */
export const VDiffStopRequestSchema: GenMessage<VDiffStopRequest, VDiffStopRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 241);

/**
 * @generated from message vtctldata.VDiffStopResponse
 */
export type VDiffStopResponse = Message<"vtctldata.VDiffStopResponse"> & {
};

/**
 * @generated from message vtctldata.VDiffStopResponse
 */
export type VDiffStopResponseJson = {
};

/**
 * Describes the message vtctldata.VDiffStopResponse.
 * Use `create(VDiffStopResponseSchema)` to create a new message.
 */
export const VDiffStopResponseSchema: GenMessage<VDiffStopResponse, VDiffStopResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 242);

/**
 * @generated from message vtctldata.WorkflowDeleteRequest
 */
export type WorkflowDeleteRequest = Message<"vtctldata.WorkflowDeleteRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow: string;

  /**
   * @generated from field: bool keep_data = 3;
   */
  keepData: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 4;
   */
  keepRoutingRules: boolean;

  /**
   * @generated from field: repeated string shards = 5;
   */
  shards: string[];
};

/**
 * @generated from message vtctldata.WorkflowDeleteRequest
 */
export type WorkflowDeleteRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow?: string;

  /**
   * @generated from field: bool keep_data = 3;
   */
  keepData?: boolean;

  /**
   * @generated from field: bool keep_routing_rules = 4;
   */
  keepRoutingRules?: boolean;

  /**
   * @generated from field: repeated string shards = 5;
   */
  shards?: string[];
};

/**
 * Describes the message vtctldata.WorkflowDeleteRequest.
 * Use `create(WorkflowDeleteRequestSchema)` to create a new message.
 */
export const WorkflowDeleteRequestSchema: GenMessage<WorkflowDeleteRequest, WorkflowDeleteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 243);

/**
 * @generated from message vtctldata.WorkflowDeleteResponse
 */
export type WorkflowDeleteResponse = Message<"vtctldata.WorkflowDeleteResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: repeated vtctldata.WorkflowDeleteResponse.TabletInfo details = 2;
   */
  details: WorkflowDeleteResponse_TabletInfo[];
};

/**
 * @generated from message vtctldata.WorkflowDeleteResponse
 */
export type WorkflowDeleteResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: repeated vtctldata.WorkflowDeleteResponse.TabletInfo details = 2;
   */
  details?: WorkflowDeleteResponse_TabletInfoJson[];
};

/**
 * Describes the message vtctldata.WorkflowDeleteResponse.
 * Use `create(WorkflowDeleteResponseSchema)` to create a new message.
 */
export const WorkflowDeleteResponseSchema: GenMessage<WorkflowDeleteResponse, WorkflowDeleteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 244);

/**
 * @generated from message vtctldata.WorkflowDeleteResponse.TabletInfo
 */
export type WorkflowDeleteResponse_TabletInfo = Message<"vtctldata.WorkflowDeleteResponse.TabletInfo"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAlias;

  /**
   * Delete is set if the workflow was deleted on this tablet.
   *
   * @generated from field: bool deleted = 2;
   */
  deleted: boolean;
};

/**
 * @generated from message vtctldata.WorkflowDeleteResponse.TabletInfo
 */
export type WorkflowDeleteResponse_TabletInfoJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAliasJson;

  /**
   * Delete is set if the workflow was deleted on this tablet.
   *
   * @generated from field: bool deleted = 2;
   */
  deleted?: boolean;
};

/**
 * Describes the message vtctldata.WorkflowDeleteResponse.TabletInfo.
 * Use `create(WorkflowDeleteResponse_TabletInfoSchema)` to create a new message.
 */
export const WorkflowDeleteResponse_TabletInfoSchema: GenMessage<WorkflowDeleteResponse_TabletInfo, WorkflowDeleteResponse_TabletInfoJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 244, 0);

/**
 * @generated from message vtctldata.WorkflowStatusRequest
 */
export type WorkflowStatusRequest = Message<"vtctldata.WorkflowStatusRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow: string;

  /**
   * @generated from field: repeated string shards = 3;
   */
  shards: string[];
};

/**
 * @generated from message vtctldata.WorkflowStatusRequest
 */
export type WorkflowStatusRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow?: string;

  /**
   * @generated from field: repeated string shards = 3;
   */
  shards?: string[];
};

/**
 * Describes the message vtctldata.WorkflowStatusRequest.
 * Use `create(WorkflowStatusRequestSchema)` to create a new message.
 */
export const WorkflowStatusRequestSchema: GenMessage<WorkflowStatusRequest, WorkflowStatusRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 245);

/**
 * @generated from message vtctldata.WorkflowStatusResponse
 */
export type WorkflowStatusResponse = Message<"vtctldata.WorkflowStatusResponse"> & {
  /**
   * The key is keyspace/shard.
   *
   * @generated from field: map<string, vtctldata.WorkflowStatusResponse.TableCopyState> table_copy_state = 1;
   */
  tableCopyState: { [key: string]: WorkflowStatusResponse_TableCopyState };

  /**
   * @generated from field: map<string, vtctldata.WorkflowStatusResponse.ShardStreams> shard_streams = 2;
   */
  shardStreams: { [key: string]: WorkflowStatusResponse_ShardStreams };

  /**
   * @generated from field: string traffic_state = 3;
   */
  trafficState: string;
};

/**
 * @generated from message vtctldata.WorkflowStatusResponse
 */
export type WorkflowStatusResponseJson = {
  /**
   * The key is keyspace/shard.
   *
   * @generated from field: map<string, vtctldata.WorkflowStatusResponse.TableCopyState> table_copy_state = 1;
   */
  tableCopyState?: { [key: string]: WorkflowStatusResponse_TableCopyStateJson };

  /**
   * @generated from field: map<string, vtctldata.WorkflowStatusResponse.ShardStreams> shard_streams = 2;
   */
  shardStreams?: { [key: string]: WorkflowStatusResponse_ShardStreamsJson };

  /**
   * @generated from field: string traffic_state = 3;
   */
  trafficState?: string;
};

/**
 * Describes the message vtctldata.WorkflowStatusResponse.
 * Use `create(WorkflowStatusResponseSchema)` to create a new message.
 */
export const WorkflowStatusResponseSchema: GenMessage<WorkflowStatusResponse, WorkflowStatusResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 246);

/**
 * @generated from message vtctldata.WorkflowStatusResponse.TableCopyState
 */
export type WorkflowStatusResponse_TableCopyState = Message<"vtctldata.WorkflowStatusResponse.TableCopyState"> & {
  /**
   * @generated from field: int64 rows_copied = 1;
   */
  rowsCopied: bigint;

  /**
   * @generated from field: int64 rows_total = 2;
   */
  rowsTotal: bigint;

  /**
   * @generated from field: float rows_percentage = 3;
   */
  rowsPercentage: number;

  /**
   * @generated from field: int64 bytes_copied = 4;
   */
  bytesCopied: bigint;

  /**
   * @generated from field: int64 bytes_total = 5;
   */
  bytesTotal: bigint;

  /**
   * @generated from field: float bytes_percentage = 6;
   */
  bytesPercentage: number;
};

/**
 * @generated from message vtctldata.WorkflowStatusResponse.TableCopyState
 */
export type WorkflowStatusResponse_TableCopyStateJson = {
  /**
   * @generated from field: int64 rows_copied = 1;
   */
  rowsCopied?: string;

  /**
   * @generated from field: int64 rows_total = 2;
   */
  rowsTotal?: string;

  /**
   * @generated from field: float rows_percentage = 3;
   */
  rowsPercentage?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: int64 bytes_copied = 4;
   */
  bytesCopied?: string;

  /**
   * @generated from field: int64 bytes_total = 5;
   */
  bytesTotal?: string;

  /**
   * @generated from field: float bytes_percentage = 6;
   */
  bytesPercentage?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message vtctldata.WorkflowStatusResponse.TableCopyState.
 * Use `create(WorkflowStatusResponse_TableCopyStateSchema)` to create a new message.
 */
export const WorkflowStatusResponse_TableCopyStateSchema: GenMessage<WorkflowStatusResponse_TableCopyState, WorkflowStatusResponse_TableCopyStateJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 246, 0);

/**
 * @generated from message vtctldata.WorkflowStatusResponse.ShardStreamState
 */
export type WorkflowStatusResponse_ShardStreamState = Message<"vtctldata.WorkflowStatusResponse.ShardStreamState"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: topodata.TabletAlias tablet = 2;
   */
  tablet?: TabletAlias;

  /**
   * @generated from field: string source_shard = 3;
   */
  sourceShard: string;

  /**
   * @generated from field: string position = 4;
   */
  position: string;

  /**
   * @generated from field: string status = 5;
   */
  status: string;

  /**
   * @generated from field: string info = 6;
   */
  info: string;
};

/**
 * @generated from message vtctldata.WorkflowStatusResponse.ShardStreamState
 */
export type WorkflowStatusResponse_ShardStreamStateJson = {
  /**
   * @generated from field: int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: topodata.TabletAlias tablet = 2;
   */
  tablet?: TabletAliasJson;

  /**
   * @generated from field: string source_shard = 3;
   */
  sourceShard?: string;

  /**
   * @generated from field: string position = 4;
   */
  position?: string;

  /**
   * @generated from field: string status = 5;
   */
  status?: string;

  /**
   * @generated from field: string info = 6;
   */
  info?: string;
};

/**
 * Describes the message vtctldata.WorkflowStatusResponse.ShardStreamState.
 * Use `create(WorkflowStatusResponse_ShardStreamStateSchema)` to create a new message.
 */
export const WorkflowStatusResponse_ShardStreamStateSchema: GenMessage<WorkflowStatusResponse_ShardStreamState, WorkflowStatusResponse_ShardStreamStateJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 246, 1);

/**
 * @generated from message vtctldata.WorkflowStatusResponse.ShardStreams
 */
export type WorkflowStatusResponse_ShardStreams = Message<"vtctldata.WorkflowStatusResponse.ShardStreams"> & {
  /**
   * @generated from field: repeated vtctldata.WorkflowStatusResponse.ShardStreamState streams = 2;
   */
  streams: WorkflowStatusResponse_ShardStreamState[];
};

/**
 * @generated from message vtctldata.WorkflowStatusResponse.ShardStreams
 */
export type WorkflowStatusResponse_ShardStreamsJson = {
  /**
   * @generated from field: repeated vtctldata.WorkflowStatusResponse.ShardStreamState streams = 2;
   */
  streams?: WorkflowStatusResponse_ShardStreamStateJson[];
};

/**
 * Describes the message vtctldata.WorkflowStatusResponse.ShardStreams.
 * Use `create(WorkflowStatusResponse_ShardStreamsSchema)` to create a new message.
 */
export const WorkflowStatusResponse_ShardStreamsSchema: GenMessage<WorkflowStatusResponse_ShardStreams, WorkflowStatusResponse_ShardStreamsJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 246, 2);

/**
 * @generated from message vtctldata.WorkflowSwitchTrafficRequest
 */
export type WorkflowSwitchTrafficRequest = Message<"vtctldata.WorkflowSwitchTrafficRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 4;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: vttime.Duration max_replication_lag_allowed = 5;
   */
  maxReplicationLagAllowed?: Duration;

  /**
   * @generated from field: bool enable_reverse_replication = 6;
   */
  enableReverseReplication: boolean;

  /**
   * @generated from field: int32 direction = 7;
   */
  direction: number;

  /**
   * @generated from field: vttime.Duration timeout = 8;
   */
  timeout?: Duration;

  /**
   * @generated from field: bool dry_run = 9;
   */
  dryRun: boolean;

  /**
   * @generated from field: bool initialize_target_sequences = 10;
   */
  initializeTargetSequences: boolean;

  /**
   * @generated from field: repeated string shards = 11;
   */
  shards: string[];

  /**
   * @generated from field: bool force = 12;
   */
  force: boolean;
};

/**
 * @generated from message vtctldata.WorkflowSwitchTrafficRequest
 */
export type WorkflowSwitchTrafficRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow?: string;

  /**
   * @generated from field: repeated string cells = 3;
   */
  cells?: string[];

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 4;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: vttime.Duration max_replication_lag_allowed = 5;
   */
  maxReplicationLagAllowed?: DurationJson;

  /**
   * @generated from field: bool enable_reverse_replication = 6;
   */
  enableReverseReplication?: boolean;

  /**
   * @generated from field: int32 direction = 7;
   */
  direction?: number;

  /**
   * @generated from field: vttime.Duration timeout = 8;
   */
  timeout?: DurationJson;

  /**
   * @generated from field: bool dry_run = 9;
   */
  dryRun?: boolean;

  /**
   * @generated from field: bool initialize_target_sequences = 10;
   */
  initializeTargetSequences?: boolean;

  /**
   * @generated from field: repeated string shards = 11;
   */
  shards?: string[];

  /**
   * @generated from field: bool force = 12;
   */
  force?: boolean;
};

/**
 * Describes the message vtctldata.WorkflowSwitchTrafficRequest.
 * Use `create(WorkflowSwitchTrafficRequestSchema)` to create a new message.
 */
export const WorkflowSwitchTrafficRequestSchema: GenMessage<WorkflowSwitchTrafficRequest, WorkflowSwitchTrafficRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 247);

/**
 * @generated from message vtctldata.WorkflowSwitchTrafficResponse
 */
export type WorkflowSwitchTrafficResponse = Message<"vtctldata.WorkflowSwitchTrafficResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: string start_state = 2;
   */
  startState: string;

  /**
   * @generated from field: string current_state = 3;
   */
  currentState: string;

  /**
   * @generated from field: repeated string dry_run_results = 4;
   */
  dryRunResults: string[];
};

/**
 * @generated from message vtctldata.WorkflowSwitchTrafficResponse
 */
export type WorkflowSwitchTrafficResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: string start_state = 2;
   */
  startState?: string;

  /**
   * @generated from field: string current_state = 3;
   */
  currentState?: string;

  /**
   * @generated from field: repeated string dry_run_results = 4;
   */
  dryRunResults?: string[];
};

/**
 * Describes the message vtctldata.WorkflowSwitchTrafficResponse.
 * Use `create(WorkflowSwitchTrafficResponseSchema)` to create a new message.
 */
export const WorkflowSwitchTrafficResponseSchema: GenMessage<WorkflowSwitchTrafficResponse, WorkflowSwitchTrafficResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 248);

/**
 * @generated from message vtctldata.WorkflowUpdateRequest
 */
export type WorkflowUpdateRequest = Message<"vtctldata.WorkflowUpdateRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * TabletRequest gets passed on to each primary tablet involved
   * in the workflow via the UpdateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request = 2;
   */
  tabletRequest?: UpdateVReplicationWorkflowRequest;
};

/**
 * @generated from message vtctldata.WorkflowUpdateRequest
 */
export type WorkflowUpdateRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * TabletRequest gets passed on to each primary tablet involved
   * in the workflow via the UpdateVReplicationWorkflow tabletmanager RPC.
   *
   * @generated from field: tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request = 2;
   */
  tabletRequest?: UpdateVReplicationWorkflowRequestJson;
};

/**
 * Describes the message vtctldata.WorkflowUpdateRequest.
 * Use `create(WorkflowUpdateRequestSchema)` to create a new message.
 */
export const WorkflowUpdateRequestSchema: GenMessage<WorkflowUpdateRequest, WorkflowUpdateRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 249);

/**
 * @generated from message vtctldata.WorkflowUpdateResponse
 */
export type WorkflowUpdateResponse = Message<"vtctldata.WorkflowUpdateResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: repeated vtctldata.WorkflowUpdateResponse.TabletInfo details = 2;
   */
  details: WorkflowUpdateResponse_TabletInfo[];
};

/**
 * @generated from message vtctldata.WorkflowUpdateResponse
 */
export type WorkflowUpdateResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: repeated vtctldata.WorkflowUpdateResponse.TabletInfo details = 2;
   */
  details?: WorkflowUpdateResponse_TabletInfoJson[];
};

/**
 * Describes the message vtctldata.WorkflowUpdateResponse.
 * Use `create(WorkflowUpdateResponseSchema)` to create a new message.
 */
export const WorkflowUpdateResponseSchema: GenMessage<WorkflowUpdateResponse, WorkflowUpdateResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 250);

/**
 * @generated from message vtctldata.WorkflowUpdateResponse.TabletInfo
 */
export type WorkflowUpdateResponse_TabletInfo = Message<"vtctldata.WorkflowUpdateResponse.TabletInfo"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAlias;

  /**
   * Changed is true if any of the provided values were different
   * than what was already stored on this tablet.
   *
   * @generated from field: bool changed = 2;
   */
  changed: boolean;
};

/**
 * @generated from message vtctldata.WorkflowUpdateResponse.TabletInfo
 */
export type WorkflowUpdateResponse_TabletInfoJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet = 1;
   */
  tablet?: TabletAliasJson;

  /**
   * Changed is true if any of the provided values were different
   * than what was already stored on this tablet.
   *
   * @generated from field: bool changed = 2;
   */
  changed?: boolean;
};

/**
 * Describes the message vtctldata.WorkflowUpdateResponse.TabletInfo.
 * Use `create(WorkflowUpdateResponse_TabletInfoSchema)` to create a new message.
 */
export const WorkflowUpdateResponse_TabletInfoSchema: GenMessage<WorkflowUpdateResponse_TabletInfo, WorkflowUpdateResponse_TabletInfoJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 250, 0);

/**
 * @generated from message vtctldata.GetMirrorRulesRequest
 */
export type GetMirrorRulesRequest = Message<"vtctldata.GetMirrorRulesRequest"> & {
};

/**
 * @generated from message vtctldata.GetMirrorRulesRequest
 */
export type GetMirrorRulesRequestJson = {
};

/**
 * Describes the message vtctldata.GetMirrorRulesRequest.
 * Use `create(GetMirrorRulesRequestSchema)` to create a new message.
 */
export const GetMirrorRulesRequestSchema: GenMessage<GetMirrorRulesRequest, GetMirrorRulesRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 251);

/**
 * @generated from message vtctldata.GetMirrorRulesResponse
 */
export type GetMirrorRulesResponse = Message<"vtctldata.GetMirrorRulesResponse"> & {
  /**
   * @generated from field: vschema.MirrorRules mirror_rules = 1;
   */
  mirrorRules?: MirrorRules;
};

/**
 * @generated from message vtctldata.GetMirrorRulesResponse
 */
export type GetMirrorRulesResponseJson = {
  /**
   * @generated from field: vschema.MirrorRules mirror_rules = 1;
   */
  mirrorRules?: MirrorRulesJson;
};

/**
 * Describes the message vtctldata.GetMirrorRulesResponse.
 * Use `create(GetMirrorRulesResponseSchema)` to create a new message.
 */
export const GetMirrorRulesResponseSchema: GenMessage<GetMirrorRulesResponse, GetMirrorRulesResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 252);

/**
 * @generated from message vtctldata.WorkflowMirrorTrafficRequest
 */
export type WorkflowMirrorTrafficRequest = Message<"vtctldata.WorkflowMirrorTrafficRequest"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow: string;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 3;
   */
  tabletTypes: TabletType[];

  /**
   * @generated from field: float percent = 4;
   */
  percent: number;
};

/**
 * @generated from message vtctldata.WorkflowMirrorTrafficRequest
 */
export type WorkflowMirrorTrafficRequestJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string workflow = 2;
   */
  workflow?: string;

  /**
   * @generated from field: repeated topodata.TabletType tablet_types = 3;
   */
  tabletTypes?: TabletTypeJson[];

  /**
   * @generated from field: float percent = 4;
   */
  percent?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message vtctldata.WorkflowMirrorTrafficRequest.
 * Use `create(WorkflowMirrorTrafficRequestSchema)` to create a new message.
 */
export const WorkflowMirrorTrafficRequestSchema: GenMessage<WorkflowMirrorTrafficRequest, WorkflowMirrorTrafficRequestJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 253);

/**
 * @generated from message vtctldata.WorkflowMirrorTrafficResponse
 */
export type WorkflowMirrorTrafficResponse = Message<"vtctldata.WorkflowMirrorTrafficResponse"> & {
  /**
   * @generated from field: string summary = 1;
   */
  summary: string;

  /**
   * @generated from field: string start_state = 2;
   */
  startState: string;

  /**
   * @generated from field: string current_state = 3;
   */
  currentState: string;
};

/**
 * @generated from message vtctldata.WorkflowMirrorTrafficResponse
 */
export type WorkflowMirrorTrafficResponseJson = {
  /**
   * @generated from field: string summary = 1;
   */
  summary?: string;

  /**
   * @generated from field: string start_state = 2;
   */
  startState?: string;

  /**
   * @generated from field: string current_state = 3;
   */
  currentState?: string;
};

/**
 * Describes the message vtctldata.WorkflowMirrorTrafficResponse.
 * Use `create(WorkflowMirrorTrafficResponseSchema)` to create a new message.
 */
export const WorkflowMirrorTrafficResponseSchema: GenMessage<WorkflowMirrorTrafficResponse, WorkflowMirrorTrafficResponseJson> = /*@__PURE__*/
  messageDesc(file_vtctldata, 254);

/**
 * MaterializationIntent describes the reason for creating the Materialize flow
 *
 * @generated from enum vtctldata.MaterializationIntent
 */
export enum MaterializationIntent {
  /**
   * CUSTOM is the default value
   *
   * @generated from enum value: CUSTOM = 0;
   */
  CUSTOM = 0,

  /**
   * MOVETABLES is when we are creating a MoveTables flow
   *
   * @generated from enum value: MOVETABLES = 1;
   */
  MOVETABLES = 1,

  /**
   * CREATELOOKUPINDEX is when we are creating a CreateLookupIndex flow
   *
   * @generated from enum value: CREATELOOKUPINDEX = 2;
   */
  CREATELOOKUPINDEX = 2,
}

/**
 * MaterializationIntent describes the reason for creating the Materialize flow
 *
 * @generated from enum vtctldata.MaterializationIntent
 */
export type MaterializationIntentJson = "CUSTOM" | "MOVETABLES" | "CREATELOOKUPINDEX";

/**
 * Describes the enum vtctldata.MaterializationIntent.
 */
export const MaterializationIntentSchema: GenEnum<MaterializationIntent, MaterializationIntentJson> = /*@__PURE__*/
  enumDesc(file_vtctldata, 0);

/**
 * @generated from enum vtctldata.QueryOrdering
 */
export enum QueryOrdering {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: ASCENDING = 1;
   */
  ASCENDING = 1,

  /**
   * @generated from enum value: DESCENDING = 2;
   */
  DESCENDING = 2,
}

/**
 * @generated from enum vtctldata.QueryOrdering
 */
export type QueryOrderingJson = "NONE" | "ASCENDING" | "DESCENDING";

/**
 * Describes the enum vtctldata.QueryOrdering.
 */
export const QueryOrderingSchema: GenEnum<QueryOrdering, QueryOrderingJson> = /*@__PURE__*/
  enumDesc(file_vtctldata, 1);

/**
 * @generated from enum vtctldata.ShardedAutoIncrementHandling
 */
export enum ShardedAutoIncrementHandling {
  /**
   * @generated from enum value: LEAVE = 0;
   */
  LEAVE = 0,

  /**
   * @generated from enum value: REMOVE = 1;
   */
  REMOVE = 1,

  /**
   * @generated from enum value: REPLACE = 2;
   */
  REPLACE = 2,
}

/**
 * @generated from enum vtctldata.ShardedAutoIncrementHandling
 */
export type ShardedAutoIncrementHandlingJson = "LEAVE" | "REMOVE" | "REPLACE";

/**
 * Describes the enum vtctldata.ShardedAutoIncrementHandling.
 */
export const ShardedAutoIncrementHandlingSchema: GenEnum<ShardedAutoIncrementHandling, ShardedAutoIncrementHandlingJson> = /*@__PURE__*/
  enumDesc(file_vtctldata, 2);

