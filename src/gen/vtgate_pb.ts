//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Data definitions for service vtgateservice.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file vtgate.proto (package vtgate, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Filter, FilterJson, VEvent, VEventJson, VGtid, VGtidJson } from "./binlogdata_pb";
import { file_binlogdata } from "./binlogdata_pb";
import type { BindVariable, BindVariableJson, BoundQuery, BoundQueryJson, ExecuteOptions, ExecuteOptionsJson, Field, FieldJson, QueryResult, QueryResultJson, QueryWarning, QueryWarningJson, ResultWithError, ResultWithErrorJson, Target, TargetJson } from "./query_pb";
import { file_query } from "./query_pb";
import type { TabletAlias, TabletAliasJson, TabletType, TabletTypeJson } from "./topodata_pb";
import { file_topodata } from "./topodata_pb";
import type { CallerID, CallerIDJson, RPCError, RPCErrorJson } from "./vtrpc_pb";
import { file_vtrpc } from "./vtrpc_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file vtgate.proto.
 */
export const file_vtgate: GenFile = /*@__PURE__*/
  fileDesc("Cgx2dGdhdGUucHJvdG8SBnZ0Z2F0ZSKSCwoHU2Vzc2lvbhIWCg5pbl90cmFuc2FjdGlvbhgBIAEoCBI0Cg5zaGFyZF9zZXNzaW9ucxgCIAMoCzIcLnZ0Z2F0ZS5TZXNzaW9uLlNoYXJkU2Vzc2lvbhISCgphdXRvY29tbWl0GAQgASgIEhUKDXRhcmdldF9zdHJpbmcYBSABKAkSJgoHb3B0aW9ucxgGIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEjEKEHRyYW5zYWN0aW9uX21vZGUYByABKA4yFy52dGdhdGUuVHJhbnNhY3Rpb25Nb2RlEiUKCHdhcm5pbmdzGAggAygLMhMucXVlcnkuUXVlcnlXYXJuaW5nEjIKDHByZV9zZXNzaW9ucxgJIAMoCzIcLnZ0Z2F0ZS5TZXNzaW9uLlNoYXJkU2Vzc2lvbhIzCg1wb3N0X3Nlc3Npb25zGAogAygLMhwudnRnYXRlLlNlc3Npb24uU2hhcmRTZXNzaW9uEhYKDmxhc3RfaW5zZXJ0X2lkGAsgASgEEhIKCmZvdW5kX3Jvd3MYDCABKAQSSQoWdXNlcl9kZWZpbmVkX3ZhcmlhYmxlcxgNIAMoCzIpLnZ0Z2F0ZS5TZXNzaW9uLlVzZXJEZWZpbmVkVmFyaWFibGVzRW50cnkSPgoQc3lzdGVtX3ZhcmlhYmxlcxgOIAMoCzIkLnZ0Z2F0ZS5TZXNzaW9uLlN5c3RlbVZhcmlhYmxlc0VudHJ5EhEKCXJvd19jb3VudBgPIAEoAxISCgpzYXZlcG9pbnRzGBAgAygJEhgKEGluX3Jlc2VydmVkX2Nvbm4YESABKAgSMgoMbG9ja19zZXNzaW9uGBIgASgLMhwudnRnYXRlLlNlc3Npb24uU2hhcmRTZXNzaW9uEhsKE2xhc3RfbG9ja19oZWFydGJlYXQYEyABKAMSMAoQcmVhZF9hZnRlcl93cml0ZRgUIAEoCzIWLnZ0Z2F0ZS5SZWFkQWZ0ZXJXcml0ZRITCgtERExTdHJhdGVneRgVIAEoCRITCgtTZXNzaW9uVVVJRBgWIAEoCRIeChZlbmFibGVfc3lzdGVtX3NldHRpbmdzGBcgASgIEjgKDWFkdmlzb3J5X2xvY2sYGCADKAsyIS52dGdhdGUuU2Vzc2lvbi5BZHZpc29yeUxvY2tFbnRyeRIVCg1xdWVyeV90aW1lb3V0GBkgASgDEkAKEXByZXBhcmVfc3RhdGVtZW50GBogAygLMiUudnRnYXRlLlNlc3Npb24uUHJlcGFyZVN0YXRlbWVudEVudHJ5EhkKEW1pZ3JhdGlvbl9jb250ZXh0GBsgASgJGpwBCgxTaGFyZFNlc3Npb24SHQoGdGFyZ2V0GAEgASgLMg0ucXVlcnkuVGFyZ2V0EhYKDnRyYW5zYWN0aW9uX2lkGAIgASgDEisKDHRhYmxldF9hbGlhcxgDIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEhMKC3Jlc2VydmVkX2lkGAQgASgDEhMKC3ZpbmRleF9vbmx5GAUgASgIGlAKGVVzZXJEZWZpbmVkVmFyaWFibGVzRW50cnkSCwoDa2V5GAEgASgJEiIKBXZhbHVlGAIgASgLMhMucXVlcnkuQmluZFZhcmlhYmxlOgI4ARo2ChRTeXN0ZW1WYXJpYWJsZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjMKEUFkdmlzb3J5TG9ja0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoAzoCOAEaTAoVUHJlcGFyZVN0YXRlbWVudEVudHJ5EgsKA2tleRgBIAEoCRIiCgV2YWx1ZRgCIAEoCzITLnZ0Z2F0ZS5QcmVwYXJlRGF0YToCOAFKBAgDEAQiPgoLUHJlcGFyZURhdGESGQoRcHJlcGFyZV9zdGF0ZW1lbnQYASABKAkSFAoMcGFyYW1zX2NvdW50GAIgASgFIm4KDlJlYWRBZnRlcldyaXRlEh0KFXJlYWRfYWZ0ZXJfd3JpdGVfZ3RpZBgBIAEoCRIgChhyZWFkX2FmdGVyX3dyaXRlX3RpbWVvdXQYAiABKAESGwoTc2Vzc2lvbl90cmFja19ndGlkcxgDIAEoCCKQAQoORXhlY3V0ZVJlcXVlc3QSIgoJY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSIAoHc2Vzc2lvbhgCIAEoCzIPLnZ0Z2F0ZS5TZXNzaW9uEiAKBXF1ZXJ5GAMgASgLMhEucXVlcnkuQm91bmRRdWVyeUoECAQQBUoECAUQBkoECAYQB0oECAcQCCJ3Cg9FeGVjdXRlUmVzcG9uc2USHgoFZXJyb3IYASABKAsyDy52dHJwYy5SUENFcnJvchIgCgdzZXNzaW9uGAIgASgLMg8udnRnYXRlLlNlc3Npb24SIgoGcmVzdWx0GAMgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQilwEKE0V4ZWN1dGVCYXRjaFJlcXVlc3QSIgoJY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSIAoHc2Vzc2lvbhgCIAEoCzIPLnZ0Z2F0ZS5TZXNzaW9uEiIKB3F1ZXJpZXMYAyADKAsyES5xdWVyeS5Cb3VuZFF1ZXJ5SgQIBBAFSgQIBRAGSgQIBhAHSgQIBxAIIoEBChRFeGVjdXRlQmF0Y2hSZXNwb25zZRIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiAKB3Nlc3Npb24YAiABKAsyDy52dGdhdGUuU2Vzc2lvbhInCgdyZXN1bHRzGAMgAygLMhYucXVlcnkuUmVzdWx0V2l0aEVycm9yIpABChRTdHJlYW1FeGVjdXRlUmVxdWVzdBIiCgljYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIgCgVxdWVyeRgCIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSIAoHc2Vzc2lvbhgGIAEoCzIPLnZ0Z2F0ZS5TZXNzaW9uSgQIAxAESgQIBBAFSgQIBRAGIl0KFVN0cmVhbUV4ZWN1dGVSZXNwb25zZRIiCgZyZXN1bHQYASABKAsyEi5xdWVyeS5RdWVyeVJlc3VsdBIgCgdzZXNzaW9uGAIgASgLMg8udnRnYXRlLlNlc3Npb24iTQoZUmVzb2x2ZVRyYW5zYWN0aW9uUmVxdWVzdBIiCgljYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIMCgRkdGlkGAIgASgJIhwKGlJlc29sdmVUcmFuc2FjdGlvblJlc3BvbnNlIuQBCgxWU3RyZWFtRmxhZ3MSFQoNbWluaW1pemVfc2tldxgBIAEoCBIaChJoZWFydGJlYXRfaW50ZXJ2YWwYAiABKA0SFwoPc3RvcF9vbl9yZXNoYXJkGAMgASgIEg0KBWNlbGxzGAQgASgJEhcKD2NlbGxfcHJlZmVyZW5jZRgFIAEoCRIUCgx0YWJsZXRfb3JkZXIYBiABKAkSIgoac3RyZWFtX2tleXNwYWNlX2hlYXJ0YmVhdHMYByABKAgSJgoeaW5jbHVkZV9yZXNoYXJkX2pvdXJuYWxfZXZlbnRzGAggASgIIsoBCg5WU3RyZWFtUmVxdWVzdBIiCgljYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIpCgt0YWJsZXRfdHlwZRgCIAEoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSIAoFdmd0aWQYAyABKAsyES5iaW5sb2dkYXRhLlZHdGlkEiIKBmZpbHRlchgEIAEoCzISLmJpbmxvZ2RhdGEuRmlsdGVyEiMKBWZsYWdzGAUgASgLMhQudnRnYXRlLlZTdHJlYW1GbGFncyI1Cg9WU3RyZWFtUmVzcG9uc2USIgoGZXZlbnRzGAEgAygLMhIuYmlubG9nZGF0YS5WRXZlbnQieAoOUHJlcGFyZVJlcXVlc3QSIgoJY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSIAoHc2Vzc2lvbhgCIAEoCzIPLnZ0Z2F0ZS5TZXNzaW9uEiAKBXF1ZXJ5GAMgASgLMhEucXVlcnkuQm91bmRRdWVyeSJxCg9QcmVwYXJlUmVzcG9uc2USHgoFZXJyb3IYASABKAsyDy52dHJwYy5SUENFcnJvchIgCgdzZXNzaW9uGAIgASgLMg8udnRnYXRlLlNlc3Npb24SHAoGZmllbGRzGAMgAygLMgwucXVlcnkuRmllbGQiWwoTQ2xvc2VTZXNzaW9uUmVxdWVzdBIiCgljYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIgCgdzZXNzaW9uGAIgASgLMg8udnRnYXRlLlNlc3Npb24iNgoUQ2xvc2VTZXNzaW9uUmVzcG9uc2USHgoFZXJyb3IYASABKAsyDy52dHJwYy5SUENFcnJvcipECg9UcmFuc2FjdGlvbk1vZGUSDwoLVU5TUEVDSUZJRUQQABIKCgZTSU5HTEUQARIJCgVNVUxUSRACEgkKBVRXT1BDEAMqPAoLQ29tbWl0T3JkZXISCgoGTk9STUFMEAASBwoDUFJFEAESCAoEUE9TVBACEg4KCkFVVE9DT01NSVQQA0I2Cg9pby52aXRlc3MucHJvdG9aI3ZpdGVzcy5pby92aXRlc3MvZ28vdnQvcHJvdG8vdnRnYXRlYgZwcm90bzM", [file_binlogdata, file_query, file_topodata, file_vtrpc]);

/**
 * Session objects are exchanged like cookies through various
 * calls to VTGate. The behavior differs between V2 & V3 APIs.
 * V3 APIs are Execute, ExecuteBatch and StreamExecute. All
 * other APIs are V2. For the V3 APIs, the session
 * must be sent with every call to Execute or ExecuteBatch.
 * For the V2 APIs, Begin does not accept a session. It instead
 * returns a brand new one with in_transaction set to true.
 * After a call to Commit or Rollback, the session can be
 * discarded. If you're not in a transaction, Session is
 * an optional parameter for the V2 APIs.
 *
 * @generated from message vtgate.Session
 */
export type Session = Message<"vtgate.Session"> & {
  /**
   * in_transaction is set to true if the session is in a transaction.
   *
   * @generated from field: bool in_transaction = 1;
   */
  inTransaction: boolean;

  /**
   * shard_sessions keep track of per-shard transaction info.
   *
   * @generated from field: repeated vtgate.Session.ShardSession shard_sessions = 2;
   */
  shardSessions: Session_ShardSession[];

  /**
   * autocommit specifies if the session is in autocommit mode.
   * This is used only for V3.
   *
   * @generated from field: bool autocommit = 4;
   */
  autocommit: boolean;

  /**
   * target_string is the target expressed as a string. Valid
   * names are: keyspace:shard@target, keyspace@target or @target.
   * This is used only for V3.
   *
   * @generated from field: string target_string = 5;
   */
  targetString: string;

  /**
   * options is used only for V3.
   *
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptions;

  /**
   * transaction_mode specifies the current transaction mode.
   *
   * @generated from field: vtgate.TransactionMode transaction_mode = 7;
   */
  transactionMode: TransactionMode;

  /**
   * warnings contains non-fatal warnings from the previous query
   *
   * @generated from field: repeated query.QueryWarning warnings = 8;
   */
  warnings: QueryWarning[];

  /**
   * pre_sessions contains sessions that have to be committed first.
   *
   * @generated from field: repeated vtgate.Session.ShardSession pre_sessions = 9;
   */
  preSessions: Session_ShardSession[];

  /**
   * post_sessions contains sessions that have to be committed last.
   *
   * @generated from field: repeated vtgate.Session.ShardSession post_sessions = 10;
   */
  postSessions: Session_ShardSession[];

  /**
   * last_insert_id keeps track of the last seen insert_id for this session
   *
   * @generated from field: uint64 last_insert_id = 11;
   */
  lastInsertId: bigint;

  /**
   * found_rows keeps track of how many rows the last query returned
   *
   * @generated from field: uint64 found_rows = 12;
   */
  foundRows: bigint;

  /**
   * user_defined_variables contains all the @variables defined for this session
   *
   * @generated from field: map<string, query.BindVariable> user_defined_variables = 13;
   */
  userDefinedVariables: { [key: string]: BindVariable };

  /**
   * system_variables keeps track of all session variables set for this connection
   * TODO: systay should we keep this so we can apply it ordered?
   *
   * @generated from field: map<string, string> system_variables = 14;
   */
  systemVariables: { [key: string]: string };

  /**
   * row_count keeps track of the last seen rows affected for this session
   *
   * @generated from field: int64 row_count = 15;
   */
  rowCount: bigint;

  /**
   * Stores savepoint and release savepoint calls inside a transaction
   * and is reset once transaction is committed or rolled back.
   *
   * @generated from field: repeated string savepoints = 16;
   */
  savepoints: string[];

  /**
   * in_reserved_conn is set to true if the session should be using reserved connections.
   *
   * @generated from field: bool in_reserved_conn = 17;
   */
  inReservedConn: boolean;

  /**
   * lock_session keep tracks of shard on which the lock query is sent.
   *
   * @generated from field: vtgate.Session.ShardSession lock_session = 18;
   */
  lockSession?: Session_ShardSession;

  /**
   * last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
   *
   * @generated from field: int64 last_lock_heartbeat = 19;
   */
  lastLockHeartbeat: bigint;

  /**
   * read_after_write tracks the ReadAfterWrite settings for this session.
   *
   * @generated from field: vtgate.ReadAfterWrite read_after_write = 20;
   */
  readAfterWrite?: ReadAfterWrite;

  /**
   * DDL strategy
   *
   * @generated from field: string DDLStrategy = 21;
   */
  DDLStrategy: string;

  /**
   * Session UUID
   *
   * @generated from field: string SessionUUID = 22;
   */
  SessionUUID: string;

  /**
   * enable_system_settings defines if we can use reserved connections.
   *
   * @generated from field: bool enable_system_settings = 23;
   */
  enableSystemSettings: boolean;

  /**
   * @generated from field: map<string, int64> advisory_lock = 24;
   */
  advisoryLock: { [key: string]: bigint };

  /**
   * query_timeout is the maximum amount of time a query is permitted to run
   *
   * @generated from field: int64 query_timeout = 25;
   */
  queryTimeout: bigint;

  /**
   * @generated from field: map<string, vtgate.PrepareData> prepare_statement = 26;
   */
  prepareStatement: { [key: string]: PrepareData };

  /**
   * MigrationContext
   *
   * @generated from field: string migration_context = 27;
   */
  migrationContext: string;
};

/**
 * Session objects are exchanged like cookies through various
 * calls to VTGate. The behavior differs between V2 & V3 APIs.
 * V3 APIs are Execute, ExecuteBatch and StreamExecute. All
 * other APIs are V2. For the V3 APIs, the session
 * must be sent with every call to Execute or ExecuteBatch.
 * For the V2 APIs, Begin does not accept a session. It instead
 * returns a brand new one with in_transaction set to true.
 * After a call to Commit or Rollback, the session can be
 * discarded. If you're not in a transaction, Session is
 * an optional parameter for the V2 APIs.
 *
 * @generated from message vtgate.Session
 */
export type SessionJson = {
  /**
   * in_transaction is set to true if the session is in a transaction.
   *
   * @generated from field: bool in_transaction = 1;
   */
  inTransaction?: boolean;

  /**
   * shard_sessions keep track of per-shard transaction info.
   *
   * @generated from field: repeated vtgate.Session.ShardSession shard_sessions = 2;
   */
  shardSessions?: Session_ShardSessionJson[];

  /**
   * autocommit specifies if the session is in autocommit mode.
   * This is used only for V3.
   *
   * @generated from field: bool autocommit = 4;
   */
  autocommit?: boolean;

  /**
   * target_string is the target expressed as a string. Valid
   * names are: keyspace:shard@target, keyspace@target or @target.
   * This is used only for V3.
   *
   * @generated from field: string target_string = 5;
   */
  targetString?: string;

  /**
   * options is used only for V3.
   *
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptionsJson;

  /**
   * transaction_mode specifies the current transaction mode.
   *
   * @generated from field: vtgate.TransactionMode transaction_mode = 7;
   */
  transactionMode?: TransactionModeJson;

  /**
   * warnings contains non-fatal warnings from the previous query
   *
   * @generated from field: repeated query.QueryWarning warnings = 8;
   */
  warnings?: QueryWarningJson[];

  /**
   * pre_sessions contains sessions that have to be committed first.
   *
   * @generated from field: repeated vtgate.Session.ShardSession pre_sessions = 9;
   */
  preSessions?: Session_ShardSessionJson[];

  /**
   * post_sessions contains sessions that have to be committed last.
   *
   * @generated from field: repeated vtgate.Session.ShardSession post_sessions = 10;
   */
  postSessions?: Session_ShardSessionJson[];

  /**
   * last_insert_id keeps track of the last seen insert_id for this session
   *
   * @generated from field: uint64 last_insert_id = 11;
   */
  lastInsertId?: string;

  /**
   * found_rows keeps track of how many rows the last query returned
   *
   * @generated from field: uint64 found_rows = 12;
   */
  foundRows?: string;

  /**
   * user_defined_variables contains all the @variables defined for this session
   *
   * @generated from field: map<string, query.BindVariable> user_defined_variables = 13;
   */
  userDefinedVariables?: { [key: string]: BindVariableJson };

  /**
   * system_variables keeps track of all session variables set for this connection
   * TODO: systay should we keep this so we can apply it ordered?
   *
   * @generated from field: map<string, string> system_variables = 14;
   */
  systemVariables?: { [key: string]: string };

  /**
   * row_count keeps track of the last seen rows affected for this session
   *
   * @generated from field: int64 row_count = 15;
   */
  rowCount?: string;

  /**
   * Stores savepoint and release savepoint calls inside a transaction
   * and is reset once transaction is committed or rolled back.
   *
   * @generated from field: repeated string savepoints = 16;
   */
  savepoints?: string[];

  /**
   * in_reserved_conn is set to true if the session should be using reserved connections.
   *
   * @generated from field: bool in_reserved_conn = 17;
   */
  inReservedConn?: boolean;

  /**
   * lock_session keep tracks of shard on which the lock query is sent.
   *
   * @generated from field: vtgate.Session.ShardSession lock_session = 18;
   */
  lockSession?: Session_ShardSessionJson;

  /**
   * last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
   *
   * @generated from field: int64 last_lock_heartbeat = 19;
   */
  lastLockHeartbeat?: string;

  /**
   * read_after_write tracks the ReadAfterWrite settings for this session.
   *
   * @generated from field: vtgate.ReadAfterWrite read_after_write = 20;
   */
  readAfterWrite?: ReadAfterWriteJson;

  /**
   * DDL strategy
   *
   * @generated from field: string DDLStrategy = 21;
   */
  DDLStrategy?: string;

  /**
   * Session UUID
   *
   * @generated from field: string SessionUUID = 22;
   */
  SessionUUID?: string;

  /**
   * enable_system_settings defines if we can use reserved connections.
   *
   * @generated from field: bool enable_system_settings = 23;
   */
  enableSystemSettings?: boolean;

  /**
   * @generated from field: map<string, int64> advisory_lock = 24;
   */
  advisoryLock?: { [key: string]: string };

  /**
   * query_timeout is the maximum amount of time a query is permitted to run
   *
   * @generated from field: int64 query_timeout = 25;
   */
  queryTimeout?: string;

  /**
   * @generated from field: map<string, vtgate.PrepareData> prepare_statement = 26;
   */
  prepareStatement?: { [key: string]: PrepareDataJson };

  /**
   * MigrationContext
   *
   * @generated from field: string migration_context = 27;
   */
  migrationContext?: string;
};

/**
 * Describes the message vtgate.Session.
 * Use `create(SessionSchema)` to create a new message.
 */
export const SessionSchema: GenMessage<Session, SessionJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 0);

/**
 * @generated from message vtgate.Session.ShardSession
 */
export type Session_ShardSession = Message<"vtgate.Session.ShardSession"> & {
  /**
   * @generated from field: query.Target target = 1;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 2;
   */
  transactionId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAlias;

  /**
   * reserved connection if a dedicated connection is needed
   *
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId: bigint;

  /**
   * @generated from field: bool vindex_only = 5;
   */
  vindexOnly: boolean;
};

/**
 * @generated from message vtgate.Session.ShardSession
 */
export type Session_ShardSessionJson = {
  /**
   * @generated from field: query.Target target = 1;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 2;
   */
  transactionId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 3;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * reserved connection if a dedicated connection is needed
   *
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId?: string;

  /**
   * @generated from field: bool vindex_only = 5;
   */
  vindexOnly?: boolean;
};

/**
 * Describes the message vtgate.Session.ShardSession.
 * Use `create(Session_ShardSessionSchema)` to create a new message.
 */
export const Session_ShardSessionSchema: GenMessage<Session_ShardSession, Session_ShardSessionJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 0, 0);

/**
 * PrepareData keeps the prepared statement and other information related for execution of it.
 *
 * @generated from message vtgate.PrepareData
 */
export type PrepareData = Message<"vtgate.PrepareData"> & {
  /**
   * @generated from field: string prepare_statement = 1;
   */
  prepareStatement: string;

  /**
   * @generated from field: int32 params_count = 2;
   */
  paramsCount: number;
};

/**
 * PrepareData keeps the prepared statement and other information related for execution of it.
 *
 * @generated from message vtgate.PrepareData
 */
export type PrepareDataJson = {
  /**
   * @generated from field: string prepare_statement = 1;
   */
  prepareStatement?: string;

  /**
   * @generated from field: int32 params_count = 2;
   */
  paramsCount?: number;
};

/**
 * Describes the message vtgate.PrepareData.
 * Use `create(PrepareDataSchema)` to create a new message.
 */
export const PrepareDataSchema: GenMessage<PrepareData, PrepareDataJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 1);

/**
 * ReadAfterWrite contains information regarding gtid set and timeout
 * Also if the gtid information needs to be passed to client.
 *
 * @generated from message vtgate.ReadAfterWrite
 */
export type ReadAfterWrite = Message<"vtgate.ReadAfterWrite"> & {
  /**
   * @generated from field: string read_after_write_gtid = 1;
   */
  readAfterWriteGtid: string;

  /**
   * @generated from field: double read_after_write_timeout = 2;
   */
  readAfterWriteTimeout: number;

  /**
   * @generated from field: bool session_track_gtids = 3;
   */
  sessionTrackGtids: boolean;
};

/**
 * ReadAfterWrite contains information regarding gtid set and timeout
 * Also if the gtid information needs to be passed to client.
 *
 * @generated from message vtgate.ReadAfterWrite
 */
export type ReadAfterWriteJson = {
  /**
   * @generated from field: string read_after_write_gtid = 1;
   */
  readAfterWriteGtid?: string;

  /**
   * @generated from field: double read_after_write_timeout = 2;
   */
  readAfterWriteTimeout?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: bool session_track_gtids = 3;
   */
  sessionTrackGtids?: boolean;
};

/**
 * Describes the message vtgate.ReadAfterWrite.
 * Use `create(ReadAfterWriteSchema)` to create a new message.
 */
export const ReadAfterWriteSchema: GenMessage<ReadAfterWrite, ReadAfterWriteJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 2);

/**
 * ExecuteRequest is the payload to Execute.
 *
 * @generated from message vtgate.ExecuteRequest
 */
export type ExecuteRequest = Message<"vtgate.ExecuteRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 3;
   */
  query?: BoundQuery;
};

/**
 * ExecuteRequest is the payload to Execute.
 *
 * @generated from message vtgate.ExecuteRequest
 */
export type ExecuteRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 3;
   */
  query?: BoundQueryJson;
};

/**
 * Describes the message vtgate.ExecuteRequest.
 * Use `create(ExecuteRequestSchema)` to create a new message.
 */
export const ExecuteRequestSchema: GenMessage<ExecuteRequest, ExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 3);

/**
 * ExecuteResponse is the returned value from Execute.
 *
 * @generated from message vtgate.ExecuteResponse
 */
export type ExecuteResponse = Message<"vtgate.ExecuteResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * result contains the query result, only set if error is unset.
   *
   * @generated from field: query.QueryResult result = 3;
   */
  result?: QueryResult;
};

/**
 * ExecuteResponse is the returned value from Execute.
 *
 * @generated from message vtgate.ExecuteResponse
 */
export type ExecuteResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * result contains the query result, only set if error is unset.
   *
   * @generated from field: query.QueryResult result = 3;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message vtgate.ExecuteResponse.
 * Use `create(ExecuteResponseSchema)` to create a new message.
 */
export const ExecuteResponseSchema: GenMessage<ExecuteResponse, ExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 4);

/**
 * ExecuteBatchRequest is the payload to ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchRequest
 */
export type ExecuteBatchRequest = Message<"vtgate.ExecuteBatchRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * queries is a list of query and bind variables to execute.
   *
   * @generated from field: repeated query.BoundQuery queries = 3;
   */
  queries: BoundQuery[];
};

/**
 * ExecuteBatchRequest is the payload to ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchRequest
 */
export type ExecuteBatchRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * queries is a list of query and bind variables to execute.
   *
   * @generated from field: repeated query.BoundQuery queries = 3;
   */
  queries?: BoundQueryJson[];
};

/**
 * Describes the message vtgate.ExecuteBatchRequest.
 * Use `create(ExecuteBatchRequestSchema)` to create a new message.
 */
export const ExecuteBatchRequestSchema: GenMessage<ExecuteBatchRequest, ExecuteBatchRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 5);

/**
 * ExecuteBatchResponse is the returned value from ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchResponse
 */
export type ExecuteBatchResponse = Message<"vtgate.ExecuteBatchResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * results contains the query results, only set if application level error is unset.
   *
   * @generated from field: repeated query.ResultWithError results = 3;
   */
  results: ResultWithError[];
};

/**
 * ExecuteBatchResponse is the returned value from ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchResponse
 */
export type ExecuteBatchResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * results contains the query results, only set if application level error is unset.
   *
   * @generated from field: repeated query.ResultWithError results = 3;
   */
  results?: ResultWithErrorJson[];
};

/**
 * Describes the message vtgate.ExecuteBatchResponse.
 * Use `create(ExecuteBatchResponseSchema)` to create a new message.
 */
export const ExecuteBatchResponseSchema: GenMessage<ExecuteBatchResponse, ExecuteBatchResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 6);

/**
 * StreamExecuteRequest is the payload to StreamExecute.
 *
 * @generated from message vtgate.StreamExecuteRequest
 */
export type StreamExecuteRequest = Message<"vtgate.StreamExecuteRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 2;
   */
  query?: BoundQuery;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 6;
   */
  session?: Session;
};

/**
 * StreamExecuteRequest is the payload to StreamExecute.
 *
 * @generated from message vtgate.StreamExecuteRequest
 */
export type StreamExecuteRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 2;
   */
  query?: BoundQueryJson;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 6;
   */
  session?: SessionJson;
};

/**
 * Describes the message vtgate.StreamExecuteRequest.
 * Use `create(StreamExecuteRequestSchema)` to create a new message.
 */
export const StreamExecuteRequestSchema: GenMessage<StreamExecuteRequest, StreamExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 7);

/**
 * StreamExecuteResponse is the returned value from StreamExecute.
 * The session is currently not returned because StreamExecute is
 * not expected to modify it.
 *
 * @generated from message vtgate.StreamExecuteResponse
 */
export type StreamExecuteResponse = Message<"vtgate.StreamExecuteResponse"> & {
  /**
   * result contains the result data.
   * The first value contains only Fields information.
   * The next values contain the actual rows, a few values per result.
   *
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;
};

/**
 * StreamExecuteResponse is the returned value from StreamExecute.
 * The session is currently not returned because StreamExecute is
 * not expected to modify it.
 *
 * @generated from message vtgate.StreamExecuteResponse
 */
export type StreamExecuteResponseJson = {
  /**
   * result contains the result data.
   * The first value contains only Fields information.
   * The next values contain the actual rows, a few values per result.
   *
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;
};

/**
 * Describes the message vtgate.StreamExecuteResponse.
 * Use `create(StreamExecuteResponseSchema)` to create a new message.
 */
export const StreamExecuteResponseSchema: GenMessage<StreamExecuteResponse, StreamExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 8);

/**
 * ResolveTransactionRequest is the payload to ResolveTransaction.
 *
 * @generated from message vtgate.ResolveTransactionRequest
 */
export type ResolveTransactionRequest = Message<"vtgate.ResolveTransactionRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * dtid is the dtid of the transaction to be resolved.
   *
   * @generated from field: string dtid = 2;
   */
  dtid: string;
};

/**
 * ResolveTransactionRequest is the payload to ResolveTransaction.
 *
 * @generated from message vtgate.ResolveTransactionRequest
 */
export type ResolveTransactionRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * dtid is the dtid of the transaction to be resolved.
   *
   * @generated from field: string dtid = 2;
   */
  dtid?: string;
};

/**
 * Describes the message vtgate.ResolveTransactionRequest.
 * Use `create(ResolveTransactionRequestSchema)` to create a new message.
 */
export const ResolveTransactionRequestSchema: GenMessage<ResolveTransactionRequest, ResolveTransactionRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 9);

/**
 * ResolveTransactionResponse is the returned value from Rollback.
 *
 * @generated from message vtgate.ResolveTransactionResponse
 */
export type ResolveTransactionResponse = Message<"vtgate.ResolveTransactionResponse"> & {
};

/**
 * ResolveTransactionResponse is the returned value from Rollback.
 *
 * @generated from message vtgate.ResolveTransactionResponse
 */
export type ResolveTransactionResponseJson = {
};

/**
 * Describes the message vtgate.ResolveTransactionResponse.
 * Use `create(ResolveTransactionResponseSchema)` to create a new message.
 */
export const ResolveTransactionResponseSchema: GenMessage<ResolveTransactionResponse, ResolveTransactionResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 10);

/**
 * @generated from message vtgate.VStreamFlags
 */
export type VStreamFlags = Message<"vtgate.VStreamFlags"> & {
  /**
   * align streams
   *
   * @generated from field: bool minimize_skew = 1;
   */
  minimizeSkew: boolean;

  /**
   * how often heartbeats must be sent when idle (seconds)
   *
   * @generated from field: uint32 heartbeat_interval = 2;
   */
  heartbeatInterval: number;

  /**
   * stop streams on a reshard (journal event)
   *
   * @generated from field: bool stop_on_reshard = 3;
   */
  stopOnReshard: boolean;

  /**
   * if specified, these cells (comma-separated) are used to pick source tablets from.
   * defaults to the cell of the vtgate serving the VStream API.
   *
   * @generated from field: string cells = 4;
   */
  cells: string;

  /**
   * @generated from field: string cell_preference = 5;
   */
  cellPreference: string;

  /**
   * @generated from field: string tablet_order = 6;
   */
  tabletOrder: string;

  /**
   * When set, all new row events from the `heartbeat` table, for all shards, in the sidecardb will be streamed.
   *
   * @generated from field: bool stream_keyspace_heartbeats = 7;
   */
  streamKeyspaceHeartbeats: boolean;

  /**
   * Include reshard journal events in the stream.
   *
   * @generated from field: bool include_reshard_journal_events = 8;
   */
  includeReshardJournalEvents: boolean;
};

/**
 * @generated from message vtgate.VStreamFlags
 */
export type VStreamFlagsJson = {
  /**
   * align streams
   *
   * @generated from field: bool minimize_skew = 1;
   */
  minimizeSkew?: boolean;

  /**
   * how often heartbeats must be sent when idle (seconds)
   *
   * @generated from field: uint32 heartbeat_interval = 2;
   */
  heartbeatInterval?: number;

  /**
   * stop streams on a reshard (journal event)
   *
   * @generated from field: bool stop_on_reshard = 3;
   */
  stopOnReshard?: boolean;

  /**
   * if specified, these cells (comma-separated) are used to pick source tablets from.
   * defaults to the cell of the vtgate serving the VStream API.
   *
   * @generated from field: string cells = 4;
   */
  cells?: string;

  /**
   * @generated from field: string cell_preference = 5;
   */
  cellPreference?: string;

  /**
   * @generated from field: string tablet_order = 6;
   */
  tabletOrder?: string;

  /**
   * When set, all new row events from the `heartbeat` table, for all shards, in the sidecardb will be streamed.
   *
   * @generated from field: bool stream_keyspace_heartbeats = 7;
   */
  streamKeyspaceHeartbeats?: boolean;

  /**
   * Include reshard journal events in the stream.
   *
   * @generated from field: bool include_reshard_journal_events = 8;
   */
  includeReshardJournalEvents?: boolean;
};

/**
 * Describes the message vtgate.VStreamFlags.
 * Use `create(VStreamFlagsSchema)` to create a new message.
 */
export const VStreamFlagsSchema: GenMessage<VStreamFlags, VStreamFlagsJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 11);

/**
 * VStreamRequest is the payload for VStream.
 *
 * @generated from message vtgate.VStreamRequest
 */
export type VStreamRequest = Message<"vtgate.VStreamRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * @generated from field: topodata.TabletType tablet_type = 2;
   */
  tabletType: TabletType;

  /**
   * position specifies the starting point of the bin log positions
   * as well as the keyspace-shards to pull events from.
   * position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
   *
   * @generated from field: binlogdata.VGtid vgtid = 3;
   */
  vgtid?: VGtid;

  /**
   * @generated from field: binlogdata.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * @generated from field: vtgate.VStreamFlags flags = 5;
   */
  flags?: VStreamFlags;
};

/**
 * VStreamRequest is the payload for VStream.
 *
 * @generated from message vtgate.VStreamRequest
 */
export type VStreamRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * @generated from field: topodata.TabletType tablet_type = 2;
   */
  tabletType?: TabletTypeJson;

  /**
   * position specifies the starting point of the bin log positions
   * as well as the keyspace-shards to pull events from.
   * position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
   *
   * @generated from field: binlogdata.VGtid vgtid = 3;
   */
  vgtid?: VGtidJson;

  /**
   * @generated from field: binlogdata.Filter filter = 4;
   */
  filter?: FilterJson;

  /**
   * @generated from field: vtgate.VStreamFlags flags = 5;
   */
  flags?: VStreamFlagsJson;
};

/**
 * Describes the message vtgate.VStreamRequest.
 * Use `create(VStreamRequestSchema)` to create a new message.
 */
export const VStreamRequestSchema: GenMessage<VStreamRequest, VStreamRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 12);

/**
 * VStreamResponse is streamed by VStream.
 *
 * @generated from message vtgate.VStreamResponse
 */
export type VStreamResponse = Message<"vtgate.VStreamResponse"> & {
  /**
   * @generated from field: repeated binlogdata.VEvent events = 1;
   */
  events: VEvent[];
};

/**
 * VStreamResponse is streamed by VStream.
 *
 * @generated from message vtgate.VStreamResponse
 */
export type VStreamResponseJson = {
  /**
   * @generated from field: repeated binlogdata.VEvent events = 1;
   */
  events?: VEventJson[];
};

/**
 * Describes the message vtgate.VStreamResponse.
 * Use `create(VStreamResponseSchema)` to create a new message.
 */
export const VStreamResponseSchema: GenMessage<VStreamResponse, VStreamResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 13);

/**
 * PrepareRequest is the payload to Prepare.
 *
 * @generated from message vtgate.PrepareRequest
 */
export type PrepareRequest = Message<"vtgate.PrepareRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 3;
   */
  query?: BoundQuery;
};

/**
 * PrepareRequest is the payload to Prepare.
 *
 * @generated from message vtgate.PrepareRequest
 */
export type PrepareRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * query is the query and bind variables to execute.
   *
   * @generated from field: query.BoundQuery query = 3;
   */
  query?: BoundQueryJson;
};

/**
 * Describes the message vtgate.PrepareRequest.
 * Use `create(PrepareRequestSchema)` to create a new message.
 */
export const PrepareRequestSchema: GenMessage<PrepareRequest, PrepareRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 14);

/**
 * PrepareResponse is the returned value from Prepare.
 *
 * @generated from message vtgate.PrepareResponse
 */
export type PrepareResponse = Message<"vtgate.PrepareResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;

  /**
   * fields contains the fields, only set if error is unset.
   *
   * @generated from field: repeated query.Field fields = 3;
   */
  fields: Field[];
};

/**
 * PrepareResponse is the returned value from Prepare.
 *
 * @generated from message vtgate.PrepareResponse
 */
export type PrepareResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * session is the updated session information.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;

  /**
   * fields contains the fields, only set if error is unset.
   *
   * @generated from field: repeated query.Field fields = 3;
   */
  fields?: FieldJson[];
};

/**
 * Describes the message vtgate.PrepareResponse.
 * Use `create(PrepareResponseSchema)` to create a new message.
 */
export const PrepareResponseSchema: GenMessage<PrepareResponse, PrepareResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 15);

/**
 * CloseSessionRequest is the payload to CloseSession.
 *
 * @generated from message vtgate.CloseSessionRequest
 */
export type CloseSessionRequest = Message<"vtgate.CloseSessionRequest"> & {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerID;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: Session;
};

/**
 * CloseSessionRequest is the payload to CloseSession.
 *
 * @generated from message vtgate.CloseSessionRequest
 */
export type CloseSessionRequestJson = {
  /**
   * caller_id identifies the caller. This is the effective caller ID,
   * set by the application to further identify the caller.
   *
   * @generated from field: vtrpc.CallerID caller_id = 1;
   */
  callerId?: CallerIDJson;

  /**
   * session carries the session state.
   *
   * @generated from field: vtgate.Session session = 2;
   */
  session?: SessionJson;
};

/**
 * Describes the message vtgate.CloseSessionRequest.
 * Use `create(CloseSessionRequestSchema)` to create a new message.
 */
export const CloseSessionRequestSchema: GenMessage<CloseSessionRequest, CloseSessionRequestJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 16);

/**
 * CloseSessionResponse is the returned value from CloseSession.
 *
 * @generated from message vtgate.CloseSessionResponse
 */
export type CloseSessionResponse = Message<"vtgate.CloseSessionResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;
};

/**
 * CloseSessionResponse is the returned value from CloseSession.
 *
 * @generated from message vtgate.CloseSessionResponse
 */
export type CloseSessionResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * session may have changed, even when an error is returned (for
   * instance if a database integrity error happened).
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;
};

/**
 * Describes the message vtgate.CloseSessionResponse.
 * Use `create(CloseSessionResponseSchema)` to create a new message.
 */
export const CloseSessionResponseSchema: GenMessage<CloseSessionResponse, CloseSessionResponseJson> = /*@__PURE__*/
  messageDesc(file_vtgate, 17);

/**
 * TransactionMode controls the execution of distributed transaction
 * across multiple shards.
 *
 * @generated from enum vtgate.TransactionMode
 */
export enum TransactionMode {
  /**
   * UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * SINGLE disallows distributed transactions.
   *
   * @generated from enum value: SINGLE = 1;
   */
  SINGLE = 1,

  /**
   * MULTI allows distributed transactions with best effort commit.
   *
   * @generated from enum value: MULTI = 2;
   */
  MULTI = 2,

  /**
   * TWOPC is for distributed transactions with atomic commits.
   *
   * @generated from enum value: TWOPC = 3;
   */
  TWOPC = 3,
}

/**
 * TransactionMode controls the execution of distributed transaction
 * across multiple shards.
 *
 * @generated from enum vtgate.TransactionMode
 */
export type TransactionModeJson = "UNSPECIFIED" | "SINGLE" | "MULTI" | "TWOPC";

/**
 * Describes the enum vtgate.TransactionMode.
 */
export const TransactionModeSchema: GenEnum<TransactionMode, TransactionModeJson> = /*@__PURE__*/
  enumDesc(file_vtgate, 0);

/**
 * CommitOrder is used to designate which of the ShardSessions
 * get used for transactions.
 *
 * @generated from enum vtgate.CommitOrder
 */
export enum CommitOrder {
  /**
   * NORMAL is the default commit order.
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * PRE is used to designate pre_sessions.
   *
   * @generated from enum value: PRE = 1;
   */
  PRE = 1,

  /**
   * POST is used to designate post_sessions.
   *
   * @generated from enum value: POST = 2;
   */
  POST = 2,

  /**
   * AUTOCOMMIT is used to run the statement as autocommitted transaction.
   *
   * @generated from enum value: AUTOCOMMIT = 3;
   */
  AUTOCOMMIT = 3,
}

/**
 * CommitOrder is used to designate which of the ShardSessions
 * get used for transactions.
 *
 * @generated from enum vtgate.CommitOrder
 */
export type CommitOrderJson = "NORMAL" | "PRE" | "POST" | "AUTOCOMMIT";

/**
 * Describes the enum vtgate.CommitOrder.
 */
export const CommitOrderSchema: GenEnum<CommitOrder, CommitOrderJson> = /*@__PURE__*/
  enumDesc(file_vtgate, 1);

