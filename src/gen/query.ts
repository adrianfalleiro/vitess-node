// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "query.proto" (package "query", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains all the types necessary to make
// RPC calls to Vttablet.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TabletAlias } from "./topodata";
import { RPCError } from "./vtrpc";
import { CallerID } from "./vtrpc";
import { TabletType } from "./topodata";
/**
 * Target describes what the client expects the tablet is.
 * If the tablet does not match, an error is returned.
 *
 * @generated from protobuf message query.Target
 */
export interface Target {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletType tablet_type = 3;
     */
    tabletType: TabletType;
    /**
     * cell is used for routing queries between vtgate and vttablets. It
     * is not used when Target is part of the Session sent by the client.
     *
     * @generated from protobuf field: string cell = 4;
     */
    cell: string;
}
/**
 * VTGateCallerID is sent by VTGate to VTTablet to describe the
 * caller. If possible, this information is secure. For instance,
 * if using unique certificates that guarantee that VTGate->VTTablet
 * traffic cannot be spoofed, then VTTablet can trust this information,
 * and VTTablet will use it for tablet ACLs, for instance.
 * Because of this security guarantee, this is different than the CallerID
 * structure, which is not secure at all, because it is provided
 * by the Vitess client.
 *
 * @generated from protobuf message query.VTGateCallerID
 */
export interface VTGateCallerID {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: repeated string groups = 2;
     */
    groups: string[];
}
/**
 * EventToken is a structure that describes a point in time in a
 * replication stream on one shard. The most recent known replication
 * position can be retrieved from vttablet when executing a query. It
 * is also sent with the replication streams from the binlog service.
 *
 * @generated from protobuf message query.EventToken
 */
export interface EventToken {
    /**
     * timestamp is the MySQL timestamp of the statements. Seconds since Epoch.
     *
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * The shard name that applied the statements. Note this is not set when
     * streaming from a vttablet. It is only used on the client -> vtgate link.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * The position on the replication stream after this statement was applied.
     * It is not the transaction ID / GTID, but the position / GTIDSet.
     *
     * @generated from protobuf field: string position = 3;
     */
    position: string;
}
/**
 * Value represents a typed value.
 *
 * @generated from protobuf message query.Value
 */
export interface Value {
    /**
     * @generated from protobuf field: query.Type type = 1;
     */
    type: Type;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
}
/**
 * BindVariable represents a single bind variable in a Query.
 *
 * @generated from protobuf message query.BindVariable
 */
export interface BindVariable {
    /**
     * @generated from protobuf field: query.Type type = 1;
     */
    type: Type;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * values are set if type is TUPLE.
     *
     * @generated from protobuf field: repeated query.Value values = 3;
     */
    values: Value[];
}
/**
 * BoundQuery is a query with its bind variables
 *
 * @generated from protobuf message query.BoundQuery
 */
export interface BoundQuery {
    /**
     * sql is the SQL query to execute
     *
     * @generated from protobuf field: string sql = 1;
     */
    sql: string;
    /**
     * bind_variables is a map of all bind variables to expand in the query.
     * nil values are not allowed. Use NULL_TYPE to express a NULL value.
     *
     * @generated from protobuf field: map<string, query.BindVariable> bind_variables = 2;
     */
    bindVariables: {
        [key: string]: BindVariable;
    };
}
/**
 * ExecuteOptions is passed around for all Execute calls.
 *
 * @generated from protobuf message query.ExecuteOptions
 */
export interface ExecuteOptions {
    /**
     * Controls what fields are returned in Field message responses from mysql, i.e.
     * field name, table name, etc. This is an optimization for high-QPS queries where
     * the client knows what it's getting
     *
     * @generated from protobuf field: query.ExecuteOptions.IncludedFields included_fields = 4;
     */
    includedFields: ExecuteOptions_IncludedFields;
    /**
     * client_rows_found specifies if rows_affected should return
     * rows found instead of rows affected. Behavior is defined
     * by MySQL's CLIENT_FOUND_ROWS flag.
     *
     * @generated from protobuf field: bool client_found_rows = 5;
     */
    clientFoundRows: boolean;
    /**
     * workload specifies the type of workload:
     * OLTP: DMLs allowed, results have row count limit, and
     * query timeouts are shorter.
     * OLAP: DMLS not allowed, no limit on row count, timeouts
     * can be as high as desired.
     * DBA: no limit on rowcount or timeout, all queries allowed
     * but intended for long DMLs and DDLs.
     *
     * @generated from protobuf field: query.ExecuteOptions.Workload workload = 6;
     */
    workload: ExecuteOptions_Workload;
    /**
     * sql_select_limit sets an implicit limit on all select statements. Since
     * vitess also sets a rowcount limit on queries, the smallest value wins.
     *
     * @generated from protobuf field: int64 sql_select_limit = 8;
     */
    sqlSelectLimit: bigint;
    /**
     * @generated from protobuf field: query.ExecuteOptions.TransactionIsolation transaction_isolation = 9;
     */
    transactionIsolation: ExecuteOptions_TransactionIsolation;
    /**
     * skip_query_plan_cache specifies if the query plan should be cached by vitess.
     * By default all query plans are cached.
     *
     * @generated from protobuf field: bool skip_query_plan_cache = 10;
     */
    skipQueryPlanCache: boolean;
    /**
     * PlannerVersion specifies which planner to use.
     * If DEFAULT is chosen, whatever vtgate was started with will be used
     *
     * @generated from protobuf field: query.ExecuteOptions.PlannerVersion planner_version = 11;
     */
    plannerVersion: ExecuteOptions_PlannerVersion;
    /**
     * has_created_temp_tables signals whether plans created in this session should be cached or not
     * if the user has created temp tables, Vitess will not reuse plans created for this session in other sessions.
     * The current session can still use other sessions cached plans.
     *
     * @generated from protobuf field: bool has_created_temp_tables = 12;
     */
    hasCreatedTempTables: boolean;
    /**
     * @generated from protobuf field: query.ExecuteOptions.Consolidator consolidator = 13;
     */
    consolidator: ExecuteOptions_Consolidator;
    /**
     * TransactionAccessMode specifies the access modes to be used while starting the transaction i.e. READ WRITE/READ ONLY/WITH CONSISTENT SNAPSHOT
     * If not specified, the transaction will be started with the default access mode on the connection.
     *
     * @generated from protobuf field: repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode = 14;
     */
    transactionAccessMode: ExecuteOptions_TransactionAccessMode[];
    /**
     * WorkloadName specifies the name of the workload as indicated in query directives. This is used for instrumentation
     * in metrics and tracing spans.
     *
     * @generated from protobuf field: string WorkloadName = 15 [json_name = "WorkloadName"];
     */
    workloadName: string;
    /**
     * priority specifies the priority of the query, between 0 and 100. This is leveraged by the transaction
     * throttler to determine whether, under resource contention, a query should or should not be throttled.
     *
     * @generated from protobuf field: string priority = 16;
     */
    priority: string;
    /**
     * @generated from protobuf oneof: timeout
     */
    timeout: {
        oneofKind: "authoritativeTimeout";
        /**
         * @generated from protobuf field: int64 authoritative_timeout = 17;
         */
        authoritativeTimeout: bigint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum query.ExecuteOptions.IncludedFields
 */
export enum ExecuteOptions_IncludedFields {
    /**
     * @generated from protobuf enum value: TYPE_AND_NAME = 0;
     */
    TYPE_AND_NAME = 0,
    /**
     * @generated from protobuf enum value: TYPE_ONLY = 1;
     */
    TYPE_ONLY = 1,
    /**
     * @generated from protobuf enum value: ALL = 2;
     */
    ALL = 2
}
/**
 * @generated from protobuf enum query.ExecuteOptions.Workload
 */
export enum ExecuteOptions_Workload {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: OLTP = 1;
     */
    OLTP = 1,
    /**
     * @generated from protobuf enum value: OLAP = 2;
     */
    OLAP = 2,
    /**
     * @generated from protobuf enum value: DBA = 3;
     */
    DBA = 3
}
/**
 * @generated from protobuf enum query.ExecuteOptions.TransactionIsolation
 */
export enum ExecuteOptions_TransactionIsolation {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * @generated from protobuf enum value: REPEATABLE_READ = 1;
     */
    REPEATABLE_READ = 1,
    /**
     * @generated from protobuf enum value: READ_COMMITTED = 2;
     */
    READ_COMMITTED = 2,
    /**
     * @generated from protobuf enum value: READ_UNCOMMITTED = 3;
     */
    READ_UNCOMMITTED = 3,
    /**
     * @generated from protobuf enum value: SERIALIZABLE = 4;
     */
    SERIALIZABLE = 4,
    /**
     * This is not an "official" transaction level but it will do a
     * START TRANSACTION WITH CONSISTENT SNAPSHOT, READ ONLY
     *
     * @generated from protobuf enum value: CONSISTENT_SNAPSHOT_READ_ONLY = 5;
     */
    CONSISTENT_SNAPSHOT_READ_ONLY = 5,
    /**
     * This not an "official" transaction level, it will send queries to mysql
     * without wrapping them in a transaction
     *
     * @generated from protobuf enum value: AUTOCOMMIT = 6;
     */
    AUTOCOMMIT = 6
}
/**
 * @generated from protobuf enum query.ExecuteOptions.PlannerVersion
 */
export enum ExecuteOptions_PlannerVersion {
    /**
     * @generated from protobuf enum value: DEFAULT_PLANNER = 0;
     */
    DEFAULT_PLANNER = 0,
    /**
     * @generated from protobuf enum value: V3 = 1;
     */
    V3 = 1,
    /**
     * @generated from protobuf enum value: Gen4 = 2;
     */
    Gen4 = 2,
    /**
     * @generated from protobuf enum value: Gen4Greedy = 3;
     */
    Gen4Greedy = 3,
    /**
     * @generated from protobuf enum value: Gen4Left2Right = 4;
     */
    Gen4Left2Right = 4,
    /**
     * @generated from protobuf enum value: Gen4WithFallback = 5;
     */
    Gen4WithFallback = 5,
    /**
     * @generated from protobuf enum value: Gen4CompareV3 = 6;
     */
    Gen4CompareV3 = 6,
    /**
     * @generated from protobuf enum value: V3Insert = 7;
     */
    V3Insert = 7
}
/**
 * @generated from protobuf enum query.ExecuteOptions.Consolidator
 */
export enum ExecuteOptions_Consolidator {
    /**
     * @generated from protobuf enum value: CONSOLIDATOR_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CONSOLIDATOR_DISABLED = 1;
     */
    DISABLED = 1,
    /**
     * @generated from protobuf enum value: CONSOLIDATOR_ENABLED = 2;
     */
    ENABLED = 2,
    /**
     * @generated from protobuf enum value: CONSOLIDATOR_ENABLED_REPLICAS = 3;
     */
    ENABLED_REPLICAS = 3
}
/**
 * @generated from protobuf enum query.ExecuteOptions.TransactionAccessMode
 */
export enum ExecuteOptions_TransactionAccessMode {
    /**
     * @generated from protobuf enum value: CONSISTENT_SNAPSHOT = 0;
     */
    CONSISTENT_SNAPSHOT = 0,
    /**
     * @generated from protobuf enum value: READ_WRITE = 1;
     */
    READ_WRITE = 1,
    /**
     * @generated from protobuf enum value: READ_ONLY = 2;
     */
    READ_ONLY = 2
}
/**
 * Field describes a single column returned by a query
 *
 * @generated from protobuf message query.Field
 */
export interface Field {
    /**
     * name of the field as returned by mysql C API
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * vitess-defined type. Conversion function is in sqltypes package.
     *
     * @generated from protobuf field: query.Type type = 2;
     */
    type: Type;
    /**
     * Remaining fields from mysql C API.
     * These fields are only populated when ExecuteOptions.included_fields
     * is set to IncludedFields.ALL.
     *
     * @generated from protobuf field: string table = 3;
     */
    table: string;
    /**
     * @generated from protobuf field: string org_table = 4;
     */
    orgTable: string;
    /**
     * @generated from protobuf field: string database = 5;
     */
    database: string;
    /**
     * @generated from protobuf field: string org_name = 6;
     */
    orgName: string;
    /**
     * column_length is really a uint32. All 32 bits can be used.
     *
     * @generated from protobuf field: uint32 column_length = 7;
     */
    columnLength: number;
    /**
     * charset is actually a uint16. Only the lower 16 bits are used.
     *
     * @generated from protobuf field: uint32 charset = 8;
     */
    charset: number;
    /**
     * decimals is actually a uint8. Only the lower 8 bits are used.
     *
     * @generated from protobuf field: uint32 decimals = 9;
     */
    decimals: number;
    /**
     * flags is actually a uint16. Only the lower 16 bits are used.
     *
     * @generated from protobuf field: uint32 flags = 10;
     */
    flags: number;
    /**
     * column_type is optionally populated from information_schema.columns
     *
     * @generated from protobuf field: string column_type = 11;
     */
    columnType: string;
}
/**
 * Row is a database row.
 *
 * @generated from protobuf message query.Row
 */
export interface Row {
    /**
     * lengths contains the length of each value in values.
     * A length of -1 means that the field is NULL. While
     * reading values, you have to accummulate the length
     * to know the offset where the next value begins in values.
     *
     * @generated from protobuf field: repeated sint64 lengths = 1;
     */
    lengths: bigint[];
    /**
     * values contains a concatenation of all values in the row.
     *
     * @generated from protobuf field: bytes values = 2;
     */
    values: Uint8Array;
}
/**
 * QueryResult is returned by Execute and ExecuteStream.
 *
 * As returned by Execute, len(fields) is always equal to len(row)
 * (for each row in rows).
 *
 * As returned by StreamExecute, the first QueryResult has the fields
 * set, and subsequent QueryResult have rows set. And as Execute,
 * len(QueryResult[0].fields) is always equal to len(row) (for each
 * row in rows for each QueryResult in QueryResult[1:]).
 *
 * @generated from protobuf message query.QueryResult
 */
export interface QueryResult {
    /**
     * @generated from protobuf field: repeated query.Field fields = 1;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: uint64 rows_affected = 2;
     */
    rowsAffected: bigint;
    /**
     * @generated from protobuf field: uint64 insert_id = 3;
     */
    insertId: bigint;
    /**
     * @generated from protobuf field: repeated query.Row rows = 4;
     */
    rows: Row[];
    /**
     * @generated from protobuf field: string info = 6;
     */
    info: string;
    /**
     * @generated from protobuf field: string session_state_changes = 7;
     */
    sessionStateChanges: string;
}
/**
 * QueryWarning is used to convey out of band query execution warnings
 * by storing in the vtgate.Session
 *
 * @generated from protobuf message query.QueryWarning
 */
export interface QueryWarning {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * StreamEvent describes a set of transformations that happened as a
 * single transactional unit on a server. It is streamed back by the
 * Update Stream calls.
 *
 * @generated from protobuf message query.StreamEvent
 */
export interface StreamEvent {
    /**
     * The statements in this transaction.
     *
     * @generated from protobuf field: repeated query.StreamEvent.Statement statements = 1;
     */
    statements: StreamEvent_Statement[];
    /**
     * The Event Token for this event.
     *
     * @generated from protobuf field: query.EventToken event_token = 2;
     */
    eventToken?: EventToken;
}
/**
 * One individual Statement in a transaction.
 *
 * @generated from protobuf message query.StreamEvent.Statement
 */
export interface StreamEvent_Statement {
    /**
     * @generated from protobuf field: query.StreamEvent.Statement.Category category = 1;
     */
    category: StreamEvent_Statement_Category;
    /**
     * table_name, primary_key_fields and primary_key_values are set for DML.
     *
     * @generated from protobuf field: string table_name = 2;
     */
    tableName: string;
    /**
     * @generated from protobuf field: repeated query.Field primary_key_fields = 3;
     */
    primaryKeyFields: Field[];
    /**
     * @generated from protobuf field: repeated query.Row primary_key_values = 4;
     */
    primaryKeyValues: Row[];
    /**
     * sql is set for all queries.
     * FIXME(alainjobart) we may not need it for DMLs.
     *
     * @generated from protobuf field: bytes sql = 5;
     */
    sql: Uint8Array;
}
/**
 * The category of one statement.
 *
 * @generated from protobuf enum query.StreamEvent.Statement.Category
 */
export enum StreamEvent_Statement_Category {
    /**
     * @generated from protobuf enum value: Error = 0;
     */
    Error = 0,
    /**
     * @generated from protobuf enum value: DML = 1;
     */
    DML = 1,
    /**
     * @generated from protobuf enum value: DDL = 2;
     */
    DDL = 2
}
/**
 * ExecuteRequest is the payload to Execute
 *
 * @generated from protobuf message query.ExecuteRequest
 */
export interface ExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: int64 transaction_id = 5;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: int64 reserved_id = 7;
     */
    reservedId: bigint;
}
/**
 * ExecuteResponse is the returned value from Execute
 *
 * @generated from protobuf message query.ExecuteResponse
 */
export interface ExecuteResponse {
    /**
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * ResultWithError represents a query response
 * in the form of result or error but not both.
 * TODO: To be used in ExecuteBatchResponse and BeginExecuteBatchResponse.
 *
 * @generated from protobuf message query.ResultWithError
 */
export interface ResultWithError {
    /**
     * error contains an query level error, only set if result is unset.
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * result contains the query result, only set if error is unset.
     *
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
}
/**
 * StreamExecuteRequest is the payload to StreamExecute
 *
 * @generated from protobuf message query.StreamExecuteRequest
 */
export interface StreamExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: int64 transaction_id = 6;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: int64 reserved_id = 7;
     */
    reservedId: bigint;
}
/**
 * StreamExecuteResponse is the returned value from StreamExecute
 *
 * @generated from protobuf message query.StreamExecuteResponse
 */
export interface StreamExecuteResponse {
    /**
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * BeginRequest is the payload to Begin
 *
 * @generated from protobuf message query.BeginRequest
 */
export interface BeginRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 4;
     */
    options?: ExecuteOptions;
}
/**
 * BeginResponse is the returned value from Begin
 *
 * @generated from protobuf message query.BeginResponse
 */
export interface BeginResponse {
    /**
     * @generated from protobuf field: int64 transaction_id = 1;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 2;
     */
    tabletAlias?: TabletAlias;
    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from protobuf field: string session_state_changes = 3;
     */
    sessionStateChanges: string;
}
/**
 * CommitRequest is the payload to Commit
 *
 * @generated from protobuf message query.CommitRequest
 */
export interface CommitRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
}
/**
 * CommitResponse is the returned value from Commit
 *
 * @generated from protobuf message query.CommitResponse
 */
export interface CommitResponse {
    /**
     * @generated from protobuf field: int64 reserved_id = 1;
     */
    reservedId: bigint;
}
/**
 * RollbackRequest is the payload to Rollback
 *
 * @generated from protobuf message query.RollbackRequest
 */
export interface RollbackRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
}
/**
 * RollbackResponse is the returned value from Rollback
 *
 * @generated from protobuf message query.RollbackResponse
 */
export interface RollbackResponse {
    /**
     * @generated from protobuf field: int64 reserved_id = 1;
     */
    reservedId: bigint;
}
/**
 * PrepareRequest is the payload to Prepare
 *
 * @generated from protobuf message query.PrepareRequest
 */
export interface PrepareRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: string dtid = 5;
     */
    dtid: string;
}
/**
 * PrepareResponse is the returned value from Prepare
 *
 * @generated from protobuf message query.PrepareResponse
 */
export interface PrepareResponse {
}
/**
 * CommitPreparedRequest is the payload to CommitPrepared
 *
 * @generated from protobuf message query.CommitPreparedRequest
 */
export interface CommitPreparedRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string dtid = 4;
     */
    dtid: string;
}
/**
 * CommitPreparedResponse is the returned value from CommitPrepared
 *
 * @generated from protobuf message query.CommitPreparedResponse
 */
export interface CommitPreparedResponse {
}
/**
 * RollbackPreparedRequest is the payload to RollbackPrepared
 *
 * @generated from protobuf message query.RollbackPreparedRequest
 */
export interface RollbackPreparedRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: string dtid = 5;
     */
    dtid: string;
}
/**
 * RollbackPreparedResponse is the returned value from RollbackPrepared
 *
 * @generated from protobuf message query.RollbackPreparedResponse
 */
export interface RollbackPreparedResponse {
}
/**
 * CreateTransactionRequest is the payload to CreateTransaction
 *
 * @generated from protobuf message query.CreateTransactionRequest
 */
export interface CreateTransactionRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string dtid = 4;
     */
    dtid: string;
    /**
     * @generated from protobuf field: repeated query.Target participants = 5;
     */
    participants: Target[];
}
/**
 * CreateTransactionResponse is the returned value from CreateTransaction
 *
 * @generated from protobuf message query.CreateTransactionResponse
 */
export interface CreateTransactionResponse {
}
/**
 * StartCommitRequest is the payload to StartCommit
 *
 * @generated from protobuf message query.StartCommitRequest
 */
export interface StartCommitRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: string dtid = 5;
     */
    dtid: string;
}
/**
 * StartCommitResponse is the returned value from StartCommit
 *
 * @generated from protobuf message query.StartCommitResponse
 */
export interface StartCommitResponse {
}
/**
 * SetRollbackRequest is the payload to SetRollback
 *
 * @generated from protobuf message query.SetRollbackRequest
 */
export interface SetRollbackRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: string dtid = 5;
     */
    dtid: string;
}
/**
 * SetRollbackResponse is the returned value from SetRollback
 *
 * @generated from protobuf message query.SetRollbackResponse
 */
export interface SetRollbackResponse {
}
/**
 * ConcludeTransactionRequest is the payload to ConcludeTransaction
 *
 * @generated from protobuf message query.ConcludeTransactionRequest
 */
export interface ConcludeTransactionRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string dtid = 4;
     */
    dtid: string;
}
/**
 * ConcludeTransactionResponse is the returned value from ConcludeTransaction
 *
 * @generated from protobuf message query.ConcludeTransactionResponse
 */
export interface ConcludeTransactionResponse {
}
/**
 * ReadTransactionRequest is the payload to ReadTransaction
 *
 * @generated from protobuf message query.ReadTransactionRequest
 */
export interface ReadTransactionRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string dtid = 4;
     */
    dtid: string;
}
/**
 * ReadTransactionResponse is the returned value from ReadTransaction
 *
 * @generated from protobuf message query.ReadTransactionResponse
 */
export interface ReadTransactionResponse {
    /**
     * @generated from protobuf field: query.TransactionMetadata metadata = 1;
     */
    metadata?: TransactionMetadata;
}
/**
 * UnresolvedTransactionsRequest is the payload to UnresolvedTransactions
 *
 * @generated from protobuf message query.UnresolvedTransactionsRequest
 */
export interface UnresolvedTransactionsRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 abandon_age = 4;
     */
    abandonAge: bigint; // Unresolved Transactions older than this (in seconds).
}
/**
 * UnresolvedTransactionsResponse is the returned value from UnresolvedTransactions
 *
 * @generated from protobuf message query.UnresolvedTransactionsResponse
 */
export interface UnresolvedTransactionsResponse {
    /**
     * @generated from protobuf field: repeated query.TransactionMetadata transactions = 1;
     */
    transactions: TransactionMetadata[];
}
/**
 * BeginExecuteRequest is the payload to BeginExecute
 *
 * @generated from protobuf message query.BeginExecuteRequest
 */
export interface BeginExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: int64 reserved_id = 6;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: repeated string pre_queries = 7;
     */
    preQueries: string[];
}
/**
 * BeginExecuteResponse is the returned value from BeginExecute
 *
 * @generated from protobuf message query.BeginExecuteResponse
 */
export interface BeginExecuteResponse {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the execute failed.
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * transaction_id might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 transaction_id = 3;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;
    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from protobuf field: string session_state_changes = 5;
     */
    sessionStateChanges: string;
}
/**
 * BeginStreamExecuteRequest is the payload to BeginStreamExecute
 *
 * @generated from protobuf message query.BeginStreamExecuteRequest
 */
export interface BeginStreamExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: repeated string pre_queries = 6;
     */
    preQueries: string[];
    /**
     * @generated from protobuf field: int64 reserved_id = 7;
     */
    reservedId: bigint;
}
/**
 * BeginStreamExecuteResponse is the returned value from BeginStreamExecute
 *
 * @generated from protobuf message query.BeginStreamExecuteResponse
 */
export interface BeginStreamExecuteResponse {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the stream execute failed.
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * transaction_id might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 transaction_id = 3;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;
    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from protobuf field: string session_state_changes = 5;
     */
    sessionStateChanges: string;
}
/**
 * MessageStreamRequest is the request payload for MessageStream.
 *
 * @generated from protobuf message query.MessageStreamRequest
 */
export interface MessageStreamRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * name is the message table name.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * MessageStreamResponse is a response for MessageStream.
 *
 * @generated from protobuf message query.MessageStreamResponse
 */
export interface MessageStreamResponse {
    /**
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * MessageAckRequest is the request payload for MessageAck.
 *
 * @generated from protobuf message query.MessageAckRequest
 */
export interface MessageAckRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * name is the message table name.
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated query.Value ids = 5;
     */
    ids: Value[];
}
/**
 * MessageAckResponse is the response for MessageAck.
 *
 * @generated from protobuf message query.MessageAckResponse
 */
export interface MessageAckResponse {
    /**
     * result contains the result of the ack operation.
     * Since this acts like a DML, only
     * RowsAffected is returned in the result.
     *
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * ReserveExecuteRequest is the payload to ReserveExecute
 *
 * @generated from protobuf message query.ReserveExecuteRequest
 */
export interface ReserveExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: int64 transaction_id = 5;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: repeated string pre_queries = 7;
     */
    preQueries: string[];
}
/**
 * ReserveExecuteResponse is the returned value from ReserveExecute
 *
 * @generated from protobuf message query.ReserveExecuteResponse
 */
export interface ReserveExecuteResponse {
    /**
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 reserved_id = 3;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;
}
/**
 * ReserveStreamExecuteRequest is the payload to ReserveStreamExecute
 *
 * @generated from protobuf message query.ReserveStreamExecuteRequest
 */
export interface ReserveStreamExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: int64 transaction_id = 6;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: repeated string pre_queries = 7;
     */
    preQueries: string[];
}
/**
 * ReserveStreamExecuteResponse is the returned value from ReserveStreamExecute
 *
 * @generated from protobuf message query.ReserveStreamExecuteResponse
 */
export interface ReserveStreamExecuteResponse {
    /**
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 reserved_id = 3;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;
}
/**
 * ReserveBeginExecuteRequest is the payload to ReserveBeginExecute
 *
 * @generated from protobuf message query.ReserveBeginExecuteRequest
 */
export interface ReserveBeginExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: repeated string pre_queries = 6;
     */
    preQueries: string[];
    /**
     * @generated from protobuf field: repeated string post_begin_queries = 7;
     */
    postBeginQueries: string[];
}
/**
 * ReserveBeginExecuteResponse is the returned value from ReserveBeginExecute
 *
 * @generated from protobuf message query.ReserveBeginExecuteResponse
 */
export interface ReserveBeginExecuteResponse {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the execute failed.
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 transaction_id = 3;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: int64 reserved_id = 4;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;
    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from protobuf field: string session_state_changes = 6;
     */
    sessionStateChanges: string;
}
/**
 * ReserveBeginStreamExecuteRequest is the payload to ReserveBeginStreamExecute
 *
 * @generated from protobuf message query.ReserveBeginStreamExecuteRequest
 */
export interface ReserveBeginStreamExecuteRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;
    /**
     * @generated from protobuf field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;
    /**
     * @generated from protobuf field: repeated string pre_queries = 6;
     */
    preQueries: string[];
    /**
     * @generated from protobuf field: repeated string post_begin_queries = 7;
     */
    postBeginQueries: string[];
}
/**
 * ReserveBeginStreamExecuteResponse is the returned value from ReserveBeginStreamExecute
 *
 * @generated from protobuf message query.ReserveBeginStreamExecuteResponse
 */
export interface ReserveBeginStreamExecuteResponse {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the stream execute failed.
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * @generated from protobuf field: query.QueryResult result = 2;
     */
    result?: QueryResult;
    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from protobuf field: int64 transaction_id = 3;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: int64 reserved_id = 4;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;
    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from protobuf field: string session_state_changes = 6;
     */
    sessionStateChanges: string;
}
/**
 * ReleaseRequest is the payload to Release
 *
 * @generated from protobuf message query.ReleaseRequest
 */
export interface ReleaseRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 4;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: int64 reserved_id = 5;
     */
    reservedId: bigint;
}
/**
 * ReleaseResponse is the returned value from Release
 *
 * @generated from protobuf message query.ReleaseResponse
 */
export interface ReleaseResponse {
}
/**
 * StreamHealthRequest is the payload for StreamHealth
 *
 * @generated from protobuf message query.StreamHealthRequest
 */
export interface StreamHealthRequest {
}
/**
 * RealtimeStats contains information about the tablet status.
 * It is only valid for a single tablet.
 *
 * @generated from protobuf message query.RealtimeStats
 */
export interface RealtimeStats {
    /**
     * health_error is the last error we got from health check,
     * or empty is the server is healthy. This is used for subset selection,
     * we do not send queries to servers that are not healthy.
     *
     * @generated from protobuf field: string health_error = 1;
     */
    healthError: string;
    /**
     * replication_lag_seconds is populated for replicas only. It indicates
     * how far behind on (MySQL) replication a replica currently is.  It is used
     * by clients for subset selection (so we don't try to send traffic
     * to tablets that are too far behind).
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     * TODO(mberlin): Let's switch it to int64 instead?
     *
     * @generated from protobuf field: uint32 replication_lag_seconds = 2;
     */
    replicationLagSeconds: number;
    /**
     * bin_log_players_count is the number of currently running binlog players.
     * if the value is 0, it means that filtered replication is currently not
     * running on the tablet. If >0, filtered replication is running.
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     *
     * @generated from protobuf field: int32 binlog_players_count = 3;
     */
    binlogPlayersCount: number;
    /**
     * filtered_replication_lag_seconds is populated for the receiving
     * primary of an ongoing filtered replication only.
     * It specifies how far the receiving primary lags behind the sending primary.
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     * NOTE: This field must not be evaluated if "bin_log_players_count" is 0.
     *
     * @generated from protobuf field: int64 filtered_replication_lag_seconds = 4;
     */
    filteredReplicationLagSeconds: bigint;
    /**
     * cpu_usage is used for load-based balancing
     *
     * @generated from protobuf field: double cpu_usage = 5;
     */
    cpuUsage: number;
    /**
     * qps is the average QPS (queries per second) rate in the last XX seconds
     * where XX is usually 60 (See query_service_stats.go).
     *
     * @generated from protobuf field: double qps = 6;
     */
    qps: number;
    /**
     * table_schema_changed is to provide list of tables that have schema changes detected by the tablet.
     *
     * @generated from protobuf field: repeated string table_schema_changed = 7;
     */
    tableSchemaChanged: string[];
    /**
     * view_schema_changed is to provide list of views that have schema changes detected by the tablet.
     *
     * @generated from protobuf field: repeated string view_schema_changed = 8;
     */
    viewSchemaChanged: string[];
    /**
     * udfs_changed is used to signal that the UDFs have changed on the tablet.
     *
     * @generated from protobuf field: bool udfs_changed = 9;
     */
    udfsChanged: boolean;
    /**
     * @generated from protobuf field: bool tx_unresolved = 10;
     */
    txUnresolved: boolean;
}
/**
 * AggregateStats contains information about the health of a group of
 * tablets for a Target.  It is used to propagate stats from a vtgate
 * to another, or from the Gateway layer of a vtgate to the routing
 * layer.
 *
 * @generated from protobuf message query.AggregateStats
 */
export interface AggregateStats {
    /**
     * healthy_tablet_count is the number of healthy tablets in the group.
     *
     * @generated from protobuf field: int32 healthy_tablet_count = 1;
     */
    healthyTabletCount: number;
    /**
     * unhealthy_tablet_count is the number of unhealthy tablets in the group.
     *
     * @generated from protobuf field: int32 unhealthy_tablet_count = 2;
     */
    unhealthyTabletCount: number;
    /**
     * replication_lag_seconds_min is the minimum of the
     * replication_lag_seconds values of the healthy tablets. It is unset
     * if the tablet type is primary.
     *
     * @generated from protobuf field: uint32 replication_lag_seconds_min = 3;
     */
    replicationLagSecondsMin: number;
    /**
     * replication_lag_seconds_max is the maximum of the
     * replication_lag_seconds values of the healthy tablets. It is unset
     * if the tablet type is primary.
     *
     * @generated from protobuf field: uint32 replication_lag_seconds_max = 4;
     */
    replicationLagSecondsMax: number;
}
/**
 * StreamHealthResponse is streamed by StreamHealth on a regular basis.
 * It is expected to be used between a vtgate and vttablet:
 * - target describes the tablet.
 * - realtime_stats is set.
 * - aggregate_stats is not set (deprecated)
 *
 * @generated from protobuf message query.StreamHealthResponse
 */
export interface StreamHealthResponse {
    /**
     * target is the current server type. Only queries with that exact Target
     * record will be accepted (the cell may not match, however).
     *
     * @generated from protobuf field: query.Target target = 1;
     */
    target?: Target;
    /**
     * serving is true iff the tablet is serving. A tablet may not be serving
     * if filtered replication is enabled on a primary for instance,
     * or if a replica should not be used because the keyspace is being resharded.
     *
     * @generated from protobuf field: bool serving = 2;
     */
    serving: boolean;
    /**
     * primary_term_start_timestamp can be interpreted as the
     * last time we knew that this tablet was promoted to a PRIMARY of this shard
     * (if StreamHealthResponse describes a group of tablets, between
     * two vtgates, only one primary will be present in the group, and
     * this is this primary's value).
     *
     * It is used by vtgate when determining the current PRIMARY of a shard.
     * If vtgate sees more than one PRIMARY tablet, this timestamp is used
     * as tiebreaker where the PRIMARY with the highest timestamp wins.
     * Another usage of this timestamp is in go/vt/vtgate/buffer to detect the end
     * of a reparent (failover) and stop buffering.
     *
     * In practice, this field is set to:
     * a) the last time the RPC tabletmanager.TabletExternallyReparented was
     *    called on this tablet (usually done by an external failover tool e.g.
     *    Orchestrator). The failover tool can call this as long as we are the
     *    primary i.e. even ages after the last reparent occurred.
     * OR
     * b) the last time an active reparent was executed through a vtctl command
     *    (InitShardPrimary, PlannedReparentShard, EmergencyReparentShard)
     * OR
     * c) the last time vttablet was started and it initialized its tablet type
     *    as PRIMARY because it was recorded as the shard's current primary in the
     *    topology (see go/vt/vttablet/tabletmanager/init_tablet.go)
     * OR
     * d) 0 if the vttablet is not a PRIMARY.
     *
     * @generated from protobuf field: int64 primary_term_start_timestamp = 3;
     */
    primaryTermStartTimestamp: bigint;
    /**
     * realtime_stats contains information about the tablet status.
     * It is only filled in if the information is about a tablet.
     *
     * @generated from protobuf field: query.RealtimeStats realtime_stats = 4;
     */
    realtimeStats?: RealtimeStats;
    /**
     * tablet_alias is the alias of the sending tablet. The discovery/healthcheck.go
     * code uses it to verify that it's talking to the correct tablet and that it
     * hasn't changed in the meantime e.g. due to tablet restarts where ports or
     * ips have been reused but assigned differently.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;
}
/**
 * TransactionMetadata contains the metadata for a distributed transaction.
 *
 * @generated from protobuf message query.TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * @generated from protobuf field: string dtid = 1;
     */
    dtid: string;
    /**
     * @generated from protobuf field: query.TransactionState state = 2;
     */
    state: TransactionState;
    /**
     * @generated from protobuf field: int64 time_created = 3;
     */
    timeCreated: bigint;
    /**
     * @generated from protobuf field: repeated query.Target participants = 4;
     */
    participants: Target[];
}
/**
 * GetSchemaRequest is the payload to GetSchema
 *
 * @generated from protobuf message query.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * @generated from protobuf field: query.Target target = 1;
     */
    target?: Target;
    /**
     * @generated from protobuf field: query.SchemaTableType table_type = 2;
     */
    tableType: SchemaTableType;
    /**
     * @generated from protobuf field: repeated string table_names = 3;
     */
    tableNames: string[];
}
/**
 * UDFInfo represents the information about a UDF.
 *
 * @generated from protobuf message query.UDFInfo
 */
export interface UDFInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bool aggregating = 2;
     */
    aggregating: boolean;
    /**
     * @generated from protobuf field: query.Type return_type = 3;
     */
    returnType: Type;
}
/**
 * GetSchemaResponse is the returned value from GetSchema
 *
 * @generated from protobuf message query.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: repeated query.UDFInfo udfs = 1;
     */
    udfs: UDFInfo[];
    /**
     * this is for the schema definition for the requested tables and views.
     *
     * @generated from protobuf field: map<string, string> table_definition = 2;
     */
    tableDefinition: {
        [key: string]: string;
    };
}
/**
 * Flags sent from the MySQL C API
 *
 * @generated from protobuf enum query.MySqlFlag
 */
export enum MySqlFlag {
    /**
     * @generated from protobuf enum value: EMPTY = 0;
     */
    EMPTY = 0,
    /**
     * @generated from protobuf enum value: NOT_NULL_FLAG = 1;
     */
    NOT_NULL_FLAG = 1,
    /**
     * @generated from protobuf enum value: PRI_KEY_FLAG = 2;
     */
    PRI_KEY_FLAG = 2,
    /**
     * @generated from protobuf enum value: UNIQUE_KEY_FLAG = 4;
     */
    UNIQUE_KEY_FLAG = 4,
    /**
     * @generated from protobuf enum value: MULTIPLE_KEY_FLAG = 8;
     */
    MULTIPLE_KEY_FLAG = 8,
    /**
     * @generated from protobuf enum value: BLOB_FLAG = 16;
     */
    BLOB_FLAG = 16,
    /**
     * @generated from protobuf enum value: UNSIGNED_FLAG = 32;
     */
    UNSIGNED_FLAG = 32,
    /**
     * @generated from protobuf enum value: ZEROFILL_FLAG = 64;
     */
    ZEROFILL_FLAG = 64,
    /**
     * @generated from protobuf enum value: BINARY_FLAG = 128;
     */
    BINARY_FLAG = 128,
    /**
     * @generated from protobuf enum value: ENUM_FLAG = 256;
     */
    ENUM_FLAG = 256,
    /**
     * @generated from protobuf enum value: AUTO_INCREMENT_FLAG = 512;
     */
    AUTO_INCREMENT_FLAG = 512,
    /**
     * @generated from protobuf enum value: TIMESTAMP_FLAG = 1024;
     */
    TIMESTAMP_FLAG = 1024,
    /**
     * @generated from protobuf enum value: SET_FLAG = 2048;
     */
    SET_FLAG = 2048,
    /**
     * @generated from protobuf enum value: NO_DEFAULT_VALUE_FLAG = 4096;
     */
    NO_DEFAULT_VALUE_FLAG = 4096,
    /**
     * @generated from protobuf enum value: ON_UPDATE_NOW_FLAG = 8192;
     */
    ON_UPDATE_NOW_FLAG = 8192,
    /**
     * @generated from protobuf enum value: NUM_FLAG = 32768;
     */
    NUM_FLAG = 32768,
    /**
     * @generated from protobuf enum value: PART_KEY_FLAG = 16384;
     */
    PART_KEY_FLAG = 16384,
    /**
     * @generated from protobuf enum value: NUM_FLAG = 32768;
     */
    GROUP_FLAG = 32768,
    /**
     * @generated from protobuf enum value: UNIQUE_FLAG = 65536;
     */
    UNIQUE_FLAG = 65536,
    /**
     * @generated from protobuf enum value: BINCMP_FLAG = 131072;
     */
    BINCMP_FLAG = 131072
}
/**
 * Flag allows us to qualify types by their common properties.
 *
 * @generated from protobuf enum query.Flag
 */
export enum Flag {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ISINTEGRAL = 256;
     */
    ISINTEGRAL = 256,
    /**
     * @generated from protobuf enum value: ISUNSIGNED = 512;
     */
    ISUNSIGNED = 512,
    /**
     * @generated from protobuf enum value: ISFLOAT = 1024;
     */
    ISFLOAT = 1024,
    /**
     * @generated from protobuf enum value: ISQUOTED = 2048;
     */
    ISQUOTED = 2048,
    /**
     * @generated from protobuf enum value: ISTEXT = 4096;
     */
    ISTEXT = 4096,
    /**
     * @generated from protobuf enum value: ISBINARY = 8192;
     */
    ISBINARY = 8192
}
/**
 * Type defines the various supported data types in bind vars
 * and query results.
 *
 * @generated from protobuf enum query.Type
 */
export enum Type {
    /**
     * NULL_TYPE specifies a NULL type.
     *
     * @generated from protobuf enum value: NULL_TYPE = 0;
     */
    NULL_TYPE = 0,
    /**
     * INT8 specifies a TINYINT type.
     * Properties: 1, IsNumber.
     *
     * @generated from protobuf enum value: INT8 = 257;
     */
    INT8 = 257,
    /**
     * UINT8 specifies a TINYINT UNSIGNED type.
     * Properties: 2, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: UINT8 = 770;
     */
    UINT8 = 770,
    /**
     * INT16 specifies a SMALLINT type.
     * Properties: 3, IsNumber.
     *
     * @generated from protobuf enum value: INT16 = 259;
     */
    INT16 = 259,
    /**
     * UINT16 specifies a SMALLINT UNSIGNED type.
     * Properties: 4, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: UINT16 = 772;
     */
    UINT16 = 772,
    /**
     * INT24 specifies a MEDIUMINT type.
     * Properties: 5, IsNumber.
     *
     * @generated from protobuf enum value: INT24 = 261;
     */
    INT24 = 261,
    /**
     * UINT24 specifies a MEDIUMINT UNSIGNED type.
     * Properties: 6, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: UINT24 = 774;
     */
    UINT24 = 774,
    /**
     * INT32 specifies a INTEGER type.
     * Properties: 7, IsNumber.
     *
     * @generated from protobuf enum value: INT32 = 263;
     */
    INT32 = 263,
    /**
     * UINT32 specifies a INTEGER UNSIGNED type.
     * Properties: 8, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: UINT32 = 776;
     */
    UINT32 = 776,
    /**
     * INT64 specifies a BIGINT type.
     * Properties: 9, IsNumber.
     *
     * @generated from protobuf enum value: INT64 = 265;
     */
    INT64 = 265,
    /**
     * UINT64 specifies a BIGINT UNSIGNED type.
     * Properties: 10, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: UINT64 = 778;
     */
    UINT64 = 778,
    /**
     * FLOAT32 specifies a FLOAT type.
     * Properties: 11, IsFloat.
     *
     * @generated from protobuf enum value: FLOAT32 = 1035;
     */
    FLOAT32 = 1035,
    /**
     * FLOAT64 specifies a DOUBLE or REAL type.
     * Properties: 12, IsFloat.
     *
     * @generated from protobuf enum value: FLOAT64 = 1036;
     */
    FLOAT64 = 1036,
    /**
     * TIMESTAMP specifies a TIMESTAMP type.
     * Properties: 13, IsQuoted.
     *
     * @generated from protobuf enum value: TIMESTAMP = 2061;
     */
    TIMESTAMP = 2061,
    /**
     * DATE specifies a DATE type.
     * Properties: 14, IsQuoted.
     *
     * @generated from protobuf enum value: DATE = 2062;
     */
    DATE = 2062,
    /**
     * TIME specifies a TIME type.
     * Properties: 15, IsQuoted.
     *
     * @generated from protobuf enum value: TIME = 2063;
     */
    TIME = 2063,
    /**
     * DATETIME specifies a DATETIME type.
     * Properties: 16, IsQuoted.
     *
     * @generated from protobuf enum value: DATETIME = 2064;
     */
    DATETIME = 2064,
    /**
     * YEAR specifies a YEAR type.
     * Properties: 17, IsNumber, IsUnsigned.
     *
     * @generated from protobuf enum value: YEAR = 785;
     */
    YEAR = 785,
    /**
     * DECIMAL specifies a DECIMAL or NUMERIC type.
     * Properties: 18, None.
     *
     * @generated from protobuf enum value: DECIMAL = 18;
     */
    DECIMAL = 18,
    /**
     * TEXT specifies a TEXT type.
     * Properties: 19, IsQuoted, IsText.
     *
     * @generated from protobuf enum value: TEXT = 6163;
     */
    TEXT = 6163,
    /**
     * BLOB specifies a BLOB type.
     * Properties: 20, IsQuoted, IsBinary.
     *
     * @generated from protobuf enum value: BLOB = 10260;
     */
    BLOB = 10260,
    /**
     * VARCHAR specifies a VARCHAR type.
     * Properties: 21, IsQuoted, IsText.
     *
     * @generated from protobuf enum value: VARCHAR = 6165;
     */
    VARCHAR = 6165,
    /**
     * VARBINARY specifies a VARBINARY type.
     * Properties: 22, IsQuoted, IsBinary.
     *
     * @generated from protobuf enum value: VARBINARY = 10262;
     */
    VARBINARY = 10262,
    /**
     * CHAR specifies a CHAR type.
     * Properties: 23, IsQuoted, IsText.
     *
     * @generated from protobuf enum value: CHAR = 6167;
     */
    CHAR = 6167,
    /**
     * BINARY specifies a BINARY type.
     * Properties: 24, IsQuoted, IsBinary.
     *
     * @generated from protobuf enum value: BINARY = 10264;
     */
    BINARY = 10264,
    /**
     * BIT specifies a BIT type.
     * Properties: 25, IsQuoted.
     *
     * @generated from protobuf enum value: BIT = 2073;
     */
    BIT = 2073,
    /**
     * ENUM specifies an ENUM type.
     * Properties: 26, IsQuoted.
     *
     * @generated from protobuf enum value: ENUM = 2074;
     */
    ENUM = 2074,
    /**
     * SET specifies a SET type.
     * Properties: 27, IsQuoted.
     *
     * @generated from protobuf enum value: SET = 2075;
     */
    SET = 2075,
    /**
     * TUPLE specifies a tuple. This cannot
     * be returned in a QueryResult, but it can
     * be sent as a bind var.
     * Properties: 28, None.
     *
     * @generated from protobuf enum value: TUPLE = 28;
     */
    TUPLE = 28,
    /**
     * GEOMETRY specifies a GEOMETRY type.
     * Properties: 29, IsQuoted.
     *
     * @generated from protobuf enum value: GEOMETRY = 2077;
     */
    GEOMETRY = 2077,
    /**
     * JSON specifies a JSON type.
     * Properties: 30, IsQuoted.
     *
     * @generated from protobuf enum value: JSON = 2078;
     */
    JSON = 2078,
    /**
     * EXPRESSION specifies a SQL expression.
     * This type is for internal use only.
     * Properties: 31, None.
     *
     * @generated from protobuf enum value: EXPRESSION = 31;
     */
    EXPRESSION = 31,
    /**
     * HEXNUM specifies a HEXNUM type (unquoted varbinary).
     * Properties: 32, IsText.
     *
     * @generated from protobuf enum value: HEXNUM = 4128;
     */
    HEXNUM = 4128,
    /**
     * HEXVAL specifies a HEXVAL type (unquoted varbinary).
     * Properties: 33, IsText.
     *
     * @generated from protobuf enum value: HEXVAL = 4129;
     */
    HEXVAL = 4129,
    /**
     * BITNUM specifies a base 2 binary type (unquoted varbinary).
     * Properties: 34, IsText.
     *
     * @generated from protobuf enum value: BITNUM = 4130;
     */
    BITNUM = 4130,
    /**
     * VECTOR specifies a VECTOR type
     * Properties: 35, IsQuoted.
     *
     * @generated from protobuf enum value: VECTOR = 2083;
     */
    VECTOR = 2083,
    /**
     * RAW specifies a type which won't be quoted but the value used as-is while encoding.
     *
     * @generated from protobuf enum value: RAW = 2084;
     */
    RAW = 2084
}
/**
 * TransactionState represents the state of a distributed transaction.
 *
 * @generated from protobuf enum query.TransactionState
 */
export enum TransactionState {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: PREPARE = 1;
     */
    PREPARE = 1,
    /**
     * @generated from protobuf enum value: ROLLBACK = 2;
     */
    ROLLBACK = 2,
    /**
     * @generated from protobuf enum value: COMMIT = 3;
     */
    COMMIT = 3
}
/**
 * SchemaTableType represents the type of table requested.
 *
 * @generated from protobuf enum query.SchemaTableType
 */
export enum SchemaTableType {
    /**
     * @generated from protobuf enum value: VIEWS = 0;
     */
    VIEWS = 0,
    /**
     * @generated from protobuf enum value: TABLES = 1;
     */
    TABLES = 1,
    /**
     * @generated from protobuf enum value: ALL = 2;
     */
    ALL = 2,
    /**
     * @generated from protobuf enum value: UDFS = 3;
     */
    UDFS = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Target$Type extends MessageType<Target> {
    constructor() {
        super("query.Target", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 4, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Target>): Target {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.tabletType = 0;
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<Target>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Target): Target {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletType tablet_type */ 3:
                    message.tabletType = reader.int32();
                    break;
                case /* string cell */ 4:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Target, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletType tablet_type = 3; */
        if (message.tabletType !== 0)
            writer.tag(3, WireType.Varint).int32(message.tabletType);
        /* string cell = 4; */
        if (message.cell !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.Target
 */
export const Target = new Target$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VTGateCallerID$Type extends MessageType<VTGateCallerID> {
    constructor() {
        super("query.VTGateCallerID", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "groups", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VTGateCallerID>): VTGateCallerID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<VTGateCallerID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VTGateCallerID): VTGateCallerID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* repeated string groups */ 2:
                    message.groups.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VTGateCallerID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* repeated string groups = 2; */
        for (let i = 0; i < message.groups.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.groups[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.VTGateCallerID
 */
export const VTGateCallerID = new VTGateCallerID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventToken$Type extends MessageType<EventToken> {
    constructor() {
        super("query.EventToken", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventToken>): EventToken {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestamp = 0n;
        message.shard = "";
        message.position = "";
        if (value !== undefined)
            reflectionMergePartial<EventToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventToken): EventToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* string position */ 3:
                    message.position = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* string position = 3; */
        if (message.position !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.EventToken
 */
export const EventToken = new EventToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Value$Type extends MessageType<Value> {
    constructor() {
        super("query.Value", [
            { no: 1, name: "type", kind: "enum", T: () => ["query.Type", Type] },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Value>): Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.value = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Value): Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.Value
 */
export const Value = new Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BindVariable$Type extends MessageType<BindVariable> {
    constructor() {
        super("query.BindVariable", [
            { no: 1, name: "type", kind: "enum", T: () => ["query.Type", Type] },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<BindVariable>): BindVariable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.value = new Uint8Array(0);
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<BindVariable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BindVariable): BindVariable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* repeated query.Value values */ 3:
                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BindVariable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* repeated query.Value values = 3; */
        for (let i = 0; i < message.values.length; i++)
            Value.internalBinaryWrite(message.values[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BindVariable
 */
export const BindVariable = new BindVariable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoundQuery$Type extends MessageType<BoundQuery> {
    constructor() {
        super("query.BoundQuery", [
            { no: 1, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bind_variables", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BindVariable } }
        ]);
    }
    create(value?: PartialMessage<BoundQuery>): BoundQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sql = "";
        message.bindVariables = {};
        if (value !== undefined)
            reflectionMergePartial<BoundQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BoundQuery): BoundQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sql */ 1:
                    message.sql = reader.string();
                    break;
                case /* map<string, query.BindVariable> bind_variables */ 2:
                    this.binaryReadMap2(message.bindVariables, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: BoundQuery["bindVariables"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BoundQuery["bindVariables"] | undefined, val: BoundQuery["bindVariables"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BindVariable.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field query.BoundQuery.bind_variables");
            }
        }
        map[key ?? ""] = val ?? BindVariable.create();
    }
    internalBinaryWrite(message: BoundQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sql = 1; */
        if (message.sql !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sql);
        /* map<string, query.BindVariable> bind_variables = 2; */
        for (let k of globalThis.Object.keys(message.bindVariables)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BindVariable.internalBinaryWrite(message.bindVariables[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BoundQuery
 */
export const BoundQuery = new BoundQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteOptions$Type extends MessageType<ExecuteOptions> {
    constructor() {
        super("query.ExecuteOptions", [
            { no: 4, name: "included_fields", kind: "enum", T: () => ["query.ExecuteOptions.IncludedFields", ExecuteOptions_IncludedFields] },
            { no: 5, name: "client_found_rows", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "workload", kind: "enum", T: () => ["query.ExecuteOptions.Workload", ExecuteOptions_Workload] },
            { no: 8, name: "sql_select_limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "transaction_isolation", kind: "enum", T: () => ["query.ExecuteOptions.TransactionIsolation", ExecuteOptions_TransactionIsolation] },
            { no: 10, name: "skip_query_plan_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "planner_version", kind: "enum", T: () => ["query.ExecuteOptions.PlannerVersion", ExecuteOptions_PlannerVersion] },
            { no: 12, name: "has_created_temp_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "consolidator", kind: "enum", T: () => ["query.ExecuteOptions.Consolidator", ExecuteOptions_Consolidator, "CONSOLIDATOR_"] },
            { no: 14, name: "transaction_access_mode", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["query.ExecuteOptions.TransactionAccessMode", ExecuteOptions_TransactionAccessMode] },
            { no: 15, name: "WorkloadName", kind: "scalar", jsonName: "WorkloadName", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "priority", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "authoritative_timeout", kind: "scalar", oneof: "timeout", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteOptions>): ExecuteOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.includedFields = 0;
        message.clientFoundRows = false;
        message.workload = 0;
        message.sqlSelectLimit = 0n;
        message.transactionIsolation = 0;
        message.skipQueryPlanCache = false;
        message.plannerVersion = 0;
        message.hasCreatedTempTables = false;
        message.consolidator = 0;
        message.transactionAccessMode = [];
        message.workloadName = "";
        message.priority = "";
        message.timeout = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExecuteOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteOptions): ExecuteOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.ExecuteOptions.IncludedFields included_fields */ 4:
                    message.includedFields = reader.int32();
                    break;
                case /* bool client_found_rows */ 5:
                    message.clientFoundRows = reader.bool();
                    break;
                case /* query.ExecuteOptions.Workload workload */ 6:
                    message.workload = reader.int32();
                    break;
                case /* int64 sql_select_limit */ 8:
                    message.sqlSelectLimit = reader.int64().toBigInt();
                    break;
                case /* query.ExecuteOptions.TransactionIsolation transaction_isolation */ 9:
                    message.transactionIsolation = reader.int32();
                    break;
                case /* bool skip_query_plan_cache */ 10:
                    message.skipQueryPlanCache = reader.bool();
                    break;
                case /* query.ExecuteOptions.PlannerVersion planner_version */ 11:
                    message.plannerVersion = reader.int32();
                    break;
                case /* bool has_created_temp_tables */ 12:
                    message.hasCreatedTempTables = reader.bool();
                    break;
                case /* query.ExecuteOptions.Consolidator consolidator */ 13:
                    message.consolidator = reader.int32();
                    break;
                case /* repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.transactionAccessMode.push(reader.int32());
                    else
                        message.transactionAccessMode.push(reader.int32());
                    break;
                case /* string WorkloadName = 15 [json_name = "WorkloadName"];*/ 15:
                    message.workloadName = reader.string();
                    break;
                case /* string priority */ 16:
                    message.priority = reader.string();
                    break;
                case /* int64 authoritative_timeout */ 17:
                    message.timeout = {
                        oneofKind: "authoritativeTimeout",
                        authoritativeTimeout: reader.int64().toBigInt()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.ExecuteOptions.IncludedFields included_fields = 4; */
        if (message.includedFields !== 0)
            writer.tag(4, WireType.Varint).int32(message.includedFields);
        /* bool client_found_rows = 5; */
        if (message.clientFoundRows !== false)
            writer.tag(5, WireType.Varint).bool(message.clientFoundRows);
        /* query.ExecuteOptions.Workload workload = 6; */
        if (message.workload !== 0)
            writer.tag(6, WireType.Varint).int32(message.workload);
        /* int64 sql_select_limit = 8; */
        if (message.sqlSelectLimit !== 0n)
            writer.tag(8, WireType.Varint).int64(message.sqlSelectLimit);
        /* query.ExecuteOptions.TransactionIsolation transaction_isolation = 9; */
        if (message.transactionIsolation !== 0)
            writer.tag(9, WireType.Varint).int32(message.transactionIsolation);
        /* bool skip_query_plan_cache = 10; */
        if (message.skipQueryPlanCache !== false)
            writer.tag(10, WireType.Varint).bool(message.skipQueryPlanCache);
        /* query.ExecuteOptions.PlannerVersion planner_version = 11; */
        if (message.plannerVersion !== 0)
            writer.tag(11, WireType.Varint).int32(message.plannerVersion);
        /* bool has_created_temp_tables = 12; */
        if (message.hasCreatedTempTables !== false)
            writer.tag(12, WireType.Varint).bool(message.hasCreatedTempTables);
        /* query.ExecuteOptions.Consolidator consolidator = 13; */
        if (message.consolidator !== 0)
            writer.tag(13, WireType.Varint).int32(message.consolidator);
        /* repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode = 14; */
        if (message.transactionAccessMode.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.transactionAccessMode.length; i++)
                writer.int32(message.transactionAccessMode[i]);
            writer.join();
        }
        /* string WorkloadName = 15 [json_name = "WorkloadName"]; */
        if (message.workloadName !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.workloadName);
        /* string priority = 16; */
        if (message.priority !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.priority);
        /* int64 authoritative_timeout = 17; */
        if (message.timeout.oneofKind === "authoritativeTimeout")
            writer.tag(17, WireType.Varint).int64(message.timeout.authoritativeTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ExecuteOptions
 */
export const ExecuteOptions = new ExecuteOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Field$Type extends MessageType<Field> {
    constructor() {
        super("query.Field", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["query.Type", Type] },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "org_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "database", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "org_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "column_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "charset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "column_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Field>): Field {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.type = 0;
        message.table = "";
        message.orgTable = "";
        message.database = "";
        message.orgName = "";
        message.columnLength = 0;
        message.charset = 0;
        message.decimals = 0;
        message.flags = 0;
        message.columnType = "";
        if (value !== undefined)
            reflectionMergePartial<Field>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Field): Field {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* query.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                case /* string org_table */ 4:
                    message.orgTable = reader.string();
                    break;
                case /* string database */ 5:
                    message.database = reader.string();
                    break;
                case /* string org_name */ 6:
                    message.orgName = reader.string();
                    break;
                case /* uint32 column_length */ 7:
                    message.columnLength = reader.uint32();
                    break;
                case /* uint32 charset */ 8:
                    message.charset = reader.uint32();
                    break;
                case /* uint32 decimals */ 9:
                    message.decimals = reader.uint32();
                    break;
                case /* uint32 flags */ 10:
                    message.flags = reader.uint32();
                    break;
                case /* string column_type */ 11:
                    message.columnType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Field, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* query.Type type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        /* string org_table = 4; */
        if (message.orgTable !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.orgTable);
        /* string database = 5; */
        if (message.database !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.database);
        /* string org_name = 6; */
        if (message.orgName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.orgName);
        /* uint32 column_length = 7; */
        if (message.columnLength !== 0)
            writer.tag(7, WireType.Varint).uint32(message.columnLength);
        /* uint32 charset = 8; */
        if (message.charset !== 0)
            writer.tag(8, WireType.Varint).uint32(message.charset);
        /* uint32 decimals = 9; */
        if (message.decimals !== 0)
            writer.tag(9, WireType.Varint).uint32(message.decimals);
        /* uint32 flags = 10; */
        if (message.flags !== 0)
            writer.tag(10, WireType.Varint).uint32(message.flags);
        /* string column_type = 11; */
        if (message.columnType !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.columnType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.Field
 */
export const Field = new Field$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Row$Type extends MessageType<Row> {
    constructor() {
        super("query.Row", [
            { no: 1, name: "lengths", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "values", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Row>): Row {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lengths = [];
        message.values = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Row>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Row): Row {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated sint64 lengths */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lengths.push(reader.sint64().toBigInt());
                    else
                        message.lengths.push(reader.sint64().toBigInt());
                    break;
                case /* bytes values */ 2:
                    message.values = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Row, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated sint64 lengths = 1; */
        if (message.lengths.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lengths.length; i++)
                writer.sint64(message.lengths[i]);
            writer.join();
        }
        /* bytes values = 2; */
        if (message.values.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.values);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.Row
 */
export const Row = new Row$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResult$Type extends MessageType<QueryResult> {
    constructor() {
        super("query.QueryResult", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 2, name: "rows_affected", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "insert_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "rows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Row },
            { no: 6, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryResult>): QueryResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        message.rowsAffected = 0n;
        message.insertId = 0n;
        message.rows = [];
        message.info = "";
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<QueryResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResult): QueryResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.Field fields */ 1:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 rows_affected */ 2:
                    message.rowsAffected = reader.uint64().toBigInt();
                    break;
                case /* uint64 insert_id */ 3:
                    message.insertId = reader.uint64().toBigInt();
                    break;
                case /* repeated query.Row rows */ 4:
                    message.rows.push(Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string info */ 6:
                    message.info = reader.string();
                    break;
                case /* string session_state_changes */ 7:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.Field fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 rows_affected = 2; */
        if (message.rowsAffected !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.rowsAffected);
        /* uint64 insert_id = 3; */
        if (message.insertId !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.insertId);
        /* repeated query.Row rows = 4; */
        for (let i = 0; i < message.rows.length; i++)
            Row.internalBinaryWrite(message.rows[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string info = 6; */
        if (message.info !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.info);
        /* string session_state_changes = 7; */
        if (message.sessionStateChanges !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.QueryResult
 */
export const QueryResult = new QueryResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryWarning$Type extends MessageType<QueryWarning> {
    constructor() {
        super("query.QueryWarning", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryWarning>): QueryWarning {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<QueryWarning>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryWarning): QueryWarning {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryWarning, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.QueryWarning
 */
export const QueryWarning = new QueryWarning$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamEvent$Type extends MessageType<StreamEvent> {
    constructor() {
        super("query.StreamEvent", [
            { no: 1, name: "statements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StreamEvent_Statement },
            { no: 2, name: "event_token", kind: "message", T: () => EventToken }
        ]);
    }
    create(value?: PartialMessage<StreamEvent>): StreamEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statements = [];
        if (value !== undefined)
            reflectionMergePartial<StreamEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamEvent): StreamEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.StreamEvent.Statement statements */ 1:
                    message.statements.push(StreamEvent_Statement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* query.EventToken event_token */ 2:
                    message.eventToken = EventToken.internalBinaryRead(reader, reader.uint32(), options, message.eventToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.StreamEvent.Statement statements = 1; */
        for (let i = 0; i < message.statements.length; i++)
            StreamEvent_Statement.internalBinaryWrite(message.statements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.EventToken event_token = 2; */
        if (message.eventToken)
            EventToken.internalBinaryWrite(message.eventToken, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamEvent
 */
export const StreamEvent = new StreamEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamEvent_Statement$Type extends MessageType<StreamEvent_Statement> {
    constructor() {
        super("query.StreamEvent.Statement", [
            { no: 1, name: "category", kind: "enum", T: () => ["query.StreamEvent.Statement.Category", StreamEvent_Statement_Category] },
            { no: 2, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primary_key_fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 4, name: "primary_key_values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Row },
            { no: 5, name: "sql", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<StreamEvent_Statement>): StreamEvent_Statement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.category = 0;
        message.tableName = "";
        message.primaryKeyFields = [];
        message.primaryKeyValues = [];
        message.sql = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<StreamEvent_Statement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamEvent_Statement): StreamEvent_Statement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.StreamEvent.Statement.Category category */ 1:
                    message.category = reader.int32();
                    break;
                case /* string table_name */ 2:
                    message.tableName = reader.string();
                    break;
                case /* repeated query.Field primary_key_fields */ 3:
                    message.primaryKeyFields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated query.Row primary_key_values */ 4:
                    message.primaryKeyValues.push(Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes sql */ 5:
                    message.sql = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamEvent_Statement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.StreamEvent.Statement.Category category = 1; */
        if (message.category !== 0)
            writer.tag(1, WireType.Varint).int32(message.category);
        /* string table_name = 2; */
        if (message.tableName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tableName);
        /* repeated query.Field primary_key_fields = 3; */
        for (let i = 0; i < message.primaryKeyFields.length; i++)
            Field.internalBinaryWrite(message.primaryKeyFields[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.Row primary_key_values = 4; */
        for (let i = 0; i < message.primaryKeyValues.length; i++)
            Row.internalBinaryWrite(message.primaryKeyValues[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes sql = 5; */
        if (message.sql.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.sql);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamEvent.Statement
 */
export const StreamEvent_Statement = new StreamEvent_Statement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteRequest$Type extends MessageType<ExecuteRequest> {
    constructor() {
        super("query.ExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 7, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteRequest>): ExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<ExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteRequest): ExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* int64 transaction_id */ 5:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* query.ExecuteOptions options */ 6:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* int64 reserved_id */ 7:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 5; */
        if (message.transactionId !== 0n)
            writer.tag(5, WireType.Varint).int64(message.transactionId);
        /* query.ExecuteOptions options = 6; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int64 reserved_id = 7; */
        if (message.reservedId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ExecuteRequest
 */
export const ExecuteRequest = new ExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteResponse$Type extends MessageType<ExecuteResponse> {
    constructor() {
        super("query.ExecuteResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ExecuteResponse>): ExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteResponse): ExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ExecuteResponse
 */
export const ExecuteResponse = new ExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResultWithError$Type extends MessageType<ResultWithError> {
    constructor() {
        super("query.ResultWithError", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ResultWithError>): ResultWithError {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResultWithError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResultWithError): ResultWithError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResultWithError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ResultWithError
 */
export const ResultWithError = new ResultWithError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamExecuteRequest$Type extends MessageType<StreamExecuteRequest> {
    constructor() {
        super("query.StreamExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<StreamExecuteRequest>): StreamExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamExecuteRequest): StreamExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* int64 transaction_id */ 6:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* int64 reserved_id */ 7:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 6; */
        if (message.transactionId !== 0n)
            writer.tag(6, WireType.Varint).int64(message.transactionId);
        /* int64 reserved_id = 7; */
        if (message.reservedId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamExecuteRequest
 */
export const StreamExecuteRequest = new StreamExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamExecuteResponse$Type extends MessageType<StreamExecuteResponse> {
    constructor() {
        super("query.StreamExecuteResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<StreamExecuteResponse>): StreamExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamExecuteResponse): StreamExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamExecuteResponse
 */
export const StreamExecuteResponse = new StreamExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginRequest$Type extends MessageType<BeginRequest> {
    constructor() {
        super("query.BeginRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "options", kind: "message", T: () => ExecuteOptions }
        ]);
    }
    create(value?: PartialMessage<BeginRequest>): BeginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BeginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginRequest): BeginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.ExecuteOptions options */ 4:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 4; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginRequest
 */
export const BeginRequest = new BeginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginResponse$Type extends MessageType<BeginResponse> {
    constructor() {
        super("query.BeginResponse", [
            { no: 1, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 3, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BeginResponse>): BeginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<BeginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginResponse): BeginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 transaction_id */ 1:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 2:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string session_state_changes */ 3:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 transaction_id = 1; */
        if (message.transactionId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.transactionId);
        /* topodata.TabletAlias tablet_alias = 2; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string session_state_changes = 3; */
        if (message.sessionStateChanges !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginResponse
 */
export const BeginResponse = new BeginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitRequest$Type extends MessageType<CommitRequest> {
    constructor() {
        super("query.CommitRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CommitRequest>): CommitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        if (value !== undefined)
            reflectionMergePartial<CommitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitRequest): CommitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CommitRequest
 */
export const CommitRequest = new CommitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitResponse$Type extends MessageType<CommitResponse> {
    constructor() {
        super("query.CommitResponse", [
            { no: 1, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CommitResponse>): CommitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<CommitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitResponse): CommitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 reserved_id */ 1:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 reserved_id = 1; */
        if (message.reservedId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CommitResponse
 */
export const CommitResponse = new CommitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollbackRequest$Type extends MessageType<RollbackRequest> {
    constructor() {
        super("query.RollbackRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RollbackRequest>): RollbackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        if (value !== undefined)
            reflectionMergePartial<RollbackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollbackRequest): RollbackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollbackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.RollbackRequest
 */
export const RollbackRequest = new RollbackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollbackResponse$Type extends MessageType<RollbackResponse> {
    constructor() {
        super("query.RollbackResponse", [
            { no: 1, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RollbackResponse>): RollbackResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<RollbackResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollbackResponse): RollbackResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 reserved_id */ 1:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollbackResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 reserved_id = 1; */
        if (message.reservedId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.RollbackResponse
 */
export const RollbackResponse = new RollbackResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareRequest$Type extends MessageType<PrepareRequest> {
    constructor() {
        super("query.PrepareRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareRequest>): PrepareRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<PrepareRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareRequest): PrepareRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* string dtid */ 5:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        /* string dtid = 5; */
        if (message.dtid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.PrepareRequest
 */
export const PrepareRequest = new PrepareRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareResponse$Type extends MessageType<PrepareResponse> {
    constructor() {
        super("query.PrepareResponse", []);
    }
    create(value?: PartialMessage<PrepareResponse>): PrepareResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PrepareResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareResponse): PrepareResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.PrepareResponse
 */
export const PrepareResponse = new PrepareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitPreparedRequest$Type extends MessageType<CommitPreparedRequest> {
    constructor() {
        super("query.CommitPreparedRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommitPreparedRequest>): CommitPreparedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<CommitPreparedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitPreparedRequest): CommitPreparedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string dtid */ 4:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitPreparedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string dtid = 4; */
        if (message.dtid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CommitPreparedRequest
 */
export const CommitPreparedRequest = new CommitPreparedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitPreparedResponse$Type extends MessageType<CommitPreparedResponse> {
    constructor() {
        super("query.CommitPreparedResponse", []);
    }
    create(value?: PartialMessage<CommitPreparedResponse>): CommitPreparedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CommitPreparedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitPreparedResponse): CommitPreparedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommitPreparedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CommitPreparedResponse
 */
export const CommitPreparedResponse = new CommitPreparedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollbackPreparedRequest$Type extends MessageType<RollbackPreparedRequest> {
    constructor() {
        super("query.RollbackPreparedRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RollbackPreparedRequest>): RollbackPreparedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<RollbackPreparedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollbackPreparedRequest): RollbackPreparedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* string dtid */ 5:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollbackPreparedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        /* string dtid = 5; */
        if (message.dtid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.RollbackPreparedRequest
 */
export const RollbackPreparedRequest = new RollbackPreparedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollbackPreparedResponse$Type extends MessageType<RollbackPreparedResponse> {
    constructor() {
        super("query.RollbackPreparedResponse", []);
    }
    create(value?: PartialMessage<RollbackPreparedResponse>): RollbackPreparedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RollbackPreparedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollbackPreparedResponse): RollbackPreparedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollbackPreparedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.RollbackPreparedResponse
 */
export const RollbackPreparedResponse = new RollbackPreparedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTransactionRequest$Type extends MessageType<CreateTransactionRequest> {
    constructor() {
        super("query.CreateTransactionRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Target }
        ]);
    }
    create(value?: PartialMessage<CreateTransactionRequest>): CreateTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        message.participants = [];
        if (value !== undefined)
            reflectionMergePartial<CreateTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTransactionRequest): CreateTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string dtid */ 4:
                    message.dtid = reader.string();
                    break;
                case /* repeated query.Target participants */ 5:
                    message.participants.push(Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string dtid = 4; */
        if (message.dtid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dtid);
        /* repeated query.Target participants = 5; */
        for (let i = 0; i < message.participants.length; i++)
            Target.internalBinaryWrite(message.participants[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CreateTransactionRequest
 */
export const CreateTransactionRequest = new CreateTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTransactionResponse$Type extends MessageType<CreateTransactionResponse> {
    constructor() {
        super("query.CreateTransactionResponse", []);
    }
    create(value?: PartialMessage<CreateTransactionResponse>): CreateTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTransactionResponse): CreateTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.CreateTransactionResponse
 */
export const CreateTransactionResponse = new CreateTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCommitRequest$Type extends MessageType<StartCommitRequest> {
    constructor() {
        super("query.StartCommitRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartCommitRequest>): StartCommitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<StartCommitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartCommitRequest): StartCommitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* string dtid */ 5:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartCommitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        /* string dtid = 5; */
        if (message.dtid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StartCommitRequest
 */
export const StartCommitRequest = new StartCommitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCommitResponse$Type extends MessageType<StartCommitResponse> {
    constructor() {
        super("query.StartCommitResponse", []);
    }
    create(value?: PartialMessage<StartCommitResponse>): StartCommitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartCommitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartCommitResponse): StartCommitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartCommitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StartCommitResponse
 */
export const StartCommitResponse = new StartCommitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRollbackRequest$Type extends MessageType<SetRollbackRequest> {
    constructor() {
        super("query.SetRollbackRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetRollbackRequest>): SetRollbackRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<SetRollbackRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRollbackRequest): SetRollbackRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* string dtid */ 5:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRollbackRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        /* string dtid = 5; */
        if (message.dtid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.SetRollbackRequest
 */
export const SetRollbackRequest = new SetRollbackRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRollbackResponse$Type extends MessageType<SetRollbackResponse> {
    constructor() {
        super("query.SetRollbackResponse", []);
    }
    create(value?: PartialMessage<SetRollbackResponse>): SetRollbackResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRollbackResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRollbackResponse): SetRollbackResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRollbackResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.SetRollbackResponse
 */
export const SetRollbackResponse = new SetRollbackResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcludeTransactionRequest$Type extends MessageType<ConcludeTransactionRequest> {
    constructor() {
        super("query.ConcludeTransactionRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConcludeTransactionRequest>): ConcludeTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<ConcludeTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcludeTransactionRequest): ConcludeTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string dtid */ 4:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcludeTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string dtid = 4; */
        if (message.dtid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ConcludeTransactionRequest
 */
export const ConcludeTransactionRequest = new ConcludeTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcludeTransactionResponse$Type extends MessageType<ConcludeTransactionResponse> {
    constructor() {
        super("query.ConcludeTransactionResponse", []);
    }
    create(value?: PartialMessage<ConcludeTransactionResponse>): ConcludeTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConcludeTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcludeTransactionResponse): ConcludeTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcludeTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ConcludeTransactionResponse
 */
export const ConcludeTransactionResponse = new ConcludeTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadTransactionRequest$Type extends MessageType<ReadTransactionRequest> {
    constructor() {
        super("query.ReadTransactionRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadTransactionRequest>): ReadTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<ReadTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadTransactionRequest): ReadTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string dtid */ 4:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string dtid = 4; */
        if (message.dtid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReadTransactionRequest
 */
export const ReadTransactionRequest = new ReadTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadTransactionResponse$Type extends MessageType<ReadTransactionResponse> {
    constructor() {
        super("query.ReadTransactionResponse", [
            { no: 1, name: "metadata", kind: "message", T: () => TransactionMetadata }
        ]);
    }
    create(value?: PartialMessage<ReadTransactionResponse>): ReadTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReadTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadTransactionResponse): ReadTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.TransactionMetadata metadata */ 1:
                    message.metadata = TransactionMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.TransactionMetadata metadata = 1; */
        if (message.metadata)
            TransactionMetadata.internalBinaryWrite(message.metadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReadTransactionResponse
 */
export const ReadTransactionResponse = new ReadTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnresolvedTransactionsRequest$Type extends MessageType<UnresolvedTransactionsRequest> {
    constructor() {
        super("query.UnresolvedTransactionsRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "abandon_age", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UnresolvedTransactionsRequest>): UnresolvedTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.abandonAge = 0n;
        if (value !== undefined)
            reflectionMergePartial<UnresolvedTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnresolvedTransactionsRequest): UnresolvedTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 abandon_age */ 4:
                    message.abandonAge = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnresolvedTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 abandon_age = 4; */
        if (message.abandonAge !== 0n)
            writer.tag(4, WireType.Varint).int64(message.abandonAge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.UnresolvedTransactionsRequest
 */
export const UnresolvedTransactionsRequest = new UnresolvedTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnresolvedTransactionsResponse$Type extends MessageType<UnresolvedTransactionsResponse> {
    constructor() {
        super("query.UnresolvedTransactionsResponse", [
            { no: 1, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionMetadata }
        ]);
    }
    create(value?: PartialMessage<UnresolvedTransactionsResponse>): UnresolvedTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<UnresolvedTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnresolvedTransactionsResponse): UnresolvedTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.TransactionMetadata transactions */ 1:
                    message.transactions.push(TransactionMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnresolvedTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.TransactionMetadata transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            TransactionMetadata.internalBinaryWrite(message.transactions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.UnresolvedTransactionsResponse
 */
export const UnresolvedTransactionsResponse = new UnresolvedTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginExecuteRequest$Type extends MessageType<BeginExecuteRequest> {
    constructor() {
        super("query.BeginExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BeginExecuteRequest>): BeginExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reservedId = 0n;
        message.preQueries = [];
        if (value !== undefined)
            reflectionMergePartial<BeginExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginExecuteRequest): BeginExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* int64 reserved_id */ 6:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* repeated string pre_queries */ 7:
                    message.preQueries.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 reserved_id = 6; */
        if (message.reservedId !== 0n)
            writer.tag(6, WireType.Varint).int64(message.reservedId);
        /* repeated string pre_queries = 7; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.preQueries[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginExecuteRequest
 */
export const BeginExecuteRequest = new BeginExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginExecuteResponse$Type extends MessageType<BeginExecuteResponse> {
    constructor() {
        super("query.BeginExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 5, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BeginExecuteResponse>): BeginExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<BeginExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginExecuteResponse): BeginExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 transaction_id */ 3:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 4:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string session_state_changes */ 5:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 3; */
        if (message.transactionId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.transactionId);
        /* topodata.TabletAlias tablet_alias = 4; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string session_state_changes = 5; */
        if (message.sessionStateChanges !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginExecuteResponse
 */
export const BeginExecuteResponse = new BeginExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginStreamExecuteRequest$Type extends MessageType<BeginStreamExecuteRequest> {
    constructor() {
        super("query.BeginStreamExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BeginStreamExecuteRequest>): BeginStreamExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.preQueries = [];
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<BeginStreamExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginStreamExecuteRequest): BeginStreamExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* repeated string pre_queries */ 6:
                    message.preQueries.push(reader.string());
                    break;
                case /* int64 reserved_id */ 7:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginStreamExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string pre_queries = 6; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.preQueries[i]);
        /* int64 reserved_id = 7; */
        if (message.reservedId !== 0n)
            writer.tag(7, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginStreamExecuteRequest
 */
export const BeginStreamExecuteRequest = new BeginStreamExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginStreamExecuteResponse$Type extends MessageType<BeginStreamExecuteResponse> {
    constructor() {
        super("query.BeginStreamExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 5, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BeginStreamExecuteResponse>): BeginStreamExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<BeginStreamExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginStreamExecuteResponse): BeginStreamExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 transaction_id */ 3:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 4:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string session_state_changes */ 5:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginStreamExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 3; */
        if (message.transactionId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.transactionId);
        /* topodata.TabletAlias tablet_alias = 4; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string session_state_changes = 5; */
        if (message.sessionStateChanges !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.BeginStreamExecuteResponse
 */
export const BeginStreamExecuteResponse = new BeginStreamExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageStreamRequest$Type extends MessageType<MessageStreamRequest> {
    constructor() {
        super("query.MessageStreamRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageStreamRequest>): MessageStreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MessageStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageStreamRequest): MessageStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.MessageStreamRequest
 */
export const MessageStreamRequest = new MessageStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageStreamResponse$Type extends MessageType<MessageStreamResponse> {
    constructor() {
        super("query.MessageStreamResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<MessageStreamResponse>): MessageStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessageStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageStreamResponse): MessageStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.MessageStreamResponse
 */
export const MessageStreamResponse = new MessageStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageAckRequest$Type extends MessageType<MessageAckRequest> {
    constructor() {
        super("query.MessageAckRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "ids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<MessageAckRequest>): MessageAckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<MessageAckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageAckRequest): MessageAckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* repeated query.Value ids */ 5:
                    message.ids.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageAckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* repeated query.Value ids = 5; */
        for (let i = 0; i < message.ids.length; i++)
            Value.internalBinaryWrite(message.ids[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.MessageAckRequest
 */
export const MessageAckRequest = new MessageAckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageAckResponse$Type extends MessageType<MessageAckResponse> {
    constructor() {
        super("query.MessageAckResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<MessageAckResponse>): MessageAckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MessageAckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageAckResponse): MessageAckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageAckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.MessageAckResponse
 */
export const MessageAckResponse = new MessageAckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveExecuteRequest$Type extends MessageType<ReserveExecuteRequest> {
    constructor() {
        super("query.ReserveExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 7, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveExecuteRequest>): ReserveExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.preQueries = [];
        if (value !== undefined)
            reflectionMergePartial<ReserveExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveExecuteRequest): ReserveExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* int64 transaction_id */ 5:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* query.ExecuteOptions options */ 6:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* repeated string pre_queries */ 7:
                    message.preQueries.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 5; */
        if (message.transactionId !== 0n)
            writer.tag(5, WireType.Varint).int64(message.transactionId);
        /* query.ExecuteOptions options = 6; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string pre_queries = 7; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.preQueries[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveExecuteRequest
 */
export const ReserveExecuteRequest = new ReserveExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveExecuteResponse$Type extends MessageType<ReserveExecuteResponse> {
    constructor() {
        super("query.ReserveExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ReserveExecuteResponse>): ReserveExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<ReserveExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveExecuteResponse): ReserveExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 reserved_id */ 3:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 4:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 reserved_id = 3; */
        if (message.reservedId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.reservedId);
        /* topodata.TabletAlias tablet_alias = 4; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveExecuteResponse
 */
export const ReserveExecuteResponse = new ReserveExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveStreamExecuteRequest$Type extends MessageType<ReserveStreamExecuteRequest> {
    constructor() {
        super("query.ReserveStreamExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveStreamExecuteRequest>): ReserveStreamExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.preQueries = [];
        if (value !== undefined)
            reflectionMergePartial<ReserveStreamExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveStreamExecuteRequest): ReserveStreamExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* int64 transaction_id */ 6:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* repeated string pre_queries */ 7:
                    message.preQueries.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveStreamExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 6; */
        if (message.transactionId !== 0n)
            writer.tag(6, WireType.Varint).int64(message.transactionId);
        /* repeated string pre_queries = 7; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.preQueries[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveStreamExecuteRequest
 */
export const ReserveStreamExecuteRequest = new ReserveStreamExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveStreamExecuteResponse$Type extends MessageType<ReserveStreamExecuteResponse> {
    constructor() {
        super("query.ReserveStreamExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ReserveStreamExecuteResponse>): ReserveStreamExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<ReserveStreamExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveStreamExecuteResponse): ReserveStreamExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 reserved_id */ 3:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 4:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveStreamExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 reserved_id = 3; */
        if (message.reservedId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.reservedId);
        /* topodata.TabletAlias tablet_alias = 4; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveStreamExecuteResponse
 */
export const ReserveStreamExecuteResponse = new ReserveStreamExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveBeginExecuteRequest$Type extends MessageType<ReserveBeginExecuteRequest> {
    constructor() {
        super("query.ReserveBeginExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "post_begin_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveBeginExecuteRequest>): ReserveBeginExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.preQueries = [];
        message.postBeginQueries = [];
        if (value !== undefined)
            reflectionMergePartial<ReserveBeginExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveBeginExecuteRequest): ReserveBeginExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* repeated string pre_queries */ 6:
                    message.preQueries.push(reader.string());
                    break;
                case /* repeated string post_begin_queries */ 7:
                    message.postBeginQueries.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveBeginExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string pre_queries = 6; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.preQueries[i]);
        /* repeated string post_begin_queries = 7; */
        for (let i = 0; i < message.postBeginQueries.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.postBeginQueries[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveBeginExecuteRequest
 */
export const ReserveBeginExecuteRequest = new ReserveBeginExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveBeginExecuteResponse$Type extends MessageType<ReserveBeginExecuteResponse> {
    constructor() {
        super("query.ReserveBeginExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 6, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveBeginExecuteResponse>): ReserveBeginExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<ReserveBeginExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveBeginExecuteResponse): ReserveBeginExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 transaction_id */ 3:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* int64 reserved_id */ 4:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 5:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string session_state_changes */ 6:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveBeginExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 3; */
        if (message.transactionId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.transactionId);
        /* int64 reserved_id = 4; */
        if (message.reservedId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.reservedId);
        /* topodata.TabletAlias tablet_alias = 5; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string session_state_changes = 6; */
        if (message.sessionStateChanges !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveBeginExecuteResponse
 */
export const ReserveBeginExecuteResponse = new ReserveBeginExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveBeginStreamExecuteRequest$Type extends MessageType<ReserveBeginStreamExecuteRequest> {
    constructor() {
        super("query.ReserveBeginStreamExecuteRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "message", T: () => BoundQuery },
            { no: 5, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 6, name: "pre_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "post_begin_queries", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveBeginStreamExecuteRequest>): ReserveBeginStreamExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.preQueries = [];
        message.postBeginQueries = [];
        if (value !== undefined)
            reflectionMergePartial<ReserveBeginStreamExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveBeginStreamExecuteRequest): ReserveBeginStreamExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.BoundQuery query */ 4:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* query.ExecuteOptions options */ 5:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* repeated string pre_queries */ 6:
                    message.preQueries.push(reader.string());
                    break;
                case /* repeated string post_begin_queries */ 7:
                    message.postBeginQueries.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveBeginStreamExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 4; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.ExecuteOptions options = 5; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string pre_queries = 6; */
        for (let i = 0; i < message.preQueries.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.preQueries[i]);
        /* repeated string post_begin_queries = 7; */
        for (let i = 0; i < message.postBeginQueries.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.postBeginQueries[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveBeginStreamExecuteRequest
 */
export const ReserveBeginStreamExecuteRequest = new ReserveBeginStreamExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReserveBeginStreamExecuteResponse$Type extends MessageType<ReserveBeginStreamExecuteResponse> {
    constructor() {
        super("query.ReserveBeginStreamExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "result", kind: "message", T: () => QueryResult },
            { no: 3, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 6, name: "session_state_changes", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReserveBeginStreamExecuteResponse>): ReserveBeginStreamExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        message.sessionStateChanges = "";
        if (value !== undefined)
            reflectionMergePartial<ReserveBeginStreamExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReserveBeginStreamExecuteResponse): ReserveBeginStreamExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* query.QueryResult result */ 2:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* int64 transaction_id */ 3:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* int64 reserved_id */ 4:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 5:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string session_state_changes */ 6:
                    message.sessionStateChanges = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReserveBeginStreamExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 2; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 3; */
        if (message.transactionId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.transactionId);
        /* int64 reserved_id = 4; */
        if (message.reservedId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.reservedId);
        /* topodata.TabletAlias tablet_alias = 5; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string session_state_changes = 6; */
        if (message.sessionStateChanges !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sessionStateChanges);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReserveBeginStreamExecuteResponse
 */
export const ReserveBeginStreamExecuteResponse = new ReserveBeginStreamExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseRequest$Type extends MessageType<ReleaseRequest> {
    constructor() {
        super("query.ReleaseRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReleaseRequest>): ReleaseRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        if (value !== undefined)
            reflectionMergePartial<ReleaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseRequest): ReleaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 4:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* int64 reserved_id */ 5:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 4; */
        if (message.transactionId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.transactionId);
        /* int64 reserved_id = 5; */
        if (message.reservedId !== 0n)
            writer.tag(5, WireType.Varint).int64(message.reservedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReleaseRequest
 */
export const ReleaseRequest = new ReleaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseResponse$Type extends MessageType<ReleaseResponse> {
    constructor() {
        super("query.ReleaseResponse", []);
    }
    create(value?: PartialMessage<ReleaseResponse>): ReleaseResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReleaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseResponse): ReleaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.ReleaseResponse
 */
export const ReleaseResponse = new ReleaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHealthRequest$Type extends MessageType<StreamHealthRequest> {
    constructor() {
        super("query.StreamHealthRequest", []);
    }
    create(value?: PartialMessage<StreamHealthRequest>): StreamHealthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamHealthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHealthRequest): StreamHealthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHealthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamHealthRequest
 */
export const StreamHealthRequest = new StreamHealthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RealtimeStats$Type extends MessageType<RealtimeStats> {
    constructor() {
        super("query.RealtimeStats", [
            { no: 1, name: "health_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "replication_lag_seconds", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "binlog_players_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "filtered_replication_lag_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "cpu_usage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "qps", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "table_schema_changed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "view_schema_changed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "udfs_changed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "tx_unresolved", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RealtimeStats>): RealtimeStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthError = "";
        message.replicationLagSeconds = 0;
        message.binlogPlayersCount = 0;
        message.filteredReplicationLagSeconds = 0n;
        message.cpuUsage = 0;
        message.qps = 0;
        message.tableSchemaChanged = [];
        message.viewSchemaChanged = [];
        message.udfsChanged = false;
        message.txUnresolved = false;
        if (value !== undefined)
            reflectionMergePartial<RealtimeStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RealtimeStats): RealtimeStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string health_error */ 1:
                    message.healthError = reader.string();
                    break;
                case /* uint32 replication_lag_seconds */ 2:
                    message.replicationLagSeconds = reader.uint32();
                    break;
                case /* int32 binlog_players_count */ 3:
                    message.binlogPlayersCount = reader.int32();
                    break;
                case /* int64 filtered_replication_lag_seconds */ 4:
                    message.filteredReplicationLagSeconds = reader.int64().toBigInt();
                    break;
                case /* double cpu_usage */ 5:
                    message.cpuUsage = reader.double();
                    break;
                case /* double qps */ 6:
                    message.qps = reader.double();
                    break;
                case /* repeated string table_schema_changed */ 7:
                    message.tableSchemaChanged.push(reader.string());
                    break;
                case /* repeated string view_schema_changed */ 8:
                    message.viewSchemaChanged.push(reader.string());
                    break;
                case /* bool udfs_changed */ 9:
                    message.udfsChanged = reader.bool();
                    break;
                case /* bool tx_unresolved */ 10:
                    message.txUnresolved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RealtimeStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string health_error = 1; */
        if (message.healthError !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.healthError);
        /* uint32 replication_lag_seconds = 2; */
        if (message.replicationLagSeconds !== 0)
            writer.tag(2, WireType.Varint).uint32(message.replicationLagSeconds);
        /* int32 binlog_players_count = 3; */
        if (message.binlogPlayersCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.binlogPlayersCount);
        /* int64 filtered_replication_lag_seconds = 4; */
        if (message.filteredReplicationLagSeconds !== 0n)
            writer.tag(4, WireType.Varint).int64(message.filteredReplicationLagSeconds);
        /* double cpu_usage = 5; */
        if (message.cpuUsage !== 0)
            writer.tag(5, WireType.Bit64).double(message.cpuUsage);
        /* double qps = 6; */
        if (message.qps !== 0)
            writer.tag(6, WireType.Bit64).double(message.qps);
        /* repeated string table_schema_changed = 7; */
        for (let i = 0; i < message.tableSchemaChanged.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.tableSchemaChanged[i]);
        /* repeated string view_schema_changed = 8; */
        for (let i = 0; i < message.viewSchemaChanged.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.viewSchemaChanged[i]);
        /* bool udfs_changed = 9; */
        if (message.udfsChanged !== false)
            writer.tag(9, WireType.Varint).bool(message.udfsChanged);
        /* bool tx_unresolved = 10; */
        if (message.txUnresolved !== false)
            writer.tag(10, WireType.Varint).bool(message.txUnresolved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.RealtimeStats
 */
export const RealtimeStats = new RealtimeStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateStats$Type extends MessageType<AggregateStats> {
    constructor() {
        super("query.AggregateStats", [
            { no: 1, name: "healthy_tablet_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unhealthy_tablet_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "replication_lag_seconds_min", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "replication_lag_seconds_max", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AggregateStats>): AggregateStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthyTabletCount = 0;
        message.unhealthyTabletCount = 0;
        message.replicationLagSecondsMin = 0;
        message.replicationLagSecondsMax = 0;
        if (value !== undefined)
            reflectionMergePartial<AggregateStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateStats): AggregateStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 healthy_tablet_count */ 1:
                    message.healthyTabletCount = reader.int32();
                    break;
                case /* int32 unhealthy_tablet_count */ 2:
                    message.unhealthyTabletCount = reader.int32();
                    break;
                case /* uint32 replication_lag_seconds_min */ 3:
                    message.replicationLagSecondsMin = reader.uint32();
                    break;
                case /* uint32 replication_lag_seconds_max */ 4:
                    message.replicationLagSecondsMax = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 healthy_tablet_count = 1; */
        if (message.healthyTabletCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.healthyTabletCount);
        /* int32 unhealthy_tablet_count = 2; */
        if (message.unhealthyTabletCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.unhealthyTabletCount);
        /* uint32 replication_lag_seconds_min = 3; */
        if (message.replicationLagSecondsMin !== 0)
            writer.tag(3, WireType.Varint).uint32(message.replicationLagSecondsMin);
        /* uint32 replication_lag_seconds_max = 4; */
        if (message.replicationLagSecondsMax !== 0)
            writer.tag(4, WireType.Varint).uint32(message.replicationLagSecondsMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.AggregateStats
 */
export const AggregateStats = new AggregateStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamHealthResponse$Type extends MessageType<StreamHealthResponse> {
    constructor() {
        super("query.StreamHealthResponse", [
            { no: 1, name: "target", kind: "message", T: () => Target },
            { no: 2, name: "serving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "primary_term_start_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "realtime_stats", kind: "message", T: () => RealtimeStats },
            { no: 5, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<StreamHealthResponse>): StreamHealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serving = false;
        message.primaryTermStartTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<StreamHealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamHealthResponse): StreamHealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Target target */ 1:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* bool serving */ 2:
                    message.serving = reader.bool();
                    break;
                case /* int64 primary_term_start_timestamp */ 3:
                    message.primaryTermStartTimestamp = reader.int64().toBigInt();
                    break;
                case /* query.RealtimeStats realtime_stats */ 4:
                    message.realtimeStats = RealtimeStats.internalBinaryRead(reader, reader.uint32(), options, message.realtimeStats);
                    break;
                case /* topodata.TabletAlias tablet_alias */ 5:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamHealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Target target = 1; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool serving = 2; */
        if (message.serving !== false)
            writer.tag(2, WireType.Varint).bool(message.serving);
        /* int64 primary_term_start_timestamp = 3; */
        if (message.primaryTermStartTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.primaryTermStartTimestamp);
        /* query.RealtimeStats realtime_stats = 4; */
        if (message.realtimeStats)
            RealtimeStats.internalBinaryWrite(message.realtimeStats, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletAlias tablet_alias = 5; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.StreamHealthResponse
 */
export const StreamHealthResponse = new StreamHealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionMetadata$Type extends MessageType<TransactionMetadata> {
    constructor() {
        super("query.TransactionMetadata", [
            { no: 1, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["query.TransactionState", TransactionState] },
            { no: 3, name: "time_created", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Target }
        ]);
    }
    create(value?: PartialMessage<TransactionMetadata>): TransactionMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        message.state = 0;
        message.timeCreated = 0n;
        message.participants = [];
        if (value !== undefined)
            reflectionMergePartial<TransactionMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionMetadata): TransactionMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dtid */ 1:
                    message.dtid = reader.string();
                    break;
                case /* query.TransactionState state */ 2:
                    message.state = reader.int32();
                    break;
                case /* int64 time_created */ 3:
                    message.timeCreated = reader.int64().toBigInt();
                    break;
                case /* repeated query.Target participants */ 4:
                    message.participants.push(Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dtid = 1; */
        if (message.dtid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dtid);
        /* query.TransactionState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        /* int64 time_created = 3; */
        if (message.timeCreated !== 0n)
            writer.tag(3, WireType.Varint).int64(message.timeCreated);
        /* repeated query.Target participants = 4; */
        for (let i = 0; i < message.participants.length; i++)
            Target.internalBinaryWrite(message.participants[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.TransactionMetadata
 */
export const TransactionMetadata = new TransactionMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("query.GetSchemaRequest", [
            { no: 1, name: "target", kind: "message", T: () => Target },
            { no: 2, name: "table_type", kind: "enum", T: () => ["query.SchemaTableType", SchemaTableType] },
            { no: 3, name: "table_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableType = 0;
        message.tableNames = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Target target */ 1:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* query.SchemaTableType table_type */ 2:
                    message.tableType = reader.int32();
                    break;
                case /* repeated string table_names */ 3:
                    message.tableNames.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Target target = 1; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.SchemaTableType table_type = 2; */
        if (message.tableType !== 0)
            writer.tag(2, WireType.Varint).int32(message.tableType);
        /* repeated string table_names = 3; */
        for (let i = 0; i < message.tableNames.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tableNames[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UDFInfo$Type extends MessageType<UDFInfo> {
    constructor() {
        super("query.UDFInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregating", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "return_type", kind: "enum", T: () => ["query.Type", Type] }
        ]);
    }
    create(value?: PartialMessage<UDFInfo>): UDFInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aggregating = false;
        message.returnType = 0;
        if (value !== undefined)
            reflectionMergePartial<UDFInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UDFInfo): UDFInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool aggregating */ 2:
                    message.aggregating = reader.bool();
                    break;
                case /* query.Type return_type */ 3:
                    message.returnType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UDFInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool aggregating = 2; */
        if (message.aggregating !== false)
            writer.tag(2, WireType.Varint).bool(message.aggregating);
        /* query.Type return_type = 3; */
        if (message.returnType !== 0)
            writer.tag(3, WireType.Varint).int32(message.returnType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.UDFInfo
 */
export const UDFInfo = new UDFInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("query.GetSchemaResponse", [
            { no: 1, name: "udfs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UDFInfo },
            { no: 2, name: "table_definition", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.udfs = [];
        message.tableDefinition = {};
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.UDFInfo udfs */ 1:
                    message.udfs.push(UDFInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, string> table_definition */ 2:
                    this.binaryReadMap2(message.tableDefinition, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GetSchemaResponse["tableDefinition"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetSchemaResponse["tableDefinition"] | undefined, val: GetSchemaResponse["tableDefinition"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field query.GetSchemaResponse.table_definition");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.UDFInfo udfs = 1; */
        for (let i = 0; i < message.udfs.length; i++)
            UDFInfo.internalBinaryWrite(message.udfs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> table_definition = 2; */
        for (let k of globalThis.Object.keys(message.tableDefinition))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tableDefinition[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message query.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
