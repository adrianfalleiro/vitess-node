//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the Vitess topology related data structures.
// Very few of these structures are exchanged over the wire (only
// TabletType and KeyRange), but they are all used by the topology
// service.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file topodata.proto (package topodata, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Time, TimeJson } from "./vttime_pb";
import { file_vttime } from "./vttime_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file topodata.proto.
 */
export const file_topodata: GenFile = /*@__PURE__*/
  fileDesc("Cg50b3BvZGF0YS5wcm90bxIIdG9wb2RhdGEiJgoIS2V5UmFuZ2USDQoFc3RhcnQYASABKAwSCwoDZW5kGAIgASgMIigKC1RhYmxldEFsaWFzEgwKBGNlbGwYASABKAkSCwoDdWlkGAIgASgNIosECgZUYWJsZXQSJAoFYWxpYXMYASABKAsyFS50b3BvZGF0YS5UYWJsZXRBbGlhcxIQCghob3N0bmFtZRgCIAEoCRIvCghwb3J0X21hcBgEIAMoCzIdLnRvcG9kYXRhLlRhYmxldC5Qb3J0TWFwRW50cnkSEAoIa2V5c3BhY2UYBSABKAkSDQoFc2hhcmQYBiABKAkSJQoJa2V5X3JhbmdlGAcgASgLMhIudG9wb2RhdGEuS2V5UmFuZ2USIgoEdHlwZRgIIAEoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSGAoQZGJfbmFtZV9vdmVycmlkZRgJIAEoCRIoCgR0YWdzGAogAygLMhoudG9wb2RhdGEuVGFibGV0LlRhZ3NFbnRyeRIWCg5teXNxbF9ob3N0bmFtZRgMIAEoCRISCgpteXNxbF9wb3J0GA0gASgFEi0KF3ByaW1hcnlfdGVybV9zdGFydF90aW1lGA4gASgLMgwudnR0aW1lLlRpbWUSHgoWZGVmYXVsdF9jb25uX2NvbGxhdGlvbhgQIAEoDRouCgxQb3J0TWFwRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgFOgI4ARorCglUYWdzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUoECAMQBEoECAsQDEoECA8QECKLBAoFU2hhcmQSLAoNcHJpbWFyeV9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEi0KF3ByaW1hcnlfdGVybV9zdGFydF90aW1lGAggASgLMgwudnR0aW1lLlRpbWUSJQoJa2V5X3JhbmdlGAIgASgLMhIudG9wb2RhdGEuS2V5UmFuZ2USMgoNc291cmNlX3NoYXJkcxgEIAMoCzIbLnRvcG9kYXRhLlNoYXJkLlNvdXJjZVNoYXJkEjYKD3RhYmxldF9jb250cm9scxgGIAMoCzIdLnRvcG9kYXRhLlNoYXJkLlRhYmxldENvbnRyb2wSGgoSaXNfcHJpbWFyeV9zZXJ2aW5nGAcgASgIGnIKC1NvdXJjZVNoYXJkEgsKA3VpZBgBIAEoBRIQCghrZXlzcGFjZRgCIAEoCRINCgVzaGFyZBgDIAEoCRIlCglrZXlfcmFuZ2UYBCABKAsyEi50b3BvZGF0YS5LZXlSYW5nZRIOCgZ0YWJsZXMYBSADKAkadgoNVGFibGV0Q29udHJvbBIpCgt0YWJsZXRfdHlwZRgBIAEoDjIULnRvcG9kYXRhLlRhYmxldFR5cGUSDQoFY2VsbHMYAiADKAkSFQoNZGVuaWVkX3RhYmxlcxgEIAMoCRIOCgZmcm96ZW4YBSABKAhKBAgDEARKBAgDEARKBAgFEAYi9gEKCEtleXNwYWNlEi0KDWtleXNwYWNlX3R5cGUYBSABKA4yFi50b3BvZGF0YS5LZXlzcGFjZVR5cGUSFQoNYmFzZV9rZXlzcGFjZRgGIAEoCRIjCg1zbmFwc2hvdF90aW1lGAcgASgLMgwudnR0aW1lLlRpbWUSGQoRZHVyYWJpbGl0eV9wb2xpY3kYCCABKAkSMwoQdGhyb3R0bGVyX2NvbmZpZxgJIAEoCzIZLnRvcG9kYXRhLlRocm90dGxlckNvbmZpZxIXCg9zaWRlY2FyX2RiX25hbWUYCiABKAlKBAgBEAJKBAgCEANKBAgDEARKBAgEEAUidwoQU2hhcmRSZXBsaWNhdGlvbhIuCgVub2RlcxgBIAMoCzIfLnRvcG9kYXRhLlNoYXJkUmVwbGljYXRpb24uTm9kZRozCgROb2RlEisKDHRhYmxldF9hbGlhcxgBIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIrMBChVTaGFyZFJlcGxpY2F0aW9uRXJyb3ISMgoEdHlwZRgBIAEoDjIkLnRvcG9kYXRhLlNoYXJkUmVwbGljYXRpb25FcnJvci5UeXBlEisKDHRhYmxldF9hbGlhcxgCIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIjkKBFR5cGUSCwoHVU5LTk9XThAAEg0KCU5PVF9GT1VORBABEhUKEVRPUE9MT0dZX01JU01BVENIEAIiRQoOU2hhcmRSZWZlcmVuY2USDAoEbmFtZRgBIAEoCRIlCglrZXlfcmFuZ2UYAiABKAsyEi50b3BvZGF0YS5LZXlSYW5nZSJpChJTaGFyZFRhYmxldENvbnRyb2wSDAoEbmFtZRgBIAEoCRIlCglrZXlfcmFuZ2UYAiABKAsyEi50b3BvZGF0YS5LZXlSYW5nZRIeChZxdWVyeV9zZXJ2aWNlX2Rpc2FibGVkGAMgASgIImEKEFRocm90dGxlZEFwcFJ1bGUSDAoEbmFtZRgBIAEoCRINCgVyYXRpbxgCIAEoARIgCgpleHBpcmVzX2F0GAMgASgLMgwudnR0aW1lLlRpbWUSDgoGZXhlbXB0GAQgASgIItMECg9UaHJvdHRsZXJDb25maWcSDwoHZW5hYmxlZBgBIAEoCBIRCgl0aHJlc2hvbGQYAiABKAESFAoMY3VzdG9tX3F1ZXJ5GAMgASgJEhsKE2NoZWNrX2FzX2NoZWNrX3NlbGYYBCABKAgSRAoOdGhyb3R0bGVkX2FwcHMYBSADKAsyLC50b3BvZGF0YS5UaHJvdHRsZXJDb25maWcuVGhyb3R0bGVkQXBwc0VudHJ5Ek0KE2FwcF9jaGVja2VkX21ldHJpY3MYBiADKAsyMC50b3BvZGF0YS5UaHJvdHRsZXJDb25maWcuQXBwQ2hlY2tlZE1ldHJpY3NFbnRyeRJKChFtZXRyaWNfdGhyZXNob2xkcxgHIAMoCzIvLnRvcG9kYXRhLlRocm90dGxlckNvbmZpZy5NZXRyaWNUaHJlc2hvbGRzRW50cnkaUAoSVGhyb3R0bGVkQXBwc0VudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLnRvcG9kYXRhLlRocm90dGxlZEFwcFJ1bGU6AjgBGhwKC01ldHJpY05hbWVzEg0KBW5hbWVzGAEgAygJGl8KFkFwcENoZWNrZWRNZXRyaWNzRW50cnkSCwoDa2V5GAEgASgJEjQKBXZhbHVlGAIgASgLMiUudG9wb2RhdGEuVGhyb3R0bGVyQ29uZmlnLk1ldHJpY05hbWVzOgI4ARo3ChVNZXRyaWNUaHJlc2hvbGRzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgBOgI4ASLJAgoLU3J2S2V5c3BhY2USOwoKcGFydGl0aW9ucxgBIAMoCzInLnRvcG9kYXRhLlNydktleXNwYWNlLktleXNwYWNlUGFydGl0aW9uEjMKEHRocm90dGxlcl9jb25maWcYBiABKAsyGS50b3BvZGF0YS5UaHJvdHRsZXJDb25maWcarwEKEUtleXNwYWNlUGFydGl0aW9uEikKC3NlcnZlZF90eXBlGAEgASgOMhQudG9wb2RhdGEuVGFibGV0VHlwZRIyChBzaGFyZF9yZWZlcmVuY2VzGAIgAygLMhgudG9wb2RhdGEuU2hhcmRSZWZlcmVuY2USOwoVc2hhcmRfdGFibGV0X2NvbnRyb2xzGAMgAygLMhwudG9wb2RhdGEuU2hhcmRUYWJsZXRDb250cm9sSgQIAhADSgQIAxAESgQIBBAFSgQIBRAGIjYKCENlbGxJbmZvEhYKDnNlcnZlcl9hZGRyZXNzGAEgASgJEgwKBHJvb3QYAiABKAlKBAgDEAQiGwoKQ2VsbHNBbGlhcxINCgVjZWxscxgCIAMoCSI9CgpUb3BvQ29uZmlnEhEKCXRvcG9fdHlwZRgBIAEoCRIOCgZzZXJ2ZXIYAiABKAkSDAoEcm9vdBgDIAEoCSJCChVFeHRlcm5hbFZpdGVzc0NsdXN0ZXISKQoLdG9wb19jb25maWcYASABKAsyFC50b3BvZGF0YS5Ub3BvQ29uZmlnIksKEEV4dGVybmFsQ2x1c3RlcnMSNwoOdml0ZXNzX2NsdXN0ZXIYASADKAsyHy50b3BvZGF0YS5FeHRlcm5hbFZpdGVzc0NsdXN0ZXIqKAoMS2V5c3BhY2VUeXBlEgoKBk5PUk1BTBAAEgwKCFNOQVBTSE9UEAEqnQEKClRhYmxldFR5cGUSCwoHVU5LTk9XThAAEgsKB1BSSU1BUlkQARIKCgZNQVNURVIQARILCgdSRVBMSUNBEAISCgoGUkRPTkxZEAMSCQoFQkFUQ0gQAxIJCgVTUEFSRRAEEhAKDEVYUEVSSU1FTlRBTBAFEgoKBkJBQ0tVUBAGEgsKB1JFU1RPUkUQBxILCgdEUkFJTkVEEAgaAhABQjgKD2lvLnZpdGVzcy5wcm90b1oldml0ZXNzLmlvL3ZpdGVzcy9nby92dC9wcm90by90b3BvZGF0YWIGcHJvdG8z", [file_vttime]);

/**
 * KeyRange describes a range of sharding keys, when range-based
 * sharding is used.
 *
 * @generated from message topodata.KeyRange
 */
export type KeyRange = Message<"topodata.KeyRange"> & {
  /**
   * @generated from field: bytes start = 1;
   */
  start: Uint8Array;

  /**
   * @generated from field: bytes end = 2;
   */
  end: Uint8Array;
};

/**
 * KeyRange describes a range of sharding keys, when range-based
 * sharding is used.
 *
 * @generated from message topodata.KeyRange
 */
export type KeyRangeJson = {
  /**
   * @generated from field: bytes start = 1;
   */
  start?: string;

  /**
   * @generated from field: bytes end = 2;
   */
  end?: string;
};

/**
 * Describes the message topodata.KeyRange.
 * Use `create(KeyRangeSchema)` to create a new message.
 */
export const KeyRangeSchema: GenMessage<KeyRange, KeyRangeJson> = /*@__PURE__*/
  messageDesc(file_topodata, 0);

/**
 * TabletAlias is a globally unique tablet identifier.
 *
 * @generated from message topodata.TabletAlias
 */
export type TabletAlias = Message<"topodata.TabletAlias"> & {
  /**
   * cell is the cell (or datacenter) the tablet is in
   *
   * @generated from field: string cell = 1;
   */
  cell: string;

  /**
   * uid is a unique id for this tablet within the shard
   * (this is the MySQL server id as well).
   *
   * @generated from field: uint32 uid = 2;
   */
  uid: number;
};

/**
 * TabletAlias is a globally unique tablet identifier.
 *
 * @generated from message topodata.TabletAlias
 */
export type TabletAliasJson = {
  /**
   * cell is the cell (or datacenter) the tablet is in
   *
   * @generated from field: string cell = 1;
   */
  cell?: string;

  /**
   * uid is a unique id for this tablet within the shard
   * (this is the MySQL server id as well).
   *
   * @generated from field: uint32 uid = 2;
   */
  uid?: number;
};

/**
 * Describes the message topodata.TabletAlias.
 * Use `create(TabletAliasSchema)` to create a new message.
 */
export const TabletAliasSchema: GenMessage<TabletAlias, TabletAliasJson> = /*@__PURE__*/
  messageDesc(file_topodata, 1);

/**
 * Tablet represents information about a running instance of vttablet.
 *
 * @generated from message topodata.Tablet
 */
export type Tablet = Message<"topodata.Tablet"> & {
  /**
   * alias is the unique name of the tablet.
   *
   * @generated from field: topodata.TabletAlias alias = 1;
   */
  alias?: TabletAlias;

  /**
   * Fully qualified domain name of the host.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;

  /**
   * Map of named ports. Normally this should include vt and grpc.
   * Going forward, the mysql port will be stored in mysql_port
   * instead of here.
   * For accessing mysql port, use topoproto.MysqlPort to fetch, and
   * topoproto.SetMysqlPort to set. These wrappers will ensure
   * legacy behavior is supported.
   *
   * @generated from field: map<string, int32> port_map = 4;
   */
  portMap: { [key: string]: number };

  /**
   * Keyspace name.
   *
   * @generated from field: string keyspace = 5;
   */
  keyspace: string;

  /**
   * Shard name. If range based sharding is used, it should match
   * key_range.
   *
   * @generated from field: string shard = 6;
   */
  shard: string;

  /**
   * If range based sharding is used, range for the tablet's shard.
   *
   * @generated from field: topodata.KeyRange key_range = 7;
   */
  keyRange?: KeyRange;

  /**
   * type is the current type of the tablet.
   *
   * @generated from field: topodata.TabletType type = 8;
   */
  type: TabletType;

  /**
   * It this is set, it is used as the database name instead of the
   * normal "vt_" + keyspace.
   *
   * @generated from field: string db_name_override = 9;
   */
  dbNameOverride: string;

  /**
   * tablet tags
   *
   * @generated from field: map<string, string> tags = 10;
   */
  tags: { [key: string]: string };

  /**
   * MySQL hostname.
   *
   * @generated from field: string mysql_hostname = 12;
   */
  mysqlHostname: string;

  /**
   * MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
   * to access this variable. The functions provide support
   * for legacy behavior.
   *
   * @generated from field: int32 mysql_port = 13;
   */
  mysqlPort: number;

  /**
   * primary_term_start_time is the time (in UTC) at which the current term of
   * the current tablet began as primary. If this tablet is not currently the
   * primary, this value is ignored.
   *
   * A new primary term begins any time an authoritative decision is communicated
   * about which tablet should be the primary, such as via Vitess
   * replication-management commands like PlannedReparentShard,
   * EmergencyReparentShard, and TabletExternallyReparented.
   *
   *
   * @generated from field: vttime.Time primary_term_start_time = 14;
   */
  primaryTermStartTime?: Time;

  /**
   * default_conn_collation is the default connection collation used by this tablet.
   *
   * @generated from field: uint32 default_conn_collation = 16;
   */
  defaultConnCollation: number;
};

/**
 * Tablet represents information about a running instance of vttablet.
 *
 * @generated from message topodata.Tablet
 */
export type TabletJson = {
  /**
   * alias is the unique name of the tablet.
   *
   * @generated from field: topodata.TabletAlias alias = 1;
   */
  alias?: TabletAliasJson;

  /**
   * Fully qualified domain name of the host.
   *
   * @generated from field: string hostname = 2;
   */
  hostname?: string;

  /**
   * Map of named ports. Normally this should include vt and grpc.
   * Going forward, the mysql port will be stored in mysql_port
   * instead of here.
   * For accessing mysql port, use topoproto.MysqlPort to fetch, and
   * topoproto.SetMysqlPort to set. These wrappers will ensure
   * legacy behavior is supported.
   *
   * @generated from field: map<string, int32> port_map = 4;
   */
  portMap?: { [key: string]: number };

  /**
   * Keyspace name.
   *
   * @generated from field: string keyspace = 5;
   */
  keyspace?: string;

  /**
   * Shard name. If range based sharding is used, it should match
   * key_range.
   *
   * @generated from field: string shard = 6;
   */
  shard?: string;

  /**
   * If range based sharding is used, range for the tablet's shard.
   *
   * @generated from field: topodata.KeyRange key_range = 7;
   */
  keyRange?: KeyRangeJson;

  /**
   * type is the current type of the tablet.
   *
   * @generated from field: topodata.TabletType type = 8;
   */
  type?: TabletTypeJson;

  /**
   * It this is set, it is used as the database name instead of the
   * normal "vt_" + keyspace.
   *
   * @generated from field: string db_name_override = 9;
   */
  dbNameOverride?: string;

  /**
   * tablet tags
   *
   * @generated from field: map<string, string> tags = 10;
   */
  tags?: { [key: string]: string };

  /**
   * MySQL hostname.
   *
   * @generated from field: string mysql_hostname = 12;
   */
  mysqlHostname?: string;

  /**
   * MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
   * to access this variable. The functions provide support
   * for legacy behavior.
   *
   * @generated from field: int32 mysql_port = 13;
   */
  mysqlPort?: number;

  /**
   * primary_term_start_time is the time (in UTC) at which the current term of
   * the current tablet began as primary. If this tablet is not currently the
   * primary, this value is ignored.
   *
   * A new primary term begins any time an authoritative decision is communicated
   * about which tablet should be the primary, such as via Vitess
   * replication-management commands like PlannedReparentShard,
   * EmergencyReparentShard, and TabletExternallyReparented.
   *
   *
   * @generated from field: vttime.Time primary_term_start_time = 14;
   */
  primaryTermStartTime?: TimeJson;

  /**
   * default_conn_collation is the default connection collation used by this tablet.
   *
   * @generated from field: uint32 default_conn_collation = 16;
   */
  defaultConnCollation?: number;
};

/**
 * Describes the message topodata.Tablet.
 * Use `create(TabletSchema)` to create a new message.
 */
export const TabletSchema: GenMessage<Tablet, TabletJson> = /*@__PURE__*/
  messageDesc(file_topodata, 2);

/**
 * A Shard contains data about a subset of the data whithin a keyspace.
 *
 * @generated from message topodata.Shard
 */
export type Shard = Message<"topodata.Shard"> & {
  /**
   * primary_alias is the tablet alias of the primary for the shard.
   * If it is unset, then there is no primary in this shard yet.
   * No lock is necessary to update this field, when for instance
   * TabletExternallyReparented updates this. However, we lock the
   * shard for reparenting operations (InitShardPrimary,
   * PlannedReparentShard,EmergencyReparentShard), to guarantee
   * exclusive operation.
   *
   * @generated from field: topodata.TabletAlias primary_alias = 1;
   */
  primaryAlias?: TabletAlias;

  /**
   * primary_term_start_time is the time (in UTC) at which the current term of
   * the primary specified in primary_alias began.
   *
   * A new primary term begins any time an authoritative decision is communicated
   * about which tablet should be the primary, such as via Vitess
   * replication-management commands like PlannedReparentShard,
   * EmergencyReparentShard, and TabletExternallyReparented.
   *
   * The primary_alias should only ever be changed if the new primary's term began
   * at a later time than this. Note that a new term can start for the tablet
   * that is already the primary. In that case, the primary_term_start_time would
   * be increased without changing the primary_alias.
   *
   * @generated from field: vttime.Time primary_term_start_time = 8;
   */
  primaryTermStartTime?: Time;

  /**
   * key_range is the KeyRange for this shard. It can be unset if:
   * - we are not using range-based sharding in this shard.
   * - the shard covers the entire keyrange.
   * This must match the shard name based on our other conventions, but
   * helpful to have it decomposed here.
   * Once set at creation time, it is never changed.
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRange;

  /**
   * SourceShards is the list of shards we're replicating from,
   * using filtered replication.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: repeated topodata.Shard.SourceShard source_shards = 4;
   */
  sourceShards: Shard_SourceShard[];

  /**
   * tablet_controls has at most one entry per TabletType.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: repeated topodata.Shard.TabletControl tablet_controls = 6;
   */
  tabletControls: Shard_TabletControl[];

  /**
   * is_primary_serving sets whether this shard primary is serving traffic or not.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: bool is_primary_serving = 7;
   */
  isPrimaryServing: boolean;
};

/**
 * A Shard contains data about a subset of the data whithin a keyspace.
 *
 * @generated from message topodata.Shard
 */
export type ShardJson = {
  /**
   * primary_alias is the tablet alias of the primary for the shard.
   * If it is unset, then there is no primary in this shard yet.
   * No lock is necessary to update this field, when for instance
   * TabletExternallyReparented updates this. However, we lock the
   * shard for reparenting operations (InitShardPrimary,
   * PlannedReparentShard,EmergencyReparentShard), to guarantee
   * exclusive operation.
   *
   * @generated from field: topodata.TabletAlias primary_alias = 1;
   */
  primaryAlias?: TabletAliasJson;

  /**
   * primary_term_start_time is the time (in UTC) at which the current term of
   * the primary specified in primary_alias began.
   *
   * A new primary term begins any time an authoritative decision is communicated
   * about which tablet should be the primary, such as via Vitess
   * replication-management commands like PlannedReparentShard,
   * EmergencyReparentShard, and TabletExternallyReparented.
   *
   * The primary_alias should only ever be changed if the new primary's term began
   * at a later time than this. Note that a new term can start for the tablet
   * that is already the primary. In that case, the primary_term_start_time would
   * be increased without changing the primary_alias.
   *
   * @generated from field: vttime.Time primary_term_start_time = 8;
   */
  primaryTermStartTime?: TimeJson;

  /**
   * key_range is the KeyRange for this shard. It can be unset if:
   * - we are not using range-based sharding in this shard.
   * - the shard covers the entire keyrange.
   * This must match the shard name based on our other conventions, but
   * helpful to have it decomposed here.
   * Once set at creation time, it is never changed.
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRangeJson;

  /**
   * SourceShards is the list of shards we're replicating from,
   * using filtered replication.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: repeated topodata.Shard.SourceShard source_shards = 4;
   */
  sourceShards?: Shard_SourceShardJson[];

  /**
   * tablet_controls has at most one entry per TabletType.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: repeated topodata.Shard.TabletControl tablet_controls = 6;
   */
  tabletControls?: Shard_TabletControlJson[];

  /**
   * is_primary_serving sets whether this shard primary is serving traffic or not.
   * The keyspace lock is always taken when changing this.
   *
   * @generated from field: bool is_primary_serving = 7;
   */
  isPrimaryServing?: boolean;
};

/**
 * Describes the message topodata.Shard.
 * Use `create(ShardSchema)` to create a new message.
 */
export const ShardSchema: GenMessage<Shard, ShardJson> = /*@__PURE__*/
  messageDesc(file_topodata, 3);

/**
 * SourceShard represents a data source for filtered replication
 * across shards. When this is used in a destination shard, the primary
 * of that shard will run filtered replication.
 *
 * @generated from message topodata.Shard.SourceShard
 */
export type Shard_SourceShard = Message<"topodata.Shard.SourceShard"> & {
  /**
   * Uid is the unique ID for this SourceShard object.
   *
   * @generated from field: int32 uid = 1;
   */
  uid: number;

  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 2;
   */
  keyspace: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 3;
   */
  shard: string;

  /**
   * the source shard keyrange
   *
   * @generated from field: topodata.KeyRange key_range = 4;
   */
  keyRange?: KeyRange;

  /**
   * the source table list to replicate
   *
   * @generated from field: repeated string tables = 5;
   */
  tables: string[];
};

/**
 * SourceShard represents a data source for filtered replication
 * across shards. When this is used in a destination shard, the primary
 * of that shard will run filtered replication.
 *
 * @generated from message topodata.Shard.SourceShard
 */
export type Shard_SourceShardJson = {
  /**
   * Uid is the unique ID for this SourceShard object.
   *
   * @generated from field: int32 uid = 1;
   */
  uid?: number;

  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 2;
   */
  keyspace?: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 3;
   */
  shard?: string;

  /**
   * the source shard keyrange
   *
   * @generated from field: topodata.KeyRange key_range = 4;
   */
  keyRange?: KeyRangeJson;

  /**
   * the source table list to replicate
   *
   * @generated from field: repeated string tables = 5;
   */
  tables?: string[];
};

/**
 * Describes the message topodata.Shard.SourceShard.
 * Use `create(Shard_SourceShardSchema)` to create a new message.
 */
export const Shard_SourceShardSchema: GenMessage<Shard_SourceShard, Shard_SourceShardJson> = /*@__PURE__*/
  messageDesc(file_topodata, 3, 0);

/**
 * TabletControl controls tablet's behavior
 *
 * @generated from message topodata.Shard.TabletControl
 */
export type Shard_TabletControl = Message<"topodata.Shard.TabletControl"> & {
  /**
   * which tablet type is affected
   *
   * @generated from field: topodata.TabletType tablet_type = 1;
   */
  tabletType: TabletType;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];

  /**
   * @generated from field: repeated string denied_tables = 4;
   */
  deniedTables: string[];

  /**
   * frozen is set if we've started failing over traffic for
   * the primary. If set, this record should not be removed.
   *
   * @generated from field: bool frozen = 5;
   */
  frozen: boolean;
};

/**
 * TabletControl controls tablet's behavior
 *
 * @generated from message topodata.Shard.TabletControl
 */
export type Shard_TabletControlJson = {
  /**
   * which tablet type is affected
   *
   * @generated from field: topodata.TabletType tablet_type = 1;
   */
  tabletType?: TabletTypeJson;

  /**
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];

  /**
   * @generated from field: repeated string denied_tables = 4;
   */
  deniedTables?: string[];

  /**
   * frozen is set if we've started failing over traffic for
   * the primary. If set, this record should not be removed.
   *
   * @generated from field: bool frozen = 5;
   */
  frozen?: boolean;
};

/**
 * Describes the message topodata.Shard.TabletControl.
 * Use `create(Shard_TabletControlSchema)` to create a new message.
 */
export const Shard_TabletControlSchema: GenMessage<Shard_TabletControl, Shard_TabletControlJson> = /*@__PURE__*/
  messageDesc(file_topodata, 3, 1);

/**
 * A Keyspace contains data about a keyspace.
 *
 * @generated from message topodata.Keyspace
 */
export type Keyspace = Message<"topodata.Keyspace"> & {
  /**
   * keyspace_type will determine how this keyspace is treated by
   * vtgate / vschema. Normal keyspaces are routable by
   * any query. Snapshot keyspaces are only accessible
   * by explicit addresssing or by calling "use keyspace" first
   *
   * @generated from field: topodata.KeyspaceType keyspace_type = 5;
   */
  keyspaceType: KeyspaceType;

  /**
   * base_keyspace is the base keyspace from which a snapshot
   * keyspace is created. empty for normal keyspaces
   *
   * @generated from field: string base_keyspace = 6;
   */
  baseKeyspace: string;

  /**
   * snapshot_time (in UTC) is a property of snapshot
   * keyspaces which tells us what point in time
   * the snapshot is of
   *
   * @generated from field: vttime.Time snapshot_time = 7;
   */
  snapshotTime?: Time;

  /**
   * DurabilityPolicy is the durability policy to be
   * used for the keyspace.
   *
   * @generated from field: string durability_policy = 8;
   */
  durabilityPolicy: string;

  /**
   * ThrottlerConfig has the configuration for the tablet
   * server's lag throttler, and applies to the entire
   * keyspace, across all shards and tablets.
   *
   * @generated from field: topodata.ThrottlerConfig throttler_config = 9;
   */
  throttlerConfig?: ThrottlerConfig;

  /**
   * SidecarDBName is the name of the Vitess sidecar database
   * used for various system metadata that is stored in each
   * tablet's mysqld instance.
   *
   * @generated from field: string sidecar_db_name = 10;
   */
  sidecarDbName: string;
};

/**
 * A Keyspace contains data about a keyspace.
 *
 * @generated from message topodata.Keyspace
 */
export type KeyspaceJson = {
  /**
   * keyspace_type will determine how this keyspace is treated by
   * vtgate / vschema. Normal keyspaces are routable by
   * any query. Snapshot keyspaces are only accessible
   * by explicit addresssing or by calling "use keyspace" first
   *
   * @generated from field: topodata.KeyspaceType keyspace_type = 5;
   */
  keyspaceType?: KeyspaceTypeJson;

  /**
   * base_keyspace is the base keyspace from which a snapshot
   * keyspace is created. empty for normal keyspaces
   *
   * @generated from field: string base_keyspace = 6;
   */
  baseKeyspace?: string;

  /**
   * snapshot_time (in UTC) is a property of snapshot
   * keyspaces which tells us what point in time
   * the snapshot is of
   *
   * @generated from field: vttime.Time snapshot_time = 7;
   */
  snapshotTime?: TimeJson;

  /**
   * DurabilityPolicy is the durability policy to be
   * used for the keyspace.
   *
   * @generated from field: string durability_policy = 8;
   */
  durabilityPolicy?: string;

  /**
   * ThrottlerConfig has the configuration for the tablet
   * server's lag throttler, and applies to the entire
   * keyspace, across all shards and tablets.
   *
   * @generated from field: topodata.ThrottlerConfig throttler_config = 9;
   */
  throttlerConfig?: ThrottlerConfigJson;

  /**
   * SidecarDBName is the name of the Vitess sidecar database
   * used for various system metadata that is stored in each
   * tablet's mysqld instance.
   *
   * @generated from field: string sidecar_db_name = 10;
   */
  sidecarDbName?: string;
};

/**
 * Describes the message topodata.Keyspace.
 * Use `create(KeyspaceSchema)` to create a new message.
 */
export const KeyspaceSchema: GenMessage<Keyspace, KeyspaceJson> = /*@__PURE__*/
  messageDesc(file_topodata, 4);

/**
 * ShardReplication describes the MySQL replication relationships
 * whithin a cell.
 *
 * @generated from message topodata.ShardReplication
 */
export type ShardReplication = Message<"topodata.ShardReplication"> & {
  /**
   * Note there can be only one Node in this array
   * for a given tablet.
   *
   * @generated from field: repeated topodata.ShardReplication.Node nodes = 1;
   */
  nodes: ShardReplication_Node[];
};

/**
 * ShardReplication describes the MySQL replication relationships
 * whithin a cell.
 *
 * @generated from message topodata.ShardReplication
 */
export type ShardReplicationJson = {
  /**
   * Note there can be only one Node in this array
   * for a given tablet.
   *
   * @generated from field: repeated topodata.ShardReplication.Node nodes = 1;
   */
  nodes?: ShardReplication_NodeJson[];
};

/**
 * Describes the message topodata.ShardReplication.
 * Use `create(ShardReplicationSchema)` to create a new message.
 */
export const ShardReplicationSchema: GenMessage<ShardReplication, ShardReplicationJson> = /*@__PURE__*/
  messageDesc(file_topodata, 5);

/**
 * Node describes a tablet instance within the cell
 *
 * @generated from message topodata.ShardReplication.Node
 */
export type ShardReplication_Node = Message<"topodata.ShardReplication.Node"> & {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAlias;
};

/**
 * Node describes a tablet instance within the cell
 *
 * @generated from message topodata.ShardReplication.Node
 */
export type ShardReplication_NodeJson = {
  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 1;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message topodata.ShardReplication.Node.
 * Use `create(ShardReplication_NodeSchema)` to create a new message.
 */
export const ShardReplication_NodeSchema: GenMessage<ShardReplication_Node, ShardReplication_NodeJson> = /*@__PURE__*/
  messageDesc(file_topodata, 5, 0);

/**
 * ShardReplicationError describes the error being fixed by
 * ShardReplicationFix.
 *
 * @generated from message topodata.ShardReplicationError
 */
export type ShardReplicationError = Message<"topodata.ShardReplicationError"> & {
  /**
   * Type is the category of problem being fixed.
   *
   * @generated from field: topodata.ShardReplicationError.Type type = 1;
   */
  type: ShardReplicationError_Type;

  /**
   * TabletAlias is the tablet record that has the problem.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 2;
   */
  tabletAlias?: TabletAlias;
};

/**
 * ShardReplicationError describes the error being fixed by
 * ShardReplicationFix.
 *
 * @generated from message topodata.ShardReplicationError
 */
export type ShardReplicationErrorJson = {
  /**
   * Type is the category of problem being fixed.
   *
   * @generated from field: topodata.ShardReplicationError.Type type = 1;
   */
  type?: ShardReplicationError_TypeJson;

  /**
   * TabletAlias is the tablet record that has the problem.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 2;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message topodata.ShardReplicationError.
 * Use `create(ShardReplicationErrorSchema)` to create a new message.
 */
export const ShardReplicationErrorSchema: GenMessage<ShardReplicationError, ShardReplicationErrorJson> = /*@__PURE__*/
  messageDesc(file_topodata, 6);

/**
 * @generated from enum topodata.ShardReplicationError.Type
 */
export enum ShardReplicationError_Type {
  /**
   * UNKNOWN is not a valid value.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * NOT_FOUND occurs when a tablet is in the ShardReplication record
   * but does not exist in the topology.
   *
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * TOPOLOGY_MISMATCH occurs when a tablet is in the replication graph and
   * exists in the topology, but at least one of the Keyspace, Shard, or Cell
   * fields for that tablet does not match the ShardReplication record.
   *
   * @generated from enum value: TOPOLOGY_MISMATCH = 2;
   */
  TOPOLOGY_MISMATCH = 2,
}

/**
 * @generated from enum topodata.ShardReplicationError.Type
 */
export type ShardReplicationError_TypeJson = "UNKNOWN" | "NOT_FOUND" | "TOPOLOGY_MISMATCH";

/**
 * Describes the enum topodata.ShardReplicationError.Type.
 */
export const ShardReplicationError_TypeSchema: GenEnum<ShardReplicationError_Type, ShardReplicationError_TypeJson> = /*@__PURE__*/
  enumDesc(file_topodata, 6, 0);

/**
 * ShardReference is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardReference
 */
export type ShardReference = Message<"topodata.ShardReference"> & {
  /**
   * Copied from Shard.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Disable query serving in this shard
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRange;
};

/**
 * ShardReference is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardReference
 */
export type ShardReferenceJson = {
  /**
   * Copied from Shard.
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * Disable query serving in this shard
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRangeJson;
};

/**
 * Describes the message topodata.ShardReference.
 * Use `create(ShardReferenceSchema)` to create a new message.
 */
export const ShardReferenceSchema: GenMessage<ShardReference, ShardReferenceJson> = /*@__PURE__*/
  messageDesc(file_topodata, 7);

/**
 * ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardTabletControl
 */
export type ShardTabletControl = Message<"topodata.ShardTabletControl"> & {
  /**
   * Copied from Shard.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRange;

  /**
   * Disable query serving in this shard
   *
   * @generated from field: bool query_service_disabled = 3;
   */
  queryServiceDisabled: boolean;
};

/**
 * ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardTabletControl
 */
export type ShardTabletControlJson = {
  /**
   * Copied from Shard.
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRangeJson;

  /**
   * Disable query serving in this shard
   *
   * @generated from field: bool query_service_disabled = 3;
   */
  queryServiceDisabled?: boolean;
};

/**
 * Describes the message topodata.ShardTabletControl.
 * Use `create(ShardTabletControlSchema)` to create a new message.
 */
export const ShardTabletControlSchema: GenMessage<ShardTabletControl, ShardTabletControlJson> = /*@__PURE__*/
  messageDesc(file_topodata, 8);

/**
 * ThrottledAppRule defines an app-specific throttling rule, with expiration.
 *
 * @generated from message topodata.ThrottledAppRule
 */
export type ThrottledAppRule = Message<"topodata.ThrottledAppRule"> & {
  /**
   * Name of the app to be throttled, e.g. "vreplication" or "online-ddl"
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Ratio defines how much the app should be throttled, range [0.0...1.0]. 1.0 means fully throttled. 0.0 means not throttled at all.
   * Negative values are reserved for a future implementation.
   *
   * @generated from field: double ratio = 2;
   */
  ratio: number;

  /**
   * ExpiresAt is the time at which the rule expires.
   *
   * @generated from field: vttime.Time expires_at = 3;
   */
  expiresAt?: Time;

  /**
   * Exempt indicates the app should never be throttled, even if the throttler is, in general, throttling other apps.
   *
   * @generated from field: bool exempt = 4;
   */
  exempt: boolean;
};

/**
 * ThrottledAppRule defines an app-specific throttling rule, with expiration.
 *
 * @generated from message topodata.ThrottledAppRule
 */
export type ThrottledAppRuleJson = {
  /**
   * Name of the app to be throttled, e.g. "vreplication" or "online-ddl"
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * Ratio defines how much the app should be throttled, range [0.0...1.0]. 1.0 means fully throttled. 0.0 means not throttled at all.
   * Negative values are reserved for a future implementation.
   *
   * @generated from field: double ratio = 2;
   */
  ratio?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * ExpiresAt is the time at which the rule expires.
   *
   * @generated from field: vttime.Time expires_at = 3;
   */
  expiresAt?: TimeJson;

  /**
   * Exempt indicates the app should never be throttled, even if the throttler is, in general, throttling other apps.
   *
   * @generated from field: bool exempt = 4;
   */
  exempt?: boolean;
};

/**
 * Describes the message topodata.ThrottledAppRule.
 * Use `create(ThrottledAppRuleSchema)` to create a new message.
 */
export const ThrottledAppRuleSchema: GenMessage<ThrottledAppRule, ThrottledAppRuleJson> = /*@__PURE__*/
  messageDesc(file_topodata, 9);

/**
 * @generated from message topodata.ThrottlerConfig
 */
export type ThrottlerConfig = Message<"topodata.ThrottlerConfig"> & {
  /**
   * Enabled indicates that the throttler is actually checking state for
   * requests. When disabled, it automatically returns 200 OK for all
   * checks.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * Threshold is the threshold for either the default check (heartbeat
   * lag) or custom check.
   *
   * @generated from field: double threshold = 2;
   */
  threshold: number;

  /**
   * CustomQuery is an optional query that overrides the default check
   * query.
   *
   * @generated from field: string custom_query = 3;
   */
  customQuery: string;

  /**
   * CheckAsCheckSelf indicates whether a throttler /check request
   * should behave like a /check-self.
   *
   * @generated from field: bool check_as_check_self = 4;
   */
  checkAsCheckSelf: boolean;

  /**
   * ThrottledApps is a map of rules for app-specific throttling
   *
   * @generated from field: map<string, topodata.ThrottledAppRule> throttled_apps = 5;
   */
  throttledApps: { [key: string]: ThrottledAppRule };

  /**
   * AppCheckedMetrics maps app names to the list of metrics that should be checked for that app
   *
   * @generated from field: map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics = 6;
   */
  appCheckedMetrics: { [key: string]: ThrottlerConfig_MetricNames };

  /**
   * MetricThresholds maps metric names to the threshold values that should be used for that metric
   *
   * @generated from field: map<string, double> metric_thresholds = 7;
   */
  metricThresholds: { [key: string]: number };
};

/**
 * @generated from message topodata.ThrottlerConfig
 */
export type ThrottlerConfigJson = {
  /**
   * Enabled indicates that the throttler is actually checking state for
   * requests. When disabled, it automatically returns 200 OK for all
   * checks.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled?: boolean;

  /**
   * Threshold is the threshold for either the default check (heartbeat
   * lag) or custom check.
   *
   * @generated from field: double threshold = 2;
   */
  threshold?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * CustomQuery is an optional query that overrides the default check
   * query.
   *
   * @generated from field: string custom_query = 3;
   */
  customQuery?: string;

  /**
   * CheckAsCheckSelf indicates whether a throttler /check request
   * should behave like a /check-self.
   *
   * @generated from field: bool check_as_check_self = 4;
   */
  checkAsCheckSelf?: boolean;

  /**
   * ThrottledApps is a map of rules for app-specific throttling
   *
   * @generated from field: map<string, topodata.ThrottledAppRule> throttled_apps = 5;
   */
  throttledApps?: { [key: string]: ThrottledAppRuleJson };

  /**
   * AppCheckedMetrics maps app names to the list of metrics that should be checked for that app
   *
   * @generated from field: map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics = 6;
   */
  appCheckedMetrics?: { [key: string]: ThrottlerConfig_MetricNamesJson };

  /**
   * MetricThresholds maps metric names to the threshold values that should be used for that metric
   *
   * @generated from field: map<string, double> metric_thresholds = 7;
   */
  metricThresholds?: { [key: string]: number | "NaN" | "Infinity" | "-Infinity" };
};

/**
 * Describes the message topodata.ThrottlerConfig.
 * Use `create(ThrottlerConfigSchema)` to create a new message.
 */
export const ThrottlerConfigSchema: GenMessage<ThrottlerConfig, ThrottlerConfigJson> = /*@__PURE__*/
  messageDesc(file_topodata, 10);

/**
 * @generated from message topodata.ThrottlerConfig.MetricNames
 */
export type ThrottlerConfig_MetricNames = Message<"topodata.ThrottlerConfig.MetricNames"> & {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * @generated from message topodata.ThrottlerConfig.MetricNames
 */
export type ThrottlerConfig_MetricNamesJson = {
  /**
   * @generated from field: repeated string names = 1;
   */
  names?: string[];
};

/**
 * Describes the message topodata.ThrottlerConfig.MetricNames.
 * Use `create(ThrottlerConfig_MetricNamesSchema)` to create a new message.
 */
export const ThrottlerConfig_MetricNamesSchema: GenMessage<ThrottlerConfig_MetricNames, ThrottlerConfig_MetricNamesJson> = /*@__PURE__*/
  messageDesc(file_topodata, 10, 0);

/**
 * SrvKeyspace is a rollup node for the keyspace itself.
 *
 * @generated from message topodata.SrvKeyspace
 */
export type SrvKeyspace = Message<"topodata.SrvKeyspace"> & {
  /**
   * The partitions this keyspace is serving, per tablet type.
   *
   * @generated from field: repeated topodata.SrvKeyspace.KeyspacePartition partitions = 1;
   */
  partitions: SrvKeyspace_KeyspacePartition[];

  /**
   * ThrottlerConfig has the configuration for the tablet server's
   * lag throttler, and applies to the entire keyspace, across all
   * shards and tablets. This is copied from the global keyspace
   * object.
   *
   * @generated from field: topodata.ThrottlerConfig throttler_config = 6;
   */
  throttlerConfig?: ThrottlerConfig;
};

/**
 * SrvKeyspace is a rollup node for the keyspace itself.
 *
 * @generated from message topodata.SrvKeyspace
 */
export type SrvKeyspaceJson = {
  /**
   * The partitions this keyspace is serving, per tablet type.
   *
   * @generated from field: repeated topodata.SrvKeyspace.KeyspacePartition partitions = 1;
   */
  partitions?: SrvKeyspace_KeyspacePartitionJson[];

  /**
   * ThrottlerConfig has the configuration for the tablet server's
   * lag throttler, and applies to the entire keyspace, across all
   * shards and tablets. This is copied from the global keyspace
   * object.
   *
   * @generated from field: topodata.ThrottlerConfig throttler_config = 6;
   */
  throttlerConfig?: ThrottlerConfigJson;
};

/**
 * Describes the message topodata.SrvKeyspace.
 * Use `create(SrvKeyspaceSchema)` to create a new message.
 */
export const SrvKeyspaceSchema: GenMessage<SrvKeyspace, SrvKeyspaceJson> = /*@__PURE__*/
  messageDesc(file_topodata, 11);

/**
 * @generated from message topodata.SrvKeyspace.KeyspacePartition
 */
export type SrvKeyspace_KeyspacePartition = Message<"topodata.SrvKeyspace.KeyspacePartition"> & {
  /**
   * The type this partition applies to.
   *
   * @generated from field: topodata.TabletType served_type = 1;
   */
  servedType: TabletType;

  /**
   * List of non-overlapping continuous shards sorted by range.
   *
   * @generated from field: repeated topodata.ShardReference shard_references = 2;
   */
  shardReferences: ShardReference[];

  /**
   * List of shard tablet controls
   *
   * @generated from field: repeated topodata.ShardTabletControl shard_tablet_controls = 3;
   */
  shardTabletControls: ShardTabletControl[];
};

/**
 * @generated from message topodata.SrvKeyspace.KeyspacePartition
 */
export type SrvKeyspace_KeyspacePartitionJson = {
  /**
   * The type this partition applies to.
   *
   * @generated from field: topodata.TabletType served_type = 1;
   */
  servedType?: TabletTypeJson;

  /**
   * List of non-overlapping continuous shards sorted by range.
   *
   * @generated from field: repeated topodata.ShardReference shard_references = 2;
   */
  shardReferences?: ShardReferenceJson[];

  /**
   * List of shard tablet controls
   *
   * @generated from field: repeated topodata.ShardTabletControl shard_tablet_controls = 3;
   */
  shardTabletControls?: ShardTabletControlJson[];
};

/**
 * Describes the message topodata.SrvKeyspace.KeyspacePartition.
 * Use `create(SrvKeyspace_KeyspacePartitionSchema)` to create a new message.
 */
export const SrvKeyspace_KeyspacePartitionSchema: GenMessage<SrvKeyspace_KeyspacePartition, SrvKeyspace_KeyspacePartitionJson> = /*@__PURE__*/
  messageDesc(file_topodata, 11, 0);

/**
 * CellInfo contains information about a cell. CellInfo objects are
 * stored in the global topology server, and describe how to reach
 * local topology servers.
 *
 * @generated from message topodata.CellInfo
 */
export type CellInfo = Message<"topodata.CellInfo"> & {
  /**
   * ServerAddress contains the address of the server for the cell.
   * The syntax of this field is topology implementation specific.
   * For instance, for Zookeeper, it is a comma-separated list of
   * server addresses.
   *
   * @generated from field: string server_address = 1;
   */
  serverAddress: string;

  /**
   * Root is the path to store data in. It is only used when talking
   * to server_address.
   *
   * @generated from field: string root = 2;
   */
  root: string;
};

/**
 * CellInfo contains information about a cell. CellInfo objects are
 * stored in the global topology server, and describe how to reach
 * local topology servers.
 *
 * @generated from message topodata.CellInfo
 */
export type CellInfoJson = {
  /**
   * ServerAddress contains the address of the server for the cell.
   * The syntax of this field is topology implementation specific.
   * For instance, for Zookeeper, it is a comma-separated list of
   * server addresses.
   *
   * @generated from field: string server_address = 1;
   */
  serverAddress?: string;

  /**
   * Root is the path to store data in. It is only used when talking
   * to server_address.
   *
   * @generated from field: string root = 2;
   */
  root?: string;
};

/**
 * Describes the message topodata.CellInfo.
 * Use `create(CellInfoSchema)` to create a new message.
 */
export const CellInfoSchema: GenMessage<CellInfo, CellInfoJson> = /*@__PURE__*/
  messageDesc(file_topodata, 12);

/**
 * CellsAlias
 *
 * @generated from message topodata.CellsAlias
 */
export type CellsAlias = Message<"topodata.CellsAlias"> & {
  /**
   * Cells that map to this alias
   *
   * @generated from field: repeated string cells = 2;
   */
  cells: string[];
};

/**
 * CellsAlias
 *
 * @generated from message topodata.CellsAlias
 */
export type CellsAliasJson = {
  /**
   * Cells that map to this alias
   *
   * @generated from field: repeated string cells = 2;
   */
  cells?: string[];
};

/**
 * Describes the message topodata.CellsAlias.
 * Use `create(CellsAliasSchema)` to create a new message.
 */
export const CellsAliasSchema: GenMessage<CellsAlias, CellsAliasJson> = /*@__PURE__*/
  messageDesc(file_topodata, 13);

/**
 * @generated from message topodata.TopoConfig
 */
export type TopoConfig = Message<"topodata.TopoConfig"> & {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType: string;

  /**
   * @generated from field: string server = 2;
   */
  server: string;

  /**
   * @generated from field: string root = 3;
   */
  root: string;
};

/**
 * @generated from message topodata.TopoConfig
 */
export type TopoConfigJson = {
  /**
   * @generated from field: string topo_type = 1;
   */
  topoType?: string;

  /**
   * @generated from field: string server = 2;
   */
  server?: string;

  /**
   * @generated from field: string root = 3;
   */
  root?: string;
};

/**
 * Describes the message topodata.TopoConfig.
 * Use `create(TopoConfigSchema)` to create a new message.
 */
export const TopoConfigSchema: GenMessage<TopoConfig, TopoConfigJson> = /*@__PURE__*/
  messageDesc(file_topodata, 14);

/**
 * @generated from message topodata.ExternalVitessCluster
 */
export type ExternalVitessCluster = Message<"topodata.ExternalVitessCluster"> & {
  /**
   * @generated from field: topodata.TopoConfig topo_config = 1;
   */
  topoConfig?: TopoConfig;
};

/**
 * @generated from message topodata.ExternalVitessCluster
 */
export type ExternalVitessClusterJson = {
  /**
   * @generated from field: topodata.TopoConfig topo_config = 1;
   */
  topoConfig?: TopoConfigJson;
};

/**
 * Describes the message topodata.ExternalVitessCluster.
 * Use `create(ExternalVitessClusterSchema)` to create a new message.
 */
export const ExternalVitessClusterSchema: GenMessage<ExternalVitessCluster, ExternalVitessClusterJson> = /*@__PURE__*/
  messageDesc(file_topodata, 15);

/**
 * ExternalClusters
 *
 * @generated from message topodata.ExternalClusters
 */
export type ExternalClusters = Message<"topodata.ExternalClusters"> & {
  /**
   * @generated from field: repeated topodata.ExternalVitessCluster vitess_cluster = 1;
   */
  vitessCluster: ExternalVitessCluster[];
};

/**
 * ExternalClusters
 *
 * @generated from message topodata.ExternalClusters
 */
export type ExternalClustersJson = {
  /**
   * @generated from field: repeated topodata.ExternalVitessCluster vitess_cluster = 1;
   */
  vitessCluster?: ExternalVitessClusterJson[];
};

/**
 * Describes the message topodata.ExternalClusters.
 * Use `create(ExternalClustersSchema)` to create a new message.
 */
export const ExternalClustersSchema: GenMessage<ExternalClusters, ExternalClustersJson> = /*@__PURE__*/
  messageDesc(file_topodata, 16);

/**
 * KeyspaceType describes the type of the keyspace
 *
 * @generated from enum topodata.KeyspaceType
 */
export enum KeyspaceType {
  /**
   * NORMAL is the default value
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * SNAPSHOT is when we are creating a snapshot keyspace
   *
   * @generated from enum value: SNAPSHOT = 1;
   */
  SNAPSHOT = 1,
}

/**
 * KeyspaceType describes the type of the keyspace
 *
 * @generated from enum topodata.KeyspaceType
 */
export type KeyspaceTypeJson = "NORMAL" | "SNAPSHOT";

/**
 * Describes the enum topodata.KeyspaceType.
 */
export const KeyspaceTypeSchema: GenEnum<KeyspaceType, KeyspaceTypeJson> = /*@__PURE__*/
  enumDesc(file_topodata, 0);

/**
 * TabletType represents the type of a given tablet.
 *
 * @generated from enum topodata.TabletType
 */
export enum TabletType {
  /**
   * UNKNOWN is not a valid value.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
   *
   * @generated from enum value: PRIMARY = 1;
   */
  PRIMARY = 1,

  /**
   * DEPRECATED
   *
   * @generated from enum value: MASTER = 1;
   */
  MASTER = 1,

  /**
   * REPLICA replicates from primary. It is used to serve live traffic.
   * A REPLICA can be promoted to PRIMARY. A demoted PRIMARY will go to REPLICA.
   *
   * @generated from enum value: REPLICA = 2;
   */
  REPLICA = 2,

  /**
   * RDONLY (old name) / BATCH (new name) is used to serve traffic for
   * long-running jobs. It is a separate type from REPLICA so
   * long-running queries don't affect web-like traffic.
   *
   * @generated from enum value: RDONLY = 3;
   */
  RDONLY = 3,

  /**
   * @generated from enum value: BATCH = 3;
   */
  BATCH = 3,

  /**
   * SPARE is a type of servers that cannot serve queries, but is available
   * in case an extra server is needed.
   *
   * @generated from enum value: SPARE = 4;
   */
  SPARE = 4,

  /**
   * EXPERIMENTAL is like SPARE, except it can serve queries. This
   * type can be used for usages not planned by Vitess, like online
   * export to another storage engine.
   *
   * @generated from enum value: EXPERIMENTAL = 5;
   */
  EXPERIMENTAL = 5,

  /**
   * BACKUP is the type a server goes to when taking a backup. No queries
   * can be served in BACKUP mode.
   *
   * @generated from enum value: BACKUP = 6;
   */
  BACKUP = 6,

  /**
   * RESTORE is the type a server uses when restoring a backup, at
   * startup time.  No queries can be served in RESTORE mode.
   *
   * @generated from enum value: RESTORE = 7;
   */
  RESTORE = 7,

  /**
   * DRAINED is the type a server goes into when used by Vitess tools
   * to perform an offline action. It is a serving type (as
   * the tools processes may need to run queries), but it's not used
   * to route queries from Vitess users. In this state,
   * this tablet is dedicated to the process that uses it.
   *
   * @generated from enum value: DRAINED = 8;
   */
  DRAINED = 8,
}

/**
 * TabletType represents the type of a given tablet.
 *
 * @generated from enum topodata.TabletType
 */
export type TabletTypeJson = "UNKNOWN" | "PRIMARY" | "MASTER" | "REPLICA" | "RDONLY" | "BATCH" | "SPARE" | "EXPERIMENTAL" | "BACKUP" | "RESTORE" | "DRAINED";

/**
 * Describes the enum topodata.TabletType.
 */
export const TabletTypeSchema: GenEnum<TabletType, TabletTypeJson> = /*@__PURE__*/
  enumDesc(file_topodata, 1);

