// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtgateservice.proto" (package "vtgateservice", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// Service definition for vtgateservice.
// This is the main entry point to Vitess.
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Vitess } from "./vtgateservice";
import type { CloseSessionResponse } from "./vtgate";
import type { CloseSessionRequest } from "./vtgate";
import type { PrepareResponse } from "./vtgate";
import type { PrepareRequest } from "./vtgate";
import type { VStreamResponse } from "./vtgate";
import type { VStreamRequest } from "./vtgate";
import type { StreamExecuteResponse } from "./vtgate";
import type { StreamExecuteRequest } from "./vtgate";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { ExecuteBatchResponse } from "./vtgate";
import type { ExecuteBatchRequest } from "./vtgate";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ExecuteResponse } from "./vtgate";
import type { ExecuteRequest } from "./vtgate";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Vitess is the main service to access a Vitess cluster. It is the API that vtgate
 * exposes to serve all queries.
 *
 * @generated from protobuf service vtgateservice.Vitess
 */
export interface IVitessClient {
    /**
     * Execute tries to route the query to the right shard.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * API group: v3
     *
     * @generated from protobuf rpc: Execute(vtgate.ExecuteRequest) returns (vtgate.ExecuteResponse);
     */
    execute(input: ExecuteRequest, options?: RpcOptions): UnaryCall<ExecuteRequest, ExecuteResponse>;
    /**
     * ExecuteBatch tries to route the list of queries on the right shards.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * API group: v3
     *
     * @generated from protobuf rpc: ExecuteBatch(vtgate.ExecuteBatchRequest) returns (vtgate.ExecuteBatchResponse);
     */
    executeBatch(input: ExecuteBatchRequest, options?: RpcOptions): UnaryCall<ExecuteBatchRequest, ExecuteBatchResponse>;
    /**
     * StreamExecute executes a streaming query based on shards.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * Use this method if the query returns a large number of rows.
     * API group: v3
     *
     * @generated from protobuf rpc: StreamExecute(vtgate.StreamExecuteRequest) returns (stream vtgate.StreamExecuteResponse);
     */
    streamExecute(input: StreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<StreamExecuteRequest, StreamExecuteResponse>;
    /**
     * VStream streams binlog events from the requested sources.
     *
     * @generated from protobuf rpc: VStream(vtgate.VStreamRequest) returns (stream vtgate.VStreamResponse);
     */
    vStream(input: VStreamRequest, options?: RpcOptions): ServerStreamingCall<VStreamRequest, VStreamResponse>;
    /**
     * Prepare is used by the MySQL server plugin as part of supporting prepared statements.
     *
     * @generated from protobuf rpc: Prepare(vtgate.PrepareRequest) returns (vtgate.PrepareResponse);
     */
    prepare(input: PrepareRequest, options?: RpcOptions): UnaryCall<PrepareRequest, PrepareResponse>;
    /**
     * CloseSession closes the session, rolling back any implicit transactions.
     * This has the same effect as if a "rollback" statement was executed,
     * but does not affect the query statistics.
     *
     * @generated from protobuf rpc: CloseSession(vtgate.CloseSessionRequest) returns (vtgate.CloseSessionResponse);
     */
    closeSession(input: CloseSessionRequest, options?: RpcOptions): UnaryCall<CloseSessionRequest, CloseSessionResponse>;
}
/**
 * Vitess is the main service to access a Vitess cluster. It is the API that vtgate
 * exposes to serve all queries.
 *
 * @generated from protobuf service vtgateservice.Vitess
 */
export class VitessClient implements IVitessClient, ServiceInfo {
    typeName = Vitess.typeName;
    methods = Vitess.methods;
    options = Vitess.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Execute tries to route the query to the right shard.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * API group: v3
     *
     * @generated from protobuf rpc: Execute(vtgate.ExecuteRequest) returns (vtgate.ExecuteResponse);
     */
    execute(input: ExecuteRequest, options?: RpcOptions): UnaryCall<ExecuteRequest, ExecuteResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteRequest, ExecuteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteBatch tries to route the list of queries on the right shards.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * API group: v3
     *
     * @generated from protobuf rpc: ExecuteBatch(vtgate.ExecuteBatchRequest) returns (vtgate.ExecuteBatchResponse);
     */
    executeBatch(input: ExecuteBatchRequest, options?: RpcOptions): UnaryCall<ExecuteBatchRequest, ExecuteBatchResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteBatchRequest, ExecuteBatchResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StreamExecute executes a streaming query based on shards.
     * It depends on the query and bind variables to provide enough
     * information in conjunction with the vindexes to route the query.
     * Use this method if the query returns a large number of rows.
     * API group: v3
     *
     * @generated from protobuf rpc: StreamExecute(vtgate.StreamExecuteRequest) returns (stream vtgate.StreamExecuteResponse);
     */
    streamExecute(input: StreamExecuteRequest, options?: RpcOptions): ServerStreamingCall<StreamExecuteRequest, StreamExecuteResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<StreamExecuteRequest, StreamExecuteResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * VStream streams binlog events from the requested sources.
     *
     * @generated from protobuf rpc: VStream(vtgate.VStreamRequest) returns (stream vtgate.VStreamResponse);
     */
    vStream(input: VStreamRequest, options?: RpcOptions): ServerStreamingCall<VStreamRequest, VStreamResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<VStreamRequest, VStreamResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Prepare is used by the MySQL server plugin as part of supporting prepared statements.
     *
     * @generated from protobuf rpc: Prepare(vtgate.PrepareRequest) returns (vtgate.PrepareResponse);
     */
    prepare(input: PrepareRequest, options?: RpcOptions): UnaryCall<PrepareRequest, PrepareResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<PrepareRequest, PrepareResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CloseSession closes the session, rolling back any implicit transactions.
     * This has the same effect as if a "rollback" statement was executed,
     * but does not affect the query statistics.
     *
     * @generated from protobuf rpc: CloseSession(vtgate.CloseSessionRequest) returns (vtgate.CloseSessionResponse);
     */
    closeSession(input: CloseSessionRequest, options?: RpcOptions): UnaryCall<CloseSessionRequest, CloseSessionResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<CloseSessionRequest, CloseSessionResponse>("unary", this._transport, method, opt, input);
    }
}
