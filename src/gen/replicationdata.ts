// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "replicationdata.proto" (package "replicationdata", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file defines the replication related structures we use.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Status is the replication status for MySQL/MariaDB/File-based. Returned by a
 * flavor-specific command and parsed into a Position and fields.
 *
 * @generated from protobuf message replicationdata.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: string position = 1;
     */
    position: string;
    /**
     * @generated from protobuf field: uint32 replication_lag_seconds = 4;
     */
    replicationLagSeconds: number;
    /**
     * @generated from protobuf field: string source_host = 5;
     */
    sourceHost: string;
    /**
     * @generated from protobuf field: int32 source_port = 6;
     */
    sourcePort: number;
    /**
     * @generated from protobuf field: int32 connect_retry = 7;
     */
    connectRetry: number;
    /**
     * RelayLogPosition will be empty for flavors that do not support returning the full GTIDSet from the relay log, such as MariaDB.
     *
     * @generated from protobuf field: string relay_log_position = 8;
     */
    relayLogPosition: string;
    /**
     * @generated from protobuf field: string file_position = 9;
     */
    filePosition: string;
    /**
     * @generated from protobuf field: string relay_log_source_binlog_equivalent_position = 10;
     */
    relayLogSourceBinlogEquivalentPosition: string;
    /**
     * @generated from protobuf field: uint32 source_server_id = 11;
     */
    sourceServerId: number;
    /**
     * @generated from protobuf field: string source_uuid = 12;
     */
    sourceUuid: string;
    /**
     * @generated from protobuf field: int32 io_state = 13;
     */
    ioState: number;
    /**
     * @generated from protobuf field: string last_io_error = 14;
     */
    lastIoError: string;
    /**
     * @generated from protobuf field: int32 sql_state = 15;
     */
    sqlState: number;
    /**
     * @generated from protobuf field: string last_sql_error = 16;
     */
    lastSqlError: string;
    /**
     * @generated from protobuf field: string relay_log_file_position = 17;
     */
    relayLogFilePosition: string;
    /**
     * @generated from protobuf field: string source_user = 18;
     */
    sourceUser: string;
    /**
     * @generated from protobuf field: uint32 sql_delay = 19;
     */
    sqlDelay: number;
    /**
     * @generated from protobuf field: bool auto_position = 20;
     */
    autoPosition: boolean;
    /**
     * @generated from protobuf field: bool using_gtid = 21;
     */
    usingGtid: boolean;
    /**
     * @generated from protobuf field: bool has_replication_filters = 22;
     */
    hasReplicationFilters: boolean;
    /**
     * @generated from protobuf field: bool ssl_allowed = 23;
     */
    sslAllowed: boolean;
    /**
     * @generated from protobuf field: bool replication_lag_unknown = 24;
     */
    replicationLagUnknown: boolean;
}
/**
 * Configuration holds replication configuration information gathered from performance_schema and global variables.
 *
 * @generated from protobuf message replicationdata.Configuration
 */
export interface Configuration {
    /**
     * HeartbeatInterval controls the heartbeat interval that the primary sends to the replica
     *
     * @generated from protobuf field: double heartbeat_interval = 1;
     */
    heartbeatInterval: number;
    /**
     * ReplicaNetTimeout specifies the number of seconds to wait for more data or a heartbeat signal from the source before the replica considers the connection broken
     *
     * @generated from protobuf field: int32 replica_net_timeout = 2;
     */
    replicaNetTimeout: number;
}
/**
 * StopReplicationStatus represents the replication status before calling StopReplication, and the replication status collected immediately after
 * calling StopReplication.
 *
 * @generated from protobuf message replicationdata.StopReplicationStatus
 */
export interface StopReplicationStatus {
    /**
     * @generated from protobuf field: replicationdata.Status before = 1;
     */
    before?: Status;
    /**
     * @generated from protobuf field: replicationdata.Status after = 2;
     */
    after?: Status;
}
/**
 * PrimaryStatus is the replication status for a MySQL primary (returned by 'show binary log status').
 *
 * @generated from protobuf message replicationdata.PrimaryStatus
 */
export interface PrimaryStatus {
    /**
     * @generated from protobuf field: string position = 1;
     */
    position: string;
    /**
     * @generated from protobuf field: string file_position = 2;
     */
    filePosition: string;
    /**
     * @generated from protobuf field: string server_uuid = 3;
     */
    serverUuid: string;
}
/**
 * FullStatus contains the full status of MySQL including the replication information, semi-sync information, GTID information among others
 *
 * @generated from protobuf message replicationdata.FullStatus
 */
export interface FullStatus {
    /**
     * @generated from protobuf field: uint32 server_id = 1;
     */
    serverId: number;
    /**
     * @generated from protobuf field: string server_uuid = 2;
     */
    serverUuid: string;
    /**
     * @generated from protobuf field: replicationdata.Status replication_status = 3;
     */
    replicationStatus?: Status;
    /**
     * @generated from protobuf field: replicationdata.PrimaryStatus primary_status = 4;
     */
    primaryStatus?: PrimaryStatus;
    /**
     * @generated from protobuf field: string gtid_purged = 5;
     */
    gtidPurged: string;
    /**
     * @generated from protobuf field: string version = 6;
     */
    version: string;
    /**
     * @generated from protobuf field: string version_comment = 7;
     */
    versionComment: string;
    /**
     * @generated from protobuf field: bool read_only = 8;
     */
    readOnly: boolean;
    /**
     * @generated from protobuf field: string gtid_mode = 9;
     */
    gtidMode: string;
    /**
     * @generated from protobuf field: string binlog_format = 10;
     */
    binlogFormat: string;
    /**
     * @generated from protobuf field: string binlog_row_image = 11;
     */
    binlogRowImage: string;
    /**
     * @generated from protobuf field: bool log_bin_enabled = 12;
     */
    logBinEnabled: boolean;
    /**
     * @generated from protobuf field: bool log_replica_updates = 13;
     */
    logReplicaUpdates: boolean;
    /**
     * @generated from protobuf field: bool semi_sync_primary_enabled = 14;
     */
    semiSyncPrimaryEnabled: boolean;
    /**
     * @generated from protobuf field: bool semi_sync_replica_enabled = 15;
     */
    semiSyncReplicaEnabled: boolean;
    /**
     * @generated from protobuf field: bool semi_sync_primary_status = 16;
     */
    semiSyncPrimaryStatus: boolean;
    /**
     * @generated from protobuf field: bool semi_sync_replica_status = 17;
     */
    semiSyncReplicaStatus: boolean;
    /**
     * @generated from protobuf field: uint32 semi_sync_primary_clients = 18;
     */
    semiSyncPrimaryClients: number;
    /**
     * @generated from protobuf field: uint64 semi_sync_primary_timeout = 19;
     */
    semiSyncPrimaryTimeout: bigint;
    /**
     * @generated from protobuf field: uint32 semi_sync_wait_for_replica_count = 20;
     */
    semiSyncWaitForReplicaCount: number;
    /**
     * @generated from protobuf field: bool super_read_only = 21;
     */
    superReadOnly: boolean;
    /**
     * @generated from protobuf field: replicationdata.Configuration replication_configuration = 22;
     */
    replicationConfiguration?: Configuration;
}
/**
 * StopReplicationMode is used to provide controls over how replication is stopped.
 *
 * @generated from protobuf enum replicationdata.StopReplicationMode
 */
export enum StopReplicationMode {
    /**
     * @generated from protobuf enum value: IOANDSQLTHREAD = 0;
     */
    IOANDSQLTHREAD = 0,
    /**
     * @generated from protobuf enum value: IOTHREADONLY = 1;
     */
    IOTHREADONLY = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("replicationdata.Status", [
            { no: 1, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "replication_lag_seconds", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "source_host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "source_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "connect_retry", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "relay_log_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "file_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "relay_log_source_binlog_equivalent_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "source_server_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "source_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "io_state", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "last_io_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "sql_state", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "last_sql_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "relay_log_file_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "source_user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "sql_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "auto_position", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "using_gtid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "has_replication_filters", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "ssl_allowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "replication_lag_unknown", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = "";
        message.replicationLagSeconds = 0;
        message.sourceHost = "";
        message.sourcePort = 0;
        message.connectRetry = 0;
        message.relayLogPosition = "";
        message.filePosition = "";
        message.relayLogSourceBinlogEquivalentPosition = "";
        message.sourceServerId = 0;
        message.sourceUuid = "";
        message.ioState = 0;
        message.lastIoError = "";
        message.sqlState = 0;
        message.lastSqlError = "";
        message.relayLogFilePosition = "";
        message.sourceUser = "";
        message.sqlDelay = 0;
        message.autoPosition = false;
        message.usingGtid = false;
        message.hasReplicationFilters = false;
        message.sslAllowed = false;
        message.replicationLagUnknown = false;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position */ 1:
                    message.position = reader.string();
                    break;
                case /* uint32 replication_lag_seconds */ 4:
                    message.replicationLagSeconds = reader.uint32();
                    break;
                case /* string source_host */ 5:
                    message.sourceHost = reader.string();
                    break;
                case /* int32 source_port */ 6:
                    message.sourcePort = reader.int32();
                    break;
                case /* int32 connect_retry */ 7:
                    message.connectRetry = reader.int32();
                    break;
                case /* string relay_log_position */ 8:
                    message.relayLogPosition = reader.string();
                    break;
                case /* string file_position */ 9:
                    message.filePosition = reader.string();
                    break;
                case /* string relay_log_source_binlog_equivalent_position */ 10:
                    message.relayLogSourceBinlogEquivalentPosition = reader.string();
                    break;
                case /* uint32 source_server_id */ 11:
                    message.sourceServerId = reader.uint32();
                    break;
                case /* string source_uuid */ 12:
                    message.sourceUuid = reader.string();
                    break;
                case /* int32 io_state */ 13:
                    message.ioState = reader.int32();
                    break;
                case /* string last_io_error */ 14:
                    message.lastIoError = reader.string();
                    break;
                case /* int32 sql_state */ 15:
                    message.sqlState = reader.int32();
                    break;
                case /* string last_sql_error */ 16:
                    message.lastSqlError = reader.string();
                    break;
                case /* string relay_log_file_position */ 17:
                    message.relayLogFilePosition = reader.string();
                    break;
                case /* string source_user */ 18:
                    message.sourceUser = reader.string();
                    break;
                case /* uint32 sql_delay */ 19:
                    message.sqlDelay = reader.uint32();
                    break;
                case /* bool auto_position */ 20:
                    message.autoPosition = reader.bool();
                    break;
                case /* bool using_gtid */ 21:
                    message.usingGtid = reader.bool();
                    break;
                case /* bool has_replication_filters */ 22:
                    message.hasReplicationFilters = reader.bool();
                    break;
                case /* bool ssl_allowed */ 23:
                    message.sslAllowed = reader.bool();
                    break;
                case /* bool replication_lag_unknown */ 24:
                    message.replicationLagUnknown = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position = 1; */
        if (message.position !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.position);
        /* uint32 replication_lag_seconds = 4; */
        if (message.replicationLagSeconds !== 0)
            writer.tag(4, WireType.Varint).uint32(message.replicationLagSeconds);
        /* string source_host = 5; */
        if (message.sourceHost !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sourceHost);
        /* int32 source_port = 6; */
        if (message.sourcePort !== 0)
            writer.tag(6, WireType.Varint).int32(message.sourcePort);
        /* int32 connect_retry = 7; */
        if (message.connectRetry !== 0)
            writer.tag(7, WireType.Varint).int32(message.connectRetry);
        /* string relay_log_position = 8; */
        if (message.relayLogPosition !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.relayLogPosition);
        /* string file_position = 9; */
        if (message.filePosition !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.filePosition);
        /* string relay_log_source_binlog_equivalent_position = 10; */
        if (message.relayLogSourceBinlogEquivalentPosition !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.relayLogSourceBinlogEquivalentPosition);
        /* uint32 source_server_id = 11; */
        if (message.sourceServerId !== 0)
            writer.tag(11, WireType.Varint).uint32(message.sourceServerId);
        /* string source_uuid = 12; */
        if (message.sourceUuid !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.sourceUuid);
        /* int32 io_state = 13; */
        if (message.ioState !== 0)
            writer.tag(13, WireType.Varint).int32(message.ioState);
        /* string last_io_error = 14; */
        if (message.lastIoError !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.lastIoError);
        /* int32 sql_state = 15; */
        if (message.sqlState !== 0)
            writer.tag(15, WireType.Varint).int32(message.sqlState);
        /* string last_sql_error = 16; */
        if (message.lastSqlError !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.lastSqlError);
        /* string relay_log_file_position = 17; */
        if (message.relayLogFilePosition !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.relayLogFilePosition);
        /* string source_user = 18; */
        if (message.sourceUser !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.sourceUser);
        /* uint32 sql_delay = 19; */
        if (message.sqlDelay !== 0)
            writer.tag(19, WireType.Varint).uint32(message.sqlDelay);
        /* bool auto_position = 20; */
        if (message.autoPosition !== false)
            writer.tag(20, WireType.Varint).bool(message.autoPosition);
        /* bool using_gtid = 21; */
        if (message.usingGtid !== false)
            writer.tag(21, WireType.Varint).bool(message.usingGtid);
        /* bool has_replication_filters = 22; */
        if (message.hasReplicationFilters !== false)
            writer.tag(22, WireType.Varint).bool(message.hasReplicationFilters);
        /* bool ssl_allowed = 23; */
        if (message.sslAllowed !== false)
            writer.tag(23, WireType.Varint).bool(message.sslAllowed);
        /* bool replication_lag_unknown = 24; */
        if (message.replicationLagUnknown !== false)
            writer.tag(24, WireType.Varint).bool(message.replicationLagUnknown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message replicationdata.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Configuration$Type extends MessageType<Configuration> {
    constructor() {
        super("replicationdata.Configuration", [
            { no: 1, name: "heartbeat_interval", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "replica_net_timeout", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Configuration>): Configuration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.heartbeatInterval = 0;
        message.replicaNetTimeout = 0;
        if (value !== undefined)
            reflectionMergePartial<Configuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Configuration): Configuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double heartbeat_interval */ 1:
                    message.heartbeatInterval = reader.double();
                    break;
                case /* int32 replica_net_timeout */ 2:
                    message.replicaNetTimeout = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Configuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double heartbeat_interval = 1; */
        if (message.heartbeatInterval !== 0)
            writer.tag(1, WireType.Bit64).double(message.heartbeatInterval);
        /* int32 replica_net_timeout = 2; */
        if (message.replicaNetTimeout !== 0)
            writer.tag(2, WireType.Varint).int32(message.replicaNetTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message replicationdata.Configuration
 */
export const Configuration = new Configuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopReplicationStatus$Type extends MessageType<StopReplicationStatus> {
    constructor() {
        super("replicationdata.StopReplicationStatus", [
            { no: 1, name: "before", kind: "message", T: () => Status },
            { no: 2, name: "after", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StopReplicationStatus>): StopReplicationStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopReplicationStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopReplicationStatus): StopReplicationStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* replicationdata.Status before */ 1:
                    message.before = Status.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* replicationdata.Status after */ 2:
                    message.after = Status.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopReplicationStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* replicationdata.Status before = 1; */
        if (message.before)
            Status.internalBinaryWrite(message.before, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* replicationdata.Status after = 2; */
        if (message.after)
            Status.internalBinaryWrite(message.after, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message replicationdata.StopReplicationStatus
 */
export const StopReplicationStatus = new StopReplicationStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrimaryStatus$Type extends MessageType<PrimaryStatus> {
    constructor() {
        super("replicationdata.PrimaryStatus", [
            { no: 1, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "server_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrimaryStatus>): PrimaryStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = "";
        message.filePosition = "";
        message.serverUuid = "";
        if (value !== undefined)
            reflectionMergePartial<PrimaryStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrimaryStatus): PrimaryStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position */ 1:
                    message.position = reader.string();
                    break;
                case /* string file_position */ 2:
                    message.filePosition = reader.string();
                    break;
                case /* string server_uuid */ 3:
                    message.serverUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrimaryStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position = 1; */
        if (message.position !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.position);
        /* string file_position = 2; */
        if (message.filePosition !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filePosition);
        /* string server_uuid = 3; */
        if (message.serverUuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serverUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message replicationdata.PrimaryStatus
 */
export const PrimaryStatus = new PrimaryStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FullStatus$Type extends MessageType<FullStatus> {
    constructor() {
        super("replicationdata.FullStatus", [
            { no: 1, name: "server_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "server_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "replication_status", kind: "message", T: () => Status },
            { no: 4, name: "primary_status", kind: "message", T: () => PrimaryStatus },
            { no: 5, name: "gtid_purged", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "version_comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "gtid_mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "binlog_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "binlog_row_image", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "log_bin_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "log_replica_updates", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "semi_sync_primary_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "semi_sync_replica_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "semi_sync_primary_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "semi_sync_replica_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "semi_sync_primary_clients", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "semi_sync_primary_timeout", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "semi_sync_wait_for_replica_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 21, name: "super_read_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "replication_configuration", kind: "message", T: () => Configuration }
        ]);
    }
    create(value?: PartialMessage<FullStatus>): FullStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverId = 0;
        message.serverUuid = "";
        message.gtidPurged = "";
        message.version = "";
        message.versionComment = "";
        message.readOnly = false;
        message.gtidMode = "";
        message.binlogFormat = "";
        message.binlogRowImage = "";
        message.logBinEnabled = false;
        message.logReplicaUpdates = false;
        message.semiSyncPrimaryEnabled = false;
        message.semiSyncReplicaEnabled = false;
        message.semiSyncPrimaryStatus = false;
        message.semiSyncReplicaStatus = false;
        message.semiSyncPrimaryClients = 0;
        message.semiSyncPrimaryTimeout = 0n;
        message.semiSyncWaitForReplicaCount = 0;
        message.superReadOnly = false;
        if (value !== undefined)
            reflectionMergePartial<FullStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FullStatus): FullStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 server_id */ 1:
                    message.serverId = reader.uint32();
                    break;
                case /* string server_uuid */ 2:
                    message.serverUuid = reader.string();
                    break;
                case /* replicationdata.Status replication_status */ 3:
                    message.replicationStatus = Status.internalBinaryRead(reader, reader.uint32(), options, message.replicationStatus);
                    break;
                case /* replicationdata.PrimaryStatus primary_status */ 4:
                    message.primaryStatus = PrimaryStatus.internalBinaryRead(reader, reader.uint32(), options, message.primaryStatus);
                    break;
                case /* string gtid_purged */ 5:
                    message.gtidPurged = reader.string();
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* string version_comment */ 7:
                    message.versionComment = reader.string();
                    break;
                case /* bool read_only */ 8:
                    message.readOnly = reader.bool();
                    break;
                case /* string gtid_mode */ 9:
                    message.gtidMode = reader.string();
                    break;
                case /* string binlog_format */ 10:
                    message.binlogFormat = reader.string();
                    break;
                case /* string binlog_row_image */ 11:
                    message.binlogRowImage = reader.string();
                    break;
                case /* bool log_bin_enabled */ 12:
                    message.logBinEnabled = reader.bool();
                    break;
                case /* bool log_replica_updates */ 13:
                    message.logReplicaUpdates = reader.bool();
                    break;
                case /* bool semi_sync_primary_enabled */ 14:
                    message.semiSyncPrimaryEnabled = reader.bool();
                    break;
                case /* bool semi_sync_replica_enabled */ 15:
                    message.semiSyncReplicaEnabled = reader.bool();
                    break;
                case /* bool semi_sync_primary_status */ 16:
                    message.semiSyncPrimaryStatus = reader.bool();
                    break;
                case /* bool semi_sync_replica_status */ 17:
                    message.semiSyncReplicaStatus = reader.bool();
                    break;
                case /* uint32 semi_sync_primary_clients */ 18:
                    message.semiSyncPrimaryClients = reader.uint32();
                    break;
                case /* uint64 semi_sync_primary_timeout */ 19:
                    message.semiSyncPrimaryTimeout = reader.uint64().toBigInt();
                    break;
                case /* uint32 semi_sync_wait_for_replica_count */ 20:
                    message.semiSyncWaitForReplicaCount = reader.uint32();
                    break;
                case /* bool super_read_only */ 21:
                    message.superReadOnly = reader.bool();
                    break;
                case /* replicationdata.Configuration replication_configuration */ 22:
                    message.replicationConfiguration = Configuration.internalBinaryRead(reader, reader.uint32(), options, message.replicationConfiguration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FullStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 server_id = 1; */
        if (message.serverId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.serverId);
        /* string server_uuid = 2; */
        if (message.serverUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serverUuid);
        /* replicationdata.Status replication_status = 3; */
        if (message.replicationStatus)
            Status.internalBinaryWrite(message.replicationStatus, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* replicationdata.PrimaryStatus primary_status = 4; */
        if (message.primaryStatus)
            PrimaryStatus.internalBinaryWrite(message.primaryStatus, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string gtid_purged = 5; */
        if (message.gtidPurged !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.gtidPurged);
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* string version_comment = 7; */
        if (message.versionComment !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.versionComment);
        /* bool read_only = 8; */
        if (message.readOnly !== false)
            writer.tag(8, WireType.Varint).bool(message.readOnly);
        /* string gtid_mode = 9; */
        if (message.gtidMode !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.gtidMode);
        /* string binlog_format = 10; */
        if (message.binlogFormat !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.binlogFormat);
        /* string binlog_row_image = 11; */
        if (message.binlogRowImage !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.binlogRowImage);
        /* bool log_bin_enabled = 12; */
        if (message.logBinEnabled !== false)
            writer.tag(12, WireType.Varint).bool(message.logBinEnabled);
        /* bool log_replica_updates = 13; */
        if (message.logReplicaUpdates !== false)
            writer.tag(13, WireType.Varint).bool(message.logReplicaUpdates);
        /* bool semi_sync_primary_enabled = 14; */
        if (message.semiSyncPrimaryEnabled !== false)
            writer.tag(14, WireType.Varint).bool(message.semiSyncPrimaryEnabled);
        /* bool semi_sync_replica_enabled = 15; */
        if (message.semiSyncReplicaEnabled !== false)
            writer.tag(15, WireType.Varint).bool(message.semiSyncReplicaEnabled);
        /* bool semi_sync_primary_status = 16; */
        if (message.semiSyncPrimaryStatus !== false)
            writer.tag(16, WireType.Varint).bool(message.semiSyncPrimaryStatus);
        /* bool semi_sync_replica_status = 17; */
        if (message.semiSyncReplicaStatus !== false)
            writer.tag(17, WireType.Varint).bool(message.semiSyncReplicaStatus);
        /* uint32 semi_sync_primary_clients = 18; */
        if (message.semiSyncPrimaryClients !== 0)
            writer.tag(18, WireType.Varint).uint32(message.semiSyncPrimaryClients);
        /* uint64 semi_sync_primary_timeout = 19; */
        if (message.semiSyncPrimaryTimeout !== 0n)
            writer.tag(19, WireType.Varint).uint64(message.semiSyncPrimaryTimeout);
        /* uint32 semi_sync_wait_for_replica_count = 20; */
        if (message.semiSyncWaitForReplicaCount !== 0)
            writer.tag(20, WireType.Varint).uint32(message.semiSyncWaitForReplicaCount);
        /* bool super_read_only = 21; */
        if (message.superReadOnly !== false)
            writer.tag(21, WireType.Varint).bool(message.superReadOnly);
        /* replicationdata.Configuration replication_configuration = 22; */
        if (message.replicationConfiguration)
            Configuration.internalBinaryWrite(message.replicationConfiguration, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message replicationdata.FullStatus
 */
export const FullStatus = new FullStatus$Type();
