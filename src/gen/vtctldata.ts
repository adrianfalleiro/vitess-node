// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtctldata.proto" (package "vtctldata", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This package contains the data structures for a service allowing
// you to use vtctld as a server for vt commands.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MirrorRules } from "./vschema";
import { UpdateVReplicationWorkflowRequest } from "./tabletmanagerdata";
import { VDiffResponse } from "./tabletmanagerdata";
import { KeyRange } from "./topodata";
import { Status } from "./replicationdata";
import { ShardReplicationError } from "./topodata";
import { Target } from "./query";
import { TransactionMetadata } from "./query";
import { GetThrottlerStatusResponse as GetThrottlerStatusResponse$ } from "./tabletmanagerdata";
import { SrvVSchema } from "./vschema";
import { ThrottledAppRule } from "./topodata";
import { SrvKeyspace } from "./topodata";
import { ShardReplication } from "./topodata";
import { SchemaDefinition } from "./tabletmanagerdata";
import { Permissions } from "./tabletmanagerdata";
import { FullStatus } from "./replicationdata";
import { CellsAlias } from "./topodata";
import { BackupInfo } from "./mysqlctl";
import { ExecuteHookResponse as ExecuteHookResponse$ } from "./tabletmanagerdata";
import { ExecuteHookRequest as ExecuteHookRequest$ } from "./tabletmanagerdata";
import { QueryResult } from "./query";
import { KeyspaceType } from "./topodata";
import { CheckThrottlerResponse as CheckThrottlerResponse$ } from "./tabletmanagerdata";
import { Tablet } from "./topodata";
import { Keyspace as Keyspace$2 } from "./vschema";
import { CallerID } from "./vtrpc";
import { ShardRoutingRules } from "./vschema";
import { RoutingRules } from "./vschema";
import { KeyspaceRoutingRules } from "./vschema";
import { CellInfo } from "./topodata";
import { TabletType } from "./topodata";
import { BinlogSource } from "./binlogdata";
import { Shard_TabletControl } from "./topodata";
import { Shard as Shard$ } from "./topodata";
import { Duration } from "./vttime";
import { TabletAlias } from "./topodata";
import { Time } from "./vttime";
import { Keyspace as Keyspace$ } from "./topodata";
import { TabletSelectionPreference } from "./tabletmanagerdata";
import { Event } from "./logutil";
/**
 * ExecuteVtctlCommandRequest is the payload for ExecuteVtctlCommand.
 * timeouts are in nanoseconds.
 *
 * @generated from protobuf message vtctldata.ExecuteVtctlCommandRequest
 */
export interface ExecuteVtctlCommandRequest {
    /**
     * @generated from protobuf field: repeated string args = 1;
     */
    args: string[];
    /**
     * @generated from protobuf field: int64 action_timeout = 2;
     */
    actionTimeout: bigint;
}
/**
 * ExecuteVtctlCommandResponse is streamed back by ExecuteVtctlCommand.
 *
 * @generated from protobuf message vtctldata.ExecuteVtctlCommandResponse
 */
export interface ExecuteVtctlCommandResponse {
    /**
     * @generated from protobuf field: logutil.Event event = 1;
     */
    event?: Event;
}
/**
 * TableMaterializeSttings contains the settings for one table.
 *
 * @generated from protobuf message vtctldata.TableMaterializeSettings
 */
export interface TableMaterializeSettings {
    /**
     * @generated from protobuf field: string target_table = 1;
     */
    targetTable: string;
    /**
     * source_expression is a select statement.
     *
     * @generated from protobuf field: string source_expression = 2;
     */
    sourceExpression: string;
    /**
     * create_ddl contains the DDL to create the target table.
     * If empty, the target table must already exist.
     * if "copy", the target table DDL is the same as the source table.
     *
     * @generated from protobuf field: string create_ddl = 3;
     */
    createDdl: string;
}
/**
 * MaterializeSettings contains the settings for the Materialize command.
 *
 * @generated from protobuf message vtctldata.MaterializeSettings
 */
export interface MaterializeSettings {
    /**
     * workflow is the name of the workflow.
     *
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string source_keyspace = 2;
     */
    sourceKeyspace: string;
    /**
     * @generated from protobuf field: string target_keyspace = 3;
     */
    targetKeyspace: string;
    /**
     * stop_after_copy specifies if vreplication should be stopped after copying.
     *
     * @generated from protobuf field: bool stop_after_copy = 4;
     */
    stopAfterCopy: boolean;
    /**
     * @generated from protobuf field: repeated vtctldata.TableMaterializeSettings table_settings = 5;
     */
    tableSettings: TableMaterializeSettings[];
    /**
     * optional parameters.
     *
     * @generated from protobuf field: string cell = 6;
     */
    cell: string;
    /**
     * @generated from protobuf field: string tablet_types = 7;
     */
    tabletTypes: string;
    /**
     * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
     * it is of the type <cluster_type.cluster_name>
     *
     * @generated from protobuf field: string external_cluster = 8;
     */
    externalCluster: string;
    /**
     * MaterializationIntent is used to identify the reason behind the materialization workflow: eg. MoveTables, CreateLookupVindex
     *
     * @generated from protobuf field: vtctldata.MaterializationIntent materialization_intent = 9;
     */
    materializationIntent: MaterializationIntent;
    /**
     * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTable
     *
     * @generated from protobuf field: string source_time_zone = 10;
     */
    sourceTimeZone: string;
    /**
     * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
     * and to the SourceTimeZone in reverse workflows
     *
     * @generated from protobuf field: string target_time_zone = 11;
     */
    targetTimeZone: string;
    /**
     * @generated from protobuf field: repeated string source_shards = 12;
     */
    sourceShards: string[];
    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from protobuf field: string on_ddl = 13;
     */
    onDdl: string;
    /**
     * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
     *
     * @generated from protobuf field: bool defer_secondary_keys = 14;
     */
    deferSecondaryKeys: boolean;
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 15;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * @generated from protobuf field: bool atomic_copy = 16;
     */
    atomicCopy: boolean;
    /**
     * @generated from protobuf field: vtctldata.WorkflowOptions workflow_options = 17;
     */
    workflowOptions?: WorkflowOptions;
    /**
     * ReferenceTables is set to a csv list of tables, if the materialization is for reference tables.
     *
     * @generated from protobuf field: repeated string reference_tables = 18;
     */
    referenceTables: string[];
}
// Data types for VtctldServer 

/**
 * @generated from protobuf message vtctldata.Keyspace
 */
export interface Keyspace {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.Keyspace keyspace = 2;
     */
    keyspace?: Keyspace$;
}
/**
 * SchemaMigration represents a row in the schema_migrations sidecar table.
 *
 * @generated from protobuf message vtctldata.SchemaMigration
 */
export interface SchemaMigration {
    /**
     * @generated from protobuf field: string uuid = 1;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: string schema = 4;
     */
    schema: string;
    /**
     * @generated from protobuf field: string table = 5;
     */
    table: string;
    /**
     * @generated from protobuf field: string migration_statement = 6;
     */
    migrationStatement: string;
    /**
     * @generated from protobuf field: vtctldata.SchemaMigration.Strategy strategy = 7;
     */
    strategy: SchemaMigration_Strategy;
    /**
     * @generated from protobuf field: string options = 8;
     */
    options: string;
    /**
     * @generated from protobuf field: vttime.Time added_at = 9;
     */
    addedAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time requested_at = 10;
     */
    requestedAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time ready_at = 11;
     */
    readyAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time started_at = 12;
     */
    startedAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time liveness_timestamp = 13;
     */
    livenessTimestamp?: Time;
    /**
     * @generated from protobuf field: vttime.Time completed_at = 14;
     */
    completedAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time cleaned_up_at = 15;
     */
    cleanedUpAt?: Time;
    /**
     * @generated from protobuf field: vtctldata.SchemaMigration.Status status = 16;
     */
    status: SchemaMigration_Status;
    /**
     * @generated from protobuf field: string log_path = 17;
     */
    logPath: string;
    /**
     * @generated from protobuf field: string artifacts = 18;
     */
    artifacts: string;
    /**
     * @generated from protobuf field: uint64 retries = 19;
     */
    retries: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 20;
     */
    tablet?: TabletAlias;
    /**
     * @generated from protobuf field: bool tablet_failure = 21;
     */
    tabletFailure: boolean;
    /**
     * @generated from protobuf field: float progress = 22;
     */
    progress: number;
    /**
     * @generated from protobuf field: string migration_context = 23;
     */
    migrationContext: string;
    /**
     * @generated from protobuf field: string ddl_action = 24;
     */
    ddlAction: string;
    /**
     * @generated from protobuf field: string message = 25;
     */
    message: string;
    /**
     * @generated from protobuf field: int64 eta_seconds = 26;
     */
    etaSeconds: bigint;
    /**
     * @generated from protobuf field: uint64 rows_copied = 27;
     */
    rowsCopied: bigint;
    /**
     * @generated from protobuf field: int64 table_rows = 28;
     */
    tableRows: bigint;
    /**
     * @generated from protobuf field: uint32 added_unique_keys = 29;
     */
    addedUniqueKeys: number;
    /**
     * @generated from protobuf field: uint32 removed_unique_keys = 30;
     */
    removedUniqueKeys: number;
    /**
     * @generated from protobuf field: string log_file = 31;
     */
    logFile: string;
    /**
     * @generated from protobuf field: vttime.Duration artifact_retention = 32;
     */
    artifactRetention?: Duration;
    /**
     * @generated from protobuf field: bool postpone_completion = 33;
     */
    postponeCompletion: boolean;
    /**
     * @generated from protobuf field: string removed_unique_key_names = 34;
     */
    removedUniqueKeyNames: string;
    /**
     * @generated from protobuf field: string dropped_no_default_column_names = 35;
     */
    droppedNoDefaultColumnNames: string;
    /**
     * @generated from protobuf field: string expanded_column_names = 36;
     */
    expandedColumnNames: string;
    /**
     * @generated from protobuf field: string revertible_notes = 37;
     */
    revertibleNotes: string;
    /**
     * @generated from protobuf field: bool allow_concurrent = 38;
     */
    allowConcurrent: boolean;
    /**
     * @generated from protobuf field: string reverted_uuid = 39;
     */
    revertedUuid: string;
    /**
     * @generated from protobuf field: bool is_view = 40;
     */
    isView: boolean;
    /**
     * @generated from protobuf field: bool ready_to_complete = 41;
     */
    readyToComplete: boolean;
    /**
     * @generated from protobuf field: int64 vitess_liveness_indicator = 42;
     */
    vitessLivenessIndicator: bigint;
    /**
     * @generated from protobuf field: float user_throttle_ratio = 43;
     */
    userThrottleRatio: number;
    /**
     * @generated from protobuf field: string special_plan = 44;
     */
    specialPlan: string;
    /**
     * @generated from protobuf field: vttime.Time last_throttled_at = 45;
     */
    lastThrottledAt?: Time;
    /**
     * @generated from protobuf field: string component_throttled = 46;
     */
    componentThrottled: string;
    /**
     * @generated from protobuf field: vttime.Time cancelled_at = 47;
     */
    cancelledAt?: Time;
    /**
     * @generated from protobuf field: bool postpone_launch = 48;
     */
    postponeLaunch: boolean;
    /**
     * @generated from protobuf field: string stage = 49;
     */
    stage: string; // enum?
    /**
     * @generated from protobuf field: uint32 cutover_attempts = 50;
     */
    cutoverAttempts: number;
    /**
     * @generated from protobuf field: bool is_immediate_operation = 51;
     */
    isImmediateOperation: boolean;
    /**
     * @generated from protobuf field: vttime.Time reviewed_at = 52;
     */
    reviewedAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time ready_to_complete_at = 53;
     */
    readyToCompleteAt?: Time;
    /**
     * @generated from protobuf field: string removed_foreign_key_names = 54;
     */
    removedForeignKeyNames: string;
}
/**
 * @generated from protobuf enum vtctldata.SchemaMigration.Strategy
 */
export enum SchemaMigration_Strategy {
    /**
     * SchemaMigration_VITESS uses vreplication to run the schema migration. It is
     * the default strategy for OnlineDDL requests.
     *
     * SchemaMigration_VITESS was also formerly called "ONLINE".
     *
     * @generated from protobuf enum value: VITESS = 0;
     */
    VITESS = 0,
    /**
     * SchemaMigration_VITESS uses vreplication to run the schema migration. It is
     * the default strategy for OnlineDDL requests.
     *
     * SchemaMigration_VITESS was also formerly called "ONLINE".
     *
     * @generated from protobuf enum value: VITESS = 0;
     */
    ONLINE = 0,
    /**
     * @generated from protobuf enum value: GHOST = 1;
     */
    GHOST = 1,
    /**
     * @generated from protobuf enum value: PTOSC = 2;
     */
    PTOSC = 2,
    /**
     * SchemaMigration_DIRECT runs the migration directly against MySQL (e.g. `ALTER TABLE ...`),
     * meaning it is not actually an "online" DDL migration.
     *
     * @generated from protobuf enum value: DIRECT = 3;
     */
    DIRECT = 3,
    /**
     * SchemaMigration_MYSQL is a managed migration (queued and executed by the
     * scheduler) but runs through a MySQL `ALTER TABLE`.
     *
     * @generated from protobuf enum value: MYSQL = 4;
     */
    MYSQL = 4
}
/**
 * @generated from protobuf enum vtctldata.SchemaMigration.Status
 */
export enum SchemaMigration_Status {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: REQUESTED = 1;
     */
    REQUESTED = 1,
    /**
     * @generated from protobuf enum value: CANCELLED = 2;
     */
    CANCELLED = 2,
    /**
     * @generated from protobuf enum value: QUEUED = 3;
     */
    QUEUED = 3,
    /**
     * @generated from protobuf enum value: READY = 4;
     */
    READY = 4,
    /**
     * @generated from protobuf enum value: RUNNING = 5;
     */
    RUNNING = 5,
    /**
     * @generated from protobuf enum value: COMPLETE = 6;
     */
    COMPLETE = 6,
    /**
     * @generated from protobuf enum value: FAILED = 7;
     */
    FAILED = 7
}
/**
 * @generated from protobuf message vtctldata.Shard
 */
export interface Shard {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.Shard shard = 3;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtctldata.WorkflowOptions
 */
export interface WorkflowOptions {
    /**
     * @generated from protobuf field: string tenant_id = 1;
     */
    tenantId: string;
    /**
     * Remove auto_increment clauses on tables when moving them to a sharded
     * keyspace and optionally replace them with vschema AutoIncrement
     * definitions.
     *
     * @generated from protobuf field: vtctldata.ShardedAutoIncrementHandling sharded_auto_increment_handling = 2;
     */
    shardedAutoIncrementHandling: ShardedAutoIncrementHandling;
    /**
     * Shards on which vreplication streams in the target keyspace are created for this workflow and to which the data
     * from the source will be vreplicated.
     *
     * @generated from protobuf field: repeated string shards = 3;
     */
    shards: string[];
    /**
     * @generated from protobuf field: map<string, string> config = 4;
     */
    config: {
        [key: string]: string;
    };
    /**
     * Where to create any related schema and vschema objects such as
     * sequence tables.
     *
     * @generated from protobuf field: string global_keyspace = 5;
     */
    globalKeyspace: string;
}
/**
 * TODO: comment the hell out of this.
 *
 * @generated from protobuf message vtctldata.Workflow
 */
export interface Workflow {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: vtctldata.Workflow.ReplicationLocation source = 2;
     */
    source?: Workflow_ReplicationLocation;
    /**
     * @generated from protobuf field: vtctldata.Workflow.ReplicationLocation target = 3;
     */
    target?: Workflow_ReplicationLocation;
    /**
     * This represents how long it's been since we processed any event in the
     * stream.
     *
     * @generated from protobuf field: int64 max_v_replication_lag = 4;
     */
    maxVReplicationLag: bigint;
    /**
     * @generated from protobuf field: map<string, vtctldata.Workflow.ShardStream> shard_streams = 5;
     */
    shardStreams: {
        [key: string]: Workflow_ShardStream;
    };
    /**
     * @generated from protobuf field: string workflow_type = 6;
     */
    workflowType: string;
    /**
     * @generated from protobuf field: string workflow_sub_type = 7;
     */
    workflowSubType: string;
    /**
     * This represents the lag across all shards, between the current time and
     * the timestamp of the last transaction OR heartbeat timestamp (if there
     * have been no writes to replicate from the source).
     *
     * @generated from protobuf field: int64 max_v_replication_transaction_lag = 8;
     */
    maxVReplicationTransactionLag: bigint;
    /**
     * This specifies whether to defer the creation of secondary keys.
     *
     * @generated from protobuf field: bool defer_secondary_keys = 9;
     */
    deferSecondaryKeys: boolean;
    /**
     * These are additional (optional) settings for vreplication workflows. Previously we used to add it to the
     * binlogdata.BinlogSource proto object. More details in go/vt/sidecardb/schema/vreplication.sql.
     *
     * @generated from protobuf field: vtctldata.WorkflowOptions options = 10;
     */
    options?: WorkflowOptions;
}
/**
 * @generated from protobuf message vtctldata.Workflow.ReplicationLocation
 */
export interface Workflow_ReplicationLocation {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string shards = 2;
     */
    shards: string[];
}
/**
 * @generated from protobuf message vtctldata.Workflow.ShardStream
 */
export interface Workflow_ShardStream {
    /**
     * @generated from protobuf field: repeated vtctldata.Workflow.Stream streams = 1;
     */
    streams: Workflow_Stream[];
    /**
     * @generated from protobuf field: repeated topodata.Shard.TabletControl tablet_controls = 2;
     */
    tabletControls: Shard_TabletControl[];
    /**
     * @generated from protobuf field: bool is_primary_serving = 3;
     */
    isPrimaryServing: boolean;
}
/**
 * @generated from protobuf message vtctldata.Workflow.Stream
 */
export interface Workflow_Stream {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 3;
     */
    tablet?: TabletAlias;
    /**
     * @generated from protobuf field: binlogdata.BinlogSource binlog_source = 4;
     */
    binlogSource?: BinlogSource;
    /**
     * @generated from protobuf field: string position = 5;
     */
    position: string;
    /**
     * @generated from protobuf field: string stop_position = 6;
     */
    stopPosition: string;
    /**
     * @generated from protobuf field: string state = 7;
     */
    state: string;
    /**
     * @generated from protobuf field: string db_name = 8;
     */
    dbName: string;
    /**
     * @generated from protobuf field: vttime.Time transaction_timestamp = 9;
     */
    transactionTimestamp?: Time;
    /**
     * @generated from protobuf field: vttime.Time time_updated = 10;
     */
    timeUpdated?: Time;
    /**
     * @generated from protobuf field: string message = 11;
     */
    message: string;
    /**
     * @generated from protobuf field: repeated vtctldata.Workflow.Stream.CopyState copy_states = 12;
     */
    copyStates: Workflow_Stream_CopyState[];
    /**
     * @generated from protobuf field: repeated vtctldata.Workflow.Stream.Log logs = 13;
     */
    logs: Workflow_Stream_Log[];
    /**
     * LogFetchError is set if we fail to fetch some logs for this stream. We
     * will never fail to fetch workflows because we cannot fetch the logs, but
     * we will still forward log-fetch errors to the caller, should that be
     * relevant to the context in which they are fetching workflows.
     *
     * Note that this field being set does not necessarily mean that Logs is nil;
     * if there are N logs that exist for the stream, and we fail to fetch the
     * ith log, we will still return logs in [0, i) + (i, N].
     *
     * @generated from protobuf field: string log_fetch_error = 14;
     */
    logFetchError: string;
    /**
     * @generated from protobuf field: repeated string tags = 15;
     */
    tags: string[];
    /**
     * @generated from protobuf field: int64 rows_copied = 16;
     */
    rowsCopied: bigint;
    /**
     * @generated from protobuf field: vtctldata.Workflow.Stream.ThrottlerStatus throttler_status = 17;
     */
    throttlerStatus?: Workflow_Stream_ThrottlerStatus;
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 18;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 19;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * @generated from protobuf field: repeated string cells = 20;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.Workflow.Stream.CopyState
 */
export interface Workflow_Stream_CopyState {
    /**
     * @generated from protobuf field: string table = 1;
     */
    table: string;
    /**
     * @generated from protobuf field: string last_pk = 2;
     */
    lastPk: string;
    /**
     * @generated from protobuf field: int64 stream_id = 3;
     */
    streamId: bigint;
}
/**
 * @generated from protobuf message vtctldata.Workflow.Stream.Log
 */
export interface Workflow_Stream_Log {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: int64 stream_id = 2;
     */
    streamId: bigint;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * @generated from protobuf field: string state = 4;
     */
    state: string;
    /**
     * @generated from protobuf field: vttime.Time created_at = 5;
     */
    createdAt?: Time;
    /**
     * @generated from protobuf field: vttime.Time updated_at = 6;
     */
    updatedAt?: Time;
    /**
     * @generated from protobuf field: string message = 7;
     */
    message: string;
    /**
     * @generated from protobuf field: int64 count = 8;
     */
    count: bigint;
}
/**
 * @generated from protobuf message vtctldata.Workflow.Stream.ThrottlerStatus
 */
export interface Workflow_Stream_ThrottlerStatus {
    /**
     * @generated from protobuf field: string component_throttled = 1;
     */
    componentThrottled: string;
    /**
     * @generated from protobuf field: vttime.Time time_throttled = 2;
     */
    timeThrottled?: Time;
}
// Request/response types for VtctldServer 

/**
 * @generated from protobuf message vtctldata.AddCellInfoRequest
 */
export interface AddCellInfoRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.CellInfo cell_info = 2;
     */
    cellInfo?: CellInfo;
}
/**
 * @generated from protobuf message vtctldata.AddCellInfoResponse
 */
export interface AddCellInfoResponse {
}
/**
 * @generated from protobuf message vtctldata.AddCellsAliasRequest
 */
export interface AddCellsAliasRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.AddCellsAliasResponse
 */
export interface AddCellsAliasResponse {
}
/**
 * @generated from protobuf message vtctldata.ApplyKeyspaceRoutingRulesRequest
 */
export interface ApplyKeyspaceRoutingRulesRequest {
    /**
     * @generated from protobuf field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
     */
    keyspaceRoutingRules?: KeyspaceRoutingRules;
    /**
     * SkipRebuild, if set, will cause ApplyKeyspaceRoutingRules to skip rebuilding the
     * SrvVSchema objects in each cell in RebuildCells.
     *
     * @generated from protobuf field: bool skip_rebuild = 2;
     */
    skipRebuild: boolean;
    /**
     * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
     * provided the SrvVSchema will be rebuilt in every cell in the topology.
     *
     * Ignored if SkipRebuild is set.
     *
     * @generated from protobuf field: repeated string rebuild_cells = 3;
     */
    rebuildCells: string[];
}
/**
 * @generated from protobuf message vtctldata.ApplyKeyspaceRoutingRulesResponse
 */
export interface ApplyKeyspaceRoutingRulesResponse {
    /**
     * KeyspaceRoutingRules returns the current set of rules.
     *
     * @generated from protobuf field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
     */
    keyspaceRoutingRules?: KeyspaceRoutingRules;
}
/**
 * @generated from protobuf message vtctldata.ApplyRoutingRulesRequest
 */
export interface ApplyRoutingRulesRequest {
    /**
     * @generated from protobuf field: vschema.RoutingRules routing_rules = 1;
     */
    routingRules?: RoutingRules;
    /**
     * SkipRebuild, if set, will cause ApplyRoutingRules to skip rebuilding the
     * SrvVSchema objects in each cell in RebuildCells.
     *
     * @generated from protobuf field: bool skip_rebuild = 2;
     */
    skipRebuild: boolean;
    /**
     * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
     * provided the SrvVSchema will be rebuilt in every cell in the topology.
     *
     * Ignored if SkipRebuild is set.
     *
     * @generated from protobuf field: repeated string rebuild_cells = 3;
     */
    rebuildCells: string[];
}
/**
 * @generated from protobuf message vtctldata.ApplyRoutingRulesResponse
 */
export interface ApplyRoutingRulesResponse {
}
/**
 * @generated from protobuf message vtctldata.ApplyShardRoutingRulesRequest
 */
export interface ApplyShardRoutingRulesRequest {
    /**
     * @generated from protobuf field: vschema.ShardRoutingRules shard_routing_rules = 1;
     */
    shardRoutingRules?: ShardRoutingRules;
    /**
     * SkipRebuild, if set, will cause ApplyShardRoutingRules to skip rebuilding the
     * SrvVSchema objects in each cell in RebuildCells.
     *
     * @generated from protobuf field: bool skip_rebuild = 2;
     */
    skipRebuild: boolean;
    /**
     * RebuildCells limits the SrvVSchema rebuild to the specified cells. If not
     * provided the SrvVSchema will be rebuilt in every cell in the topology.
     *
     * Ignored if SkipRebuild is set.
     *
     * @generated from protobuf field: repeated string rebuild_cells = 3;
     */
    rebuildCells: string[];
}
/**
 * @generated from protobuf message vtctldata.ApplyShardRoutingRulesResponse
 */
export interface ApplyShardRoutingRulesResponse {
}
/**
 * @generated from protobuf message vtctldata.ApplySchemaRequest
 */
export interface ApplySchemaRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * SQL commands to run.
     *
     * @generated from protobuf field: repeated string sql = 3;
     */
    sql: string[];
    /**
     * Online DDL strategy, compatible with @@ddl_strategy session variable (examples: 'gh-ost', 'pt-osc', 'gh-ost --max-load=Threads_running=100'")
     *
     * @generated from protobuf field: string ddl_strategy = 4;
     */
    ddlStrategy: string;
    /**
     * Optional: explicit UUIDs for migration.
     * If given, must match number of DDL changes
     *
     * @generated from protobuf field: repeated string uuid_list = 5;
     */
    uuidList: string[];
    /**
     * For Online DDL, optionally supply a custom unique string used as context for the migration(s) in this command.
     * By default a unique context is auto-generated by Vitess
     *
     * @generated from protobuf field: string migration_context = 6;
     */
    migrationContext: string;
    /**
     * WaitReplicasTimeout is the duration of time to wait for replicas to catch
     * up in reparenting.
     *
     * @generated from protobuf field: vttime.Duration wait_replicas_timeout = 7;
     */
    waitReplicasTimeout?: Duration;
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 9;
     */
    callerId?: CallerID;
    /**
     * BatchSize indicates how many queries to apply together
     *
     * @generated from protobuf field: int64 batch_size = 10;
     */
    batchSize: bigint;
}
/**
 * @generated from protobuf message vtctldata.ApplySchemaResponse
 */
export interface ApplySchemaResponse {
    /**
     * @generated from protobuf field: repeated string uuid_list = 1;
     */
    uuidList: string[];
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 2;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.ApplyVSchemaRequest
 */
export interface ApplyVSchemaRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: bool skip_rebuild = 2;
     */
    skipRebuild: boolean;
    /**
     * @generated from protobuf field: bool dry_run = 3;
     */
    dryRun: boolean;
    /**
     * @generated from protobuf field: repeated string cells = 4;
     */
    cells: string[];
    /**
     * @generated from protobuf field: vschema.Keyspace v_schema = 5;
     */
    vSchema?: Keyspace$2;
    /**
     * @generated from protobuf field: string sql = 6;
     */
    sql: string;
    /**
     * Strict returns an error if there are unknown vindex params.
     *
     * @generated from protobuf field: bool strict = 7;
     */
    strict: boolean;
}
/**
 * @generated from protobuf message vtctldata.ApplyVSchemaResponse
 */
export interface ApplyVSchemaResponse {
    /**
     * @generated from protobuf field: vschema.Keyspace v_schema = 1;
     */
    vSchema?: Keyspace$2;
    /**
     * UnknownVindexParams is a map of vindex name to params that were not recognized by the vindex
     * type. E.g.:
     *
     * {
     *   "lookup_vdx": {
     *     "params": ["raed_lock", "not_verify"]
     *   }
     * }
     *
     * @generated from protobuf field: map<string, vtctldata.ApplyVSchemaResponse.ParamList> unknown_vindex_params = 2;
     */
    unknownVindexParams: {
        [key: string]: ApplyVSchemaResponse_ParamList;
    };
}
/**
 * @generated from protobuf message vtctldata.ApplyVSchemaResponse.ParamList
 */
export interface ApplyVSchemaResponse_ParamList {
    /**
     * @generated from protobuf field: repeated string params = 1;
     */
    params: string[];
}
/**
 * @generated from protobuf message vtctldata.BackupRequest
 */
export interface BackupRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * AllowPrimary allows the backup to proceed if TabletAlias is a PRIMARY.
     *
     * WARNING: If using the builtin backup engine, this will shutdown mysqld on
     * the primary for the duration of the backup, and no writes will be possible.
     *
     * @generated from protobuf field: bool allow_primary = 2;
     */
    allowPrimary: boolean;
    /**
     * Concurrency specifies the number of compression/checksum jobs to run
     * simultaneously.
     *
     * @generated from protobuf field: int32 concurrency = 3;
     */
    concurrency: number;
    /**
     * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
     * then the backup becomes incremental and applies as of given position.
     *
     * @generated from protobuf field: string incremental_from_pos = 4;
     */
    incrementalFromPos: string;
    /**
     * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
     * so that it's a backup that can be used for an upgrade.
     *
     * @generated from protobuf field: bool upgrade_safe = 5;
     */
    upgradeSafe: boolean;
    /**
     * BackupEngine specifies if we want to use a particular backup engine for this backup request
     *
     * @generated from protobuf field: optional string backup_engine = 6;
     */
    backupEngine?: string;
}
/**
 * @generated from protobuf message vtctldata.BackupResponse
 */
export interface BackupResponse {
    /**
     * TabletAlias is the alias being used for the backup.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: logutil.Event event = 4;
     */
    event?: Event;
}
/**
 * @generated from protobuf message vtctldata.BackupShardRequest
 */
export interface BackupShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * AllowPrimary allows the backup to occur on a PRIMARY tablet. See
     * BackupRequest.AllowPrimary for warnings and caveats.
     *
     * @generated from protobuf field: bool allow_primary = 3;
     */
    allowPrimary: boolean;
    /**
     * Concurrency specifies the number of compression/checksum jobs to run
     * simultaneously.
     *
     * @generated from protobuf field: int32 concurrency = 4;
     */
    concurrency: number;
    /**
     * UpgradeSafe indicates if the backup should be taken with innodb_fast_shutdown=0
     * so that it's a backup that can be used for an upgrade.
     *
     * @generated from protobuf field: bool upgrade_safe = 5;
     */
    upgradeSafe: boolean;
    /**
     * IncrementalFromPos indicates a position of a previous backup. When this value is non-empty
     * then the backup becomes incremental and applies as of given position.
     *
     * @generated from protobuf field: string incremental_from_pos = 6;
     */
    incrementalFromPos: string;
}
/**
 * @generated from protobuf message vtctldata.CancelSchemaMigrationRequest
 */
export interface CancelSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.CancelSchemaMigrationResponse
 */
export interface CancelSchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.ChangeTabletTagsRequest
 */
export interface ChangeTabletTagsRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: map<string, string> tags = 2;
     */
    tags: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: bool replace = 3;
     */
    replace: boolean;
}
/**
 * @generated from protobuf message vtctldata.ChangeTabletTagsResponse
 */
export interface ChangeTabletTagsResponse {
    /**
     * @generated from protobuf field: map<string, string> before_tags = 1;
     */
    beforeTags: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: map<string, string> after_tags = 2;
     */
    afterTags: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message vtctldata.ChangeTabletTypeRequest
 */
export interface ChangeTabletTypeRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: topodata.TabletType db_type = 2;
     */
    dbType: TabletType;
    /**
     * @generated from protobuf field: bool dry_run = 3;
     */
    dryRun: boolean;
}
/**
 * @generated from protobuf message vtctldata.ChangeTabletTypeResponse
 */
export interface ChangeTabletTypeResponse {
    /**
     * @generated from protobuf field: topodata.Tablet before_tablet = 1;
     */
    beforeTablet?: Tablet;
    /**
     * @generated from protobuf field: topodata.Tablet after_tablet = 2;
     */
    afterTablet?: Tablet;
    /**
     * @generated from protobuf field: bool was_dry_run = 3;
     */
    wasDryRun: boolean;
}
/**
 * @generated from protobuf message vtctldata.CheckThrottlerRequest
 */
export interface CheckThrottlerRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: string app_name = 2;
     */
    appName: string;
    /**
     * @generated from protobuf field: string scope = 3;
     */
    scope: string;
    /**
     * SkipRequestHeartbeats ensures this check does not renew heartbeat lease
     *
     * @generated from protobuf field: bool skip_request_heartbeats = 4;
     */
    skipRequestHeartbeats: boolean;
    /**
     * OKIfNotExists asks the throttler to return OK even if the metric does not exist
     *
     * @generated from protobuf field: bool ok_if_not_exists = 5;
     */
    okIfNotExists: boolean;
}
/**
 * @generated from protobuf message vtctldata.CheckThrottlerResponse
 */
export interface CheckThrottlerResponse {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: tabletmanagerdata.CheckThrottlerResponse Check = 2 [json_name = "Check"];
     */
    check?: CheckThrottlerResponse$;
}
/**
 * @generated from protobuf message vtctldata.CleanupSchemaMigrationRequest
 */
export interface CleanupSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.CleanupSchemaMigrationResponse
 */
export interface CleanupSchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.CompleteSchemaMigrationRequest
 */
export interface CompleteSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.CompleteSchemaMigrationResponse
 */
export interface CompleteSchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.CreateKeyspaceRequest
 */
export interface CreateKeyspaceRequest {
    /**
     * Name is the name of the keyspace.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Force proceeds with the request even if the keyspace already exists.
     *
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
    /**
     * AllowEmptyVSchema allows a keyspace to be created with no vschema.
     *
     * @generated from protobuf field: bool allow_empty_v_schema = 3;
     */
    allowEmptyVSchema: boolean;
    /**
     * Type is the type of the keyspace to create.
     *
     * @generated from protobuf field: topodata.KeyspaceType type = 7;
     */
    type: KeyspaceType;
    /**
     * BaseKeyspace specifies the base keyspace for SNAPSHOT keyspaces. It is
     * required to create a SNAPSHOT keyspace.
     *
     * @generated from protobuf field: string base_keyspace = 8;
     */
    baseKeyspace: string;
    /**
     * SnapshotTime specifies the snapshot time for this keyspace. It is required
     * to create a SNAPSHOT keyspace.
     *
     * @generated from protobuf field: vttime.Time snapshot_time = 9;
     */
    snapshotTime?: Time;
    /**
     * DurabilityPolicy is the durability policy to be
     * used for this keyspace.
     *
     * @generated from protobuf field: string durability_policy = 10;
     */
    durabilityPolicy: string;
    /**
     * SidecarDBName is the name of the sidecar database that
     * each vttablet in the keyspace will use.
     *
     * @generated from protobuf field: string sidecar_db_name = 11;
     */
    sidecarDbName: string;
}
/**
 * @generated from protobuf message vtctldata.CreateKeyspaceResponse
 */
export interface CreateKeyspaceResponse {
    /**
     * Keyspace is the newly-created keyspace.
     *
     * @generated from protobuf field: vtctldata.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace;
}
/**
 * @generated from protobuf message vtctldata.CreateShardRequest
 */
export interface CreateShardRequest {
    /**
     * Keyspace is the name of the keyspace to create the shard in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * ShardName is the name of the shard to create. E.g. "-" or "-80".
     *
     * @generated from protobuf field: string shard_name = 2;
     */
    shardName: string;
    /**
     * Force treats an attempt to create a shard that already exists as a
     * non-error.
     *
     * @generated from protobuf field: bool force = 3;
     */
    force: boolean;
    /**
     * IncludeParent creates the parent keyspace as an empty BASE keyspace, if it
     * doesn't already exist.
     *
     * @generated from protobuf field: bool include_parent = 4;
     */
    includeParent: boolean;
}
/**
 * @generated from protobuf message vtctldata.CreateShardResponse
 */
export interface CreateShardResponse {
    /**
     * Keyspace is the created keyspace. It is set only if IncludeParent was
     * specified in the request and the parent keyspace needed to be created.
     *
     * @generated from protobuf field: vtctldata.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace;
    /**
     * Shard is the newly-created shard object.
     *
     * @generated from protobuf field: vtctldata.Shard shard = 2;
     */
    shard?: Shard;
    /**
     * ShardAlreadyExists is set if Force was specified in the request and the
     * shard already existed.
     *
     * @generated from protobuf field: bool shard_already_exists = 3;
     */
    shardAlreadyExists: boolean;
}
/**
 * @generated from protobuf message vtctldata.DeleteCellInfoRequest
 */
export interface DeleteCellInfoRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean;
}
/**
 * @generated from protobuf message vtctldata.DeleteCellInfoResponse
 */
export interface DeleteCellInfoResponse {
}
/**
 * @generated from protobuf message vtctldata.DeleteCellsAliasRequest
 */
export interface DeleteCellsAliasRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.DeleteCellsAliasResponse
 */
export interface DeleteCellsAliasResponse {
}
/**
 * @generated from protobuf message vtctldata.DeleteKeyspaceRequest
 */
export interface DeleteKeyspaceRequest {
    /**
     * Keyspace is the name of the keyspace to delete.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Recursive causes all shards in the keyspace to be recursively deleted
     * before deleting the keyspace. It is an error to call DeleteKeyspace on a
     * non-empty keyspace without also specifying Recursive.
     *
     * @generated from protobuf field: bool recursive = 2;
     */
    recursive: boolean;
    /**
     * Force allows a keyspace to be deleted even if the keyspace lock cannot be
     * obtained. This should only be used to force-clean a keyspace.
     *
     * @generated from protobuf field: bool force = 3;
     */
    force: boolean;
}
/**
 * @generated from protobuf message vtctldata.DeleteKeyspaceResponse
 */
export interface DeleteKeyspaceResponse {
}
/**
 * @generated from protobuf message vtctldata.DeleteShardsRequest
 */
export interface DeleteShardsRequest {
    /**
     * Shards is the list of shards to delete. The nested topodatapb.Shard field
     * is not required for DeleteShard, but the Keyspace and Shard fields are.
     *
     * @generated from protobuf field: repeated vtctldata.Shard shards = 1;
     */
    shards: Shard[];
    /**
     * Recursive also deletes all tablets belonging to the shard(s). It is an
     * error to call DeleteShard on a non-empty shard without also specificying
     * Recursive.
     *
     * @generated from protobuf field: bool recursive = 2;
     */
    recursive: boolean;
    /**
     * EvenIfServing allows a shard to be deleted even if it is serving, which is
     * normally an error. Use with caution.
     *
     * @generated from protobuf field: bool even_if_serving = 4;
     */
    evenIfServing: boolean;
    /**
     * Force allows a shard to be deleted even if the shard lock cannot be
     * obtained. This should only be used to force-clean a shard.
     *
     * @generated from protobuf field: bool force = 5;
     */
    force: boolean;
}
/**
 * @generated from protobuf message vtctldata.DeleteShardsResponse
 */
export interface DeleteShardsResponse {
}
/**
 * @generated from protobuf message vtctldata.DeleteSrvVSchemaRequest
 */
export interface DeleteSrvVSchemaRequest {
    /**
     * @generated from protobuf field: string cell = 1;
     */
    cell: string;
}
/**
 * @generated from protobuf message vtctldata.DeleteSrvVSchemaResponse
 */
export interface DeleteSrvVSchemaResponse {
}
/**
 * @generated from protobuf message vtctldata.DeleteTabletsRequest
 */
export interface DeleteTabletsRequest {
    /**
     * TabletAliases is the list of tablets to delete.
     *
     * @generated from protobuf field: repeated topodata.TabletAlias tablet_aliases = 1;
     */
    tabletAliases: TabletAlias[];
    /**
     * AllowPrimary allows for the primary tablet of a shard to be deleted.
     * Use with caution.
     *
     * @generated from protobuf field: bool allow_primary = 2;
     */
    allowPrimary: boolean;
}
/**
 * @generated from protobuf message vtctldata.DeleteTabletsResponse
 */
export interface DeleteTabletsResponse {
}
/**
 * @generated from protobuf message vtctldata.EmergencyReparentShardRequest
 */
export interface EmergencyReparentShardRequest {
    /**
     * Keyspace is the name of the keyspace to perform the Emergency Reparent in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard to perform the Emergency Reparent in.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * Optional alias of a tablet that should become the new shard primary. If not
     * not specified, the vtctld will select the most up-to-date canditate to
     * promote.
     *
     * @generated from protobuf field: topodata.TabletAlias new_primary = 3;
     */
    newPrimary?: TabletAlias;
    /**
     * List of replica aliases to ignore during the Emergency Reparent. The vtctld
     * will not attempt to stop replication on these tablets, nor attempt to
     * demote any that may think they are the shard primary.
     *
     * @generated from protobuf field: repeated topodata.TabletAlias ignore_replicas = 4;
     */
    ignoreReplicas: TabletAlias[];
    /**
     * WaitReplicasTimeout is the duration of time to wait for replicas to catch
     * up in reparenting.
     *
     * @generated from protobuf field: vttime.Duration wait_replicas_timeout = 5;
     */
    waitReplicasTimeout?: Duration;
    /**
     * PreventCrossCellPromotion is used to only promote the new primary from the same cell
     * as the failed primary.
     *
     * @generated from protobuf field: bool prevent_cross_cell_promotion = 6;
     */
    preventCrossCellPromotion: boolean;
    /**
     * WaitForAllTablets makes ERS wait for a response from all the tablets before proceeding.
     * Useful when all the tablets are up and reachable.
     *
     * @generated from protobuf field: bool wait_for_all_tablets = 7;
     */
    waitForAllTablets: boolean;
    /**
     * ExpectedPrimary is the optional alias we expect to be the current primary in order for
     * the reparent operation to succeed.
     *
     * @generated from protobuf field: topodata.TabletAlias expected_primary = 8;
     */
    expectedPrimary?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.EmergencyReparentShardResponse
 */
export interface EmergencyReparentShardResponse {
    /**
     * Keyspace is the name of the keyspace the Emergency Reparent took place in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard the Emergency Reparent took place in.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * PromotedPrimary is the alias of the tablet that was promoted to shard
     * primary. If NewPrimary was set in the request, then this will be the same
     * alias. Otherwise, it will be the alias of the tablet found to be most
     * up-to-date.
     *
     * @generated from protobuf field: topodata.TabletAlias promoted_primary = 3;
     */
    promotedPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 4;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtctldata.ExecuteFetchAsAppRequest
 */
export interface ExecuteFetchAsAppRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: string query = 2;
     */
    query: string;
    /**
     * MaxRows is an optional parameter to limit the number of rows read into the
     * QueryResult. Note that this does not apply a LIMIT to the query, just how
     * many rows are read from the MySQL server on the tablet side.
     *
     * This field is optional. Specifying a non-positive value will use whatever
     * default is configured in the VtctldService.
     *
     * @generated from protobuf field: int64 max_rows = 3;
     */
    maxRows: bigint;
    /**
     * UsePool causes the query to be run with a pooled connection to the tablet.
     *
     * @generated from protobuf field: bool use_pool = 4;
     */
    usePool: boolean;
}
/**
 * @generated from protobuf message vtctldata.ExecuteFetchAsAppResponse
 */
export interface ExecuteFetchAsAppResponse {
    /**
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * @generated from protobuf message vtctldata.ExecuteFetchAsDBARequest
 */
export interface ExecuteFetchAsDBARequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: string query = 2;
     */
    query: string;
    /**
     * MaxRows is an optional parameter to limit the number of rows read into the
     * QueryResult. Note that this does not apply a LIMIT to the query, just how
     * many rows are read from the MySQL server on the tablet side.
     *
     * This field is optional. Specifying a non-positive value will use whatever
     * default is configured in the VtctldService.
     *
     * @generated from protobuf field: int64 max_rows = 3;
     */
    maxRows: bigint;
    /**
     * DisableBinlogs instructs the tablet not to use binary logging when
     * executing the query.
     *
     * @generated from protobuf field: bool disable_binlogs = 4;
     */
    disableBinlogs: boolean;
    /**
     * ReloadSchema instructs the tablet to reload its schema after executing the
     * query.
     *
     * @generated from protobuf field: bool reload_schema = 5;
     */
    reloadSchema: boolean;
}
/**
 * @generated from protobuf message vtctldata.ExecuteFetchAsDBAResponse
 */
export interface ExecuteFetchAsDBAResponse {
    /**
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
}
/**
 * @generated from protobuf message vtctldata.ExecuteHookRequest
 */
export interface ExecuteHookRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: tabletmanagerdata.ExecuteHookRequest tablet_hook_request = 2;
     */
    tabletHookRequest?: ExecuteHookRequest$;
}
/**
 * @generated from protobuf message vtctldata.ExecuteHookResponse
 */
export interface ExecuteHookResponse {
    /**
     * @generated from protobuf field: tabletmanagerdata.ExecuteHookResponse hook_result = 1;
     */
    hookResult?: ExecuteHookResponse$;
}
/**
 * @generated from protobuf message vtctldata.ExecuteMultiFetchAsDBARequest
 */
export interface ExecuteMultiFetchAsDBARequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * SQL could have potentially multiple queries separated by semicolons.
     *
     * @generated from protobuf field: string sql = 2;
     */
    sql: string;
    /**
     * MaxRows is an optional parameter to limit the number of rows read into the
     * QueryResult. Note that this does not apply a LIMIT to a query, just how
     * many rows are read from the MySQL server on the tablet side.
     *
     * This field is optional. Specifying a non-positive value will use whatever
     * default is configured in the VtctldService.
     *
     * @generated from protobuf field: int64 max_rows = 3;
     */
    maxRows: bigint;
    /**
     * DisableBinlogs instructs the tablet not to use binary logging when
     * executing the query.
     *
     * @generated from protobuf field: bool disable_binlogs = 4;
     */
    disableBinlogs: boolean;
    /**
     * ReloadSchema instructs the tablet to reload its schema after executing the
     * query.
     *
     * @generated from protobuf field: bool reload_schema = 5;
     */
    reloadSchema: boolean;
}
/**
 * @generated from protobuf message vtctldata.ExecuteMultiFetchAsDBAResponse
 */
export interface ExecuteMultiFetchAsDBAResponse {
    /**
     * @generated from protobuf field: repeated query.QueryResult results = 1;
     */
    results: QueryResult[];
}
/**
 * @generated from protobuf message vtctldata.FindAllShardsInKeyspaceRequest
 */
export interface FindAllShardsInKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtctldata.FindAllShardsInKeyspaceResponse
 */
export interface FindAllShardsInKeyspaceResponse {
    /**
     * @generated from protobuf field: map<string, vtctldata.Shard> shards = 1;
     */
    shards: {
        [key: string]: Shard;
    };
}
/**
 * @generated from protobuf message vtctldata.ForceCutOverSchemaMigrationRequest
 */
export interface ForceCutOverSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.ForceCutOverSchemaMigrationResponse
 */
export interface ForceCutOverSchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.GetBackupsRequest
 */
export interface GetBackupsRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * Limit, if nonzero, will return only the most N recent backups.
     *
     * @generated from protobuf field: uint32 limit = 3;
     */
    limit: number;
    /**
     * Detailed indicates whether to use the backupengine, if supported, to
     * populate additional fields, such as Engine and Status, on BackupInfo
     * objects in the response. If not set, or if the backupengine does not
     * support populating these fields, Engine will always be empty, and Status
     * will always be UNKNOWN.
     *
     * @generated from protobuf field: bool detailed = 4;
     */
    detailed: boolean;
    /**
     * DetailedLimit, if nonzero, will only populate additional fields (see Detailed)
     * on the N most recent backups. The Limit field still dictates the total
     * number of backup info objects returned, so, in reality, min(Limit, DetailedLimit)
     * backup infos will have additional fields set, and any remaining backups
     * will not.
     *
     * @generated from protobuf field: uint32 detailed_limit = 5;
     */
    detailedLimit: number;
}
/**
 * @generated from protobuf message vtctldata.GetBackupsResponse
 */
export interface GetBackupsResponse {
    /**
     * @generated from protobuf field: repeated mysqlctl.BackupInfo backups = 1;
     */
    backups: BackupInfo[];
}
/**
 * @generated from protobuf message vtctldata.GetCellInfoRequest
 */
export interface GetCellInfoRequest {
    /**
     * @generated from protobuf field: string cell = 1;
     */
    cell: string;
}
/**
 * @generated from protobuf message vtctldata.GetCellInfoResponse
 */
export interface GetCellInfoResponse {
    /**
     * @generated from protobuf field: topodata.CellInfo cell_info = 1;
     */
    cellInfo?: CellInfo;
}
/**
 * @generated from protobuf message vtctldata.GetCellInfoNamesRequest
 */
export interface GetCellInfoNamesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetCellInfoNamesResponse
 */
export interface GetCellInfoNamesResponse {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * @generated from protobuf message vtctldata.GetCellsAliasesRequest
 */
export interface GetCellsAliasesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetCellsAliasesResponse
 */
export interface GetCellsAliasesResponse {
    /**
     * @generated from protobuf field: map<string, topodata.CellsAlias> aliases = 1;
     */
    aliases: {
        [key: string]: CellsAlias;
    };
}
/**
 * @generated from protobuf message vtctldata.GetFullStatusRequest
 */
export interface GetFullStatusRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.GetFullStatusResponse
 */
export interface GetFullStatusResponse {
    /**
     * @generated from protobuf field: replicationdata.FullStatus status = 1;
     */
    status?: FullStatus;
}
/**
 * @generated from protobuf message vtctldata.GetKeyspacesRequest
 */
export interface GetKeyspacesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetKeyspacesResponse
 */
export interface GetKeyspacesResponse {
    /**
     * @generated from protobuf field: repeated vtctldata.Keyspace keyspaces = 1;
     */
    keyspaces: Keyspace[];
}
/**
 * @generated from protobuf message vtctldata.GetKeyspaceRequest
 */
export interface GetKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtctldata.GetKeyspaceResponse
 */
export interface GetKeyspaceResponse {
    /**
     * @generated from protobuf field: vtctldata.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace;
}
/**
 * @generated from protobuf message vtctldata.GetPermissionsRequest
 */
export interface GetPermissionsRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.GetPermissionsResponse
 */
export interface GetPermissionsResponse {
    /**
     * @generated from protobuf field: tabletmanagerdata.Permissions permissions = 1;
     */
    permissions?: Permissions;
}
/**
 * @generated from protobuf message vtctldata.GetKeyspaceRoutingRulesRequest
 */
export interface GetKeyspaceRoutingRulesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetKeyspaceRoutingRulesResponse
 */
export interface GetKeyspaceRoutingRulesResponse {
    /**
     * @generated from protobuf field: vschema.KeyspaceRoutingRules keyspace_routing_rules = 1;
     */
    keyspaceRoutingRules?: KeyspaceRoutingRules;
}
/**
 * @generated from protobuf message vtctldata.GetRoutingRulesRequest
 */
export interface GetRoutingRulesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetRoutingRulesResponse
 */
export interface GetRoutingRulesResponse {
    /**
     * @generated from protobuf field: vschema.RoutingRules routing_rules = 1;
     */
    routingRules?: RoutingRules;
}
/**
 * @generated from protobuf message vtctldata.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * Tables is a list of tables for which we should gather information. Each is
     * either an exact match, or a regular expression of the form /regexp/.
     *
     * @generated from protobuf field: repeated string tables = 2;
     */
    tables: string[];
    /**
     * ExcludeTables is a list of tables to exclude from the result. Each is
     * either an exact match, or a regular expression of the form /regexp/.
     *
     * @generated from protobuf field: repeated string exclude_tables = 3;
     */
    excludeTables: string[];
    /**
     * IncludeViews specifies whether to include views in the result.
     *
     * @generated from protobuf field: bool include_views = 4;
     */
    includeViews: boolean;
    /**
     * TableNamesOnly specifies whether to limit the results to just table names,
     * rather than full schema information for each table.
     *
     * @generated from protobuf field: bool table_names_only = 5;
     */
    tableNamesOnly: boolean;
    /**
     * TableSizesOnly specifies whether to limit the results to just table sizes,
     * rather than full schema information for each table. It is ignored if
     * TableNamesOnly is set to true.
     *
     * @generated from protobuf field: bool table_sizes_only = 6;
     */
    tableSizesOnly: boolean;
    /**
     * TableSchemaOnly specifies whether to limit the results to just table/view
     * schema definition (CREATE TABLE/VIEW statements) and skip column/field information
     *
     * @generated from protobuf field: bool table_schema_only = 7;
     */
    tableSchemaOnly: boolean;
}
/**
 * @generated from protobuf message vtctldata.GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * @generated from protobuf field: tabletmanagerdata.SchemaDefinition schema = 1;
     */
    schema?: SchemaDefinition;
}
/**
 * GetSchemaMigrationsRequest controls the behavior of the GetSchemaMigrations
 * rpc.
 *
 * Keyspace is a required field, while all other fields are optional.
 *
 * If UUID is set, other optional fields will be ignored, since there will be at
 * most one migration with that UUID. Furthermore, if no migration with that
 * UUID exists, an empty response, not an error, is returned.
 *
 * MigrationContext, Status, and Recent are mutually exclusive.
 *
 * @generated from protobuf message vtctldata.GetSchemaMigrationsRequest
 */
export interface GetSchemaMigrationsRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Uuid, if set, will cause GetSchemaMigrations to return exactly 1 migration,
     * namely the one with that UUID. If no migration exists, the response will
     * be an empty slice, not an error.
     *
     * If this field is set, other fields (status filters, limit, skip, order) are
     * ignored.
     *
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
    /**
     * @generated from protobuf field: string migration_context = 3;
     */
    migrationContext: string;
    /**
     * @generated from protobuf field: vtctldata.SchemaMigration.Status status = 4;
     */
    status: SchemaMigration_Status;
    /**
     * Recent, if set, returns migrations requested between now and the provided
     * value.
     *
     * @generated from protobuf field: vttime.Duration recent = 5;
     */
    recent?: Duration;
    /**
     * @generated from protobuf field: vtctldata.QueryOrdering order = 6;
     */
    order: QueryOrdering;
    /**
     * @generated from protobuf field: uint64 limit = 7;
     */
    limit: bigint;
    /**
     * @generated from protobuf field: uint64 skip = 8;
     */
    skip: bigint;
}
/**
 * @generated from protobuf message vtctldata.GetSchemaMigrationsResponse
 */
export interface GetSchemaMigrationsResponse {
    /**
     * @generated from protobuf field: repeated vtctldata.SchemaMigration migrations = 1;
     */
    migrations: SchemaMigration[];
}
/**
 * @generated from protobuf message vtctldata.GetShardReplicationRequest
 */
export interface GetShardReplicationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * Cells is the list of cells to fetch data for. Omit to fetch data from all
     * cells.
     *
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.GetShardReplicationResponse
 */
export interface GetShardReplicationResponse {
    /**
     * @generated from protobuf field: map<string, topodata.ShardReplication> shard_replication_by_cell = 1;
     */
    shardReplicationByCell: {
        [key: string]: ShardReplication;
    };
}
/**
 * @generated from protobuf message vtctldata.GetShardRequest
 */
export interface GetShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard_name = 2;
     */
    shardName: string;
}
/**
 * @generated from protobuf message vtctldata.GetShardResponse
 */
export interface GetShardResponse {
    /**
     * @generated from protobuf field: vtctldata.Shard shard = 1;
     */
    shard?: Shard;
}
/**
 * @generated from protobuf message vtctldata.GetShardRoutingRulesRequest
 */
export interface GetShardRoutingRulesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetShardRoutingRulesResponse
 */
export interface GetShardRoutingRulesResponse {
    /**
     * @generated from protobuf field: vschema.ShardRoutingRules shard_routing_rules = 1;
     */
    shardRoutingRules?: ShardRoutingRules;
}
/**
 * @generated from protobuf message vtctldata.GetSrvKeyspaceNamesRequest
 */
export interface GetSrvKeyspaceNamesRequest {
    /**
     * @generated from protobuf field: repeated string cells = 1;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.GetSrvKeyspaceNamesResponse
 */
export interface GetSrvKeyspaceNamesResponse {
    /**
     * Names is a mapping of cell name to a list of SrvKeyspace names.
     *
     * @generated from protobuf field: map<string, vtctldata.GetSrvKeyspaceNamesResponse.NameList> names = 1;
     */
    names: {
        [key: string]: GetSrvKeyspaceNamesResponse_NameList;
    };
}
/**
 * @generated from protobuf message vtctldata.GetSrvKeyspaceNamesResponse.NameList
 */
export interface GetSrvKeyspaceNamesResponse_NameList {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * @generated from protobuf message vtctldata.GetSrvKeyspacesRequest
 */
export interface GetSrvKeyspacesRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
     * equivalent to specifying all cells in the topo.
     *
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.GetSrvKeyspacesResponse
 */
export interface GetSrvKeyspacesResponse {
    /**
     * SrvKeyspaces is a mapping of cell name to SrvKeyspace.
     *
     * @generated from protobuf field: map<string, topodata.SrvKeyspace> srv_keyspaces = 1;
     */
    srvKeyspaces: {
        [key: string]: SrvKeyspace;
    };
}
/**
 * @generated from protobuf message vtctldata.UpdateThrottlerConfigRequest
 */
export interface UpdateThrottlerConfigRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Enable instructs to enable the throttler
     *
     * @generated from protobuf field: bool enable = 2;
     */
    enable: boolean;
    /**
     * Disable instructs to disable the throttler
     *
     * @generated from protobuf field: bool disable = 3;
     */
    disable: boolean;
    /**
     * Threshold for throttler (with no custom query, ie using default query, only positive values are considered)
     *
     * @generated from protobuf field: double threshold = 4;
     */
    threshold: number;
    /**
     * CustomQuery replaces the default replication lag query
     *
     * @generated from protobuf field: string custom_query = 5;
     */
    customQuery: string;
    /**
     * CustomQuerySet indicates that the value of CustomQuery has changed
     *
     * @generated from protobuf field: bool custom_query_set = 6;
     */
    customQuerySet: boolean;
    /**
     * CheckAsCheckSelf instructs the throttler to respond to /check requests by checking the tablet's own health
     *
     * @generated from protobuf field: bool check_as_check_self = 7;
     */
    checkAsCheckSelf: boolean;
    /**
     * CheckAsCheckShard instructs the throttler to respond to /check requests by checking the shard's health (this is the default behavior)
     *
     * @generated from protobuf field: bool check_as_check_shard = 8;
     */
    checkAsCheckShard: boolean;
    /**
     * ThrottledApp indicates a single throttled app rule (ignored if name is empty)
     *
     * @generated from protobuf field: topodata.ThrottledAppRule throttled_app = 9;
     */
    throttledApp?: ThrottledAppRule;
    /**
     * MetricName is the name of the metric for which we apply a new threshold
     *
     * @generated from protobuf field: string metric_name = 10;
     */
    metricName: string;
    /**
     * AppName is the name of the app for which we assign metrics
     *
     * @generated from protobuf field: string app_name = 11;
     */
    appName: string;
    /**
     * AppCheckedMetrics are the metrics to be checked got the given AppName. These can be scoped. For example:
     * ["lag", "self/loadvg", "shard/threads_running"]
     *
     * @generated from protobuf field: repeated string app_checked_metrics = 12;
     */
    appCheckedMetrics: string[];
}
/**
 * @generated from protobuf message vtctldata.UpdateThrottlerConfigResponse
 */
export interface UpdateThrottlerConfigResponse {
}
/**
 * @generated from protobuf message vtctldata.GetSrvVSchemaRequest
 */
export interface GetSrvVSchemaRequest {
    /**
     * @generated from protobuf field: string cell = 1;
     */
    cell: string;
}
/**
 * @generated from protobuf message vtctldata.GetSrvVSchemaResponse
 */
export interface GetSrvVSchemaResponse {
    /**
     * @generated from protobuf field: vschema.SrvVSchema srv_v_schema = 1;
     */
    srvVSchema?: SrvVSchema;
}
/**
 * @generated from protobuf message vtctldata.GetSrvVSchemasRequest
 */
export interface GetSrvVSchemasRequest {
    /**
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.GetSrvVSchemasResponse
 */
export interface GetSrvVSchemasResponse {
    /**
     * SrvVSchemas is a mapping of cell name to SrvVSchema
     *
     * @generated from protobuf field: map<string, vschema.SrvVSchema> srv_v_schemas = 1;
     */
    srvVSchemas: {
        [key: string]: SrvVSchema;
    };
}
/**
 * @generated from protobuf message vtctldata.GetTabletRequest
 */
export interface GetTabletRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.GetTabletResponse
 */
export interface GetTabletResponse {
    /**
     * @generated from protobuf field: topodata.Tablet tablet = 1;
     */
    tablet?: Tablet;
}
/**
 * @generated from protobuf message vtctldata.GetTabletsRequest
 */
export interface GetTabletsRequest {
    /**
     * Keyspace is the name of the keyspace to return tablets for. Omit to return
     * tablets from all keyspaces.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard to return tablets for. This field is ignored
     * if Keyspace is not set.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * Cells is an optional set of cells to return tablets for.
     *
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
    /**
     * Strict specifies how the server should treat failures from individual
     * cells.
     *
     * When false (the default), GetTablets will return data from any cells that
     * return successfully, but will fail the request if all cells fail. When
     * true, any individual cell can fail the full request.
     *
     * @generated from protobuf field: bool strict = 4;
     */
    strict: boolean;
    /**
     * TabletAliases is an optional list of tablet aliases to fetch Tablet objects
     * for. If specified, Keyspace, Shard, and Cells are ignored, and tablets are
     * looked up by their respective aliases' Cells directly.
     *
     * @generated from protobuf field: repeated topodata.TabletAlias tablet_aliases = 5;
     */
    tabletAliases: TabletAlias[];
    /**
     * tablet_type specifies the type of tablets to return. Omit to return all
     * tablet types.
     *
     * @generated from protobuf field: topodata.TabletType tablet_type = 6;
     */
    tabletType: TabletType;
}
/**
 * @generated from protobuf message vtctldata.GetTabletsResponse
 */
export interface GetTabletsResponse {
    /**
     * @generated from protobuf field: repeated topodata.Tablet tablets = 1;
     */
    tablets: Tablet[];
}
/**
 * @generated from protobuf message vtctldata.GetThrottlerStatusRequest
 */
export interface GetThrottlerStatusRequest {
    /**
     * TabletAlias is the alias of the tablet to probe
     *
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.GetThrottlerStatusResponse
 */
export interface GetThrottlerStatusResponse {
    /**
     * @generated from protobuf field: tabletmanagerdata.GetThrottlerStatusResponse status = 1;
     */
    status?: GetThrottlerStatusResponse$;
}
/**
 * @generated from protobuf message vtctldata.GetTopologyPathRequest
 */
export interface GetTopologyPathRequest {
    /**
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * @generated from protobuf field: int64 version = 2;
     */
    version: bigint;
    /**
     * @generated from protobuf field: bool as_json = 3;
     */
    asJson: boolean;
}
/**
 * @generated from protobuf message vtctldata.GetTopologyPathResponse
 */
export interface GetTopologyPathResponse {
    /**
     * @generated from protobuf field: vtctldata.TopologyCell cell = 1;
     */
    cell?: TopologyCell;
}
/**
 * @generated from protobuf message vtctldata.TopologyCell
 */
export interface TopologyCell {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * Data is the file contents of the cell located at path.
     * It is only populated if the cell is a terminal node.
     *
     * @generated from protobuf field: string data = 3;
     */
    data: string;
    /**
     * @generated from protobuf field: repeated string children = 4;
     */
    children: string[];
    /**
     * @generated from protobuf field: int64 version = 5;
     */
    version: bigint;
}
/**
 * @generated from protobuf message vtctldata.GetUnresolvedTransactionsRequest
 */
export interface GetUnresolvedTransactionsRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: int64 abandon_age = 2;
     */
    abandonAge: bigint; // in seconds
}
/**
 * @generated from protobuf message vtctldata.GetUnresolvedTransactionsResponse
 */
export interface GetUnresolvedTransactionsResponse {
    /**
     * @generated from protobuf field: repeated query.TransactionMetadata transactions = 1;
     */
    transactions: TransactionMetadata[];
}
/**
 * @generated from protobuf message vtctldata.ConcludeTransactionRequest
 */
export interface ConcludeTransactionRequest {
    /**
     * @generated from protobuf field: string dtid = 1;
     */
    dtid: string;
    /**
     * @generated from protobuf field: repeated query.Target participants = 2;
     */
    participants: Target[];
}
/**
 * @generated from protobuf message vtctldata.ConcludeTransactionResponse
 */
export interface ConcludeTransactionResponse {
}
/**
 * @generated from protobuf message vtctldata.GetVSchemaRequest
 */
export interface GetVSchemaRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtctldata.GetVersionRequest
 */
export interface GetVersionRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.GetVersionResponse
 */
export interface GetVersionResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * @generated from protobuf message vtctldata.GetVSchemaResponse
 */
export interface GetVSchemaResponse {
    /**
     * @generated from protobuf field: vschema.Keyspace v_schema = 1;
     */
    vSchema?: Keyspace$2;
}
/**
 * @generated from protobuf message vtctldata.GetWorkflowsRequest
 */
export interface GetWorkflowsRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: bool active_only = 2;
     */
    activeOnly: boolean;
    /**
     * @generated from protobuf field: bool name_only = 3;
     */
    nameOnly: boolean;
    /**
     * If you only want a specific workflow then set this field.
     *
     * @generated from protobuf field: string workflow = 4;
     */
    workflow: string;
    /**
     * @generated from protobuf field: bool include_logs = 5;
     */
    includeLogs: boolean;
    /**
     * @generated from protobuf field: repeated string shards = 6;
     */
    shards: string[];
}
/**
 * @generated from protobuf message vtctldata.GetWorkflowsResponse
 */
export interface GetWorkflowsResponse {
    /**
     * @generated from protobuf field: repeated vtctldata.Workflow workflows = 1;
     */
    workflows: Workflow[];
}
/**
 * @generated from protobuf message vtctldata.InitShardPrimaryRequest
 */
export interface InitShardPrimaryRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias primary_elect_tablet_alias = 3;
     */
    primaryElectTabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: bool force = 4;
     */
    force: boolean;
    /**
     * @generated from protobuf field: vttime.Duration wait_replicas_timeout = 5;
     */
    waitReplicasTimeout?: Duration;
}
/**
 * @generated from protobuf message vtctldata.InitShardPrimaryResponse
 */
export interface InitShardPrimaryResponse {
    /**
     * @generated from protobuf field: repeated logutil.Event events = 1;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtctldata.LaunchSchemaMigrationRequest
 */
export interface LaunchSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.LaunchSchemaMigrationResponse
 */
export interface LaunchSchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.LookupVindexCreateRequest
 */
export interface LookupVindexCreateRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 2;
     */
    workflow: string;
    /**
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
    /**
     * @generated from protobuf field: vschema.Keyspace vindex = 4;
     */
    vindex?: Keyspace$2;
    /**
     * @generated from protobuf field: bool continue_after_copy_with_owner = 5;
     */
    continueAfterCopyWithOwner: boolean;
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 6;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
     */
    tabletSelectionPreference: TabletSelectionPreference;
}
/**
 * @generated from protobuf message vtctldata.LookupVindexCreateResponse
 */
export interface LookupVindexCreateResponse {
}
/**
 * @generated from protobuf message vtctldata.LookupVindexExternalizeRequest
 */
export interface LookupVindexExternalizeRequest {
    /**
     * Where the lookup vindex lives.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * This is the name of the lookup vindex and the vreplication workflow.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Where the vreplication workflow lives.
     *
     * @generated from protobuf field: string table_keyspace = 3;
     */
    tableKeyspace: string;
}
/**
 * @generated from protobuf message vtctldata.LookupVindexExternalizeResponse
 */
export interface LookupVindexExternalizeResponse {
    /**
     * Was the workflow also deleted.
     *
     * @generated from protobuf field: bool workflow_deleted = 1;
     */
    workflowDeleted: boolean;
}
/**
 * @generated from protobuf message vtctldata.MaterializeCreateRequest
 */
export interface MaterializeCreateRequest {
    /**
     * @generated from protobuf field: vtctldata.MaterializeSettings settings = 1;
     */
    settings?: MaterializeSettings;
}
/**
 * @generated from protobuf message vtctldata.MaterializeCreateResponse
 */
export interface MaterializeCreateResponse {
}
/**
 * @generated from protobuf message vtctldata.MigrateCreateRequest
 */
export interface MigrateCreateRequest {
    /**
     * The necessary info gets passed on to each primary tablet involved
     * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
     *
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string source_keyspace = 2;
     */
    sourceKeyspace: string;
    /**
     * @generated from protobuf field: string target_keyspace = 3;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: string mount_name = 4;
     */
    mountName: string;
    /**
     * @generated from protobuf field: repeated string cells = 5;
     */
    cells: string[];
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 6;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * @generated from protobuf field: bool all_tables = 8;
     */
    allTables: boolean;
    /**
     * @generated from protobuf field: repeated string include_tables = 9;
     */
    includeTables: string[];
    /**
     * @generated from protobuf field: repeated string exclude_tables = 10;
     */
    excludeTables: string[];
    /**
     * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
     *
     * @generated from protobuf field: string source_time_zone = 11;
     */
    sourceTimeZone: string;
    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from protobuf field: string on_ddl = 12;
     */
    onDdl: string;
    /**
     * StopAfterCopy specifies if vreplication should be stopped after copying.
     *
     * @generated from protobuf field: bool stop_after_copy = 13;
     */
    stopAfterCopy: boolean;
    /**
     * DropForeignKeys specifies if foreign key constraints should be elided on the target.
     *
     * @generated from protobuf field: bool drop_foreign_keys = 14;
     */
    dropForeignKeys: boolean;
    /**
     * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
     *
     * @generated from protobuf field: bool defer_secondary_keys = 15;
     */
    deferSecondaryKeys: boolean;
    /**
     * Start the workflow after creating it.
     *
     * @generated from protobuf field: bool auto_start = 16;
     */
    autoStart: boolean;
    /**
     * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
     *
     * @generated from protobuf field: bool no_routing_rules = 17;
     */
    noRoutingRules: boolean;
}
/**
 * @generated from protobuf message vtctldata.MigrateCompleteRequest
 */
export interface MigrateCompleteRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 3;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: bool keep_data = 4;
     */
    keepData: boolean;
    /**
     * @generated from protobuf field: bool keep_routing_rules = 5;
     */
    keepRoutingRules: boolean;
    /**
     * @generated from protobuf field: bool rename_tables = 6;
     */
    renameTables: boolean;
    /**
     * @generated from protobuf field: bool dry_run = 7;
     */
    dryRun: boolean;
}
/**
 * @generated from protobuf message vtctldata.MigrateCompleteResponse
 */
export interface MigrateCompleteResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: repeated string dry_run_results = 2;
     */
    dryRunResults: string[];
}
/**
 * @generated from protobuf message vtctldata.MountRegisterRequest
 */
export interface MountRegisterRequest {
    /**
     * @generated from protobuf field: string topo_type = 1;
     */
    topoType: string;
    /**
     * @generated from protobuf field: string topo_server = 2;
     */
    topoServer: string;
    /**
     * @generated from protobuf field: string topo_root = 3;
     */
    topoRoot: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.MountRegisterResponse
 */
export interface MountRegisterResponse {
}
/**
 * @generated from protobuf message vtctldata.MountUnregisterRequest
 */
export interface MountUnregisterRequest {
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.MountUnregisterResponse
 */
export interface MountUnregisterResponse {
}
/**
 * @generated from protobuf message vtctldata.MountShowRequest
 */
export interface MountShowRequest {
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.MountShowResponse
 */
export interface MountShowResponse {
    /**
     * @generated from protobuf field: string topo_type = 1;
     */
    topoType: string;
    /**
     * @generated from protobuf field: string topo_server = 2;
     */
    topoServer: string;
    /**
     * @generated from protobuf field: string topo_root = 3;
     */
    topoRoot: string;
    /**
     * @generated from protobuf field: string name = 4;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.MountListRequest
 */
export interface MountListRequest {
}
/**
 * @generated from protobuf message vtctldata.MountListResponse
 */
export interface MountListResponse {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * @generated from protobuf message vtctldata.MoveTablesCreateRequest
 */
export interface MoveTablesCreateRequest {
    /**
     * The necessary info gets passed on to each primary tablet involved
     * in the workflow via the CreateVReplicationWorkflow tabletmanager RPC.
     *
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string source_keyspace = 2;
     */
    sourceKeyspace: string;
    /**
     * @generated from protobuf field: string target_keyspace = 3;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: repeated string cells = 4;
     */
    cells: string[];
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 5;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 6;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * @generated from protobuf field: repeated string source_shards = 7;
     */
    sourceShards: string[];
    /**
     * @generated from protobuf field: bool all_tables = 8;
     */
    allTables: boolean;
    /**
     * @generated from protobuf field: repeated string include_tables = 9;
     */
    includeTables: string[];
    /**
     * @generated from protobuf field: repeated string exclude_tables = 10;
     */
    excludeTables: string[];
    /**
     * The name of the external cluster mounted in topo server.
     *
     * @generated from protobuf field: string external_cluster_name = 11;
     */
    externalClusterName: string;
    /**
     * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
     *
     * @generated from protobuf field: string source_time_zone = 12;
     */
    sourceTimeZone: string;
    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from protobuf field: string on_ddl = 13;
     */
    onDdl: string;
    /**
     * StopAfterCopy specifies if vreplication should be stopped after copying.
     *
     * @generated from protobuf field: bool stop_after_copy = 14;
     */
    stopAfterCopy: boolean;
    /**
     * DropForeignKeys specifies if foreign key constraints should be elided on the target.
     *
     * @generated from protobuf field: bool drop_foreign_keys = 15;
     */
    dropForeignKeys: boolean;
    /**
     * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
     *
     * @generated from protobuf field: bool defer_secondary_keys = 16;
     */
    deferSecondaryKeys: boolean;
    /**
     * Start the workflow after creating it.
     *
     * @generated from protobuf field: bool auto_start = 17;
     */
    autoStart: boolean;
    /**
     * NoRoutingRules is set to true if routing rules should not be created on the target when the workflow is created.
     *
     * @generated from protobuf field: bool no_routing_rules = 18;
     */
    noRoutingRules: boolean;
    /**
     * Run a single copy phase for the entire database.
     *
     * @generated from protobuf field: bool atomic_copy = 19;
     */
    atomicCopy: boolean;
    /**
     * @generated from protobuf field: vtctldata.WorkflowOptions workflow_options = 20;
     */
    workflowOptions?: WorkflowOptions;
}
/**
 * @generated from protobuf message vtctldata.MoveTablesCreateResponse
 */
export interface MoveTablesCreateResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: repeated vtctldata.MoveTablesCreateResponse.TabletInfo details = 2;
     */
    details: MoveTablesCreateResponse_TabletInfo[];
}
/**
 * @generated from protobuf message vtctldata.MoveTablesCreateResponse.TabletInfo
 */
export interface MoveTablesCreateResponse_TabletInfo {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 1;
     */
    tablet?: TabletAlias;
    /**
     * Created is set if the workflow was created on this tablet or not.
     *
     * @generated from protobuf field: bool created = 2;
     */
    created: boolean;
}
/**
 * @generated from protobuf message vtctldata.MoveTablesCompleteRequest
 */
export interface MoveTablesCompleteRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 3;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: bool keep_data = 4;
     */
    keepData: boolean;
    /**
     * @generated from protobuf field: bool keep_routing_rules = 5;
     */
    keepRoutingRules: boolean;
    /**
     * @generated from protobuf field: bool rename_tables = 6;
     */
    renameTables: boolean;
    /**
     * @generated from protobuf field: bool dry_run = 7;
     */
    dryRun: boolean;
    /**
     * @generated from protobuf field: repeated string shards = 8;
     */
    shards: string[];
}
/**
 * @generated from protobuf message vtctldata.MoveTablesCompleteResponse
 */
export interface MoveTablesCompleteResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: repeated string dry_run_results = 2;
     */
    dryRunResults: string[];
}
/**
 * @generated from protobuf message vtctldata.PingTabletRequest
 */
export interface PingTabletRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.PingTabletResponse
 */
export interface PingTabletResponse {
}
/**
 * @generated from protobuf message vtctldata.PlannedReparentShardRequest
 */
export interface PlannedReparentShardRequest {
    /**
     * Keyspace is the name of the keyspace to perform the Planned Reparent in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard to perform teh Planned Reparent in.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * NewPrimary is the alias of the tablet to promote to shard primary. If not
     * specified, the vtctld will select the most up-to-date candidate to promote.
     *
     * It is an error to set NewPrimary and AvoidPrimary to the same alias.
     *
     * @generated from protobuf field: topodata.TabletAlias new_primary = 3;
     */
    newPrimary?: TabletAlias;
    /**
     * AvoidPrimary is the alias of the tablet to demote. In other words,
     * specifying an AvoidPrimary alias tells the vtctld to promote any replica
     * other than this one. A shard whose current primary is not this one is then
     * a no-op.
     *
     * It is an error to set NewPrimary and AvoidPrimary to the same alias.
     *
     * @generated from protobuf field: topodata.TabletAlias avoid_primary = 4;
     */
    avoidPrimary?: TabletAlias;
    /**
     * WaitReplicasTimeout is the duration of time to wait for replicas to catch
     * up in replication both before and after the reparent. The timeout is not
     * cumulative across both wait periods, meaning that the replicas have
     * WaitReplicasTimeout time to catch up before the reparent, and an additional
     * WaitReplicasTimeout time to catch up after the reparent.
     *
     * @generated from protobuf field: vttime.Duration wait_replicas_timeout = 5;
     */
    waitReplicasTimeout?: Duration;
    /**
     * TolerableReplicationLag is the amount of replication lag that is considered
     * acceptable for a tablet to be eligible for promotion when Vitess makes the choice of a new primary.
     * A value of 0 indicates that Vitess shouldn't consider the replication lag at all.
     *
     * @generated from protobuf field: vttime.Duration tolerable_replication_lag = 6;
     */
    tolerableReplicationLag?: Duration;
    /**
     * AllowCrossCellPromotion allows cross cell promotion,
     *
     * @generated from protobuf field: bool allow_cross_cell_promotion = 7;
     */
    allowCrossCellPromotion: boolean;
    /**
     * ExpectedPrimary is the optional alias we expect to be the current primary in order for
     * the reparent operation to succeed.
     *
     * @generated from protobuf field: topodata.TabletAlias expected_primary = 8;
     */
    expectedPrimary?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.PlannedReparentShardResponse
 */
export interface PlannedReparentShardResponse {
    /**
     * Keyspace is the name of the keyspace the Planned Reparent took place in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard the Planned Reparent took place in.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * PromotedPrimary is the alias of the tablet that was promoted to shard
     * primary. If NewPrimary was set in the request, then this will be the same
     * alias. Otherwise, it will be the alias of the tablet found to be most
     * up-to-date.
     *
     * @generated from protobuf field: topodata.TabletAlias promoted_primary = 3;
     */
    promotedPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 4;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtctldata.RebuildKeyspaceGraphRequest
 */
export interface RebuildKeyspaceGraphRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
    /**
     * AllowPartial, when set, allows a SNAPSHOT keyspace to serve with an
     * incomplete set of shards. It is ignored for all other keyspace types.
     *
     * @generated from protobuf field: bool allow_partial = 3;
     */
    allowPartial: boolean;
}
/**
 * @generated from protobuf message vtctldata.RebuildKeyspaceGraphResponse
 */
export interface RebuildKeyspaceGraphResponse {
}
/**
 * @generated from protobuf message vtctldata.RebuildVSchemaGraphRequest
 */
export interface RebuildVSchemaGraphRequest {
    /**
     * Cells specifies the cells to rebuild the SrvVSchema objects for. If empty,
     * RebuildVSchemaGraph rebuilds the SrvVSchema for every cell in the topo.
     *
     * @generated from protobuf field: repeated string cells = 1;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.RebuildVSchemaGraphResponse
 */
export interface RebuildVSchemaGraphResponse {
}
/**
 * @generated from protobuf message vtctldata.RefreshStateRequest
 */
export interface RefreshStateRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.RefreshStateResponse
 */
export interface RefreshStateResponse {
}
/**
 * @generated from protobuf message vtctldata.RefreshStateByShardRequest
 */
export interface RefreshStateByShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtctldata.RefreshStateByShardResponse
 */
export interface RefreshStateByShardResponse {
    /**
     * @generated from protobuf field: bool is_partial_refresh = 1;
     */
    isPartialRefresh: boolean;
    /**
     * This explains why we had a partial refresh (if we did)
     *
     * @generated from protobuf field: string partial_refresh_details = 2;
     */
    partialRefreshDetails: string;
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaRequest
 */
export interface ReloadSchemaRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaResponse
 */
export interface ReloadSchemaResponse {
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaKeyspaceRequest
 */
export interface ReloadSchemaKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string wait_position = 2;
     */
    waitPosition: string;
    /**
     * @generated from protobuf field: bool include_primary = 3;
     */
    includePrimary: boolean;
    /**
     * Concurrency is the global concurrency across all shards in the keyspace
     * (so, at most this many tablets will be reloaded across the keyspace at any
     * given point).
     *
     * @generated from protobuf field: int32 concurrency = 4;
     */
    concurrency: number;
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaKeyspaceResponse
 */
export interface ReloadSchemaKeyspaceResponse {
    /**
     * @generated from protobuf field: repeated logutil.Event events = 1;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaShardRequest
 */
export interface ReloadSchemaShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: string wait_position = 3;
     */
    waitPosition: string;
    /**
     * @generated from protobuf field: bool include_primary = 4;
     */
    includePrimary: boolean;
    /**
     * Concurrency is the maximum number of tablets to reload at one time.
     *
     * @generated from protobuf field: int32 concurrency = 5;
     */
    concurrency: number;
}
/**
 * @generated from protobuf message vtctldata.ReloadSchemaShardResponse
 */
export interface ReloadSchemaShardResponse {
    /**
     * @generated from protobuf field: repeated logutil.Event events = 2;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtctldata.RemoveBackupRequest
 */
export interface RemoveBackupRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message vtctldata.RemoveBackupResponse
 */
export interface RemoveBackupResponse {
}
/**
 * @generated from protobuf message vtctldata.RemoveKeyspaceCellRequest
 */
export interface RemoveKeyspaceCellRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string cell = 2;
     */
    cell: string;
    /**
     * Force proceeds even if the cell's topology server cannot be reached. This
     * should only be set if a cell has been shut down entirely, and the global
     * topology data just needs to be updated.
     *
     * @generated from protobuf field: bool force = 3;
     */
    force: boolean;
    /**
     * Recursive also deletes all tablets in that cell belonging to the specified
     * keyspace.
     *
     * @generated from protobuf field: bool recursive = 4;
     */
    recursive: boolean;
}
/**
 * (TODO:@amason) Consider including the deleted SrvKeyspace object and any
 * deleted Tablet objects here.
 *
 * @generated from protobuf message vtctldata.RemoveKeyspaceCellResponse
 */
export interface RemoveKeyspaceCellResponse {
}
/**
 * @generated from protobuf message vtctldata.RemoveShardCellRequest
 */
export interface RemoveShardCellRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard_name = 2;
     */
    shardName: string;
    /**
     * @generated from protobuf field: string cell = 3;
     */
    cell: string;
    /**
     * Force proceeds even if the cell's topology server cannot be reached. This
     * should only be set if a cell has been shut down entirely, and the global
     * topology data just needs to be updated.
     *
     * @generated from protobuf field: bool force = 4;
     */
    force: boolean;
    /**
     * Recursive also deletes all tablets in that cell belonging to the specified
     * keyspace and shard.
     *
     * @generated from protobuf field: bool recursive = 5;
     */
    recursive: boolean;
}
/**
 * (TODO:@amason) Consider including the deleted SrvKeyspacePartitions objects
 * and any deleted Tablet objects here.
 *
 * @generated from protobuf message vtctldata.RemoveShardCellResponse
 */
export interface RemoveShardCellResponse {
}
/**
 * @generated from protobuf message vtctldata.ReparentTabletRequest
 */
export interface ReparentTabletRequest {
    /**
     * Tablet is the alias of the tablet that should be reparented under the
     * current shard primary.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet = 1;
     */
    tablet?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.ReparentTabletResponse
 */
export interface ReparentTabletResponse {
    /**
     * Keyspace is the name of the keyspace the tablet was reparented in.
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * Shard is the name of the shard the tablet was reparented in.
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * Primary is the alias of the tablet that the tablet was reparented under.
     *
     * @generated from protobuf field: topodata.TabletAlias primary = 3;
     */
    primary?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.ReshardCreateRequest
 */
export interface ReshardCreateRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string source_shards = 3;
     */
    sourceShards: string[];
    /**
     * @generated from protobuf field: repeated string target_shards = 4;
     */
    targetShards: string[];
    /**
     * @generated from protobuf field: repeated string cells = 5;
     */
    cells: string[];
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 6;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * SkipSchemaCopy specifies if the schema should be copied from the source shard, set false if
     * schema is already created on the target shard before Reshard is invoked.
     *
     * @generated from protobuf field: bool skip_schema_copy = 8;
     */
    skipSchemaCopy: boolean;
    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from protobuf field: string on_ddl = 9;
     */
    onDdl: string;
    /**
     * StopAfterCopy specifies if vreplication should be stopped after copying.
     *
     * @generated from protobuf field: bool stop_after_copy = 10;
     */
    stopAfterCopy: boolean;
    /**
     * DeferSecondaryKeys specifies if secondary keys should be created in one shot after table copy finishes.
     *
     * @generated from protobuf field: bool defer_secondary_keys = 11;
     */
    deferSecondaryKeys: boolean;
    /**
     * Start the workflow after creating it.
     *
     * @generated from protobuf field: bool auto_start = 12;
     */
    autoStart: boolean;
    /**
     * @generated from protobuf field: vtctldata.WorkflowOptions workflow_options = 13;
     */
    workflowOptions?: WorkflowOptions;
}
/**
 * @generated from protobuf message vtctldata.RestoreFromBackupRequest
 */
export interface RestoreFromBackupRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * BackupTime, if set, will use the backup taken most closely at or before
     * this time. If nil, the latest backup will be restored on the tablet.
     *
     * @generated from protobuf field: vttime.Time backup_time = 2;
     */
    backupTime?: Time;
    /**
     * RestoreToPos indicates a position for a point-in-time recovery. The recovery
     * is expected to utilize one full backup, followed by zero or more incremental backups,
     * that reach the precise desired position
     *
     * @generated from protobuf field: string restore_to_pos = 3;
     */
    restoreToPos: string;
    /**
     * Dry run does not actually performs the restore, but validates the steps and availability of backups
     *
     * @generated from protobuf field: bool dry_run = 4;
     */
    dryRun: boolean;
    /**
     * RestoreToTimestamp, if given, requested an inremental restore up to (and excluding) the given timestamp.
     * RestoreToTimestamp and RestoreToPos are mutually exclusive.
     *
     * @generated from protobuf field: vttime.Time restore_to_timestamp = 5;
     */
    restoreToTimestamp?: Time;
    /**
     * AllowedBackupEngines, if present will filter out any backups taken with engines not included in the list
     *
     * @generated from protobuf field: repeated string allowed_backup_engines = 6;
     */
    allowedBackupEngines: string[];
}
/**
 * @generated from protobuf message vtctldata.RestoreFromBackupResponse
 */
export interface RestoreFromBackupResponse {
    /**
     * TabletAlias is the alias of the tablet doing the restore.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: logutil.Event event = 4;
     */
    event?: Event;
}
/**
 * @generated from protobuf message vtctldata.RetrySchemaMigrationRequest
 */
export interface RetrySchemaMigrationRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string uuid = 2;
     */
    uuid: string;
}
/**
 * @generated from protobuf message vtctldata.RetrySchemaMigrationResponse
 */
export interface RetrySchemaMigrationResponse {
    /**
     * @generated from protobuf field: map<string, uint64> rows_affected_by_shard = 1;
     */
    rowsAffectedByShard: {
        [key: string]: bigint;
    };
}
/**
 * @generated from protobuf message vtctldata.RunHealthCheckRequest
 */
export interface RunHealthCheckRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.RunHealthCheckResponse
 */
export interface RunHealthCheckResponse {
}
/**
 * @generated from protobuf message vtctldata.SetKeyspaceDurabilityPolicyRequest
 */
export interface SetKeyspaceDurabilityPolicyRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string durability_policy = 2;
     */
    durabilityPolicy: string;
}
/**
 * @generated from protobuf message vtctldata.SetKeyspaceDurabilityPolicyResponse
 */
export interface SetKeyspaceDurabilityPolicyResponse {
    /**
     * Keyspace is the updated keyspace record.
     *
     * @generated from protobuf field: topodata.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace$;
}
/**
 * @generated from protobuf message vtctldata.SetKeyspaceShardingInfoRequest
 */
export interface SetKeyspaceShardingInfoRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: bool force = 4;
     */
    force: boolean;
}
/**
 * @generated from protobuf message vtctldata.SetKeyspaceShardingInfoResponse
 */
export interface SetKeyspaceShardingInfoResponse {
    /**
     * Keyspace is the updated keyspace record.
     *
     * @generated from protobuf field: topodata.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace$;
}
/**
 * @generated from protobuf message vtctldata.SetShardIsPrimaryServingRequest
 */
export interface SetShardIsPrimaryServingRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: bool is_serving = 3;
     */
    isServing: boolean;
}
/**
 * @generated from protobuf message vtctldata.SetShardIsPrimaryServingResponse
 */
export interface SetShardIsPrimaryServingResponse {
    /**
     * Shard is the updated shard record.
     *
     * @generated from protobuf field: topodata.Shard shard = 1;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtctldata.SetShardTabletControlRequest
 */
export interface SetShardTabletControlRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletType tablet_type = 3;
     */
    tabletType: TabletType;
    /**
     * @generated from protobuf field: repeated string cells = 4;
     */
    cells: string[];
    /**
     * DeniedTables updates the list of denied tables the shard will serve for
     * the given tablet type. This is useful to fix tables that are being blocked
     * after a MoveTables operation.
     *
     * NOTE: Setting this field will cause DisableQueryService to be ignored.
     *
     * @generated from protobuf field: repeated string denied_tables = 5;
     */
    deniedTables: string[];
    /**
     * DisableQueryService instructs whether to enable the query service on
     * tablets of the given type in the shard. This is useful to fix Reshard
     * operations gone awry.
     *
     * NOTE: this is ignored if DeniedTables is not empty.
     *
     * @generated from protobuf field: bool disable_query_service = 6;
     */
    disableQueryService: boolean;
    /**
     * Remove removes the ShardTabletControl record entirely. If set, this takes
     * precedence over DeniedTables and DisableQueryService fields, and is useful
     * to manually remove serving restrictions after a completed MoveTables
     * operation.
     *
     * @generated from protobuf field: bool remove = 7;
     */
    remove: boolean;
}
/**
 * @generated from protobuf message vtctldata.SetShardTabletControlResponse
 */
export interface SetShardTabletControlResponse {
    /**
     * Shard is the updated shard record.
     *
     * @generated from protobuf field: topodata.Shard shard = 1;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtctldata.SetWritableRequest
 */
export interface SetWritableRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: bool writable = 2;
     */
    writable: boolean;
}
/**
 * @generated from protobuf message vtctldata.SetWritableResponse
 */
export interface SetWritableResponse {
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationAddRequest
 */
export interface ShardReplicationAddRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 3;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationAddResponse
 */
export interface ShardReplicationAddResponse {
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationFixRequest
 */
export interface ShardReplicationFixRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: string cell = 3;
     */
    cell: string;
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationFixResponse
 */
export interface ShardReplicationFixResponse {
    /**
     * Error contains information about the error fixed by a
     * ShardReplicationFix RPC. If there were no errors to fix (i.e. all nodes
     * in the replication graph are valid), this field is nil.
     *
     * @generated from protobuf field: topodata.ShardReplicationError error = 1;
     */
    error?: ShardReplicationError;
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationPositionsRequest
 */
export interface ShardReplicationPositionsRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationPositionsResponse
 */
export interface ShardReplicationPositionsResponse {
    /**
     * ReplicationStatuses is a mapping of tablet alias string to replication
     * status for that tablet.
     *
     * @generated from protobuf field: map<string, replicationdata.Status> replication_statuses = 1;
     */
    replicationStatuses: {
        [key: string]: Status;
    };
    /**
     * TabletMap is the set of tablets whose replication statuses were queried,
     * keyed by tablet alias.
     *
     * @generated from protobuf field: map<string, topodata.Tablet> tablet_map = 2;
     */
    tabletMap: {
        [key: string]: Tablet;
    };
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationRemoveRequest
 */
export interface ShardReplicationRemoveRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 3;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.ShardReplicationRemoveResponse
 */
export interface ShardReplicationRemoveResponse {
}
/**
 * @generated from protobuf message vtctldata.SleepTabletRequest
 */
export interface SleepTabletRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: vttime.Duration duration = 2;
     */
    duration?: Duration;
}
/**
 * @generated from protobuf message vtctldata.SleepTabletResponse
 */
export interface SleepTabletResponse {
}
/**
 * @generated from protobuf message vtctldata.SourceShardAddRequest
 */
export interface SourceShardAddRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: int32 uid = 3;
     */
    uid: number;
    /**
     * @generated from protobuf field: string source_keyspace = 4;
     */
    sourceKeyspace: string;
    /**
     * @generated from protobuf field: string source_shard = 5;
     */
    sourceShard: string;
    /**
     * KeyRange identifies the key range to use for the SourceShard. This field is
     * optional.
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 6;
     */
    keyRange?: KeyRange;
    /**
     * Tables is a list of tables replicate (for MoveTables). Each "table" can be
     * either an exact match or a regular expression of the form "/regexp/".
     *
     * @generated from protobuf field: repeated string tables = 7;
     */
    tables: string[];
}
/**
 * @generated from protobuf message vtctldata.SourceShardAddResponse
 */
export interface SourceShardAddResponse {
    /**
     * Shard is the updated shard record.
     *
     * @generated from protobuf field: topodata.Shard shard = 1;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtctldata.SourceShardDeleteRequest
 */
export interface SourceShardDeleteRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: int32 uid = 3;
     */
    uid: number;
}
/**
 * @generated from protobuf message vtctldata.SourceShardDeleteResponse
 */
export interface SourceShardDeleteResponse {
    /**
     * Shard is the updated shard record.
     *
     * @generated from protobuf field: topodata.Shard shard = 1;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtctldata.StartReplicationRequest
 */
export interface StartReplicationRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.StartReplicationResponse
 */
export interface StartReplicationResponse {
}
/**
 * @generated from protobuf message vtctldata.StopReplicationRequest
 */
export interface StopReplicationRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.StopReplicationResponse
 */
export interface StopReplicationResponse {
}
/**
 * @generated from protobuf message vtctldata.TabletExternallyReparentedRequest
 */
export interface TabletExternallyReparentedRequest {
    /**
     * Tablet is the alias of the tablet that was promoted externally and should
     * be updated to the shard primary in the topo.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet = 1;
     */
    tablet?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.TabletExternallyReparentedResponse
 */
export interface TabletExternallyReparentedResponse {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias new_primary = 3;
     */
    newPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: topodata.TabletAlias old_primary = 4;
     */
    oldPrimary?: TabletAlias;
}
/**
 * @generated from protobuf message vtctldata.UpdateCellInfoRequest
 */
export interface UpdateCellInfoRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.CellInfo cell_info = 2;
     */
    cellInfo?: CellInfo;
}
/**
 * @generated from protobuf message vtctldata.UpdateCellInfoResponse
 */
export interface UpdateCellInfoResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.CellInfo cell_info = 2;
     */
    cellInfo?: CellInfo;
}
/**
 * @generated from protobuf message vtctldata.UpdateCellsAliasRequest
 */
export interface UpdateCellsAliasRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.CellsAlias cells_alias = 2;
     */
    cellsAlias?: CellsAlias;
}
/**
 * @generated from protobuf message vtctldata.UpdateCellsAliasResponse
 */
export interface UpdateCellsAliasResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.CellsAlias cells_alias = 2;
     */
    cellsAlias?: CellsAlias;
}
/**
 * @generated from protobuf message vtctldata.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: bool ping_tablets = 1;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtctldata.ValidateResponse
 */
export interface ValidateResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
    /**
     * @generated from protobuf field: map<string, vtctldata.ValidateKeyspaceResponse> results_by_keyspace = 2;
     */
    resultsByKeyspace: {
        [key: string]: ValidateKeyspaceResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.ValidateKeyspaceRequest
 */
export interface ValidateKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: bool ping_tablets = 2;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtctldata.ValidateKeyspaceResponse
 */
export interface ValidateKeyspaceResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
    /**
     * @generated from protobuf field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
     */
    resultsByShard: {
        [key: string]: ValidateShardResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.ValidateSchemaKeyspaceRequest
 */
export interface ValidateSchemaKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string exclude_tables = 2;
     */
    excludeTables: string[];
    /**
     * @generated from protobuf field: bool include_views = 3;
     */
    includeViews: boolean;
    /**
     * @generated from protobuf field: bool skip_no_primary = 4;
     */
    skipNoPrimary: boolean;
    /**
     * @generated from protobuf field: bool include_vschema = 5;
     */
    includeVschema: boolean;
}
/**
 * @generated from protobuf message vtctldata.ValidateSchemaKeyspaceResponse
 */
export interface ValidateSchemaKeyspaceResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
    /**
     * @generated from protobuf field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
     */
    resultsByShard: {
        [key: string]: ValidateShardResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.ValidateShardRequest
 */
export interface ValidateShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: bool ping_tablets = 3;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtctldata.ValidateShardResponse
 */
export interface ValidateShardResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
}
/**
 * @generated from protobuf message vtctldata.ValidateVersionKeyspaceRequest
 */
export interface ValidateVersionKeyspaceRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtctldata.ValidateVersionKeyspaceResponse
 */
export interface ValidateVersionKeyspaceResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
    /**
     * @generated from protobuf field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
     */
    resultsByShard: {
        [key: string]: ValidateShardResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.ValidateVersionShardRequest
 */
export interface ValidateVersionShardRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
}
/**
 * @generated from protobuf message vtctldata.ValidateVersionShardResponse
 */
export interface ValidateVersionShardResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
}
/**
 * @generated from protobuf message vtctldata.ValidateVSchemaRequest
 */
export interface ValidateVSchemaRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string shards = 2;
     */
    shards: string[];
    /**
     * @generated from protobuf field: repeated string exclude_tables = 3;
     */
    excludeTables: string[];
    /**
     * @generated from protobuf field: bool include_views = 4;
     */
    includeViews: boolean;
}
/**
 * @generated from protobuf message vtctldata.ValidateVSchemaResponse
 */
export interface ValidateVSchemaResponse {
    /**
     * @generated from protobuf field: repeated string results = 1;
     */
    results: string[];
    /**
     * @generated from protobuf field: map<string, vtctldata.ValidateShardResponse> results_by_shard = 2;
     */
    resultsByShard: {
        [key: string]: ValidateShardResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.VDiffCreateRequest
 */
export interface VDiffCreateRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 2;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * @generated from protobuf field: repeated string source_cells = 4;
     */
    sourceCells: string[];
    /**
     * @generated from protobuf field: repeated string target_cells = 5;
     */
    targetCells: string[];
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 6;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7;
     */
    tabletSelectionPreference: TabletSelectionPreference;
    /**
     * @generated from protobuf field: repeated string tables = 8;
     */
    tables: string[];
    /**
     * @generated from protobuf field: int64 limit = 9;
     */
    limit: bigint;
    /**
     * @generated from protobuf field: vttime.Duration filtered_replication_wait_time = 10;
     */
    filteredReplicationWaitTime?: Duration;
    /**
     * @generated from protobuf field: bool debug_query = 11;
     */
    debugQuery: boolean;
    /**
     * @generated from protobuf field: bool only_p_ks = 12;
     */
    onlyPKs: boolean;
    /**
     * @generated from protobuf field: bool update_table_stats = 13;
     */
    updateTableStats: boolean;
    /**
     * @generated from protobuf field: int64 max_extra_rows_to_compare = 14;
     */
    maxExtraRowsToCompare: bigint;
    /**
     * @generated from protobuf field: bool wait = 15;
     */
    wait: boolean;
    /**
     * @generated from protobuf field: vttime.Duration wait_update_interval = 16;
     */
    waitUpdateInterval?: Duration;
    /**
     * @generated from protobuf field: bool auto_retry = 17;
     */
    autoRetry: boolean;
    /**
     * @generated from protobuf field: bool verbose = 18;
     */
    verbose: boolean;
    /**
     * @generated from protobuf field: int64 max_report_sample_rows = 19;
     */
    maxReportSampleRows: bigint;
    /**
     * @generated from protobuf field: vttime.Duration max_diff_duration = 20;
     */
    maxDiffDuration?: Duration;
    /**
     * @generated from protobuf field: int64 row_diff_column_truncate_at = 21;
     */
    rowDiffColumnTruncateAt: bigint;
    /**
     * @generated from protobuf field: optional bool auto_start = 22;
     */
    autoStart?: boolean;
}
/**
 * @generated from protobuf message vtctldata.VDiffCreateResponse
 */
export interface VDiffCreateResponse {
    /**
     * Intentionally upper case to maintain compatibility with
     * vtctlclient and other VDiff client command output.
     *
     * @generated from protobuf field: string UUID = 1 [json_name = "UUID"];
     */
    uUID: string;
}
/**
 * @generated from protobuf message vtctldata.VDiffDeleteRequest
 */
export interface VDiffDeleteRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 2;
     */
    targetKeyspace: string;
    /**
     * This will be 'all' or a UUID.
     *
     * @generated from protobuf field: string arg = 3;
     */
    arg: string;
}
/**
 * @generated from protobuf message vtctldata.VDiffDeleteResponse
 */
export interface VDiffDeleteResponse {
}
/**
 * @generated from protobuf message vtctldata.VDiffResumeRequest
 */
export interface VDiffResumeRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 2;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * @generated from protobuf field: repeated string target_shards = 4;
     */
    targetShards: string[];
}
/**
 * @generated from protobuf message vtctldata.VDiffResumeResponse
 */
export interface VDiffResumeResponse {
}
/**
 * @generated from protobuf message vtctldata.VDiffShowRequest
 */
export interface VDiffShowRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 2;
     */
    targetKeyspace: string;
    /**
     * This will be 'all', 'last', or a UUID.
     *
     * @generated from protobuf field: string arg = 3;
     */
    arg: string;
}
/**
 * @generated from protobuf message vtctldata.VDiffShowResponse
 */
export interface VDiffShowResponse {
    /**
     * The key is keyspace/shard.
     *
     * @generated from protobuf field: map<string, tabletmanagerdata.VDiffResponse> tablet_responses = 1;
     */
    tabletResponses: {
        [key: string]: VDiffResponse;
    };
}
/**
 * @generated from protobuf message vtctldata.VDiffStopRequest
 */
export interface VDiffStopRequest {
    /**
     * @generated from protobuf field: string workflow = 1;
     */
    workflow: string;
    /**
     * @generated from protobuf field: string target_keyspace = 2;
     */
    targetKeyspace: string;
    /**
     * @generated from protobuf field: string uuid = 3;
     */
    uuid: string;
    /**
     * @generated from protobuf field: repeated string target_shards = 4;
     */
    targetShards: string[];
}
/**
 * @generated from protobuf message vtctldata.VDiffStopResponse
 */
export interface VDiffStopResponse {
}
/**
 * @generated from protobuf message vtctldata.WorkflowDeleteRequest
 */
export interface WorkflowDeleteRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 2;
     */
    workflow: string;
    /**
     * @generated from protobuf field: bool keep_data = 3;
     */
    keepData: boolean;
    /**
     * @generated from protobuf field: bool keep_routing_rules = 4;
     */
    keepRoutingRules: boolean;
    /**
     * @generated from protobuf field: repeated string shards = 5;
     */
    shards: string[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowDeleteResponse
 */
export interface WorkflowDeleteResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: repeated vtctldata.WorkflowDeleteResponse.TabletInfo details = 2;
     */
    details: WorkflowDeleteResponse_TabletInfo[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowDeleteResponse.TabletInfo
 */
export interface WorkflowDeleteResponse_TabletInfo {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 1;
     */
    tablet?: TabletAlias;
    /**
     * Delete is set if the workflow was deleted on this tablet.
     *
     * @generated from protobuf field: bool deleted = 2;
     */
    deleted: boolean;
}
/**
 * @generated from protobuf message vtctldata.WorkflowStatusRequest
 */
export interface WorkflowStatusRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 2;
     */
    workflow: string;
    /**
     * @generated from protobuf field: repeated string shards = 3;
     */
    shards: string[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowStatusResponse
 */
export interface WorkflowStatusResponse {
    /**
     * The key is keyspace/shard.
     *
     * @generated from protobuf field: map<string, vtctldata.WorkflowStatusResponse.TableCopyState> table_copy_state = 1;
     */
    tableCopyState: {
        [key: string]: WorkflowStatusResponse_TableCopyState;
    };
    /**
     * @generated from protobuf field: map<string, vtctldata.WorkflowStatusResponse.ShardStreams> shard_streams = 2;
     */
    shardStreams: {
        [key: string]: WorkflowStatusResponse_ShardStreams;
    };
    /**
     * @generated from protobuf field: string traffic_state = 3;
     */
    trafficState: string;
}
/**
 * @generated from protobuf message vtctldata.WorkflowStatusResponse.TableCopyState
 */
export interface WorkflowStatusResponse_TableCopyState {
    /**
     * @generated from protobuf field: int64 rows_copied = 1;
     */
    rowsCopied: bigint;
    /**
     * @generated from protobuf field: int64 rows_total = 2;
     */
    rowsTotal: bigint;
    /**
     * @generated from protobuf field: float rows_percentage = 3;
     */
    rowsPercentage: number;
    /**
     * @generated from protobuf field: int64 bytes_copied = 4;
     */
    bytesCopied: bigint;
    /**
     * @generated from protobuf field: int64 bytes_total = 5;
     */
    bytesTotal: bigint;
    /**
     * @generated from protobuf field: float bytes_percentage = 6;
     */
    bytesPercentage: number;
}
/**
 * @generated from protobuf message vtctldata.WorkflowStatusResponse.ShardStreamState
 */
export interface WorkflowStatusResponse_ShardStreamState {
    /**
     * @generated from protobuf field: int32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 2;
     */
    tablet?: TabletAlias;
    /**
     * @generated from protobuf field: string source_shard = 3;
     */
    sourceShard: string;
    /**
     * @generated from protobuf field: string position = 4;
     */
    position: string;
    /**
     * @generated from protobuf field: string status = 5;
     */
    status: string;
    /**
     * @generated from protobuf field: string info = 6;
     */
    info: string;
}
/**
 * @generated from protobuf message vtctldata.WorkflowStatusResponse.ShardStreams
 */
export interface WorkflowStatusResponse_ShardStreams {
    /**
     * @generated from protobuf field: repeated vtctldata.WorkflowStatusResponse.ShardStreamState streams = 2;
     */
    streams: WorkflowStatusResponse_ShardStreamState[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowSwitchTrafficRequest
 */
export interface WorkflowSwitchTrafficRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 2;
     */
    workflow: string;
    /**
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 4;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: vttime.Duration max_replication_lag_allowed = 5;
     */
    maxReplicationLagAllowed?: Duration;
    /**
     * @generated from protobuf field: bool enable_reverse_replication = 6;
     */
    enableReverseReplication: boolean;
    /**
     * @generated from protobuf field: int32 direction = 7;
     */
    direction: number;
    /**
     * @generated from protobuf field: vttime.Duration timeout = 8;
     */
    timeout?: Duration;
    /**
     * @generated from protobuf field: bool dry_run = 9;
     */
    dryRun: boolean;
    /**
     * @generated from protobuf field: bool initialize_target_sequences = 10;
     */
    initializeTargetSequences: boolean;
    /**
     * @generated from protobuf field: repeated string shards = 11;
     */
    shards: string[];
    /**
     * @generated from protobuf field: bool force = 12;
     */
    force: boolean;
}
/**
 * @generated from protobuf message vtctldata.WorkflowSwitchTrafficResponse
 */
export interface WorkflowSwitchTrafficResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: string start_state = 2;
     */
    startState: string;
    /**
     * @generated from protobuf field: string current_state = 3;
     */
    currentState: string;
    /**
     * @generated from protobuf field: repeated string dry_run_results = 4;
     */
    dryRunResults: string[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowUpdateRequest
 */
export interface WorkflowUpdateRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * TabletRequest gets passed on to each primary tablet involved
     * in the workflow via the UpdateVReplicationWorkflow tabletmanager RPC.
     *
     * @generated from protobuf field: tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request = 2;
     */
    tabletRequest?: UpdateVReplicationWorkflowRequest;
}
/**
 * @generated from protobuf message vtctldata.WorkflowUpdateResponse
 */
export interface WorkflowUpdateResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: repeated vtctldata.WorkflowUpdateResponse.TabletInfo details = 2;
     */
    details: WorkflowUpdateResponse_TabletInfo[];
}
/**
 * @generated from protobuf message vtctldata.WorkflowUpdateResponse.TabletInfo
 */
export interface WorkflowUpdateResponse_TabletInfo {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet = 1;
     */
    tablet?: TabletAlias;
    /**
     * Changed is true if any of the provided values were different
     * than what was already stored on this tablet.
     *
     * @generated from protobuf field: bool changed = 2;
     */
    changed: boolean;
}
/**
 * @generated from protobuf message vtctldata.GetMirrorRulesRequest
 */
export interface GetMirrorRulesRequest {
}
/**
 * @generated from protobuf message vtctldata.GetMirrorRulesResponse
 */
export interface GetMirrorRulesResponse {
    /**
     * @generated from protobuf field: vschema.MirrorRules mirror_rules = 1;
     */
    mirrorRules?: MirrorRules;
}
/**
 * @generated from protobuf message vtctldata.WorkflowMirrorTrafficRequest
 */
export interface WorkflowMirrorTrafficRequest {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 2;
     */
    workflow: string;
    /**
     * @generated from protobuf field: repeated topodata.TabletType tablet_types = 3;
     */
    tabletTypes: TabletType[];
    /**
     * @generated from protobuf field: float percent = 4;
     */
    percent: number;
}
/**
 * @generated from protobuf message vtctldata.WorkflowMirrorTrafficResponse
 */
export interface WorkflowMirrorTrafficResponse {
    /**
     * @generated from protobuf field: string summary = 1;
     */
    summary: string;
    /**
     * @generated from protobuf field: string start_state = 2;
     */
    startState: string;
    /**
     * @generated from protobuf field: string current_state = 3;
     */
    currentState: string;
}
/**
 * MaterializationIntent describes the reason for creating the Materialize flow
 *
 * @generated from protobuf enum vtctldata.MaterializationIntent
 */
export enum MaterializationIntent {
    /**
     * CUSTOM is the default value
     *
     * @generated from protobuf enum value: CUSTOM = 0;
     */
    CUSTOM = 0,
    /**
     * MOVETABLES is when we are creating a MoveTables flow
     *
     * @generated from protobuf enum value: MOVETABLES = 1;
     */
    MOVETABLES = 1,
    /**
     * CREATELOOKUPINDEX is when we are creating a CreateLookupIndex flow
     *
     * @generated from protobuf enum value: CREATELOOKUPINDEX = 2;
     */
    CREATELOOKUPINDEX = 2
}
/**
 * @generated from protobuf enum vtctldata.QueryOrdering
 */
export enum QueryOrdering {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: ASCENDING = 1;
     */
    ASCENDING = 1,
    /**
     * @generated from protobuf enum value: DESCENDING = 2;
     */
    DESCENDING = 2
}
/**
 * @generated from protobuf enum vtctldata.ShardedAutoIncrementHandling
 */
export enum ShardedAutoIncrementHandling {
    /**
     * @generated from protobuf enum value: LEAVE = 0;
     */
    LEAVE = 0,
    /**
     * @generated from protobuf enum value: REMOVE = 1;
     */
    REMOVE = 1,
    /**
     * @generated from protobuf enum value: REPLACE = 2;
     */
    REPLACE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteVtctlCommandRequest$Type extends MessageType<ExecuteVtctlCommandRequest> {
    constructor() {
        super("vtctldata.ExecuteVtctlCommandRequest", [
            { no: 1, name: "args", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action_timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteVtctlCommandRequest>): ExecuteVtctlCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.args = [];
        message.actionTimeout = 0n;
        if (value !== undefined)
            reflectionMergePartial<ExecuteVtctlCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteVtctlCommandRequest): ExecuteVtctlCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string args */ 1:
                    message.args.push(reader.string());
                    break;
                case /* int64 action_timeout */ 2:
                    message.actionTimeout = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteVtctlCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string args = 1; */
        for (let i = 0; i < message.args.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.args[i]);
        /* int64 action_timeout = 2; */
        if (message.actionTimeout !== 0n)
            writer.tag(2, WireType.Varint).int64(message.actionTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteVtctlCommandRequest
 */
export const ExecuteVtctlCommandRequest = new ExecuteVtctlCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteVtctlCommandResponse$Type extends MessageType<ExecuteVtctlCommandResponse> {
    constructor() {
        super("vtctldata.ExecuteVtctlCommandResponse", [
            { no: 1, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ExecuteVtctlCommandResponse>): ExecuteVtctlCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteVtctlCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteVtctlCommandResponse): ExecuteVtctlCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* logutil.Event event */ 1:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteVtctlCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* logutil.Event event = 1; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteVtctlCommandResponse
 */
export const ExecuteVtctlCommandResponse = new ExecuteVtctlCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableMaterializeSettings$Type extends MessageType<TableMaterializeSettings> {
    constructor() {
        super("vtctldata.TableMaterializeSettings", [
            { no: 1, name: "target_table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "create_ddl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TableMaterializeSettings>): TableMaterializeSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetTable = "";
        message.sourceExpression = "";
        message.createDdl = "";
        if (value !== undefined)
            reflectionMergePartial<TableMaterializeSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableMaterializeSettings): TableMaterializeSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target_table */ 1:
                    message.targetTable = reader.string();
                    break;
                case /* string source_expression */ 2:
                    message.sourceExpression = reader.string();
                    break;
                case /* string create_ddl */ 3:
                    message.createDdl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TableMaterializeSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target_table = 1; */
        if (message.targetTable !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetTable);
        /* string source_expression = 2; */
        if (message.sourceExpression !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceExpression);
        /* string create_ddl = 3; */
        if (message.createDdl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createDdl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.TableMaterializeSettings
 */
export const TableMaterializeSettings = new TableMaterializeSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterializeSettings$Type extends MessageType<MaterializeSettings> {
    constructor() {
        super("vtctldata.MaterializeSettings", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "stop_after_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "table_settings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TableMaterializeSettings },
            { no: 6, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "tablet_types", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "external_cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "materialization_intent", kind: "enum", T: () => ["vtctldata.MaterializationIntent", MaterializationIntent] },
            { no: 10, name: "source_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "target_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "source_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "on_ddl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "defer_secondary_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 16, name: "atomic_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "workflow_options", kind: "message", T: () => WorkflowOptions },
            { no: 18, name: "reference_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MaterializeSettings>): MaterializeSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.sourceKeyspace = "";
        message.targetKeyspace = "";
        message.stopAfterCopy = false;
        message.tableSettings = [];
        message.cell = "";
        message.tabletTypes = "";
        message.externalCluster = "";
        message.materializationIntent = 0;
        message.sourceTimeZone = "";
        message.targetTimeZone = "";
        message.sourceShards = [];
        message.onDdl = "";
        message.deferSecondaryKeys = false;
        message.tabletSelectionPreference = 0;
        message.atomicCopy = false;
        message.referenceTables = [];
        if (value !== undefined)
            reflectionMergePartial<MaterializeSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterializeSettings): MaterializeSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string source_keyspace */ 2:
                    message.sourceKeyspace = reader.string();
                    break;
                case /* string target_keyspace */ 3:
                    message.targetKeyspace = reader.string();
                    break;
                case /* bool stop_after_copy */ 4:
                    message.stopAfterCopy = reader.bool();
                    break;
                case /* repeated vtctldata.TableMaterializeSettings table_settings */ 5:
                    message.tableSettings.push(TableMaterializeSettings.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string cell */ 6:
                    message.cell = reader.string();
                    break;
                case /* string tablet_types */ 7:
                    message.tabletTypes = reader.string();
                    break;
                case /* string external_cluster */ 8:
                    message.externalCluster = reader.string();
                    break;
                case /* vtctldata.MaterializationIntent materialization_intent */ 9:
                    message.materializationIntent = reader.int32();
                    break;
                case /* string source_time_zone */ 10:
                    message.sourceTimeZone = reader.string();
                    break;
                case /* string target_time_zone */ 11:
                    message.targetTimeZone = reader.string();
                    break;
                case /* repeated string source_shards */ 12:
                    message.sourceShards.push(reader.string());
                    break;
                case /* string on_ddl */ 13:
                    message.onDdl = reader.string();
                    break;
                case /* bool defer_secondary_keys */ 14:
                    message.deferSecondaryKeys = reader.bool();
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 15:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* bool atomic_copy */ 16:
                    message.atomicCopy = reader.bool();
                    break;
                case /* vtctldata.WorkflowOptions workflow_options */ 17:
                    message.workflowOptions = WorkflowOptions.internalBinaryRead(reader, reader.uint32(), options, message.workflowOptions);
                    break;
                case /* repeated string reference_tables */ 18:
                    message.referenceTables.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterializeSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string source_keyspace = 2; */
        if (message.sourceKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceKeyspace);
        /* string target_keyspace = 3; */
        if (message.targetKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetKeyspace);
        /* bool stop_after_copy = 4; */
        if (message.stopAfterCopy !== false)
            writer.tag(4, WireType.Varint).bool(message.stopAfterCopy);
        /* repeated vtctldata.TableMaterializeSettings table_settings = 5; */
        for (let i = 0; i < message.tableSettings.length; i++)
            TableMaterializeSettings.internalBinaryWrite(message.tableSettings[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string cell = 6; */
        if (message.cell !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cell);
        /* string tablet_types = 7; */
        if (message.tabletTypes !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.tabletTypes);
        /* string external_cluster = 8; */
        if (message.externalCluster !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.externalCluster);
        /* vtctldata.MaterializationIntent materialization_intent = 9; */
        if (message.materializationIntent !== 0)
            writer.tag(9, WireType.Varint).int32(message.materializationIntent);
        /* string source_time_zone = 10; */
        if (message.sourceTimeZone !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.sourceTimeZone);
        /* string target_time_zone = 11; */
        if (message.targetTimeZone !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.targetTimeZone);
        /* repeated string source_shards = 12; */
        for (let i = 0; i < message.sourceShards.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.sourceShards[i]);
        /* string on_ddl = 13; */
        if (message.onDdl !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.onDdl);
        /* bool defer_secondary_keys = 14; */
        if (message.deferSecondaryKeys !== false)
            writer.tag(14, WireType.Varint).bool(message.deferSecondaryKeys);
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 15; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(15, WireType.Varint).int32(message.tabletSelectionPreference);
        /* bool atomic_copy = 16; */
        if (message.atomicCopy !== false)
            writer.tag(16, WireType.Varint).bool(message.atomicCopy);
        /* vtctldata.WorkflowOptions workflow_options = 17; */
        if (message.workflowOptions)
            WorkflowOptions.internalBinaryWrite(message.workflowOptions, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* repeated string reference_tables = 18; */
        for (let i = 0; i < message.referenceTables.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.referenceTables[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MaterializeSettings
 */
export const MaterializeSettings = new MaterializeSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Keyspace$Type extends MessageType<Keyspace> {
    constructor() {
        super("vtctldata.Keyspace", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "message", T: () => Keyspace$ }
        ]);
    }
    create(value?: PartialMessage<Keyspace>): Keyspace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Keyspace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Keyspace): Keyspace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.Keyspace keyspace */ 2:
                    message.keyspace = Keyspace$.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Keyspace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.Keyspace keyspace = 2; */
        if (message.keyspace)
            Keyspace$.internalBinaryWrite(message.keyspace, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Keyspace
 */
export const Keyspace = new Keyspace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaMigration$Type extends MessageType<SchemaMigration> {
    constructor() {
        super("vtctldata.SchemaMigration", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "migration_statement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "strategy", kind: "enum", T: () => ["vtctldata.SchemaMigration.Strategy", SchemaMigration_Strategy] },
            { no: 8, name: "options", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "added_at", kind: "message", T: () => Time },
            { no: 10, name: "requested_at", kind: "message", T: () => Time },
            { no: 11, name: "ready_at", kind: "message", T: () => Time },
            { no: 12, name: "started_at", kind: "message", T: () => Time },
            { no: 13, name: "liveness_timestamp", kind: "message", T: () => Time },
            { no: 14, name: "completed_at", kind: "message", T: () => Time },
            { no: 15, name: "cleaned_up_at", kind: "message", T: () => Time },
            { no: 16, name: "status", kind: "enum", T: () => ["vtctldata.SchemaMigration.Status", SchemaMigration_Status] },
            { no: 17, name: "log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "artifacts", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "retries", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 21, name: "tablet_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "progress", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 23, name: "migration_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "ddl_action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "eta_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 27, name: "rows_copied", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "table_rows", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 29, name: "added_unique_keys", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "removed_unique_keys", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "log_file", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "artifact_retention", kind: "message", T: () => Duration },
            { no: 33, name: "postpone_completion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "removed_unique_key_names", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "dropped_no_default_column_names", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "expanded_column_names", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 37, name: "revertible_notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "allow_concurrent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "reverted_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "is_view", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "ready_to_complete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "vitess_liveness_indicator", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 43, name: "user_throttle_ratio", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 44, name: "special_plan", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "last_throttled_at", kind: "message", T: () => Time },
            { no: 46, name: "component_throttled", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 47, name: "cancelled_at", kind: "message", T: () => Time },
            { no: 48, name: "postpone_launch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 49, name: "stage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 50, name: "cutover_attempts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 51, name: "is_immediate_operation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 52, name: "reviewed_at", kind: "message", T: () => Time },
            { no: 53, name: "ready_to_complete_at", kind: "message", T: () => Time },
            { no: 54, name: "removed_foreign_key_names", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaMigration>): SchemaMigration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.keyspace = "";
        message.shard = "";
        message.schema = "";
        message.table = "";
        message.migrationStatement = "";
        message.strategy = 0;
        message.options = "";
        message.status = 0;
        message.logPath = "";
        message.artifacts = "";
        message.retries = 0n;
        message.tabletFailure = false;
        message.progress = 0;
        message.migrationContext = "";
        message.ddlAction = "";
        message.message = "";
        message.etaSeconds = 0n;
        message.rowsCopied = 0n;
        message.tableRows = 0n;
        message.addedUniqueKeys = 0;
        message.removedUniqueKeys = 0;
        message.logFile = "";
        message.postponeCompletion = false;
        message.removedUniqueKeyNames = "";
        message.droppedNoDefaultColumnNames = "";
        message.expandedColumnNames = "";
        message.revertibleNotes = "";
        message.allowConcurrent = false;
        message.revertedUuid = "";
        message.isView = false;
        message.readyToComplete = false;
        message.vitessLivenessIndicator = 0n;
        message.userThrottleRatio = 0;
        message.specialPlan = "";
        message.componentThrottled = "";
        message.postponeLaunch = false;
        message.stage = "";
        message.cutoverAttempts = 0;
        message.isImmediateOperation = false;
        message.removedForeignKeyNames = "";
        if (value !== undefined)
            reflectionMergePartial<SchemaMigration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaMigration): SchemaMigration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* string schema */ 4:
                    message.schema = reader.string();
                    break;
                case /* string table */ 5:
                    message.table = reader.string();
                    break;
                case /* string migration_statement */ 6:
                    message.migrationStatement = reader.string();
                    break;
                case /* vtctldata.SchemaMigration.Strategy strategy */ 7:
                    message.strategy = reader.int32();
                    break;
                case /* string options */ 8:
                    message.options = reader.string();
                    break;
                case /* vttime.Time added_at */ 9:
                    message.addedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.addedAt);
                    break;
                case /* vttime.Time requested_at */ 10:
                    message.requestedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.requestedAt);
                    break;
                case /* vttime.Time ready_at */ 11:
                    message.readyAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.readyAt);
                    break;
                case /* vttime.Time started_at */ 12:
                    message.startedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);
                    break;
                case /* vttime.Time liveness_timestamp */ 13:
                    message.livenessTimestamp = Time.internalBinaryRead(reader, reader.uint32(), options, message.livenessTimestamp);
                    break;
                case /* vttime.Time completed_at */ 14:
                    message.completedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.completedAt);
                    break;
                case /* vttime.Time cleaned_up_at */ 15:
                    message.cleanedUpAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.cleanedUpAt);
                    break;
                case /* vtctldata.SchemaMigration.Status status */ 16:
                    message.status = reader.int32();
                    break;
                case /* string log_path */ 17:
                    message.logPath = reader.string();
                    break;
                case /* string artifacts */ 18:
                    message.artifacts = reader.string();
                    break;
                case /* uint64 retries */ 19:
                    message.retries = reader.uint64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet */ 20:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* bool tablet_failure */ 21:
                    message.tabletFailure = reader.bool();
                    break;
                case /* float progress */ 22:
                    message.progress = reader.float();
                    break;
                case /* string migration_context */ 23:
                    message.migrationContext = reader.string();
                    break;
                case /* string ddl_action */ 24:
                    message.ddlAction = reader.string();
                    break;
                case /* string message */ 25:
                    message.message = reader.string();
                    break;
                case /* int64 eta_seconds */ 26:
                    message.etaSeconds = reader.int64().toBigInt();
                    break;
                case /* uint64 rows_copied */ 27:
                    message.rowsCopied = reader.uint64().toBigInt();
                    break;
                case /* int64 table_rows */ 28:
                    message.tableRows = reader.int64().toBigInt();
                    break;
                case /* uint32 added_unique_keys */ 29:
                    message.addedUniqueKeys = reader.uint32();
                    break;
                case /* uint32 removed_unique_keys */ 30:
                    message.removedUniqueKeys = reader.uint32();
                    break;
                case /* string log_file */ 31:
                    message.logFile = reader.string();
                    break;
                case /* vttime.Duration artifact_retention */ 32:
                    message.artifactRetention = Duration.internalBinaryRead(reader, reader.uint32(), options, message.artifactRetention);
                    break;
                case /* bool postpone_completion */ 33:
                    message.postponeCompletion = reader.bool();
                    break;
                case /* string removed_unique_key_names */ 34:
                    message.removedUniqueKeyNames = reader.string();
                    break;
                case /* string dropped_no_default_column_names */ 35:
                    message.droppedNoDefaultColumnNames = reader.string();
                    break;
                case /* string expanded_column_names */ 36:
                    message.expandedColumnNames = reader.string();
                    break;
                case /* string revertible_notes */ 37:
                    message.revertibleNotes = reader.string();
                    break;
                case /* bool allow_concurrent */ 38:
                    message.allowConcurrent = reader.bool();
                    break;
                case /* string reverted_uuid */ 39:
                    message.revertedUuid = reader.string();
                    break;
                case /* bool is_view */ 40:
                    message.isView = reader.bool();
                    break;
                case /* bool ready_to_complete */ 41:
                    message.readyToComplete = reader.bool();
                    break;
                case /* int64 vitess_liveness_indicator */ 42:
                    message.vitessLivenessIndicator = reader.int64().toBigInt();
                    break;
                case /* float user_throttle_ratio */ 43:
                    message.userThrottleRatio = reader.float();
                    break;
                case /* string special_plan */ 44:
                    message.specialPlan = reader.string();
                    break;
                case /* vttime.Time last_throttled_at */ 45:
                    message.lastThrottledAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.lastThrottledAt);
                    break;
                case /* string component_throttled */ 46:
                    message.componentThrottled = reader.string();
                    break;
                case /* vttime.Time cancelled_at */ 47:
                    message.cancelledAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.cancelledAt);
                    break;
                case /* bool postpone_launch */ 48:
                    message.postponeLaunch = reader.bool();
                    break;
                case /* string stage */ 49:
                    message.stage = reader.string();
                    break;
                case /* uint32 cutover_attempts */ 50:
                    message.cutoverAttempts = reader.uint32();
                    break;
                case /* bool is_immediate_operation */ 51:
                    message.isImmediateOperation = reader.bool();
                    break;
                case /* vttime.Time reviewed_at */ 52:
                    message.reviewedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.reviewedAt);
                    break;
                case /* vttime.Time ready_to_complete_at */ 53:
                    message.readyToCompleteAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.readyToCompleteAt);
                    break;
                case /* string removed_foreign_key_names */ 54:
                    message.removedForeignKeyNames = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaMigration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* string schema = 4; */
        if (message.schema !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.schema);
        /* string table = 5; */
        if (message.table !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.table);
        /* string migration_statement = 6; */
        if (message.migrationStatement !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.migrationStatement);
        /* vtctldata.SchemaMigration.Strategy strategy = 7; */
        if (message.strategy !== 0)
            writer.tag(7, WireType.Varint).int32(message.strategy);
        /* string options = 8; */
        if (message.options !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.options);
        /* vttime.Time added_at = 9; */
        if (message.addedAt)
            Time.internalBinaryWrite(message.addedAt, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time requested_at = 10; */
        if (message.requestedAt)
            Time.internalBinaryWrite(message.requestedAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time ready_at = 11; */
        if (message.readyAt)
            Time.internalBinaryWrite(message.readyAt, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time started_at = 12; */
        if (message.startedAt)
            Time.internalBinaryWrite(message.startedAt, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time liveness_timestamp = 13; */
        if (message.livenessTimestamp)
            Time.internalBinaryWrite(message.livenessTimestamp, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time completed_at = 14; */
        if (message.completedAt)
            Time.internalBinaryWrite(message.completedAt, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time cleaned_up_at = 15; */
        if (message.cleanedUpAt)
            Time.internalBinaryWrite(message.cleanedUpAt, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.SchemaMigration.Status status = 16; */
        if (message.status !== 0)
            writer.tag(16, WireType.Varint).int32(message.status);
        /* string log_path = 17; */
        if (message.logPath !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.logPath);
        /* string artifacts = 18; */
        if (message.artifacts !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.artifacts);
        /* uint64 retries = 19; */
        if (message.retries !== 0n)
            writer.tag(19, WireType.Varint).uint64(message.retries);
        /* topodata.TabletAlias tablet = 20; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* bool tablet_failure = 21; */
        if (message.tabletFailure !== false)
            writer.tag(21, WireType.Varint).bool(message.tabletFailure);
        /* float progress = 22; */
        if (message.progress !== 0)
            writer.tag(22, WireType.Bit32).float(message.progress);
        /* string migration_context = 23; */
        if (message.migrationContext !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.migrationContext);
        /* string ddl_action = 24; */
        if (message.ddlAction !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.ddlAction);
        /* string message = 25; */
        if (message.message !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.message);
        /* int64 eta_seconds = 26; */
        if (message.etaSeconds !== 0n)
            writer.tag(26, WireType.Varint).int64(message.etaSeconds);
        /* uint64 rows_copied = 27; */
        if (message.rowsCopied !== 0n)
            writer.tag(27, WireType.Varint).uint64(message.rowsCopied);
        /* int64 table_rows = 28; */
        if (message.tableRows !== 0n)
            writer.tag(28, WireType.Varint).int64(message.tableRows);
        /* uint32 added_unique_keys = 29; */
        if (message.addedUniqueKeys !== 0)
            writer.tag(29, WireType.Varint).uint32(message.addedUniqueKeys);
        /* uint32 removed_unique_keys = 30; */
        if (message.removedUniqueKeys !== 0)
            writer.tag(30, WireType.Varint).uint32(message.removedUniqueKeys);
        /* string log_file = 31; */
        if (message.logFile !== "")
            writer.tag(31, WireType.LengthDelimited).string(message.logFile);
        /* vttime.Duration artifact_retention = 32; */
        if (message.artifactRetention)
            Duration.internalBinaryWrite(message.artifactRetention, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* bool postpone_completion = 33; */
        if (message.postponeCompletion !== false)
            writer.tag(33, WireType.Varint).bool(message.postponeCompletion);
        /* string removed_unique_key_names = 34; */
        if (message.removedUniqueKeyNames !== "")
            writer.tag(34, WireType.LengthDelimited).string(message.removedUniqueKeyNames);
        /* string dropped_no_default_column_names = 35; */
        if (message.droppedNoDefaultColumnNames !== "")
            writer.tag(35, WireType.LengthDelimited).string(message.droppedNoDefaultColumnNames);
        /* string expanded_column_names = 36; */
        if (message.expandedColumnNames !== "")
            writer.tag(36, WireType.LengthDelimited).string(message.expandedColumnNames);
        /* string revertible_notes = 37; */
        if (message.revertibleNotes !== "")
            writer.tag(37, WireType.LengthDelimited).string(message.revertibleNotes);
        /* bool allow_concurrent = 38; */
        if (message.allowConcurrent !== false)
            writer.tag(38, WireType.Varint).bool(message.allowConcurrent);
        /* string reverted_uuid = 39; */
        if (message.revertedUuid !== "")
            writer.tag(39, WireType.LengthDelimited).string(message.revertedUuid);
        /* bool is_view = 40; */
        if (message.isView !== false)
            writer.tag(40, WireType.Varint).bool(message.isView);
        /* bool ready_to_complete = 41; */
        if (message.readyToComplete !== false)
            writer.tag(41, WireType.Varint).bool(message.readyToComplete);
        /* int64 vitess_liveness_indicator = 42; */
        if (message.vitessLivenessIndicator !== 0n)
            writer.tag(42, WireType.Varint).int64(message.vitessLivenessIndicator);
        /* float user_throttle_ratio = 43; */
        if (message.userThrottleRatio !== 0)
            writer.tag(43, WireType.Bit32).float(message.userThrottleRatio);
        /* string special_plan = 44; */
        if (message.specialPlan !== "")
            writer.tag(44, WireType.LengthDelimited).string(message.specialPlan);
        /* vttime.Time last_throttled_at = 45; */
        if (message.lastThrottledAt)
            Time.internalBinaryWrite(message.lastThrottledAt, writer.tag(45, WireType.LengthDelimited).fork(), options).join();
        /* string component_throttled = 46; */
        if (message.componentThrottled !== "")
            writer.tag(46, WireType.LengthDelimited).string(message.componentThrottled);
        /* vttime.Time cancelled_at = 47; */
        if (message.cancelledAt)
            Time.internalBinaryWrite(message.cancelledAt, writer.tag(47, WireType.LengthDelimited).fork(), options).join();
        /* bool postpone_launch = 48; */
        if (message.postponeLaunch !== false)
            writer.tag(48, WireType.Varint).bool(message.postponeLaunch);
        /* string stage = 49; */
        if (message.stage !== "")
            writer.tag(49, WireType.LengthDelimited).string(message.stage);
        /* uint32 cutover_attempts = 50; */
        if (message.cutoverAttempts !== 0)
            writer.tag(50, WireType.Varint).uint32(message.cutoverAttempts);
        /* bool is_immediate_operation = 51; */
        if (message.isImmediateOperation !== false)
            writer.tag(51, WireType.Varint).bool(message.isImmediateOperation);
        /* vttime.Time reviewed_at = 52; */
        if (message.reviewedAt)
            Time.internalBinaryWrite(message.reviewedAt, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time ready_to_complete_at = 53; */
        if (message.readyToCompleteAt)
            Time.internalBinaryWrite(message.readyToCompleteAt, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* string removed_foreign_key_names = 54; */
        if (message.removedForeignKeyNames !== "")
            writer.tag(54, WireType.LengthDelimited).string(message.removedForeignKeyNames);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SchemaMigration
 */
export const SchemaMigration = new SchemaMigration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shard$Type extends MessageType<Shard> {
    constructor() {
        super("vtctldata.Shard", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<Shard>): Shard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Shard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shard): Shard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* topodata.Shard shard */ 3:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* topodata.Shard shard = 3; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Shard
 */
export const Shard = new Shard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowOptions$Type extends MessageType<WorkflowOptions> {
    constructor() {
        super("vtctldata.WorkflowOptions", [
            { no: 1, name: "tenant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sharded_auto_increment_handling", kind: "enum", T: () => ["vtctldata.ShardedAutoIncrementHandling", ShardedAutoIncrementHandling] },
            { no: 3, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "global_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowOptions>): WorkflowOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tenantId = "";
        message.shardedAutoIncrementHandling = 0;
        message.shards = [];
        message.config = {};
        message.globalKeyspace = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowOptions): WorkflowOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id */ 1:
                    message.tenantId = reader.string();
                    break;
                case /* vtctldata.ShardedAutoIncrementHandling sharded_auto_increment_handling */ 2:
                    message.shardedAutoIncrementHandling = reader.int32();
                    break;
                case /* repeated string shards */ 3:
                    message.shards.push(reader.string());
                    break;
                case /* map<string, string> config */ 4:
                    this.binaryReadMap4(message.config, reader, options);
                    break;
                case /* string global_keyspace */ 5:
                    message.globalKeyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: WorkflowOptions["config"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WorkflowOptions["config"] | undefined, val: WorkflowOptions["config"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.WorkflowOptions.config");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WorkflowOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* vtctldata.ShardedAutoIncrementHandling sharded_auto_increment_handling = 2; */
        if (message.shardedAutoIncrementHandling !== 0)
            writer.tag(2, WireType.Varint).int32(message.shardedAutoIncrementHandling);
        /* repeated string shards = 3; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.shards[i]);
        /* map<string, string> config = 4; */
        for (let k of globalThis.Object.keys(message.config))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.config[k]).join();
        /* string global_keyspace = 5; */
        if (message.globalKeyspace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.globalKeyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowOptions
 */
export const WorkflowOptions = new WorkflowOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow$Type extends MessageType<Workflow> {
    constructor() {
        super("vtctldata.Workflow", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source", kind: "message", T: () => Workflow_ReplicationLocation },
            { no: 3, name: "target", kind: "message", T: () => Workflow_ReplicationLocation },
            { no: 4, name: "max_v_replication_lag", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "shard_streams", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Workflow_ShardStream } },
            { no: 6, name: "workflow_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "workflow_sub_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "max_v_replication_transaction_lag", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "defer_secondary_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "options", kind: "message", T: () => WorkflowOptions }
        ]);
    }
    create(value?: PartialMessage<Workflow>): Workflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.maxVReplicationLag = 0n;
        message.shardStreams = {};
        message.workflowType = "";
        message.workflowSubType = "";
        message.maxVReplicationTransactionLag = 0n;
        message.deferSecondaryKeys = false;
        if (value !== undefined)
            reflectionMergePartial<Workflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow): Workflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* vtctldata.Workflow.ReplicationLocation source */ 2:
                    message.source = Workflow_ReplicationLocation.internalBinaryRead(reader, reader.uint32(), options, message.source);
                    break;
                case /* vtctldata.Workflow.ReplicationLocation target */ 3:
                    message.target = Workflow_ReplicationLocation.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 max_v_replication_lag */ 4:
                    message.maxVReplicationLag = reader.int64().toBigInt();
                    break;
                case /* map<string, vtctldata.Workflow.ShardStream> shard_streams */ 5:
                    this.binaryReadMap5(message.shardStreams, reader, options);
                    break;
                case /* string workflow_type */ 6:
                    message.workflowType = reader.string();
                    break;
                case /* string workflow_sub_type */ 7:
                    message.workflowSubType = reader.string();
                    break;
                case /* int64 max_v_replication_transaction_lag */ 8:
                    message.maxVReplicationTransactionLag = reader.int64().toBigInt();
                    break;
                case /* bool defer_secondary_keys */ 9:
                    message.deferSecondaryKeys = reader.bool();
                    break;
                case /* vtctldata.WorkflowOptions options */ 10:
                    message.options = WorkflowOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: Workflow["shardStreams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Workflow["shardStreams"] | undefined, val: Workflow["shardStreams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Workflow_ShardStream.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.Workflow.shard_streams");
            }
        }
        map[key ?? ""] = val ?? Workflow_ShardStream.create();
    }
    internalBinaryWrite(message: Workflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* vtctldata.Workflow.ReplicationLocation source = 2; */
        if (message.source)
            Workflow_ReplicationLocation.internalBinaryWrite(message.source, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.Workflow.ReplicationLocation target = 3; */
        if (message.target)
            Workflow_ReplicationLocation.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 max_v_replication_lag = 4; */
        if (message.maxVReplicationLag !== 0n)
            writer.tag(4, WireType.Varint).int64(message.maxVReplicationLag);
        /* map<string, vtctldata.Workflow.ShardStream> shard_streams = 5; */
        for (let k of globalThis.Object.keys(message.shardStreams)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Workflow_ShardStream.internalBinaryWrite(message.shardStreams[k], writer, options);
            writer.join().join();
        }
        /* string workflow_type = 6; */
        if (message.workflowType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.workflowType);
        /* string workflow_sub_type = 7; */
        if (message.workflowSubType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.workflowSubType);
        /* int64 max_v_replication_transaction_lag = 8; */
        if (message.maxVReplicationTransactionLag !== 0n)
            writer.tag(8, WireType.Varint).int64(message.maxVReplicationTransactionLag);
        /* bool defer_secondary_keys = 9; */
        if (message.deferSecondaryKeys !== false)
            writer.tag(9, WireType.Varint).bool(message.deferSecondaryKeys);
        /* vtctldata.WorkflowOptions options = 10; */
        if (message.options)
            WorkflowOptions.internalBinaryWrite(message.options, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow
 */
export const Workflow = new Workflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_ReplicationLocation$Type extends MessageType<Workflow_ReplicationLocation> {
    constructor() {
        super("vtctldata.Workflow.ReplicationLocation", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_ReplicationLocation>): Workflow_ReplicationLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shards = [];
        if (value !== undefined)
            reflectionMergePartial<Workflow_ReplicationLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_ReplicationLocation): Workflow_ReplicationLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string shards */ 2:
                    message.shards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_ReplicationLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string shards = 2; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.shards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.ReplicationLocation
 */
export const Workflow_ReplicationLocation = new Workflow_ReplicationLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_ShardStream$Type extends MessageType<Workflow_ShardStream> {
    constructor() {
        super("vtctldata.Workflow.ShardStream", [
            { no: 1, name: "streams", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Workflow_Stream },
            { no: 2, name: "tablet_controls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Shard_TabletControl },
            { no: 3, name: "is_primary_serving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_ShardStream>): Workflow_ShardStream {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streams = [];
        message.tabletControls = [];
        message.isPrimaryServing = false;
        if (value !== undefined)
            reflectionMergePartial<Workflow_ShardStream>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_ShardStream): Workflow_ShardStream {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.Workflow.Stream streams */ 1:
                    message.streams.push(Workflow_Stream.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated topodata.Shard.TabletControl tablet_controls */ 2:
                    message.tabletControls.push(Shard_TabletControl.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_primary_serving */ 3:
                    message.isPrimaryServing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_ShardStream, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.Workflow.Stream streams = 1; */
        for (let i = 0; i < message.streams.length; i++)
            Workflow_Stream.internalBinaryWrite(message.streams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.Shard.TabletControl tablet_controls = 2; */
        for (let i = 0; i < message.tabletControls.length; i++)
            Shard_TabletControl.internalBinaryWrite(message.tabletControls[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool is_primary_serving = 3; */
        if (message.isPrimaryServing !== false)
            writer.tag(3, WireType.Varint).bool(message.isPrimaryServing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.ShardStream
 */
export const Workflow_ShardStream = new Workflow_ShardStream$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_Stream$Type extends MessageType<Workflow_Stream> {
    constructor() {
        super("vtctldata.Workflow.Stream", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 4, name: "binlog_source", kind: "message", T: () => BinlogSource },
            { no: 5, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "stop_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "db_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "transaction_timestamp", kind: "message", T: () => Time },
            { no: 10, name: "time_updated", kind: "message", T: () => Time },
            { no: 11, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "copy_states", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Workflow_Stream_CopyState },
            { no: 13, name: "logs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Workflow_Stream_Log },
            { no: 14, name: "log_fetch_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "rows_copied", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "throttler_status", kind: "message", T: () => Workflow_Stream_ThrottlerStatus },
            { no: 18, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 19, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 20, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_Stream>): Workflow_Stream {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.shard = "";
        message.position = "";
        message.stopPosition = "";
        message.state = "";
        message.dbName = "";
        message.message = "";
        message.copyStates = [];
        message.logs = [];
        message.logFetchError = "";
        message.tags = [];
        message.rowsCopied = 0n;
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<Workflow_Stream>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_Stream): Workflow_Stream {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias tablet */ 3:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* binlogdata.BinlogSource binlog_source */ 4:
                    message.binlogSource = BinlogSource.internalBinaryRead(reader, reader.uint32(), options, message.binlogSource);
                    break;
                case /* string position */ 5:
                    message.position = reader.string();
                    break;
                case /* string stop_position */ 6:
                    message.stopPosition = reader.string();
                    break;
                case /* string state */ 7:
                    message.state = reader.string();
                    break;
                case /* string db_name */ 8:
                    message.dbName = reader.string();
                    break;
                case /* vttime.Time transaction_timestamp */ 9:
                    message.transactionTimestamp = Time.internalBinaryRead(reader, reader.uint32(), options, message.transactionTimestamp);
                    break;
                case /* vttime.Time time_updated */ 10:
                    message.timeUpdated = Time.internalBinaryRead(reader, reader.uint32(), options, message.timeUpdated);
                    break;
                case /* string message */ 11:
                    message.message = reader.string();
                    break;
                case /* repeated vtctldata.Workflow.Stream.CopyState copy_states */ 12:
                    message.copyStates.push(Workflow_Stream_CopyState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vtctldata.Workflow.Stream.Log logs */ 13:
                    message.logs.push(Workflow_Stream_Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string log_fetch_error */ 14:
                    message.logFetchError = reader.string();
                    break;
                case /* repeated string tags */ 15:
                    message.tags.push(reader.string());
                    break;
                case /* int64 rows_copied */ 16:
                    message.rowsCopied = reader.int64().toBigInt();
                    break;
                case /* vtctldata.Workflow.Stream.ThrottlerStatus throttler_status */ 17:
                    message.throttlerStatus = Workflow_Stream_ThrottlerStatus.internalBinaryRead(reader, reader.uint32(), options, message.throttlerStatus);
                    break;
                case /* repeated topodata.TabletType tablet_types */ 18:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 19:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* repeated string cells */ 20:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_Stream, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias tablet = 3; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.BinlogSource binlog_source = 4; */
        if (message.binlogSource)
            BinlogSource.internalBinaryWrite(message.binlogSource, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string position = 5; */
        if (message.position !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.position);
        /* string stop_position = 6; */
        if (message.stopPosition !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.stopPosition);
        /* string state = 7; */
        if (message.state !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.state);
        /* string db_name = 8; */
        if (message.dbName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.dbName);
        /* vttime.Time transaction_timestamp = 9; */
        if (message.transactionTimestamp)
            Time.internalBinaryWrite(message.transactionTimestamp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time time_updated = 10; */
        if (message.timeUpdated)
            Time.internalBinaryWrite(message.timeUpdated, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string message = 11; */
        if (message.message !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.message);
        /* repeated vtctldata.Workflow.Stream.CopyState copy_states = 12; */
        for (let i = 0; i < message.copyStates.length; i++)
            Workflow_Stream_CopyState.internalBinaryWrite(message.copyStates[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated vtctldata.Workflow.Stream.Log logs = 13; */
        for (let i = 0; i < message.logs.length; i++)
            Workflow_Stream_Log.internalBinaryWrite(message.logs[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* string log_fetch_error = 14; */
        if (message.logFetchError !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.logFetchError);
        /* repeated string tags = 15; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(15, WireType.LengthDelimited).string(message.tags[i]);
        /* int64 rows_copied = 16; */
        if (message.rowsCopied !== 0n)
            writer.tag(16, WireType.Varint).int64(message.rowsCopied);
        /* vtctldata.Workflow.Stream.ThrottlerStatus throttler_status = 17; */
        if (message.throttlerStatus)
            Workflow_Stream_ThrottlerStatus.internalBinaryWrite(message.throttlerStatus, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.TabletType tablet_types = 18; */
        if (message.tabletTypes.length) {
            writer.tag(18, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 19; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(19, WireType.Varint).int32(message.tabletSelectionPreference);
        /* repeated string cells = 20; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(20, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.Stream
 */
export const Workflow_Stream = new Workflow_Stream$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_Stream_CopyState$Type extends MessageType<Workflow_Stream_CopyState> {
    constructor() {
        super("vtctldata.Workflow.Stream.CopyState", [
            { no: 1, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_pk", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stream_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_Stream_CopyState>): Workflow_Stream_CopyState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.table = "";
        message.lastPk = "";
        message.streamId = 0n;
        if (value !== undefined)
            reflectionMergePartial<Workflow_Stream_CopyState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_Stream_CopyState): Workflow_Stream_CopyState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table */ 1:
                    message.table = reader.string();
                    break;
                case /* string last_pk */ 2:
                    message.lastPk = reader.string();
                    break;
                case /* int64 stream_id */ 3:
                    message.streamId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_Stream_CopyState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table = 1; */
        if (message.table !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        /* string last_pk = 2; */
        if (message.lastPk !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.lastPk);
        /* int64 stream_id = 3; */
        if (message.streamId !== 0n)
            writer.tag(3, WireType.Varint).int64(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.Stream.CopyState
 */
export const Workflow_Stream_CopyState = new Workflow_Stream_CopyState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_Stream_Log$Type extends MessageType<Workflow_Stream_Log> {
    constructor() {
        super("vtctldata.Workflow.Stream.Log", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "stream_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "created_at", kind: "message", T: () => Time },
            { no: 6, name: "updated_at", kind: "message", T: () => Time },
            { no: 7, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow_Stream_Log>): Workflow_Stream_Log {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.streamId = 0n;
        message.type = "";
        message.state = "";
        message.message = "";
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<Workflow_Stream_Log>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_Stream_Log): Workflow_Stream_Log {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* int64 stream_id */ 2:
                    message.streamId = reader.int64().toBigInt();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* string state */ 4:
                    message.state = reader.string();
                    break;
                case /* vttime.Time created_at */ 5:
                    message.createdAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* vttime.Time updated_at */ 6:
                    message.updatedAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                case /* string message */ 7:
                    message.message = reader.string();
                    break;
                case /* int64 count */ 8:
                    message.count = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_Stream_Log, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* int64 stream_id = 2; */
        if (message.streamId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.streamId);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* string state = 4; */
        if (message.state !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.state);
        /* vttime.Time created_at = 5; */
        if (message.createdAt)
            Time.internalBinaryWrite(message.createdAt, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time updated_at = 6; */
        if (message.updatedAt)
            Time.internalBinaryWrite(message.updatedAt, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string message = 7; */
        if (message.message !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.message);
        /* int64 count = 8; */
        if (message.count !== 0n)
            writer.tag(8, WireType.Varint).int64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.Stream.Log
 */
export const Workflow_Stream_Log = new Workflow_Stream_Log$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow_Stream_ThrottlerStatus$Type extends MessageType<Workflow_Stream_ThrottlerStatus> {
    constructor() {
        super("vtctldata.Workflow.Stream.ThrottlerStatus", [
            { no: 1, name: "component_throttled", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "time_throttled", kind: "message", T: () => Time }
        ]);
    }
    create(value?: PartialMessage<Workflow_Stream_ThrottlerStatus>): Workflow_Stream_ThrottlerStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.componentThrottled = "";
        if (value !== undefined)
            reflectionMergePartial<Workflow_Stream_ThrottlerStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow_Stream_ThrottlerStatus): Workflow_Stream_ThrottlerStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string component_throttled */ 1:
                    message.componentThrottled = reader.string();
                    break;
                case /* vttime.Time time_throttled */ 2:
                    message.timeThrottled = Time.internalBinaryRead(reader, reader.uint32(), options, message.timeThrottled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow_Stream_ThrottlerStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string component_throttled = 1; */
        if (message.componentThrottled !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.componentThrottled);
        /* vttime.Time time_throttled = 2; */
        if (message.timeThrottled)
            Time.internalBinaryWrite(message.timeThrottled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.Workflow.Stream.ThrottlerStatus
 */
export const Workflow_Stream_ThrottlerStatus = new Workflow_Stream_ThrottlerStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddCellInfoRequest$Type extends MessageType<AddCellInfoRequest> {
    constructor() {
        super("vtctldata.AddCellInfoRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cell_info", kind: "message", T: () => CellInfo }
        ]);
    }
    create(value?: PartialMessage<AddCellInfoRequest>): AddCellInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<AddCellInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddCellInfoRequest): AddCellInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.CellInfo cell_info */ 2:
                    message.cellInfo = CellInfo.internalBinaryRead(reader, reader.uint32(), options, message.cellInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddCellInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.CellInfo cell_info = 2; */
        if (message.cellInfo)
            CellInfo.internalBinaryWrite(message.cellInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.AddCellInfoRequest
 */
export const AddCellInfoRequest = new AddCellInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddCellInfoResponse$Type extends MessageType<AddCellInfoResponse> {
    constructor() {
        super("vtctldata.AddCellInfoResponse", []);
    }
    create(value?: PartialMessage<AddCellInfoResponse>): AddCellInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddCellInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddCellInfoResponse): AddCellInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddCellInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.AddCellInfoResponse
 */
export const AddCellInfoResponse = new AddCellInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddCellsAliasRequest$Type extends MessageType<AddCellsAliasRequest> {
    constructor() {
        super("vtctldata.AddCellsAliasRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddCellsAliasRequest>): AddCellsAliasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<AddCellsAliasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddCellsAliasRequest): AddCellsAliasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddCellsAliasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.AddCellsAliasRequest
 */
export const AddCellsAliasRequest = new AddCellsAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddCellsAliasResponse$Type extends MessageType<AddCellsAliasResponse> {
    constructor() {
        super("vtctldata.AddCellsAliasResponse", []);
    }
    create(value?: PartialMessage<AddCellsAliasResponse>): AddCellsAliasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddCellsAliasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddCellsAliasResponse): AddCellsAliasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddCellsAliasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.AddCellsAliasResponse
 */
export const AddCellsAliasResponse = new AddCellsAliasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyKeyspaceRoutingRulesRequest$Type extends MessageType<ApplyKeyspaceRoutingRulesRequest> {
    constructor() {
        super("vtctldata.ApplyKeyspaceRoutingRulesRequest", [
            { no: 1, name: "keyspace_routing_rules", kind: "message", T: () => KeyspaceRoutingRules },
            { no: 2, name: "skip_rebuild", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "rebuild_cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyKeyspaceRoutingRulesRequest>): ApplyKeyspaceRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skipRebuild = false;
        message.rebuildCells = [];
        if (value !== undefined)
            reflectionMergePartial<ApplyKeyspaceRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyKeyspaceRoutingRulesRequest): ApplyKeyspaceRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.KeyspaceRoutingRules keyspace_routing_rules */ 1:
                    message.keyspaceRoutingRules = KeyspaceRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.keyspaceRoutingRules);
                    break;
                case /* bool skip_rebuild */ 2:
                    message.skipRebuild = reader.bool();
                    break;
                case /* repeated string rebuild_cells */ 3:
                    message.rebuildCells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyKeyspaceRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.KeyspaceRoutingRules keyspace_routing_rules = 1; */
        if (message.keyspaceRoutingRules)
            KeyspaceRoutingRules.internalBinaryWrite(message.keyspaceRoutingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_rebuild = 2; */
        if (message.skipRebuild !== false)
            writer.tag(2, WireType.Varint).bool(message.skipRebuild);
        /* repeated string rebuild_cells = 3; */
        for (let i = 0; i < message.rebuildCells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rebuildCells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyKeyspaceRoutingRulesRequest
 */
export const ApplyKeyspaceRoutingRulesRequest = new ApplyKeyspaceRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyKeyspaceRoutingRulesResponse$Type extends MessageType<ApplyKeyspaceRoutingRulesResponse> {
    constructor() {
        super("vtctldata.ApplyKeyspaceRoutingRulesResponse", [
            { no: 1, name: "keyspace_routing_rules", kind: "message", T: () => KeyspaceRoutingRules }
        ]);
    }
    create(value?: PartialMessage<ApplyKeyspaceRoutingRulesResponse>): ApplyKeyspaceRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ApplyKeyspaceRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyKeyspaceRoutingRulesResponse): ApplyKeyspaceRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.KeyspaceRoutingRules keyspace_routing_rules */ 1:
                    message.keyspaceRoutingRules = KeyspaceRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.keyspaceRoutingRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyKeyspaceRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.KeyspaceRoutingRules keyspace_routing_rules = 1; */
        if (message.keyspaceRoutingRules)
            KeyspaceRoutingRules.internalBinaryWrite(message.keyspaceRoutingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyKeyspaceRoutingRulesResponse
 */
export const ApplyKeyspaceRoutingRulesResponse = new ApplyKeyspaceRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyRoutingRulesRequest$Type extends MessageType<ApplyRoutingRulesRequest> {
    constructor() {
        super("vtctldata.ApplyRoutingRulesRequest", [
            { no: 1, name: "routing_rules", kind: "message", T: () => RoutingRules },
            { no: 2, name: "skip_rebuild", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "rebuild_cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyRoutingRulesRequest>): ApplyRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skipRebuild = false;
        message.rebuildCells = [];
        if (value !== undefined)
            reflectionMergePartial<ApplyRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyRoutingRulesRequest): ApplyRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.RoutingRules routing_rules */ 1:
                    message.routingRules = RoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.routingRules);
                    break;
                case /* bool skip_rebuild */ 2:
                    message.skipRebuild = reader.bool();
                    break;
                case /* repeated string rebuild_cells */ 3:
                    message.rebuildCells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.RoutingRules routing_rules = 1; */
        if (message.routingRules)
            RoutingRules.internalBinaryWrite(message.routingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_rebuild = 2; */
        if (message.skipRebuild !== false)
            writer.tag(2, WireType.Varint).bool(message.skipRebuild);
        /* repeated string rebuild_cells = 3; */
        for (let i = 0; i < message.rebuildCells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rebuildCells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyRoutingRulesRequest
 */
export const ApplyRoutingRulesRequest = new ApplyRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyRoutingRulesResponse$Type extends MessageType<ApplyRoutingRulesResponse> {
    constructor() {
        super("vtctldata.ApplyRoutingRulesResponse", []);
    }
    create(value?: PartialMessage<ApplyRoutingRulesResponse>): ApplyRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ApplyRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyRoutingRulesResponse): ApplyRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyRoutingRulesResponse
 */
export const ApplyRoutingRulesResponse = new ApplyRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyShardRoutingRulesRequest$Type extends MessageType<ApplyShardRoutingRulesRequest> {
    constructor() {
        super("vtctldata.ApplyShardRoutingRulesRequest", [
            { no: 1, name: "shard_routing_rules", kind: "message", T: () => ShardRoutingRules },
            { no: 2, name: "skip_rebuild", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "rebuild_cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyShardRoutingRulesRequest>): ApplyShardRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skipRebuild = false;
        message.rebuildCells = [];
        if (value !== undefined)
            reflectionMergePartial<ApplyShardRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyShardRoutingRulesRequest): ApplyShardRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.ShardRoutingRules shard_routing_rules */ 1:
                    message.shardRoutingRules = ShardRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.shardRoutingRules);
                    break;
                case /* bool skip_rebuild */ 2:
                    message.skipRebuild = reader.bool();
                    break;
                case /* repeated string rebuild_cells */ 3:
                    message.rebuildCells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyShardRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.ShardRoutingRules shard_routing_rules = 1; */
        if (message.shardRoutingRules)
            ShardRoutingRules.internalBinaryWrite(message.shardRoutingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_rebuild = 2; */
        if (message.skipRebuild !== false)
            writer.tag(2, WireType.Varint).bool(message.skipRebuild);
        /* repeated string rebuild_cells = 3; */
        for (let i = 0; i < message.rebuildCells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rebuildCells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyShardRoutingRulesRequest
 */
export const ApplyShardRoutingRulesRequest = new ApplyShardRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyShardRoutingRulesResponse$Type extends MessageType<ApplyShardRoutingRulesResponse> {
    constructor() {
        super("vtctldata.ApplyShardRoutingRulesResponse", []);
    }
    create(value?: PartialMessage<ApplyShardRoutingRulesResponse>): ApplyShardRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ApplyShardRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyShardRoutingRulesResponse): ApplyShardRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyShardRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyShardRoutingRulesResponse
 */
export const ApplyShardRoutingRulesResponse = new ApplyShardRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplySchemaRequest$Type extends MessageType<ApplySchemaRequest> {
    constructor() {
        super("vtctldata.ApplySchemaRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sql", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ddl_strategy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "uuid_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "migration_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "wait_replicas_timeout", kind: "message", T: () => Duration },
            { no: 9, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 10, name: "batch_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ApplySchemaRequest>): ApplySchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.sql = [];
        message.ddlStrategy = "";
        message.uuidList = [];
        message.migrationContext = "";
        message.batchSize = 0n;
        if (value !== undefined)
            reflectionMergePartial<ApplySchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplySchemaRequest): ApplySchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string sql */ 3:
                    message.sql.push(reader.string());
                    break;
                case /* string ddl_strategy */ 4:
                    message.ddlStrategy = reader.string();
                    break;
                case /* repeated string uuid_list */ 5:
                    message.uuidList.push(reader.string());
                    break;
                case /* string migration_context */ 6:
                    message.migrationContext = reader.string();
                    break;
                case /* vttime.Duration wait_replicas_timeout */ 7:
                    message.waitReplicasTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.waitReplicasTimeout);
                    break;
                case /* vtrpc.CallerID caller_id */ 9:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* int64 batch_size */ 10:
                    message.batchSize = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplySchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string sql = 3; */
        for (let i = 0; i < message.sql.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.sql[i]);
        /* string ddl_strategy = 4; */
        if (message.ddlStrategy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ddlStrategy);
        /* repeated string uuid_list = 5; */
        for (let i = 0; i < message.uuidList.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.uuidList[i]);
        /* string migration_context = 6; */
        if (message.migrationContext !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.migrationContext);
        /* vttime.Duration wait_replicas_timeout = 7; */
        if (message.waitReplicasTimeout)
            Duration.internalBinaryWrite(message.waitReplicasTimeout, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* vtrpc.CallerID caller_id = 9; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 batch_size = 10; */
        if (message.batchSize !== 0n)
            writer.tag(10, WireType.Varint).int64(message.batchSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplySchemaRequest
 */
export const ApplySchemaRequest = new ApplySchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplySchemaResponse$Type extends MessageType<ApplySchemaResponse> {
    constructor() {
        super("vtctldata.ApplySchemaResponse", [
            { no: 1, name: "uuid_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<ApplySchemaResponse>): ApplySchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuidList = [];
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ApplySchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplySchemaResponse): ApplySchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string uuid_list */ 1:
                    message.uuidList.push(reader.string());
                    break;
                case /* map<string, uint64> rows_affected_by_shard */ 2:
                    this.binaryReadMap2(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ApplySchemaResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ApplySchemaResponse["rowsAffectedByShard"] | undefined, val: ApplySchemaResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ApplySchemaResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: ApplySchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string uuid_list = 1; */
        for (let i = 0; i < message.uuidList.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.uuidList[i]);
        /* map<string, uint64> rows_affected_by_shard = 2; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplySchemaResponse
 */
export const ApplySchemaResponse = new ApplySchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyVSchemaRequest$Type extends MessageType<ApplyVSchemaRequest> {
    constructor() {
        super("vtctldata.ApplyVSchemaRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "skip_rebuild", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "v_schema", kind: "message", T: () => Keyspace$2 },
            { no: 6, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "strict", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyVSchemaRequest>): ApplyVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.skipRebuild = false;
        message.dryRun = false;
        message.cells = [];
        message.sql = "";
        message.strict = false;
        if (value !== undefined)
            reflectionMergePartial<ApplyVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyVSchemaRequest): ApplyVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool skip_rebuild */ 2:
                    message.skipRebuild = reader.bool();
                    break;
                case /* bool dry_run */ 3:
                    message.dryRun = reader.bool();
                    break;
                case /* repeated string cells */ 4:
                    message.cells.push(reader.string());
                    break;
                case /* vschema.Keyspace v_schema */ 5:
                    message.vSchema = Keyspace$2.internalBinaryRead(reader, reader.uint32(), options, message.vSchema);
                    break;
                case /* string sql */ 6:
                    message.sql = reader.string();
                    break;
                case /* bool strict */ 7:
                    message.strict = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool skip_rebuild = 2; */
        if (message.skipRebuild !== false)
            writer.tag(2, WireType.Varint).bool(message.skipRebuild);
        /* bool dry_run = 3; */
        if (message.dryRun !== false)
            writer.tag(3, WireType.Varint).bool(message.dryRun);
        /* repeated string cells = 4; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.cells[i]);
        /* vschema.Keyspace v_schema = 5; */
        if (message.vSchema)
            Keyspace$2.internalBinaryWrite(message.vSchema, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string sql = 6; */
        if (message.sql !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sql);
        /* bool strict = 7; */
        if (message.strict !== false)
            writer.tag(7, WireType.Varint).bool(message.strict);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyVSchemaRequest
 */
export const ApplyVSchemaRequest = new ApplyVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyVSchemaResponse$Type extends MessageType<ApplyVSchemaResponse> {
    constructor() {
        super("vtctldata.ApplyVSchemaResponse", [
            { no: 1, name: "v_schema", kind: "message", T: () => Keyspace$2 },
            { no: 2, name: "unknown_vindex_params", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ApplyVSchemaResponse_ParamList } }
        ]);
    }
    create(value?: PartialMessage<ApplyVSchemaResponse>): ApplyVSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unknownVindexParams = {};
        if (value !== undefined)
            reflectionMergePartial<ApplyVSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyVSchemaResponse): ApplyVSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.Keyspace v_schema */ 1:
                    message.vSchema = Keyspace$2.internalBinaryRead(reader, reader.uint32(), options, message.vSchema);
                    break;
                case /* map<string, vtctldata.ApplyVSchemaResponse.ParamList> unknown_vindex_params */ 2:
                    this.binaryReadMap2(message.unknownVindexParams, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ApplyVSchemaResponse["unknownVindexParams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ApplyVSchemaResponse["unknownVindexParams"] | undefined, val: ApplyVSchemaResponse["unknownVindexParams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ApplyVSchemaResponse_ParamList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ApplyVSchemaResponse.unknown_vindex_params");
            }
        }
        map[key ?? ""] = val ?? ApplyVSchemaResponse_ParamList.create();
    }
    internalBinaryWrite(message: ApplyVSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.Keyspace v_schema = 1; */
        if (message.vSchema)
            Keyspace$2.internalBinaryWrite(message.vSchema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, vtctldata.ApplyVSchemaResponse.ParamList> unknown_vindex_params = 2; */
        for (let k of globalThis.Object.keys(message.unknownVindexParams)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ApplyVSchemaResponse_ParamList.internalBinaryWrite(message.unknownVindexParams[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyVSchemaResponse
 */
export const ApplyVSchemaResponse = new ApplyVSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyVSchemaResponse_ParamList$Type extends MessageType<ApplyVSchemaResponse_ParamList> {
    constructor() {
        super("vtctldata.ApplyVSchemaResponse.ParamList", [
            { no: 1, name: "params", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyVSchemaResponse_ParamList>): ApplyVSchemaResponse_ParamList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.params = [];
        if (value !== undefined)
            reflectionMergePartial<ApplyVSchemaResponse_ParamList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyVSchemaResponse_ParamList): ApplyVSchemaResponse_ParamList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string params */ 1:
                    message.params.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyVSchemaResponse_ParamList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string params = 1; */
        for (let i = 0; i < message.params.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.params[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ApplyVSchemaResponse.ParamList
 */
export const ApplyVSchemaResponse_ParamList = new ApplyVSchemaResponse_ParamList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BackupRequest$Type extends MessageType<BackupRequest> {
    constructor() {
        super("vtctldata.BackupRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "allow_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "incremental_from_pos", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "upgrade_safe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "backup_engine", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BackupRequest>): BackupRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowPrimary = false;
        message.concurrency = 0;
        message.incrementalFromPos = "";
        message.upgradeSafe = false;
        if (value !== undefined)
            reflectionMergePartial<BackupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackupRequest): BackupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* bool allow_primary */ 2:
                    message.allowPrimary = reader.bool();
                    break;
                case /* int32 concurrency */ 3:
                    message.concurrency = reader.int32();
                    break;
                case /* string incremental_from_pos */ 4:
                    message.incrementalFromPos = reader.string();
                    break;
                case /* bool upgrade_safe */ 5:
                    message.upgradeSafe = reader.bool();
                    break;
                case /* optional string backup_engine */ 6:
                    message.backupEngine = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_primary = 2; */
        if (message.allowPrimary !== false)
            writer.tag(2, WireType.Varint).bool(message.allowPrimary);
        /* int32 concurrency = 3; */
        if (message.concurrency !== 0)
            writer.tag(3, WireType.Varint).int32(message.concurrency);
        /* string incremental_from_pos = 4; */
        if (message.incrementalFromPos !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.incrementalFromPos);
        /* bool upgrade_safe = 5; */
        if (message.upgradeSafe !== false)
            writer.tag(5, WireType.Varint).bool(message.upgradeSafe);
        /* optional string backup_engine = 6; */
        if (message.backupEngine !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.backupEngine);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.BackupRequest
 */
export const BackupRequest = new BackupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BackupResponse$Type extends MessageType<BackupResponse> {
    constructor() {
        super("vtctldata.BackupResponse", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<BackupResponse>): BackupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<BackupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackupResponse): BackupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* logutil.Event event */ 4:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* logutil.Event event = 4; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.BackupResponse
 */
export const BackupResponse = new BackupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BackupShardRequest$Type extends MessageType<BackupShardRequest> {
    constructor() {
        super("vtctldata.BackupShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allow_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "upgrade_safe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "incremental_from_pos", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BackupShardRequest>): BackupShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.allowPrimary = false;
        message.concurrency = 0;
        message.upgradeSafe = false;
        message.incrementalFromPos = "";
        if (value !== undefined)
            reflectionMergePartial<BackupShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackupShardRequest): BackupShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* bool allow_primary */ 3:
                    message.allowPrimary = reader.bool();
                    break;
                case /* int32 concurrency */ 4:
                    message.concurrency = reader.int32();
                    break;
                case /* bool upgrade_safe */ 5:
                    message.upgradeSafe = reader.bool();
                    break;
                case /* string incremental_from_pos */ 6:
                    message.incrementalFromPos = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackupShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* bool allow_primary = 3; */
        if (message.allowPrimary !== false)
            writer.tag(3, WireType.Varint).bool(message.allowPrimary);
        /* int32 concurrency = 4; */
        if (message.concurrency !== 0)
            writer.tag(4, WireType.Varint).int32(message.concurrency);
        /* bool upgrade_safe = 5; */
        if (message.upgradeSafe !== false)
            writer.tag(5, WireType.Varint).bool(message.upgradeSafe);
        /* string incremental_from_pos = 6; */
        if (message.incrementalFromPos !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.incrementalFromPos);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.BackupShardRequest
 */
export const BackupShardRequest = new BackupShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelSchemaMigrationRequest$Type extends MessageType<CancelSchemaMigrationRequest> {
    constructor() {
        super("vtctldata.CancelSchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelSchemaMigrationRequest>): CancelSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<CancelSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelSchemaMigrationRequest): CancelSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CancelSchemaMigrationRequest
 */
export const CancelSchemaMigrationRequest = new CancelSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelSchemaMigrationResponse$Type extends MessageType<CancelSchemaMigrationResponse> {
    constructor() {
        super("vtctldata.CancelSchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<CancelSchemaMigrationResponse>): CancelSchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<CancelSchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelSchemaMigrationResponse): CancelSchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CancelSchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CancelSchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: CancelSchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.CancelSchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: CancelSchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CancelSchemaMigrationResponse
 */
export const CancelSchemaMigrationResponse = new CancelSchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTabletTagsRequest$Type extends MessageType<ChangeTabletTagsRequest> {
    constructor() {
        super("vtctldata.ChangeTabletTagsRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "replace", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeTabletTagsRequest>): ChangeTabletTagsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tags = {};
        message.replace = false;
        if (value !== undefined)
            reflectionMergePartial<ChangeTabletTagsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTabletTagsRequest): ChangeTabletTagsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* map<string, string> tags */ 2:
                    this.binaryReadMap2(message.tags, reader, options);
                    break;
                case /* bool replace */ 3:
                    message.replace = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ChangeTabletTagsRequest["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChangeTabletTagsRequest["tags"] | undefined, val: ChangeTabletTagsRequest["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ChangeTabletTagsRequest.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ChangeTabletTagsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> tags = 2; */
        for (let k of globalThis.Object.keys(message.tags))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        /* bool replace = 3; */
        if (message.replace !== false)
            writer.tag(3, WireType.Varint).bool(message.replace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ChangeTabletTagsRequest
 */
export const ChangeTabletTagsRequest = new ChangeTabletTagsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTabletTagsResponse$Type extends MessageType<ChangeTabletTagsResponse> {
    constructor() {
        super("vtctldata.ChangeTabletTagsResponse", [
            { no: 1, name: "before_tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "after_tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ChangeTabletTagsResponse>): ChangeTabletTagsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.beforeTags = {};
        message.afterTags = {};
        if (value !== undefined)
            reflectionMergePartial<ChangeTabletTagsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTabletTagsResponse): ChangeTabletTagsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> before_tags */ 1:
                    this.binaryReadMap1(message.beforeTags, reader, options);
                    break;
                case /* map<string, string> after_tags */ 2:
                    this.binaryReadMap2(message.afterTags, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ChangeTabletTagsResponse["beforeTags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChangeTabletTagsResponse["beforeTags"] | undefined, val: ChangeTabletTagsResponse["beforeTags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ChangeTabletTagsResponse.before_tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap2(map: ChangeTabletTagsResponse["afterTags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ChangeTabletTagsResponse["afterTags"] | undefined, val: ChangeTabletTagsResponse["afterTags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ChangeTabletTagsResponse.after_tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ChangeTabletTagsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> before_tags = 1; */
        for (let k of globalThis.Object.keys(message.beforeTags))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.beforeTags[k]).join();
        /* map<string, string> after_tags = 2; */
        for (let k of globalThis.Object.keys(message.afterTags))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.afterTags[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ChangeTabletTagsResponse
 */
export const ChangeTabletTagsResponse = new ChangeTabletTagsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTabletTypeRequest$Type extends MessageType<ChangeTabletTypeRequest> {
    constructor() {
        super("vtctldata.ChangeTabletTypeRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "db_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 3, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeTabletTypeRequest>): ChangeTabletTypeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dbType = 0;
        message.dryRun = false;
        if (value !== undefined)
            reflectionMergePartial<ChangeTabletTypeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTabletTypeRequest): ChangeTabletTypeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* topodata.TabletType db_type */ 2:
                    message.dbType = reader.int32();
                    break;
                case /* bool dry_run */ 3:
                    message.dryRun = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeTabletTypeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletType db_type = 2; */
        if (message.dbType !== 0)
            writer.tag(2, WireType.Varint).int32(message.dbType);
        /* bool dry_run = 3; */
        if (message.dryRun !== false)
            writer.tag(3, WireType.Varint).bool(message.dryRun);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ChangeTabletTypeRequest
 */
export const ChangeTabletTypeRequest = new ChangeTabletTypeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeTabletTypeResponse$Type extends MessageType<ChangeTabletTypeResponse> {
    constructor() {
        super("vtctldata.ChangeTabletTypeResponse", [
            { no: 1, name: "before_tablet", kind: "message", T: () => Tablet },
            { no: 2, name: "after_tablet", kind: "message", T: () => Tablet },
            { no: 3, name: "was_dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeTabletTypeResponse>): ChangeTabletTypeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.wasDryRun = false;
        if (value !== undefined)
            reflectionMergePartial<ChangeTabletTypeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeTabletTypeResponse): ChangeTabletTypeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Tablet before_tablet */ 1:
                    message.beforeTablet = Tablet.internalBinaryRead(reader, reader.uint32(), options, message.beforeTablet);
                    break;
                case /* topodata.Tablet after_tablet */ 2:
                    message.afterTablet = Tablet.internalBinaryRead(reader, reader.uint32(), options, message.afterTablet);
                    break;
                case /* bool was_dry_run */ 3:
                    message.wasDryRun = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeTabletTypeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Tablet before_tablet = 1; */
        if (message.beforeTablet)
            Tablet.internalBinaryWrite(message.beforeTablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* topodata.Tablet after_tablet = 2; */
        if (message.afterTablet)
            Tablet.internalBinaryWrite(message.afterTablet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool was_dry_run = 3; */
        if (message.wasDryRun !== false)
            writer.tag(3, WireType.Varint).bool(message.wasDryRun);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ChangeTabletTypeResponse
 */
export const ChangeTabletTypeResponse = new ChangeTabletTypeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckThrottlerRequest$Type extends MessageType<CheckThrottlerRequest> {
    constructor() {
        super("vtctldata.CheckThrottlerRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "skip_request_heartbeats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "ok_if_not_exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CheckThrottlerRequest>): CheckThrottlerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appName = "";
        message.scope = "";
        message.skipRequestHeartbeats = false;
        message.okIfNotExists = false;
        if (value !== undefined)
            reflectionMergePartial<CheckThrottlerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckThrottlerRequest): CheckThrottlerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string app_name */ 2:
                    message.appName = reader.string();
                    break;
                case /* string scope */ 3:
                    message.scope = reader.string();
                    break;
                case /* bool skip_request_heartbeats */ 4:
                    message.skipRequestHeartbeats = reader.bool();
                    break;
                case /* bool ok_if_not_exists */ 5:
                    message.okIfNotExists = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckThrottlerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string app_name = 2; */
        if (message.appName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.appName);
        /* string scope = 3; */
        if (message.scope !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.scope);
        /* bool skip_request_heartbeats = 4; */
        if (message.skipRequestHeartbeats !== false)
            writer.tag(4, WireType.Varint).bool(message.skipRequestHeartbeats);
        /* bool ok_if_not_exists = 5; */
        if (message.okIfNotExists !== false)
            writer.tag(5, WireType.Varint).bool(message.okIfNotExists);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CheckThrottlerRequest
 */
export const CheckThrottlerRequest = new CheckThrottlerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckThrottlerResponse$Type extends MessageType<CheckThrottlerResponse> {
    constructor() {
        super("vtctldata.CheckThrottlerResponse", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "Check", kind: "message", jsonName: "Check", T: () => CheckThrottlerResponse$ }
        ]);
    }
    create(value?: PartialMessage<CheckThrottlerResponse>): CheckThrottlerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CheckThrottlerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckThrottlerResponse): CheckThrottlerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* tabletmanagerdata.CheckThrottlerResponse Check = 2 [json_name = "Check"];*/ 2:
                    message.check = CheckThrottlerResponse$.internalBinaryRead(reader, reader.uint32(), options, message.check);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckThrottlerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tabletmanagerdata.CheckThrottlerResponse Check = 2 [json_name = "Check"]; */
        if (message.check)
            CheckThrottlerResponse$.internalBinaryWrite(message.check, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CheckThrottlerResponse
 */
export const CheckThrottlerResponse = new CheckThrottlerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CleanupSchemaMigrationRequest$Type extends MessageType<CleanupSchemaMigrationRequest> {
    constructor() {
        super("vtctldata.CleanupSchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CleanupSchemaMigrationRequest>): CleanupSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<CleanupSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CleanupSchemaMigrationRequest): CleanupSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CleanupSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CleanupSchemaMigrationRequest
 */
export const CleanupSchemaMigrationRequest = new CleanupSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CleanupSchemaMigrationResponse$Type extends MessageType<CleanupSchemaMigrationResponse> {
    constructor() {
        super("vtctldata.CleanupSchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<CleanupSchemaMigrationResponse>): CleanupSchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<CleanupSchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CleanupSchemaMigrationResponse): CleanupSchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CleanupSchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CleanupSchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: CleanupSchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.CleanupSchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: CleanupSchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CleanupSchemaMigrationResponse
 */
export const CleanupSchemaMigrationResponse = new CleanupSchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompleteSchemaMigrationRequest$Type extends MessageType<CompleteSchemaMigrationRequest> {
    constructor() {
        super("vtctldata.CompleteSchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CompleteSchemaMigrationRequest>): CompleteSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<CompleteSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompleteSchemaMigrationRequest): CompleteSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompleteSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CompleteSchemaMigrationRequest
 */
export const CompleteSchemaMigrationRequest = new CompleteSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompleteSchemaMigrationResponse$Type extends MessageType<CompleteSchemaMigrationResponse> {
    constructor() {
        super("vtctldata.CompleteSchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<CompleteSchemaMigrationResponse>): CompleteSchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<CompleteSchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompleteSchemaMigrationResponse): CompleteSchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CompleteSchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CompleteSchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: CompleteSchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.CompleteSchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: CompleteSchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CompleteSchemaMigrationResponse
 */
export const CompleteSchemaMigrationResponse = new CompleteSchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyspaceRequest$Type extends MessageType<CreateKeyspaceRequest> {
    constructor() {
        super("vtctldata.CreateKeyspaceRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "allow_empty_v_schema", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "type", kind: "enum", T: () => ["topodata.KeyspaceType", KeyspaceType] },
            { no: 8, name: "base_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "snapshot_time", kind: "message", T: () => Time },
            { no: 10, name: "durability_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "sidecar_db_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateKeyspaceRequest>): CreateKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.force = false;
        message.allowEmptyVSchema = false;
        message.type = 0;
        message.baseKeyspace = "";
        message.durabilityPolicy = "";
        message.sidecarDbName = "";
        if (value !== undefined)
            reflectionMergePartial<CreateKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyspaceRequest): CreateKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                case /* bool allow_empty_v_schema */ 3:
                    message.allowEmptyVSchema = reader.bool();
                    break;
                case /* topodata.KeyspaceType type */ 7:
                    message.type = reader.int32();
                    break;
                case /* string base_keyspace */ 8:
                    message.baseKeyspace = reader.string();
                    break;
                case /* vttime.Time snapshot_time */ 9:
                    message.snapshotTime = Time.internalBinaryRead(reader, reader.uint32(), options, message.snapshotTime);
                    break;
                case /* string durability_policy */ 10:
                    message.durabilityPolicy = reader.string();
                    break;
                case /* string sidecar_db_name */ 11:
                    message.sidecarDbName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        /* bool allow_empty_v_schema = 3; */
        if (message.allowEmptyVSchema !== false)
            writer.tag(3, WireType.Varint).bool(message.allowEmptyVSchema);
        /* topodata.KeyspaceType type = 7; */
        if (message.type !== 0)
            writer.tag(7, WireType.Varint).int32(message.type);
        /* string base_keyspace = 8; */
        if (message.baseKeyspace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.baseKeyspace);
        /* vttime.Time snapshot_time = 9; */
        if (message.snapshotTime)
            Time.internalBinaryWrite(message.snapshotTime, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string durability_policy = 10; */
        if (message.durabilityPolicy !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.durabilityPolicy);
        /* string sidecar_db_name = 11; */
        if (message.sidecarDbName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sidecarDbName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CreateKeyspaceRequest
 */
export const CreateKeyspaceRequest = new CreateKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyspaceResponse$Type extends MessageType<CreateKeyspaceResponse> {
    constructor() {
        super("vtctldata.CreateKeyspaceResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace }
        ]);
    }
    create(value?: PartialMessage<CreateKeyspaceResponse>): CreateKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyspaceResponse): CreateKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CreateKeyspaceResponse
 */
export const CreateKeyspaceResponse = new CreateKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateShardRequest$Type extends MessageType<CreateShardRequest> {
    constructor() {
        super("vtctldata.CreateShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "include_parent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateShardRequest>): CreateShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shardName = "";
        message.force = false;
        message.includeParent = false;
        if (value !== undefined)
            reflectionMergePartial<CreateShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateShardRequest): CreateShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard_name */ 2:
                    message.shardName = reader.string();
                    break;
                case /* bool force */ 3:
                    message.force = reader.bool();
                    break;
                case /* bool include_parent */ 4:
                    message.includeParent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard_name = 2; */
        if (message.shardName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shardName);
        /* bool force = 3; */
        if (message.force !== false)
            writer.tag(3, WireType.Varint).bool(message.force);
        /* bool include_parent = 4; */
        if (message.includeParent !== false)
            writer.tag(4, WireType.Varint).bool(message.includeParent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CreateShardRequest
 */
export const CreateShardRequest = new CreateShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateShardResponse$Type extends MessageType<CreateShardResponse> {
    constructor() {
        super("vtctldata.CreateShardResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace },
            { no: 2, name: "shard", kind: "message", T: () => Shard },
            { no: 3, name: "shard_already_exists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateShardResponse>): CreateShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardAlreadyExists = false;
        if (value !== undefined)
            reflectionMergePartial<CreateShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateShardResponse): CreateShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                case /* vtctldata.Shard shard */ 2:
                    message.shard = Shard.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                case /* bool shard_already_exists */ 3:
                    message.shardAlreadyExists = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.Shard shard = 2; */
        if (message.shard)
            Shard.internalBinaryWrite(message.shard, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool shard_already_exists = 3; */
        if (message.shardAlreadyExists !== false)
            writer.tag(3, WireType.Varint).bool(message.shardAlreadyExists);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.CreateShardResponse
 */
export const CreateShardResponse = new CreateShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCellInfoRequest$Type extends MessageType<DeleteCellInfoRequest> {
    constructor() {
        super("vtctldata.DeleteCellInfoRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteCellInfoRequest>): DeleteCellInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteCellInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCellInfoRequest): DeleteCellInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCellInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteCellInfoRequest
 */
export const DeleteCellInfoRequest = new DeleteCellInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCellInfoResponse$Type extends MessageType<DeleteCellInfoResponse> {
    constructor() {
        super("vtctldata.DeleteCellInfoResponse", []);
    }
    create(value?: PartialMessage<DeleteCellInfoResponse>): DeleteCellInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteCellInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCellInfoResponse): DeleteCellInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCellInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteCellInfoResponse
 */
export const DeleteCellInfoResponse = new DeleteCellInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCellsAliasRequest$Type extends MessageType<DeleteCellsAliasRequest> {
    constructor() {
        super("vtctldata.DeleteCellsAliasRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteCellsAliasRequest>): DeleteCellsAliasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteCellsAliasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCellsAliasRequest): DeleteCellsAliasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCellsAliasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteCellsAliasRequest
 */
export const DeleteCellsAliasRequest = new DeleteCellsAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteCellsAliasResponse$Type extends MessageType<DeleteCellsAliasResponse> {
    constructor() {
        super("vtctldata.DeleteCellsAliasResponse", []);
    }
    create(value?: PartialMessage<DeleteCellsAliasResponse>): DeleteCellsAliasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteCellsAliasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteCellsAliasResponse): DeleteCellsAliasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteCellsAliasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteCellsAliasResponse
 */
export const DeleteCellsAliasResponse = new DeleteCellsAliasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyspaceRequest$Type extends MessageType<DeleteKeyspaceRequest> {
    constructor() {
        super("vtctldata.DeleteKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteKeyspaceRequest>): DeleteKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.recursive = false;
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteKeyspaceRequest): DeleteKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool recursive */ 2:
                    message.recursive = reader.bool();
                    break;
                case /* bool force */ 3:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool recursive = 2; */
        if (message.recursive !== false)
            writer.tag(2, WireType.Varint).bool(message.recursive);
        /* bool force = 3; */
        if (message.force !== false)
            writer.tag(3, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteKeyspaceRequest
 */
export const DeleteKeyspaceRequest = new DeleteKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyspaceResponse$Type extends MessageType<DeleteKeyspaceResponse> {
    constructor() {
        super("vtctldata.DeleteKeyspaceResponse", []);
    }
    create(value?: PartialMessage<DeleteKeyspaceResponse>): DeleteKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteKeyspaceResponse): DeleteKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteKeyspaceResponse
 */
export const DeleteKeyspaceResponse = new DeleteKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteShardsRequest$Type extends MessageType<DeleteShardsRequest> {
    constructor() {
        super("vtctldata.DeleteShardsRequest", [
            { no: 1, name: "shards", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Shard },
            { no: 2, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "even_if_serving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteShardsRequest>): DeleteShardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shards = [];
        message.recursive = false;
        message.evenIfServing = false;
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteShardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteShardsRequest): DeleteShardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.Shard shards */ 1:
                    message.shards.push(Shard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool recursive */ 2:
                    message.recursive = reader.bool();
                    break;
                case /* bool even_if_serving */ 4:
                    message.evenIfServing = reader.bool();
                    break;
                case /* bool force */ 5:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteShardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.Shard shards = 1; */
        for (let i = 0; i < message.shards.length; i++)
            Shard.internalBinaryWrite(message.shards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool recursive = 2; */
        if (message.recursive !== false)
            writer.tag(2, WireType.Varint).bool(message.recursive);
        /* bool even_if_serving = 4; */
        if (message.evenIfServing !== false)
            writer.tag(4, WireType.Varint).bool(message.evenIfServing);
        /* bool force = 5; */
        if (message.force !== false)
            writer.tag(5, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteShardsRequest
 */
export const DeleteShardsRequest = new DeleteShardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteShardsResponse$Type extends MessageType<DeleteShardsResponse> {
    constructor() {
        super("vtctldata.DeleteShardsResponse", []);
    }
    create(value?: PartialMessage<DeleteShardsResponse>): DeleteShardsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteShardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteShardsResponse): DeleteShardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteShardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteShardsResponse
 */
export const DeleteShardsResponse = new DeleteShardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSrvVSchemaRequest$Type extends MessageType<DeleteSrvVSchemaRequest> {
    constructor() {
        super("vtctldata.DeleteSrvVSchemaRequest", [
            { no: 1, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSrvVSchemaRequest>): DeleteSrvVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteSrvVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSrvVSchemaRequest): DeleteSrvVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cell */ 1:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSrvVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cell = 1; */
        if (message.cell !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteSrvVSchemaRequest
 */
export const DeleteSrvVSchemaRequest = new DeleteSrvVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSrvVSchemaResponse$Type extends MessageType<DeleteSrvVSchemaResponse> {
    constructor() {
        super("vtctldata.DeleteSrvVSchemaResponse", []);
    }
    create(value?: PartialMessage<DeleteSrvVSchemaResponse>): DeleteSrvVSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteSrvVSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSrvVSchemaResponse): DeleteSrvVSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSrvVSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteSrvVSchemaResponse
 */
export const DeleteSrvVSchemaResponse = new DeleteSrvVSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTabletsRequest$Type extends MessageType<DeleteTabletsRequest> {
    constructor() {
        super("vtctldata.DeleteTabletsRequest", [
            { no: 1, name: "tablet_aliases", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TabletAlias },
            { no: 2, name: "allow_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTabletsRequest>): DeleteTabletsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tabletAliases = [];
        message.allowPrimary = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteTabletsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTabletsRequest): DeleteTabletsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated topodata.TabletAlias tablet_aliases */ 1:
                    message.tabletAliases.push(TabletAlias.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool allow_primary */ 2:
                    message.allowPrimary = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTabletsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated topodata.TabletAlias tablet_aliases = 1; */
        for (let i = 0; i < message.tabletAliases.length; i++)
            TabletAlias.internalBinaryWrite(message.tabletAliases[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_primary = 2; */
        if (message.allowPrimary !== false)
            writer.tag(2, WireType.Varint).bool(message.allowPrimary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteTabletsRequest
 */
export const DeleteTabletsRequest = new DeleteTabletsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTabletsResponse$Type extends MessageType<DeleteTabletsResponse> {
    constructor() {
        super("vtctldata.DeleteTabletsResponse", []);
    }
    create(value?: PartialMessage<DeleteTabletsResponse>): DeleteTabletsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteTabletsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTabletsResponse): DeleteTabletsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTabletsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.DeleteTabletsResponse
 */
export const DeleteTabletsResponse = new DeleteTabletsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyReparentShardRequest$Type extends MessageType<EmergencyReparentShardRequest> {
    constructor() {
        super("vtctldata.EmergencyReparentShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "ignore_replicas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TabletAlias },
            { no: 5, name: "wait_replicas_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "prevent_cross_cell_promotion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "wait_for_all_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "expected_primary", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<EmergencyReparentShardRequest>): EmergencyReparentShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.ignoreReplicas = [];
        message.preventCrossCellPromotion = false;
        message.waitForAllTablets = false;
        if (value !== undefined)
            reflectionMergePartial<EmergencyReparentShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyReparentShardRequest): EmergencyReparentShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias new_primary */ 3:
                    message.newPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.newPrimary);
                    break;
                case /* repeated topodata.TabletAlias ignore_replicas */ 4:
                    message.ignoreReplicas.push(TabletAlias.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* vttime.Duration wait_replicas_timeout */ 5:
                    message.waitReplicasTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.waitReplicasTimeout);
                    break;
                case /* bool prevent_cross_cell_promotion */ 6:
                    message.preventCrossCellPromotion = reader.bool();
                    break;
                case /* bool wait_for_all_tablets */ 7:
                    message.waitForAllTablets = reader.bool();
                    break;
                case /* topodata.TabletAlias expected_primary */ 8:
                    message.expectedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.expectedPrimary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyReparentShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias new_primary = 3; */
        if (message.newPrimary)
            TabletAlias.internalBinaryWrite(message.newPrimary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.TabletAlias ignore_replicas = 4; */
        for (let i = 0; i < message.ignoreReplicas.length; i++)
            TabletAlias.internalBinaryWrite(message.ignoreReplicas[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Duration wait_replicas_timeout = 5; */
        if (message.waitReplicasTimeout)
            Duration.internalBinaryWrite(message.waitReplicasTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool prevent_cross_cell_promotion = 6; */
        if (message.preventCrossCellPromotion !== false)
            writer.tag(6, WireType.Varint).bool(message.preventCrossCellPromotion);
        /* bool wait_for_all_tablets = 7; */
        if (message.waitForAllTablets !== false)
            writer.tag(7, WireType.Varint).bool(message.waitForAllTablets);
        /* topodata.TabletAlias expected_primary = 8; */
        if (message.expectedPrimary)
            TabletAlias.internalBinaryWrite(message.expectedPrimary, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.EmergencyReparentShardRequest
 */
export const EmergencyReparentShardRequest = new EmergencyReparentShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyReparentShardResponse$Type extends MessageType<EmergencyReparentShardResponse> {
    constructor() {
        super("vtctldata.EmergencyReparentShardResponse", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "promoted_primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<EmergencyReparentShardResponse>): EmergencyReparentShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<EmergencyReparentShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyReparentShardResponse): EmergencyReparentShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias promoted_primary */ 3:
                    message.promotedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.promotedPrimary);
                    break;
                case /* repeated logutil.Event events */ 4:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyReparentShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias promoted_primary = 3; */
        if (message.promotedPrimary)
            TabletAlias.internalBinaryWrite(message.promotedPrimary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 4; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.EmergencyReparentShardResponse
 */
export const EmergencyReparentShardResponse = new EmergencyReparentShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFetchAsAppRequest$Type extends MessageType<ExecuteFetchAsAppRequest> {
    constructor() {
        super("vtctldata.ExecuteFetchAsAppRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "max_rows", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "use_pool", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteFetchAsAppRequest>): ExecuteFetchAsAppRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.maxRows = 0n;
        message.usePool = false;
        if (value !== undefined)
            reflectionMergePartial<ExecuteFetchAsAppRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFetchAsAppRequest): ExecuteFetchAsAppRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string query */ 2:
                    message.query = reader.string();
                    break;
                case /* int64 max_rows */ 3:
                    message.maxRows = reader.int64().toBigInt();
                    break;
                case /* bool use_pool */ 4:
                    message.usePool = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFetchAsAppRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string query = 2; */
        if (message.query !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* int64 max_rows = 3; */
        if (message.maxRows !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxRows);
        /* bool use_pool = 4; */
        if (message.usePool !== false)
            writer.tag(4, WireType.Varint).bool(message.usePool);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteFetchAsAppRequest
 */
export const ExecuteFetchAsAppRequest = new ExecuteFetchAsAppRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFetchAsAppResponse$Type extends MessageType<ExecuteFetchAsAppResponse> {
    constructor() {
        super("vtctldata.ExecuteFetchAsAppResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ExecuteFetchAsAppResponse>): ExecuteFetchAsAppResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteFetchAsAppResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFetchAsAppResponse): ExecuteFetchAsAppResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFetchAsAppResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteFetchAsAppResponse
 */
export const ExecuteFetchAsAppResponse = new ExecuteFetchAsAppResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFetchAsDBARequest$Type extends MessageType<ExecuteFetchAsDBARequest> {
    constructor() {
        super("vtctldata.ExecuteFetchAsDBARequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "max_rows", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_binlogs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "reload_schema", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteFetchAsDBARequest>): ExecuteFetchAsDBARequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.maxRows = 0n;
        message.disableBinlogs = false;
        message.reloadSchema = false;
        if (value !== undefined)
            reflectionMergePartial<ExecuteFetchAsDBARequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFetchAsDBARequest): ExecuteFetchAsDBARequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string query */ 2:
                    message.query = reader.string();
                    break;
                case /* int64 max_rows */ 3:
                    message.maxRows = reader.int64().toBigInt();
                    break;
                case /* bool disable_binlogs */ 4:
                    message.disableBinlogs = reader.bool();
                    break;
                case /* bool reload_schema */ 5:
                    message.reloadSchema = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFetchAsDBARequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string query = 2; */
        if (message.query !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* int64 max_rows = 3; */
        if (message.maxRows !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxRows);
        /* bool disable_binlogs = 4; */
        if (message.disableBinlogs !== false)
            writer.tag(4, WireType.Varint).bool(message.disableBinlogs);
        /* bool reload_schema = 5; */
        if (message.reloadSchema !== false)
            writer.tag(5, WireType.Varint).bool(message.reloadSchema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteFetchAsDBARequest
 */
export const ExecuteFetchAsDBARequest = new ExecuteFetchAsDBARequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteFetchAsDBAResponse$Type extends MessageType<ExecuteFetchAsDBAResponse> {
    constructor() {
        super("vtctldata.ExecuteFetchAsDBAResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ExecuteFetchAsDBAResponse>): ExecuteFetchAsDBAResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteFetchAsDBAResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteFetchAsDBAResponse): ExecuteFetchAsDBAResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteFetchAsDBAResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteFetchAsDBAResponse
 */
export const ExecuteFetchAsDBAResponse = new ExecuteFetchAsDBAResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteHookRequest$Type extends MessageType<ExecuteHookRequest> {
    constructor() {
        super("vtctldata.ExecuteHookRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "tablet_hook_request", kind: "message", T: () => ExecuteHookRequest$ }
        ]);
    }
    create(value?: PartialMessage<ExecuteHookRequest>): ExecuteHookRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteHookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteHookRequest): ExecuteHookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* tabletmanagerdata.ExecuteHookRequest tablet_hook_request */ 2:
                    message.tabletHookRequest = ExecuteHookRequest$.internalBinaryRead(reader, reader.uint32(), options, message.tabletHookRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteHookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tabletmanagerdata.ExecuteHookRequest tablet_hook_request = 2; */
        if (message.tabletHookRequest)
            ExecuteHookRequest$.internalBinaryWrite(message.tabletHookRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteHookRequest
 */
export const ExecuteHookRequest = new ExecuteHookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteHookResponse$Type extends MessageType<ExecuteHookResponse> {
    constructor() {
        super("vtctldata.ExecuteHookResponse", [
            { no: 1, name: "hook_result", kind: "message", T: () => ExecuteHookResponse$ }
        ]);
    }
    create(value?: PartialMessage<ExecuteHookResponse>): ExecuteHookResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteHookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteHookResponse): ExecuteHookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tabletmanagerdata.ExecuteHookResponse hook_result */ 1:
                    message.hookResult = ExecuteHookResponse$.internalBinaryRead(reader, reader.uint32(), options, message.hookResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteHookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tabletmanagerdata.ExecuteHookResponse hook_result = 1; */
        if (message.hookResult)
            ExecuteHookResponse$.internalBinaryWrite(message.hookResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteHookResponse
 */
export const ExecuteHookResponse = new ExecuteHookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteMultiFetchAsDBARequest$Type extends MessageType<ExecuteMultiFetchAsDBARequest> {
    constructor() {
        super("vtctldata.ExecuteMultiFetchAsDBARequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "max_rows", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "disable_binlogs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "reload_schema", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExecuteMultiFetchAsDBARequest>): ExecuteMultiFetchAsDBARequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sql = "";
        message.maxRows = 0n;
        message.disableBinlogs = false;
        message.reloadSchema = false;
        if (value !== undefined)
            reflectionMergePartial<ExecuteMultiFetchAsDBARequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteMultiFetchAsDBARequest): ExecuteMultiFetchAsDBARequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string sql */ 2:
                    message.sql = reader.string();
                    break;
                case /* int64 max_rows */ 3:
                    message.maxRows = reader.int64().toBigInt();
                    break;
                case /* bool disable_binlogs */ 4:
                    message.disableBinlogs = reader.bool();
                    break;
                case /* bool reload_schema */ 5:
                    message.reloadSchema = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteMultiFetchAsDBARequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string sql = 2; */
        if (message.sql !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sql);
        /* int64 max_rows = 3; */
        if (message.maxRows !== 0n)
            writer.tag(3, WireType.Varint).int64(message.maxRows);
        /* bool disable_binlogs = 4; */
        if (message.disableBinlogs !== false)
            writer.tag(4, WireType.Varint).bool(message.disableBinlogs);
        /* bool reload_schema = 5; */
        if (message.reloadSchema !== false)
            writer.tag(5, WireType.Varint).bool(message.reloadSchema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteMultiFetchAsDBARequest
 */
export const ExecuteMultiFetchAsDBARequest = new ExecuteMultiFetchAsDBARequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteMultiFetchAsDBAResponse$Type extends MessageType<ExecuteMultiFetchAsDBAResponse> {
    constructor() {
        super("vtctldata.ExecuteMultiFetchAsDBAResponse", [
            { no: 1, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ExecuteMultiFetchAsDBAResponse>): ExecuteMultiFetchAsDBAResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<ExecuteMultiFetchAsDBAResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteMultiFetchAsDBAResponse): ExecuteMultiFetchAsDBAResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.QueryResult results */ 1:
                    message.results.push(QueryResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteMultiFetchAsDBAResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.QueryResult results = 1; */
        for (let i = 0; i < message.results.length; i++)
            QueryResult.internalBinaryWrite(message.results[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ExecuteMultiFetchAsDBAResponse
 */
export const ExecuteMultiFetchAsDBAResponse = new ExecuteMultiFetchAsDBAResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindAllShardsInKeyspaceRequest$Type extends MessageType<FindAllShardsInKeyspaceRequest> {
    constructor() {
        super("vtctldata.FindAllShardsInKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindAllShardsInKeyspaceRequest>): FindAllShardsInKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<FindAllShardsInKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindAllShardsInKeyspaceRequest): FindAllShardsInKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindAllShardsInKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.FindAllShardsInKeyspaceRequest
 */
export const FindAllShardsInKeyspaceRequest = new FindAllShardsInKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindAllShardsInKeyspaceResponse$Type extends MessageType<FindAllShardsInKeyspaceResponse> {
    constructor() {
        super("vtctldata.FindAllShardsInKeyspaceResponse", [
            { no: 1, name: "shards", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Shard } }
        ]);
    }
    create(value?: PartialMessage<FindAllShardsInKeyspaceResponse>): FindAllShardsInKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shards = {};
        if (value !== undefined)
            reflectionMergePartial<FindAllShardsInKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindAllShardsInKeyspaceResponse): FindAllShardsInKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vtctldata.Shard> shards */ 1:
                    this.binaryReadMap1(message.shards, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FindAllShardsInKeyspaceResponse["shards"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FindAllShardsInKeyspaceResponse["shards"] | undefined, val: FindAllShardsInKeyspaceResponse["shards"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Shard.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.FindAllShardsInKeyspaceResponse.shards");
            }
        }
        map[key ?? ""] = val ?? Shard.create();
    }
    internalBinaryWrite(message: FindAllShardsInKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vtctldata.Shard> shards = 1; */
        for (let k of globalThis.Object.keys(message.shards)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Shard.internalBinaryWrite(message.shards[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.FindAllShardsInKeyspaceResponse
 */
export const FindAllShardsInKeyspaceResponse = new FindAllShardsInKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceCutOverSchemaMigrationRequest$Type extends MessageType<ForceCutOverSchemaMigrationRequest> {
    constructor() {
        super("vtctldata.ForceCutOverSchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ForceCutOverSchemaMigrationRequest>): ForceCutOverSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<ForceCutOverSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForceCutOverSchemaMigrationRequest): ForceCutOverSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ForceCutOverSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ForceCutOverSchemaMigrationRequest
 */
export const ForceCutOverSchemaMigrationRequest = new ForceCutOverSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceCutOverSchemaMigrationResponse$Type extends MessageType<ForceCutOverSchemaMigrationResponse> {
    constructor() {
        super("vtctldata.ForceCutOverSchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<ForceCutOverSchemaMigrationResponse>): ForceCutOverSchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ForceCutOverSchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForceCutOverSchemaMigrationResponse): ForceCutOverSchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ForceCutOverSchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ForceCutOverSchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: ForceCutOverSchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ForceCutOverSchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: ForceCutOverSchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ForceCutOverSchemaMigrationResponse
 */
export const ForceCutOverSchemaMigrationResponse = new ForceCutOverSchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBackupsRequest$Type extends MessageType<GetBackupsRequest> {
    constructor() {
        super("vtctldata.GetBackupsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "detailed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "detailed_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBackupsRequest>): GetBackupsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.limit = 0;
        message.detailed = false;
        message.detailedLimit = 0;
        if (value !== undefined)
            reflectionMergePartial<GetBackupsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBackupsRequest): GetBackupsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* uint32 limit */ 3:
                    message.limit = reader.uint32();
                    break;
                case /* bool detailed */ 4:
                    message.detailed = reader.bool();
                    break;
                case /* uint32 detailed_limit */ 5:
                    message.detailedLimit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBackupsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* uint32 limit = 3; */
        if (message.limit !== 0)
            writer.tag(3, WireType.Varint).uint32(message.limit);
        /* bool detailed = 4; */
        if (message.detailed !== false)
            writer.tag(4, WireType.Varint).bool(message.detailed);
        /* uint32 detailed_limit = 5; */
        if (message.detailedLimit !== 0)
            writer.tag(5, WireType.Varint).uint32(message.detailedLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetBackupsRequest
 */
export const GetBackupsRequest = new GetBackupsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBackupsResponse$Type extends MessageType<GetBackupsResponse> {
    constructor() {
        super("vtctldata.GetBackupsResponse", [
            { no: 1, name: "backups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BackupInfo }
        ]);
    }
    create(value?: PartialMessage<GetBackupsResponse>): GetBackupsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.backups = [];
        if (value !== undefined)
            reflectionMergePartial<GetBackupsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBackupsResponse): GetBackupsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mysqlctl.BackupInfo backups */ 1:
                    message.backups.push(BackupInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBackupsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mysqlctl.BackupInfo backups = 1; */
        for (let i = 0; i < message.backups.length; i++)
            BackupInfo.internalBinaryWrite(message.backups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetBackupsResponse
 */
export const GetBackupsResponse = new GetBackupsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfoRequest$Type extends MessageType<GetCellInfoRequest> {
    constructor() {
        super("vtctldata.GetCellInfoRequest", [
            { no: 1, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCellInfoRequest>): GetCellInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<GetCellInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfoRequest): GetCellInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cell */ 1:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cell = 1; */
        if (message.cell !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellInfoRequest
 */
export const GetCellInfoRequest = new GetCellInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfoResponse$Type extends MessageType<GetCellInfoResponse> {
    constructor() {
        super("vtctldata.GetCellInfoResponse", [
            { no: 1, name: "cell_info", kind: "message", T: () => CellInfo }
        ]);
    }
    create(value?: PartialMessage<GetCellInfoResponse>): GetCellInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCellInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfoResponse): GetCellInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.CellInfo cell_info */ 1:
                    message.cellInfo = CellInfo.internalBinaryRead(reader, reader.uint32(), options, message.cellInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.CellInfo cell_info = 1; */
        if (message.cellInfo)
            CellInfo.internalBinaryWrite(message.cellInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellInfoResponse
 */
export const GetCellInfoResponse = new GetCellInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfoNamesRequest$Type extends MessageType<GetCellInfoNamesRequest> {
    constructor() {
        super("vtctldata.GetCellInfoNamesRequest", []);
    }
    create(value?: PartialMessage<GetCellInfoNamesRequest>): GetCellInfoNamesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCellInfoNamesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfoNamesRequest): GetCellInfoNamesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfoNamesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellInfoNamesRequest
 */
export const GetCellInfoNamesRequest = new GetCellInfoNamesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfoNamesResponse$Type extends MessageType<GetCellInfoNamesResponse> {
    constructor() {
        super("vtctldata.GetCellInfoNamesResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCellInfoNamesResponse>): GetCellInfoNamesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<GetCellInfoNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfoNamesResponse): GetCellInfoNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfoNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellInfoNamesResponse
 */
export const GetCellInfoNamesResponse = new GetCellInfoNamesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellsAliasesRequest$Type extends MessageType<GetCellsAliasesRequest> {
    constructor() {
        super("vtctldata.GetCellsAliasesRequest", []);
    }
    create(value?: PartialMessage<GetCellsAliasesRequest>): GetCellsAliasesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetCellsAliasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellsAliasesRequest): GetCellsAliasesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellsAliasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellsAliasesRequest
 */
export const GetCellsAliasesRequest = new GetCellsAliasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellsAliasesResponse$Type extends MessageType<GetCellsAliasesResponse> {
    constructor() {
        super("vtctldata.GetCellsAliasesResponse", [
            { no: 1, name: "aliases", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CellsAlias } }
        ]);
    }
    create(value?: PartialMessage<GetCellsAliasesResponse>): GetCellsAliasesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aliases = {};
        if (value !== undefined)
            reflectionMergePartial<GetCellsAliasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellsAliasesResponse): GetCellsAliasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, topodata.CellsAlias> aliases */ 1:
                    this.binaryReadMap1(message.aliases, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetCellsAliasesResponse["aliases"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetCellsAliasesResponse["aliases"] | undefined, val: GetCellsAliasesResponse["aliases"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CellsAlias.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.GetCellsAliasesResponse.aliases");
            }
        }
        map[key ?? ""] = val ?? CellsAlias.create();
    }
    internalBinaryWrite(message: GetCellsAliasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, topodata.CellsAlias> aliases = 1; */
        for (let k of globalThis.Object.keys(message.aliases)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CellsAlias.internalBinaryWrite(message.aliases[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetCellsAliasesResponse
 */
export const GetCellsAliasesResponse = new GetCellsAliasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFullStatusRequest$Type extends MessageType<GetFullStatusRequest> {
    constructor() {
        super("vtctldata.GetFullStatusRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetFullStatusRequest>): GetFullStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFullStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFullStatusRequest): GetFullStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFullStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetFullStatusRequest
 */
export const GetFullStatusRequest = new GetFullStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFullStatusResponse$Type extends MessageType<GetFullStatusResponse> {
    constructor() {
        super("vtctldata.GetFullStatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => FullStatus }
        ]);
    }
    create(value?: PartialMessage<GetFullStatusResponse>): GetFullStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFullStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFullStatusResponse): GetFullStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* replicationdata.FullStatus status */ 1:
                    message.status = FullStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFullStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* replicationdata.FullStatus status = 1; */
        if (message.status)
            FullStatus.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetFullStatusResponse
 */
export const GetFullStatusResponse = new GetFullStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspacesRequest$Type extends MessageType<GetKeyspacesRequest> {
    constructor() {
        super("vtctldata.GetKeyspacesRequest", []);
    }
    create(value?: PartialMessage<GetKeyspacesRequest>): GetKeyspacesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetKeyspacesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspacesRequest): GetKeyspacesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspacesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspacesRequest
 */
export const GetKeyspacesRequest = new GetKeyspacesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspacesResponse$Type extends MessageType<GetKeyspacesResponse> {
    constructor() {
        super("vtctldata.GetKeyspacesResponse", [
            { no: 1, name: "keyspaces", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Keyspace }
        ]);
    }
    create(value?: PartialMessage<GetKeyspacesResponse>): GetKeyspacesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaces = [];
        if (value !== undefined)
            reflectionMergePartial<GetKeyspacesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspacesResponse): GetKeyspacesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.Keyspace keyspaces */ 1:
                    message.keyspaces.push(Keyspace.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspacesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.Keyspace keyspaces = 1; */
        for (let i = 0; i < message.keyspaces.length; i++)
            Keyspace.internalBinaryWrite(message.keyspaces[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspacesResponse
 */
export const GetKeyspacesResponse = new GetKeyspacesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspaceRequest$Type extends MessageType<GetKeyspaceRequest> {
    constructor() {
        super("vtctldata.GetKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKeyspaceRequest>): GetKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<GetKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspaceRequest): GetKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspaceRequest
 */
export const GetKeyspaceRequest = new GetKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspaceResponse$Type extends MessageType<GetKeyspaceResponse> {
    constructor() {
        super("vtctldata.GetKeyspaceResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace }
        ]);
    }
    create(value?: PartialMessage<GetKeyspaceResponse>): GetKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspaceResponse): GetKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspaceResponse
 */
export const GetKeyspaceResponse = new GetKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsRequest$Type extends MessageType<GetPermissionsRequest> {
    constructor() {
        super("vtctldata.GetPermissionsRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsRequest>): GetPermissionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsRequest): GetPermissionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetPermissionsRequest
 */
export const GetPermissionsRequest = new GetPermissionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPermissionsResponse$Type extends MessageType<GetPermissionsResponse> {
    constructor() {
        super("vtctldata.GetPermissionsResponse", [
            { no: 1, name: "permissions", kind: "message", T: () => Permissions }
        ]);
    }
    create(value?: PartialMessage<GetPermissionsResponse>): GetPermissionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPermissionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPermissionsResponse): GetPermissionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tabletmanagerdata.Permissions permissions */ 1:
                    message.permissions = Permissions.internalBinaryRead(reader, reader.uint32(), options, message.permissions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPermissionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tabletmanagerdata.Permissions permissions = 1; */
        if (message.permissions)
            Permissions.internalBinaryWrite(message.permissions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetPermissionsResponse
 */
export const GetPermissionsResponse = new GetPermissionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspaceRoutingRulesRequest$Type extends MessageType<GetKeyspaceRoutingRulesRequest> {
    constructor() {
        super("vtctldata.GetKeyspaceRoutingRulesRequest", []);
    }
    create(value?: PartialMessage<GetKeyspaceRoutingRulesRequest>): GetKeyspaceRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetKeyspaceRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspaceRoutingRulesRequest): GetKeyspaceRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspaceRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspaceRoutingRulesRequest
 */
export const GetKeyspaceRoutingRulesRequest = new GetKeyspaceRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspaceRoutingRulesResponse$Type extends MessageType<GetKeyspaceRoutingRulesResponse> {
    constructor() {
        super("vtctldata.GetKeyspaceRoutingRulesResponse", [
            { no: 1, name: "keyspace_routing_rules", kind: "message", T: () => KeyspaceRoutingRules }
        ]);
    }
    create(value?: PartialMessage<GetKeyspaceRoutingRulesResponse>): GetKeyspaceRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetKeyspaceRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspaceRoutingRulesResponse): GetKeyspaceRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.KeyspaceRoutingRules keyspace_routing_rules */ 1:
                    message.keyspaceRoutingRules = KeyspaceRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.keyspaceRoutingRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspaceRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.KeyspaceRoutingRules keyspace_routing_rules = 1; */
        if (message.keyspaceRoutingRules)
            KeyspaceRoutingRules.internalBinaryWrite(message.keyspaceRoutingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetKeyspaceRoutingRulesResponse
 */
export const GetKeyspaceRoutingRulesResponse = new GetKeyspaceRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoutingRulesRequest$Type extends MessageType<GetRoutingRulesRequest> {
    constructor() {
        super("vtctldata.GetRoutingRulesRequest", []);
    }
    create(value?: PartialMessage<GetRoutingRulesRequest>): GetRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoutingRulesRequest): GetRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetRoutingRulesRequest
 */
export const GetRoutingRulesRequest = new GetRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoutingRulesResponse$Type extends MessageType<GetRoutingRulesResponse> {
    constructor() {
        super("vtctldata.GetRoutingRulesResponse", [
            { no: 1, name: "routing_rules", kind: "message", T: () => RoutingRules }
        ]);
    }
    create(value?: PartialMessage<GetRoutingRulesResponse>): GetRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoutingRulesResponse): GetRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.RoutingRules routing_rules */ 1:
                    message.routingRules = RoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.routingRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.RoutingRules routing_rules = 1; */
        if (message.routingRules)
            RoutingRules.internalBinaryWrite(message.routingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetRoutingRulesResponse
 */
export const GetRoutingRulesResponse = new GetRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("vtctldata.GetSchemaRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "exclude_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "include_views", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "table_names_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "table_sizes_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "table_schema_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tables = [];
        message.excludeTables = [];
        message.includeViews = false;
        message.tableNamesOnly = false;
        message.tableSizesOnly = false;
        message.tableSchemaOnly = false;
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* repeated string tables */ 2:
                    message.tables.push(reader.string());
                    break;
                case /* repeated string exclude_tables */ 3:
                    message.excludeTables.push(reader.string());
                    break;
                case /* bool include_views */ 4:
                    message.includeViews = reader.bool();
                    break;
                case /* bool table_names_only */ 5:
                    message.tableNamesOnly = reader.bool();
                    break;
                case /* bool table_sizes_only */ 6:
                    message.tableSizesOnly = reader.bool();
                    break;
                case /* bool table_schema_only */ 7:
                    message.tableSchemaOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tables = 2; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.tables[i]);
        /* repeated string exclude_tables = 3; */
        for (let i = 0; i < message.excludeTables.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.excludeTables[i]);
        /* bool include_views = 4; */
        if (message.includeViews !== false)
            writer.tag(4, WireType.Varint).bool(message.includeViews);
        /* bool table_names_only = 5; */
        if (message.tableNamesOnly !== false)
            writer.tag(5, WireType.Varint).bool(message.tableNamesOnly);
        /* bool table_sizes_only = 6; */
        if (message.tableSizesOnly !== false)
            writer.tag(6, WireType.Varint).bool(message.tableSizesOnly);
        /* bool table_schema_only = 7; */
        if (message.tableSchemaOnly !== false)
            writer.tag(7, WireType.Varint).bool(message.tableSchemaOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaResponse$Type extends MessageType<GetSchemaResponse> {
    constructor() {
        super("vtctldata.GetSchemaResponse", [
            { no: 1, name: "schema", kind: "message", T: () => SchemaDefinition }
        ]);
    }
    create(value?: PartialMessage<GetSchemaResponse>): GetSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaResponse): GetSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tabletmanagerdata.SchemaDefinition schema */ 1:
                    message.schema = SchemaDefinition.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tabletmanagerdata.SchemaDefinition schema = 1; */
        if (message.schema)
            SchemaDefinition.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSchemaResponse
 */
export const GetSchemaResponse = new GetSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaMigrationsRequest$Type extends MessageType<GetSchemaMigrationsRequest> {
    constructor() {
        super("vtctldata.GetSchemaMigrationsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "migration_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "status", kind: "enum", T: () => ["vtctldata.SchemaMigration.Status", SchemaMigration_Status] },
            { no: 5, name: "recent", kind: "message", T: () => Duration },
            { no: 6, name: "order", kind: "enum", T: () => ["vtctldata.QueryOrdering", QueryOrdering] },
            { no: 7, name: "limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "skip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaMigrationsRequest>): GetSchemaMigrationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        message.migrationContext = "";
        message.status = 0;
        message.order = 0;
        message.limit = 0n;
        message.skip = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetSchemaMigrationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaMigrationsRequest): GetSchemaMigrationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* string migration_context */ 3:
                    message.migrationContext = reader.string();
                    break;
                case /* vtctldata.SchemaMigration.Status status */ 4:
                    message.status = reader.int32();
                    break;
                case /* vttime.Duration recent */ 5:
                    message.recent = Duration.internalBinaryRead(reader, reader.uint32(), options, message.recent);
                    break;
                case /* vtctldata.QueryOrdering order */ 6:
                    message.order = reader.int32();
                    break;
                case /* uint64 limit */ 7:
                    message.limit = reader.uint64().toBigInt();
                    break;
                case /* uint64 skip */ 8:
                    message.skip = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaMigrationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* string migration_context = 3; */
        if (message.migrationContext !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.migrationContext);
        /* vtctldata.SchemaMigration.Status status = 4; */
        if (message.status !== 0)
            writer.tag(4, WireType.Varint).int32(message.status);
        /* vttime.Duration recent = 5; */
        if (message.recent)
            Duration.internalBinaryWrite(message.recent, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.QueryOrdering order = 6; */
        if (message.order !== 0)
            writer.tag(6, WireType.Varint).int32(message.order);
        /* uint64 limit = 7; */
        if (message.limit !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.limit);
        /* uint64 skip = 8; */
        if (message.skip !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.skip);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSchemaMigrationsRequest
 */
export const GetSchemaMigrationsRequest = new GetSchemaMigrationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaMigrationsResponse$Type extends MessageType<GetSchemaMigrationsResponse> {
    constructor() {
        super("vtctldata.GetSchemaMigrationsResponse", [
            { no: 1, name: "migrations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaMigration }
        ]);
    }
    create(value?: PartialMessage<GetSchemaMigrationsResponse>): GetSchemaMigrationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.migrations = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemaMigrationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaMigrationsResponse): GetSchemaMigrationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.SchemaMigration migrations */ 1:
                    message.migrations.push(SchemaMigration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaMigrationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.SchemaMigration migrations = 1; */
        for (let i = 0; i < message.migrations.length; i++)
            SchemaMigration.internalBinaryWrite(message.migrations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSchemaMigrationsResponse
 */
export const GetSchemaMigrationsResponse = new GetSchemaMigrationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardReplicationRequest$Type extends MessageType<GetShardReplicationRequest> {
    constructor() {
        super("vtctldata.GetShardReplicationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetShardReplicationRequest>): GetShardReplicationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetShardReplicationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardReplicationRequest): GetShardReplicationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardReplicationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardReplicationRequest
 */
export const GetShardReplicationRequest = new GetShardReplicationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardReplicationResponse$Type extends MessageType<GetShardReplicationResponse> {
    constructor() {
        super("vtctldata.GetShardReplicationResponse", [
            { no: 1, name: "shard_replication_by_cell", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ShardReplication } }
        ]);
    }
    create(value?: PartialMessage<GetShardReplicationResponse>): GetShardReplicationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardReplicationByCell = {};
        if (value !== undefined)
            reflectionMergePartial<GetShardReplicationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardReplicationResponse): GetShardReplicationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, topodata.ShardReplication> shard_replication_by_cell */ 1:
                    this.binaryReadMap1(message.shardReplicationByCell, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetShardReplicationResponse["shardReplicationByCell"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetShardReplicationResponse["shardReplicationByCell"] | undefined, val: GetShardReplicationResponse["shardReplicationByCell"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ShardReplication.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.GetShardReplicationResponse.shard_replication_by_cell");
            }
        }
        map[key ?? ""] = val ?? ShardReplication.create();
    }
    internalBinaryWrite(message: GetShardReplicationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, topodata.ShardReplication> shard_replication_by_cell = 1; */
        for (let k of globalThis.Object.keys(message.shardReplicationByCell)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ShardReplication.internalBinaryWrite(message.shardReplicationByCell[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardReplicationResponse
 */
export const GetShardReplicationResponse = new GetShardReplicationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardRequest$Type extends MessageType<GetShardRequest> {
    constructor() {
        super("vtctldata.GetShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetShardRequest>): GetShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shardName = "";
        if (value !== undefined)
            reflectionMergePartial<GetShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardRequest): GetShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard_name */ 2:
                    message.shardName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard_name = 2; */
        if (message.shardName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shardName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardRequest
 */
export const GetShardRequest = new GetShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardResponse$Type extends MessageType<GetShardResponse> {
    constructor() {
        super("vtctldata.GetShardResponse", [
            { no: 1, name: "shard", kind: "message", T: () => Shard }
        ]);
    }
    create(value?: PartialMessage<GetShardResponse>): GetShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardResponse): GetShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.Shard shard */ 1:
                    message.shard = Shard.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.Shard shard = 1; */
        if (message.shard)
            Shard.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardResponse
 */
export const GetShardResponse = new GetShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardRoutingRulesRequest$Type extends MessageType<GetShardRoutingRulesRequest> {
    constructor() {
        super("vtctldata.GetShardRoutingRulesRequest", []);
    }
    create(value?: PartialMessage<GetShardRoutingRulesRequest>): GetShardRoutingRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetShardRoutingRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardRoutingRulesRequest): GetShardRoutingRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardRoutingRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardRoutingRulesRequest
 */
export const GetShardRoutingRulesRequest = new GetShardRoutingRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardRoutingRulesResponse$Type extends MessageType<GetShardRoutingRulesResponse> {
    constructor() {
        super("vtctldata.GetShardRoutingRulesResponse", [
            { no: 1, name: "shard_routing_rules", kind: "message", T: () => ShardRoutingRules }
        ]);
    }
    create(value?: PartialMessage<GetShardRoutingRulesResponse>): GetShardRoutingRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetShardRoutingRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardRoutingRulesResponse): GetShardRoutingRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.ShardRoutingRules shard_routing_rules */ 1:
                    message.shardRoutingRules = ShardRoutingRules.internalBinaryRead(reader, reader.uint32(), options, message.shardRoutingRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardRoutingRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.ShardRoutingRules shard_routing_rules = 1; */
        if (message.shardRoutingRules)
            ShardRoutingRules.internalBinaryWrite(message.shardRoutingRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetShardRoutingRulesResponse
 */
export const GetShardRoutingRulesResponse = new GetShardRoutingRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspaceNamesRequest$Type extends MessageType<GetSrvKeyspaceNamesRequest> {
    constructor() {
        super("vtctldata.GetSrvKeyspaceNamesRequest", [
            { no: 1, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspaceNamesRequest>): GetSrvKeyspaceNamesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspaceNamesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspaceNamesRequest): GetSrvKeyspaceNamesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cells */ 1:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvKeyspaceNamesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cells = 1; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvKeyspaceNamesRequest
 */
export const GetSrvKeyspaceNamesRequest = new GetSrvKeyspaceNamesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspaceNamesResponse$Type extends MessageType<GetSrvKeyspaceNamesResponse> {
    constructor() {
        super("vtctldata.GetSrvKeyspaceNamesResponse", [
            { no: 1, name: "names", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => GetSrvKeyspaceNamesResponse_NameList } }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspaceNamesResponse>): GetSrvKeyspaceNamesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = {};
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspaceNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspaceNamesResponse): GetSrvKeyspaceNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vtctldata.GetSrvKeyspaceNamesResponse.NameList> names */ 1:
                    this.binaryReadMap1(message.names, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetSrvKeyspaceNamesResponse["names"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetSrvKeyspaceNamesResponse["names"] | undefined, val: GetSrvKeyspaceNamesResponse["names"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = GetSrvKeyspaceNamesResponse_NameList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.GetSrvKeyspaceNamesResponse.names");
            }
        }
        map[key ?? ""] = val ?? GetSrvKeyspaceNamesResponse_NameList.create();
    }
    internalBinaryWrite(message: GetSrvKeyspaceNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vtctldata.GetSrvKeyspaceNamesResponse.NameList> names = 1; */
        for (let k of globalThis.Object.keys(message.names)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            GetSrvKeyspaceNamesResponse_NameList.internalBinaryWrite(message.names[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvKeyspaceNamesResponse
 */
export const GetSrvKeyspaceNamesResponse = new GetSrvKeyspaceNamesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspaceNamesResponse_NameList$Type extends MessageType<GetSrvKeyspaceNamesResponse_NameList> {
    constructor() {
        super("vtctldata.GetSrvKeyspaceNamesResponse.NameList", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspaceNamesResponse_NameList>): GetSrvKeyspaceNamesResponse_NameList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspaceNamesResponse_NameList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspaceNamesResponse_NameList): GetSrvKeyspaceNamesResponse_NameList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvKeyspaceNamesResponse_NameList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvKeyspaceNamesResponse.NameList
 */
export const GetSrvKeyspaceNamesResponse_NameList = new GetSrvKeyspaceNamesResponse_NameList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspacesRequest$Type extends MessageType<GetSrvKeyspacesRequest> {
    constructor() {
        super("vtctldata.GetSrvKeyspacesRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspacesRequest>): GetSrvKeyspacesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspacesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspacesRequest): GetSrvKeyspacesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvKeyspacesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvKeyspacesRequest
 */
export const GetSrvKeyspacesRequest = new GetSrvKeyspacesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspacesResponse$Type extends MessageType<GetSrvKeyspacesResponse> {
    constructor() {
        super("vtctldata.GetSrvKeyspacesResponse", [
            { no: 1, name: "srv_keyspaces", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SrvKeyspace } }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspacesResponse>): GetSrvKeyspacesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srvKeyspaces = {};
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspacesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspacesResponse): GetSrvKeyspacesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, topodata.SrvKeyspace> srv_keyspaces */ 1:
                    this.binaryReadMap1(message.srvKeyspaces, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetSrvKeyspacesResponse["srvKeyspaces"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetSrvKeyspacesResponse["srvKeyspaces"] | undefined, val: GetSrvKeyspacesResponse["srvKeyspaces"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SrvKeyspace.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.GetSrvKeyspacesResponse.srv_keyspaces");
            }
        }
        map[key ?? ""] = val ?? SrvKeyspace.create();
    }
    internalBinaryWrite(message: GetSrvKeyspacesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, topodata.SrvKeyspace> srv_keyspaces = 1; */
        for (let k of globalThis.Object.keys(message.srvKeyspaces)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SrvKeyspace.internalBinaryWrite(message.srvKeyspaces[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvKeyspacesResponse
 */
export const GetSrvKeyspacesResponse = new GetSrvKeyspacesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateThrottlerConfigRequest$Type extends MessageType<UpdateThrottlerConfigRequest> {
    constructor() {
        super("vtctldata.UpdateThrottlerConfigRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "disable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "custom_query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "custom_query_set", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "check_as_check_self", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "check_as_check_shard", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "throttled_app", kind: "message", T: () => ThrottledAppRule },
            { no: 10, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "app_checked_metrics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateThrottlerConfigRequest>): UpdateThrottlerConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.enable = false;
        message.disable = false;
        message.threshold = 0;
        message.customQuery = "";
        message.customQuerySet = false;
        message.checkAsCheckSelf = false;
        message.checkAsCheckShard = false;
        message.metricName = "";
        message.appName = "";
        message.appCheckedMetrics = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateThrottlerConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateThrottlerConfigRequest): UpdateThrottlerConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool enable */ 2:
                    message.enable = reader.bool();
                    break;
                case /* bool disable */ 3:
                    message.disable = reader.bool();
                    break;
                case /* double threshold */ 4:
                    message.threshold = reader.double();
                    break;
                case /* string custom_query */ 5:
                    message.customQuery = reader.string();
                    break;
                case /* bool custom_query_set */ 6:
                    message.customQuerySet = reader.bool();
                    break;
                case /* bool check_as_check_self */ 7:
                    message.checkAsCheckSelf = reader.bool();
                    break;
                case /* bool check_as_check_shard */ 8:
                    message.checkAsCheckShard = reader.bool();
                    break;
                case /* topodata.ThrottledAppRule throttled_app */ 9:
                    message.throttledApp = ThrottledAppRule.internalBinaryRead(reader, reader.uint32(), options, message.throttledApp);
                    break;
                case /* string metric_name */ 10:
                    message.metricName = reader.string();
                    break;
                case /* string app_name */ 11:
                    message.appName = reader.string();
                    break;
                case /* repeated string app_checked_metrics */ 12:
                    message.appCheckedMetrics.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateThrottlerConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool enable = 2; */
        if (message.enable !== false)
            writer.tag(2, WireType.Varint).bool(message.enable);
        /* bool disable = 3; */
        if (message.disable !== false)
            writer.tag(3, WireType.Varint).bool(message.disable);
        /* double threshold = 4; */
        if (message.threshold !== 0)
            writer.tag(4, WireType.Bit64).double(message.threshold);
        /* string custom_query = 5; */
        if (message.customQuery !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.customQuery);
        /* bool custom_query_set = 6; */
        if (message.customQuerySet !== false)
            writer.tag(6, WireType.Varint).bool(message.customQuerySet);
        /* bool check_as_check_self = 7; */
        if (message.checkAsCheckSelf !== false)
            writer.tag(7, WireType.Varint).bool(message.checkAsCheckSelf);
        /* bool check_as_check_shard = 8; */
        if (message.checkAsCheckShard !== false)
            writer.tag(8, WireType.Varint).bool(message.checkAsCheckShard);
        /* topodata.ThrottledAppRule throttled_app = 9; */
        if (message.throttledApp)
            ThrottledAppRule.internalBinaryWrite(message.throttledApp, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string metric_name = 10; */
        if (message.metricName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.metricName);
        /* string app_name = 11; */
        if (message.appName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appName);
        /* repeated string app_checked_metrics = 12; */
        for (let i = 0; i < message.appCheckedMetrics.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.appCheckedMetrics[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateThrottlerConfigRequest
 */
export const UpdateThrottlerConfigRequest = new UpdateThrottlerConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateThrottlerConfigResponse$Type extends MessageType<UpdateThrottlerConfigResponse> {
    constructor() {
        super("vtctldata.UpdateThrottlerConfigResponse", []);
    }
    create(value?: PartialMessage<UpdateThrottlerConfigResponse>): UpdateThrottlerConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateThrottlerConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateThrottlerConfigResponse): UpdateThrottlerConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateThrottlerConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateThrottlerConfigResponse
 */
export const UpdateThrottlerConfigResponse = new UpdateThrottlerConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemaRequest$Type extends MessageType<GetSrvVSchemaRequest> {
    constructor() {
        super("vtctldata.GetSrvVSchemaRequest", [
            { no: 1, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemaRequest>): GetSrvVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemaRequest): GetSrvVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cell */ 1:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cell = 1; */
        if (message.cell !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvVSchemaRequest
 */
export const GetSrvVSchemaRequest = new GetSrvVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemaResponse$Type extends MessageType<GetSrvVSchemaResponse> {
    constructor() {
        super("vtctldata.GetSrvVSchemaResponse", [
            { no: 1, name: "srv_v_schema", kind: "message", T: () => SrvVSchema }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemaResponse>): GetSrvVSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemaResponse): GetSrvVSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.SrvVSchema srv_v_schema */ 1:
                    message.srvVSchema = SrvVSchema.internalBinaryRead(reader, reader.uint32(), options, message.srvVSchema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.SrvVSchema srv_v_schema = 1; */
        if (message.srvVSchema)
            SrvVSchema.internalBinaryWrite(message.srvVSchema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvVSchemaResponse
 */
export const GetSrvVSchemaResponse = new GetSrvVSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemasRequest$Type extends MessageType<GetSrvVSchemasRequest> {
    constructor() {
        super("vtctldata.GetSrvVSchemasRequest", [
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemasRequest>): GetSrvVSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemasRequest): GetSrvVSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvVSchemasRequest
 */
export const GetSrvVSchemasRequest = new GetSrvVSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemasResponse$Type extends MessageType<GetSrvVSchemasResponse> {
    constructor() {
        super("vtctldata.GetSrvVSchemasResponse", [
            { no: 1, name: "srv_v_schemas", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SrvVSchema } }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemasResponse>): GetSrvVSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srvVSchemas = {};
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemasResponse): GetSrvVSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vschema.SrvVSchema> srv_v_schemas */ 1:
                    this.binaryReadMap1(message.srvVSchemas, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetSrvVSchemasResponse["srvVSchemas"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetSrvVSchemasResponse["srvVSchemas"] | undefined, val: GetSrvVSchemasResponse["srvVSchemas"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SrvVSchema.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.GetSrvVSchemasResponse.srv_v_schemas");
            }
        }
        map[key ?? ""] = val ?? SrvVSchema.create();
    }
    internalBinaryWrite(message: GetSrvVSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vschema.SrvVSchema> srv_v_schemas = 1; */
        for (let k of globalThis.Object.keys(message.srvVSchemas)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SrvVSchema.internalBinaryWrite(message.srvVSchemas[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetSrvVSchemasResponse
 */
export const GetSrvVSchemasResponse = new GetSrvVSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletRequest$Type extends MessageType<GetTabletRequest> {
    constructor() {
        super("vtctldata.GetTabletRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetTabletRequest>): GetTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletRequest): GetTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTabletRequest
 */
export const GetTabletRequest = new GetTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletResponse$Type extends MessageType<GetTabletResponse> {
    constructor() {
        super("vtctldata.GetTabletResponse", [
            { no: 1, name: "tablet", kind: "message", T: () => Tablet }
        ]);
    }
    create(value?: PartialMessage<GetTabletResponse>): GetTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletResponse): GetTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Tablet tablet */ 1:
                    message.tablet = Tablet.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Tablet tablet = 1; */
        if (message.tablet)
            Tablet.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTabletResponse
 */
export const GetTabletResponse = new GetTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletsRequest$Type extends MessageType<GetTabletsRequest> {
    constructor() {
        super("vtctldata.GetTabletsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "strict", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tablet_aliases", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TabletAlias },
            { no: 6, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] }
        ]);
    }
    create(value?: PartialMessage<GetTabletsRequest>): GetTabletsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.cells = [];
        message.strict = false;
        message.tabletAliases = [];
        message.tabletType = 0;
        if (value !== undefined)
            reflectionMergePartial<GetTabletsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletsRequest): GetTabletsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                case /* bool strict */ 4:
                    message.strict = reader.bool();
                    break;
                case /* repeated topodata.TabletAlias tablet_aliases */ 5:
                    message.tabletAliases.push(TabletAlias.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* topodata.TabletType tablet_type */ 6:
                    message.tabletType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        /* bool strict = 4; */
        if (message.strict !== false)
            writer.tag(4, WireType.Varint).bool(message.strict);
        /* repeated topodata.TabletAlias tablet_aliases = 5; */
        for (let i = 0; i < message.tabletAliases.length; i++)
            TabletAlias.internalBinaryWrite(message.tabletAliases[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletType tablet_type = 6; */
        if (message.tabletType !== 0)
            writer.tag(6, WireType.Varint).int32(message.tabletType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTabletsRequest
 */
export const GetTabletsRequest = new GetTabletsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletsResponse$Type extends MessageType<GetTabletsResponse> {
    constructor() {
        super("vtctldata.GetTabletsResponse", [
            { no: 1, name: "tablets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tablet }
        ]);
    }
    create(value?: PartialMessage<GetTabletsResponse>): GetTabletsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tablets = [];
        if (value !== undefined)
            reflectionMergePartial<GetTabletsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletsResponse): GetTabletsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated topodata.Tablet tablets */ 1:
                    message.tablets.push(Tablet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated topodata.Tablet tablets = 1; */
        for (let i = 0; i < message.tablets.length; i++)
            Tablet.internalBinaryWrite(message.tablets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTabletsResponse
 */
export const GetTabletsResponse = new GetTabletsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetThrottlerStatusRequest$Type extends MessageType<GetThrottlerStatusRequest> {
    constructor() {
        super("vtctldata.GetThrottlerStatusRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetThrottlerStatusRequest>): GetThrottlerStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetThrottlerStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetThrottlerStatusRequest): GetThrottlerStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetThrottlerStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetThrottlerStatusRequest
 */
export const GetThrottlerStatusRequest = new GetThrottlerStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetThrottlerStatusResponse$Type extends MessageType<GetThrottlerStatusResponse> {
    constructor() {
        super("vtctldata.GetThrottlerStatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => GetThrottlerStatusResponse$ }
        ]);
    }
    create(value?: PartialMessage<GetThrottlerStatusResponse>): GetThrottlerStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetThrottlerStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetThrottlerStatusResponse): GetThrottlerStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tabletmanagerdata.GetThrottlerStatusResponse status */ 1:
                    message.status = GetThrottlerStatusResponse$.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetThrottlerStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tabletmanagerdata.GetThrottlerStatusResponse status = 1; */
        if (message.status)
            GetThrottlerStatusResponse$.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetThrottlerStatusResponse
 */
export const GetThrottlerStatusResponse = new GetThrottlerStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTopologyPathRequest$Type extends MessageType<GetTopologyPathRequest> {
    constructor() {
        super("vtctldata.GetTopologyPathRequest", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "as_json", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetTopologyPathRequest>): GetTopologyPathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.version = 0n;
        message.asJson = false;
        if (value !== undefined)
            reflectionMergePartial<GetTopologyPathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopologyPathRequest): GetTopologyPathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* int64 version */ 2:
                    message.version = reader.int64().toBigInt();
                    break;
                case /* bool as_json */ 3:
                    message.asJson = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopologyPathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* int64 version = 2; */
        if (message.version !== 0n)
            writer.tag(2, WireType.Varint).int64(message.version);
        /* bool as_json = 3; */
        if (message.asJson !== false)
            writer.tag(3, WireType.Varint).bool(message.asJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTopologyPathRequest
 */
export const GetTopologyPathRequest = new GetTopologyPathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTopologyPathResponse$Type extends MessageType<GetTopologyPathResponse> {
    constructor() {
        super("vtctldata.GetTopologyPathResponse", [
            { no: 1, name: "cell", kind: "message", T: () => TopologyCell }
        ]);
    }
    create(value?: PartialMessage<GetTopologyPathResponse>): GetTopologyPathResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTopologyPathResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopologyPathResponse): GetTopologyPathResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.TopologyCell cell */ 1:
                    message.cell = TopologyCell.internalBinaryRead(reader, reader.uint32(), options, message.cell);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopologyPathResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.TopologyCell cell = 1; */
        if (message.cell)
            TopologyCell.internalBinaryWrite(message.cell, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetTopologyPathResponse
 */
export const GetTopologyPathResponse = new GetTopologyPathResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopologyCell$Type extends MessageType<TopologyCell> {
    constructor() {
        super("vtctldata.TopologyCell", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "children", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TopologyCell>): TopologyCell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.path = "";
        message.data = "";
        message.children = [];
        message.version = 0n;
        if (value !== undefined)
            reflectionMergePartial<TopologyCell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopologyCell): TopologyCell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* string data */ 3:
                    message.data = reader.string();
                    break;
                case /* repeated string children */ 4:
                    message.children.push(reader.string());
                    break;
                case /* int64 version */ 5:
                    message.version = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TopologyCell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* string data = 3; */
        if (message.data !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.data);
        /* repeated string children = 4; */
        for (let i = 0; i < message.children.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.children[i]);
        /* int64 version = 5; */
        if (message.version !== 0n)
            writer.tag(5, WireType.Varint).int64(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.TopologyCell
 */
export const TopologyCell = new TopologyCell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUnresolvedTransactionsRequest$Type extends MessageType<GetUnresolvedTransactionsRequest> {
    constructor() {
        super("vtctldata.GetUnresolvedTransactionsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "abandon_age", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetUnresolvedTransactionsRequest>): GetUnresolvedTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.abandonAge = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetUnresolvedTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUnresolvedTransactionsRequest): GetUnresolvedTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* int64 abandon_age */ 2:
                    message.abandonAge = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUnresolvedTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* int64 abandon_age = 2; */
        if (message.abandonAge !== 0n)
            writer.tag(2, WireType.Varint).int64(message.abandonAge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetUnresolvedTransactionsRequest
 */
export const GetUnresolvedTransactionsRequest = new GetUnresolvedTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUnresolvedTransactionsResponse$Type extends MessageType<GetUnresolvedTransactionsResponse> {
    constructor() {
        super("vtctldata.GetUnresolvedTransactionsResponse", [
            { no: 1, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionMetadata }
        ]);
    }
    create(value?: PartialMessage<GetUnresolvedTransactionsResponse>): GetUnresolvedTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<GetUnresolvedTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUnresolvedTransactionsResponse): GetUnresolvedTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.TransactionMetadata transactions */ 1:
                    message.transactions.push(TransactionMetadata.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUnresolvedTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.TransactionMetadata transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            TransactionMetadata.internalBinaryWrite(message.transactions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetUnresolvedTransactionsResponse
 */
export const GetUnresolvedTransactionsResponse = new GetUnresolvedTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcludeTransactionRequest$Type extends MessageType<ConcludeTransactionRequest> {
    constructor() {
        super("vtctldata.ConcludeTransactionRequest", [
            { no: 1, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Target }
        ]);
    }
    create(value?: PartialMessage<ConcludeTransactionRequest>): ConcludeTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        message.participants = [];
        if (value !== undefined)
            reflectionMergePartial<ConcludeTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcludeTransactionRequest): ConcludeTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dtid */ 1:
                    message.dtid = reader.string();
                    break;
                case /* repeated query.Target participants */ 2:
                    message.participants.push(Target.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcludeTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dtid = 1; */
        if (message.dtid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dtid);
        /* repeated query.Target participants = 2; */
        for (let i = 0; i < message.participants.length; i++)
            Target.internalBinaryWrite(message.participants[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ConcludeTransactionRequest
 */
export const ConcludeTransactionRequest = new ConcludeTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcludeTransactionResponse$Type extends MessageType<ConcludeTransactionResponse> {
    constructor() {
        super("vtctldata.ConcludeTransactionResponse", []);
    }
    create(value?: PartialMessage<ConcludeTransactionResponse>): ConcludeTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConcludeTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcludeTransactionResponse): ConcludeTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcludeTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ConcludeTransactionResponse
 */
export const ConcludeTransactionResponse = new ConcludeTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVSchemaRequest$Type extends MessageType<GetVSchemaRequest> {
    constructor() {
        super("vtctldata.GetVSchemaRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVSchemaRequest>): GetVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<GetVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVSchemaRequest): GetVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetVSchemaRequest
 */
export const GetVSchemaRequest = new GetVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVersionRequest$Type extends MessageType<GetVersionRequest> {
    constructor() {
        super("vtctldata.GetVersionRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetVersionRequest>): GetVersionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVersionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVersionRequest): GetVersionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVersionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetVersionRequest
 */
export const GetVersionRequest = new GetVersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVersionResponse$Type extends MessageType<GetVersionResponse> {
    constructor() {
        super("vtctldata.GetVersionResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVersionResponse>): GetVersionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<GetVersionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVersionResponse): GetVersionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVersionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetVersionResponse
 */
export const GetVersionResponse = new GetVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVSchemaResponse$Type extends MessageType<GetVSchemaResponse> {
    constructor() {
        super("vtctldata.GetVSchemaResponse", [
            { no: 1, name: "v_schema", kind: "message", T: () => Keyspace$2 }
        ]);
    }
    create(value?: PartialMessage<GetVSchemaResponse>): GetVSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVSchemaResponse): GetVSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.Keyspace v_schema */ 1:
                    message.vSchema = Keyspace$2.internalBinaryRead(reader, reader.uint32(), options, message.vSchema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.Keyspace v_schema = 1; */
        if (message.vSchema)
            Keyspace$2.internalBinaryWrite(message.vSchema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetVSchemaResponse
 */
export const GetVSchemaResponse = new GetVSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowsRequest$Type extends MessageType<GetWorkflowsRequest> {
    constructor() {
        super("vtctldata.GetWorkflowsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "name_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "include_logs", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowsRequest>): GetWorkflowsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.activeOnly = false;
        message.nameOnly = false;
        message.workflow = "";
        message.includeLogs = false;
        message.shards = [];
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowsRequest): GetWorkflowsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool active_only */ 2:
                    message.activeOnly = reader.bool();
                    break;
                case /* bool name_only */ 3:
                    message.nameOnly = reader.bool();
                    break;
                case /* string workflow */ 4:
                    message.workflow = reader.string();
                    break;
                case /* bool include_logs */ 5:
                    message.includeLogs = reader.bool();
                    break;
                case /* repeated string shards */ 6:
                    message.shards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool active_only = 2; */
        if (message.activeOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.activeOnly);
        /* bool name_only = 3; */
        if (message.nameOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.nameOnly);
        /* string workflow = 4; */
        if (message.workflow !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workflow);
        /* bool include_logs = 5; */
        if (message.includeLogs !== false)
            writer.tag(5, WireType.Varint).bool(message.includeLogs);
        /* repeated string shards = 6; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.shards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetWorkflowsRequest
 */
export const GetWorkflowsRequest = new GetWorkflowsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowsResponse$Type extends MessageType<GetWorkflowsResponse> {
    constructor() {
        super("vtctldata.GetWorkflowsResponse", [
            { no: 1, name: "workflows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Workflow }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowsResponse>): GetWorkflowsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflows = [];
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowsResponse): GetWorkflowsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.Workflow workflows */ 1:
                    message.workflows.push(Workflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.Workflow workflows = 1; */
        for (let i = 0; i < message.workflows.length; i++)
            Workflow.internalBinaryWrite(message.workflows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetWorkflowsResponse
 */
export const GetWorkflowsResponse = new GetWorkflowsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitShardPrimaryRequest$Type extends MessageType<InitShardPrimaryRequest> {
    constructor() {
        super("vtctldata.InitShardPrimaryRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primary_elect_tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 4, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "wait_replicas_timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<InitShardPrimaryRequest>): InitShardPrimaryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<InitShardPrimaryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitShardPrimaryRequest): InitShardPrimaryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias primary_elect_tablet_alias */ 3:
                    message.primaryElectTabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.primaryElectTabletAlias);
                    break;
                case /* bool force */ 4:
                    message.force = reader.bool();
                    break;
                case /* vttime.Duration wait_replicas_timeout */ 5:
                    message.waitReplicasTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.waitReplicasTimeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitShardPrimaryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias primary_elect_tablet_alias = 3; */
        if (message.primaryElectTabletAlias)
            TabletAlias.internalBinaryWrite(message.primaryElectTabletAlias, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool force = 4; */
        if (message.force !== false)
            writer.tag(4, WireType.Varint).bool(message.force);
        /* vttime.Duration wait_replicas_timeout = 5; */
        if (message.waitReplicasTimeout)
            Duration.internalBinaryWrite(message.waitReplicasTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.InitShardPrimaryRequest
 */
export const InitShardPrimaryRequest = new InitShardPrimaryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitShardPrimaryResponse$Type extends MessageType<InitShardPrimaryResponse> {
    constructor() {
        super("vtctldata.InitShardPrimaryResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<InitShardPrimaryResponse>): InitShardPrimaryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<InitShardPrimaryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitShardPrimaryResponse): InitShardPrimaryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logutil.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitShardPrimaryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logutil.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.InitShardPrimaryResponse
 */
export const InitShardPrimaryResponse = new InitShardPrimaryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchSchemaMigrationRequest$Type extends MessageType<LaunchSchemaMigrationRequest> {
    constructor() {
        super("vtctldata.LaunchSchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LaunchSchemaMigrationRequest>): LaunchSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<LaunchSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchSchemaMigrationRequest): LaunchSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LaunchSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LaunchSchemaMigrationRequest
 */
export const LaunchSchemaMigrationRequest = new LaunchSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchSchemaMigrationResponse$Type extends MessageType<LaunchSchemaMigrationResponse> {
    constructor() {
        super("vtctldata.LaunchSchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<LaunchSchemaMigrationResponse>): LaunchSchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<LaunchSchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchSchemaMigrationResponse): LaunchSchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LaunchSchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LaunchSchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: LaunchSchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.LaunchSchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: LaunchSchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LaunchSchemaMigrationResponse
 */
export const LaunchSchemaMigrationResponse = new LaunchSchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupVindexCreateRequest$Type extends MessageType<LookupVindexCreateRequest> {
    constructor() {
        super("vtctldata.LookupVindexCreateRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "vindex", kind: "message", T: () => Keyspace$2 },
            { no: 5, name: "continue_after_copy_with_owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 7, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] }
        ]);
    }
    create(value?: PartialMessage<LookupVindexCreateRequest>): LookupVindexCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.workflow = "";
        message.cells = [];
        message.continueAfterCopyWithOwner = false;
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        if (value !== undefined)
            reflectionMergePartial<LookupVindexCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupVindexCreateRequest): LookupVindexCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 2:
                    message.workflow = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                case /* vschema.Keyspace vindex */ 4:
                    message.vindex = Keyspace$2.internalBinaryRead(reader, reader.uint32(), options, message.vindex);
                    break;
                case /* bool continue_after_copy_with_owner */ 5:
                    message.continueAfterCopyWithOwner = reader.bool();
                    break;
                case /* repeated topodata.TabletType tablet_types */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 7:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupVindexCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 2; */
        if (message.workflow !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflow);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        /* vschema.Keyspace vindex = 4; */
        if (message.vindex)
            Keyspace$2.internalBinaryWrite(message.vindex, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool continue_after_copy_with_owner = 5; */
        if (message.continueAfterCopyWithOwner !== false)
            writer.tag(5, WireType.Varint).bool(message.continueAfterCopyWithOwner);
        /* repeated topodata.TabletType tablet_types = 6; */
        if (message.tabletTypes.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(7, WireType.Varint).int32(message.tabletSelectionPreference);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LookupVindexCreateRequest
 */
export const LookupVindexCreateRequest = new LookupVindexCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupVindexCreateResponse$Type extends MessageType<LookupVindexCreateResponse> {
    constructor() {
        super("vtctldata.LookupVindexCreateResponse", []);
    }
    create(value?: PartialMessage<LookupVindexCreateResponse>): LookupVindexCreateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LookupVindexCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupVindexCreateResponse): LookupVindexCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupVindexCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LookupVindexCreateResponse
 */
export const LookupVindexCreateResponse = new LookupVindexCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupVindexExternalizeRequest$Type extends MessageType<LookupVindexExternalizeRequest> {
    constructor() {
        super("vtctldata.LookupVindexExternalizeRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LookupVindexExternalizeRequest>): LookupVindexExternalizeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.name = "";
        message.tableKeyspace = "";
        if (value !== undefined)
            reflectionMergePartial<LookupVindexExternalizeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupVindexExternalizeRequest): LookupVindexExternalizeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string table_keyspace */ 3:
                    message.tableKeyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupVindexExternalizeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string table_keyspace = 3; */
        if (message.tableKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tableKeyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LookupVindexExternalizeRequest
 */
export const LookupVindexExternalizeRequest = new LookupVindexExternalizeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupVindexExternalizeResponse$Type extends MessageType<LookupVindexExternalizeResponse> {
    constructor() {
        super("vtctldata.LookupVindexExternalizeResponse", [
            { no: 1, name: "workflow_deleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LookupVindexExternalizeResponse>): LookupVindexExternalizeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowDeleted = false;
        if (value !== undefined)
            reflectionMergePartial<LookupVindexExternalizeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupVindexExternalizeResponse): LookupVindexExternalizeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool workflow_deleted */ 1:
                    message.workflowDeleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupVindexExternalizeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool workflow_deleted = 1; */
        if (message.workflowDeleted !== false)
            writer.tag(1, WireType.Varint).bool(message.workflowDeleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.LookupVindexExternalizeResponse
 */
export const LookupVindexExternalizeResponse = new LookupVindexExternalizeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterializeCreateRequest$Type extends MessageType<MaterializeCreateRequest> {
    constructor() {
        super("vtctldata.MaterializeCreateRequest", [
            { no: 1, name: "settings", kind: "message", T: () => MaterializeSettings }
        ]);
    }
    create(value?: PartialMessage<MaterializeCreateRequest>): MaterializeCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MaterializeCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterializeCreateRequest): MaterializeCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtctldata.MaterializeSettings settings */ 1:
                    message.settings = MaterializeSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterializeCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtctldata.MaterializeSettings settings = 1; */
        if (message.settings)
            MaterializeSettings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MaterializeCreateRequest
 */
export const MaterializeCreateRequest = new MaterializeCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaterializeCreateResponse$Type extends MessageType<MaterializeCreateResponse> {
    constructor() {
        super("vtctldata.MaterializeCreateResponse", []);
    }
    create(value?: PartialMessage<MaterializeCreateResponse>): MaterializeCreateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MaterializeCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaterializeCreateResponse): MaterializeCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaterializeCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MaterializeCreateResponse
 */
export const MaterializeCreateResponse = new MaterializeCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MigrateCreateRequest$Type extends MessageType<MigrateCreateRequest> {
    constructor() {
        super("vtctldata.MigrateCreateRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mount_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 7, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 8, name: "all_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "include_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "exclude_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "source_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "on_ddl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "stop_after_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "drop_foreign_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "defer_secondary_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "auto_start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "no_routing_rules", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MigrateCreateRequest>): MigrateCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.sourceKeyspace = "";
        message.targetKeyspace = "";
        message.mountName = "";
        message.cells = [];
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        message.allTables = false;
        message.includeTables = [];
        message.excludeTables = [];
        message.sourceTimeZone = "";
        message.onDdl = "";
        message.stopAfterCopy = false;
        message.dropForeignKeys = false;
        message.deferSecondaryKeys = false;
        message.autoStart = false;
        message.noRoutingRules = false;
        if (value !== undefined)
            reflectionMergePartial<MigrateCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MigrateCreateRequest): MigrateCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string source_keyspace */ 2:
                    message.sourceKeyspace = reader.string();
                    break;
                case /* string target_keyspace */ 3:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string mount_name */ 4:
                    message.mountName = reader.string();
                    break;
                case /* repeated string cells */ 5:
                    message.cells.push(reader.string());
                    break;
                case /* repeated topodata.TabletType tablet_types */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 7:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* bool all_tables */ 8:
                    message.allTables = reader.bool();
                    break;
                case /* repeated string include_tables */ 9:
                    message.includeTables.push(reader.string());
                    break;
                case /* repeated string exclude_tables */ 10:
                    message.excludeTables.push(reader.string());
                    break;
                case /* string source_time_zone */ 11:
                    message.sourceTimeZone = reader.string();
                    break;
                case /* string on_ddl */ 12:
                    message.onDdl = reader.string();
                    break;
                case /* bool stop_after_copy */ 13:
                    message.stopAfterCopy = reader.bool();
                    break;
                case /* bool drop_foreign_keys */ 14:
                    message.dropForeignKeys = reader.bool();
                    break;
                case /* bool defer_secondary_keys */ 15:
                    message.deferSecondaryKeys = reader.bool();
                    break;
                case /* bool auto_start */ 16:
                    message.autoStart = reader.bool();
                    break;
                case /* bool no_routing_rules */ 17:
                    message.noRoutingRules = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MigrateCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string source_keyspace = 2; */
        if (message.sourceKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceKeyspace);
        /* string target_keyspace = 3; */
        if (message.targetKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string mount_name = 4; */
        if (message.mountName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.mountName);
        /* repeated string cells = 5; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated topodata.TabletType tablet_types = 6; */
        if (message.tabletTypes.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(7, WireType.Varint).int32(message.tabletSelectionPreference);
        /* bool all_tables = 8; */
        if (message.allTables !== false)
            writer.tag(8, WireType.Varint).bool(message.allTables);
        /* repeated string include_tables = 9; */
        for (let i = 0; i < message.includeTables.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.includeTables[i]);
        /* repeated string exclude_tables = 10; */
        for (let i = 0; i < message.excludeTables.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.excludeTables[i]);
        /* string source_time_zone = 11; */
        if (message.sourceTimeZone !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sourceTimeZone);
        /* string on_ddl = 12; */
        if (message.onDdl !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.onDdl);
        /* bool stop_after_copy = 13; */
        if (message.stopAfterCopy !== false)
            writer.tag(13, WireType.Varint).bool(message.stopAfterCopy);
        /* bool drop_foreign_keys = 14; */
        if (message.dropForeignKeys !== false)
            writer.tag(14, WireType.Varint).bool(message.dropForeignKeys);
        /* bool defer_secondary_keys = 15; */
        if (message.deferSecondaryKeys !== false)
            writer.tag(15, WireType.Varint).bool(message.deferSecondaryKeys);
        /* bool auto_start = 16; */
        if (message.autoStart !== false)
            writer.tag(16, WireType.Varint).bool(message.autoStart);
        /* bool no_routing_rules = 17; */
        if (message.noRoutingRules !== false)
            writer.tag(17, WireType.Varint).bool(message.noRoutingRules);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MigrateCreateRequest
 */
export const MigrateCreateRequest = new MigrateCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MigrateCompleteRequest$Type extends MessageType<MigrateCompleteRequest> {
    constructor() {
        super("vtctldata.MigrateCompleteRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "keep_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "keep_routing_rules", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "rename_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MigrateCompleteRequest>): MigrateCompleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.keepData = false;
        message.keepRoutingRules = false;
        message.renameTables = false;
        message.dryRun = false;
        if (value !== undefined)
            reflectionMergePartial<MigrateCompleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MigrateCompleteRequest): MigrateCompleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 3:
                    message.targetKeyspace = reader.string();
                    break;
                case /* bool keep_data */ 4:
                    message.keepData = reader.bool();
                    break;
                case /* bool keep_routing_rules */ 5:
                    message.keepRoutingRules = reader.bool();
                    break;
                case /* bool rename_tables */ 6:
                    message.renameTables = reader.bool();
                    break;
                case /* bool dry_run */ 7:
                    message.dryRun = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MigrateCompleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 3; */
        if (message.targetKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetKeyspace);
        /* bool keep_data = 4; */
        if (message.keepData !== false)
            writer.tag(4, WireType.Varint).bool(message.keepData);
        /* bool keep_routing_rules = 5; */
        if (message.keepRoutingRules !== false)
            writer.tag(5, WireType.Varint).bool(message.keepRoutingRules);
        /* bool rename_tables = 6; */
        if (message.renameTables !== false)
            writer.tag(6, WireType.Varint).bool(message.renameTables);
        /* bool dry_run = 7; */
        if (message.dryRun !== false)
            writer.tag(7, WireType.Varint).bool(message.dryRun);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MigrateCompleteRequest
 */
export const MigrateCompleteRequest = new MigrateCompleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MigrateCompleteResponse$Type extends MessageType<MigrateCompleteResponse> {
    constructor() {
        super("vtctldata.MigrateCompleteResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dry_run_results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MigrateCompleteResponse>): MigrateCompleteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.dryRunResults = [];
        if (value !== undefined)
            reflectionMergePartial<MigrateCompleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MigrateCompleteResponse): MigrateCompleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* repeated string dry_run_results */ 2:
                    message.dryRunResults.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MigrateCompleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* repeated string dry_run_results = 2; */
        for (let i = 0; i < message.dryRunResults.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dryRunResults[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MigrateCompleteResponse
 */
export const MigrateCompleteResponse = new MigrateCompleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountRegisterRequest$Type extends MessageType<MountRegisterRequest> {
    constructor() {
        super("vtctldata.MountRegisterRequest", [
            { no: 1, name: "topo_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "topo_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "topo_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MountRegisterRequest>): MountRegisterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.topoType = "";
        message.topoServer = "";
        message.topoRoot = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MountRegisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountRegisterRequest): MountRegisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string topo_type */ 1:
                    message.topoType = reader.string();
                    break;
                case /* string topo_server */ 2:
                    message.topoServer = reader.string();
                    break;
                case /* string topo_root */ 3:
                    message.topoRoot = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountRegisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string topo_type = 1; */
        if (message.topoType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.topoType);
        /* string topo_server = 2; */
        if (message.topoServer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.topoServer);
        /* string topo_root = 3; */
        if (message.topoRoot !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.topoRoot);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountRegisterRequest
 */
export const MountRegisterRequest = new MountRegisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountRegisterResponse$Type extends MessageType<MountRegisterResponse> {
    constructor() {
        super("vtctldata.MountRegisterResponse", []);
    }
    create(value?: PartialMessage<MountRegisterResponse>): MountRegisterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MountRegisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountRegisterResponse): MountRegisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountRegisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountRegisterResponse
 */
export const MountRegisterResponse = new MountRegisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountUnregisterRequest$Type extends MessageType<MountUnregisterRequest> {
    constructor() {
        super("vtctldata.MountUnregisterRequest", [
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MountUnregisterRequest>): MountUnregisterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MountUnregisterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountUnregisterRequest): MountUnregisterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountUnregisterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountUnregisterRequest
 */
export const MountUnregisterRequest = new MountUnregisterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountUnregisterResponse$Type extends MessageType<MountUnregisterResponse> {
    constructor() {
        super("vtctldata.MountUnregisterResponse", []);
    }
    create(value?: PartialMessage<MountUnregisterResponse>): MountUnregisterResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MountUnregisterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountUnregisterResponse): MountUnregisterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountUnregisterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountUnregisterResponse
 */
export const MountUnregisterResponse = new MountUnregisterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountShowRequest$Type extends MessageType<MountShowRequest> {
    constructor() {
        super("vtctldata.MountShowRequest", [
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MountShowRequest>): MountShowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MountShowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountShowRequest): MountShowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountShowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountShowRequest
 */
export const MountShowRequest = new MountShowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountShowResponse$Type extends MessageType<MountShowResponse> {
    constructor() {
        super("vtctldata.MountShowResponse", [
            { no: 1, name: "topo_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "topo_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "topo_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MountShowResponse>): MountShowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.topoType = "";
        message.topoServer = "";
        message.topoRoot = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<MountShowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountShowResponse): MountShowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string topo_type */ 1:
                    message.topoType = reader.string();
                    break;
                case /* string topo_server */ 2:
                    message.topoServer = reader.string();
                    break;
                case /* string topo_root */ 3:
                    message.topoRoot = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountShowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string topo_type = 1; */
        if (message.topoType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.topoType);
        /* string topo_server = 2; */
        if (message.topoServer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.topoServer);
        /* string topo_root = 3; */
        if (message.topoRoot !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.topoRoot);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountShowResponse
 */
export const MountShowResponse = new MountShowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountListRequest$Type extends MessageType<MountListRequest> {
    constructor() {
        super("vtctldata.MountListRequest", []);
    }
    create(value?: PartialMessage<MountListRequest>): MountListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MountListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountListRequest): MountListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountListRequest
 */
export const MountListRequest = new MountListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MountListResponse$Type extends MessageType<MountListResponse> {
    constructor() {
        super("vtctldata.MountListResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MountListResponse>): MountListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<MountListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MountListResponse): MountListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MountListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MountListResponse
 */
export const MountListResponse = new MountListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCreateRequest$Type extends MessageType<MoveTablesCreateRequest> {
    constructor() {
        super("vtctldata.MoveTablesCreateRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "source_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 6, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 7, name: "source_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "all_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "include_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "exclude_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "external_cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "source_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "on_ddl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "stop_after_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "drop_foreign_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "defer_secondary_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "auto_start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "no_routing_rules", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "atomic_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "workflow_options", kind: "message", T: () => WorkflowOptions }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCreateRequest>): MoveTablesCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.sourceKeyspace = "";
        message.targetKeyspace = "";
        message.cells = [];
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        message.sourceShards = [];
        message.allTables = false;
        message.includeTables = [];
        message.excludeTables = [];
        message.externalClusterName = "";
        message.sourceTimeZone = "";
        message.onDdl = "";
        message.stopAfterCopy = false;
        message.dropForeignKeys = false;
        message.deferSecondaryKeys = false;
        message.autoStart = false;
        message.noRoutingRules = false;
        message.atomicCopy = false;
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCreateRequest): MoveTablesCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string source_keyspace */ 2:
                    message.sourceKeyspace = reader.string();
                    break;
                case /* string target_keyspace */ 3:
                    message.targetKeyspace = reader.string();
                    break;
                case /* repeated string cells */ 4:
                    message.cells.push(reader.string());
                    break;
                case /* repeated topodata.TabletType tablet_types */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 6:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* repeated string source_shards */ 7:
                    message.sourceShards.push(reader.string());
                    break;
                case /* bool all_tables */ 8:
                    message.allTables = reader.bool();
                    break;
                case /* repeated string include_tables */ 9:
                    message.includeTables.push(reader.string());
                    break;
                case /* repeated string exclude_tables */ 10:
                    message.excludeTables.push(reader.string());
                    break;
                case /* string external_cluster_name */ 11:
                    message.externalClusterName = reader.string();
                    break;
                case /* string source_time_zone */ 12:
                    message.sourceTimeZone = reader.string();
                    break;
                case /* string on_ddl */ 13:
                    message.onDdl = reader.string();
                    break;
                case /* bool stop_after_copy */ 14:
                    message.stopAfterCopy = reader.bool();
                    break;
                case /* bool drop_foreign_keys */ 15:
                    message.dropForeignKeys = reader.bool();
                    break;
                case /* bool defer_secondary_keys */ 16:
                    message.deferSecondaryKeys = reader.bool();
                    break;
                case /* bool auto_start */ 17:
                    message.autoStart = reader.bool();
                    break;
                case /* bool no_routing_rules */ 18:
                    message.noRoutingRules = reader.bool();
                    break;
                case /* bool atomic_copy */ 19:
                    message.atomicCopy = reader.bool();
                    break;
                case /* vtctldata.WorkflowOptions workflow_options */ 20:
                    message.workflowOptions = WorkflowOptions.internalBinaryRead(reader, reader.uint32(), options, message.workflowOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string source_keyspace = 2; */
        if (message.sourceKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sourceKeyspace);
        /* string target_keyspace = 3; */
        if (message.targetKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetKeyspace);
        /* repeated string cells = 4; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated topodata.TabletType tablet_types = 5; */
        if (message.tabletTypes.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 6; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(6, WireType.Varint).int32(message.tabletSelectionPreference);
        /* repeated string source_shards = 7; */
        for (let i = 0; i < message.sourceShards.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.sourceShards[i]);
        /* bool all_tables = 8; */
        if (message.allTables !== false)
            writer.tag(8, WireType.Varint).bool(message.allTables);
        /* repeated string include_tables = 9; */
        for (let i = 0; i < message.includeTables.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.includeTables[i]);
        /* repeated string exclude_tables = 10; */
        for (let i = 0; i < message.excludeTables.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.excludeTables[i]);
        /* string external_cluster_name = 11; */
        if (message.externalClusterName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.externalClusterName);
        /* string source_time_zone = 12; */
        if (message.sourceTimeZone !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.sourceTimeZone);
        /* string on_ddl = 13; */
        if (message.onDdl !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.onDdl);
        /* bool stop_after_copy = 14; */
        if (message.stopAfterCopy !== false)
            writer.tag(14, WireType.Varint).bool(message.stopAfterCopy);
        /* bool drop_foreign_keys = 15; */
        if (message.dropForeignKeys !== false)
            writer.tag(15, WireType.Varint).bool(message.dropForeignKeys);
        /* bool defer_secondary_keys = 16; */
        if (message.deferSecondaryKeys !== false)
            writer.tag(16, WireType.Varint).bool(message.deferSecondaryKeys);
        /* bool auto_start = 17; */
        if (message.autoStart !== false)
            writer.tag(17, WireType.Varint).bool(message.autoStart);
        /* bool no_routing_rules = 18; */
        if (message.noRoutingRules !== false)
            writer.tag(18, WireType.Varint).bool(message.noRoutingRules);
        /* bool atomic_copy = 19; */
        if (message.atomicCopy !== false)
            writer.tag(19, WireType.Varint).bool(message.atomicCopy);
        /* vtctldata.WorkflowOptions workflow_options = 20; */
        if (message.workflowOptions)
            WorkflowOptions.internalBinaryWrite(message.workflowOptions, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MoveTablesCreateRequest
 */
export const MoveTablesCreateRequest = new MoveTablesCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCreateResponse$Type extends MessageType<MoveTablesCreateResponse> {
    constructor() {
        super("vtctldata.MoveTablesCreateResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "details", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoveTablesCreateResponse_TabletInfo }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCreateResponse>): MoveTablesCreateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.details = [];
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCreateResponse): MoveTablesCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* repeated vtctldata.MoveTablesCreateResponse.TabletInfo details */ 2:
                    message.details.push(MoveTablesCreateResponse_TabletInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* repeated vtctldata.MoveTablesCreateResponse.TabletInfo details = 2; */
        for (let i = 0; i < message.details.length; i++)
            MoveTablesCreateResponse_TabletInfo.internalBinaryWrite(message.details[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MoveTablesCreateResponse
 */
export const MoveTablesCreateResponse = new MoveTablesCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCreateResponse_TabletInfo$Type extends MessageType<MoveTablesCreateResponse_TabletInfo> {
    constructor() {
        super("vtctldata.MoveTablesCreateResponse.TabletInfo", [
            { no: 1, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 2, name: "created", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCreateResponse_TabletInfo>): MoveTablesCreateResponse_TabletInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.created = false;
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCreateResponse_TabletInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCreateResponse_TabletInfo): MoveTablesCreateResponse_TabletInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet */ 1:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* bool created */ 2:
                    message.created = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCreateResponse_TabletInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet = 1; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool created = 2; */
        if (message.created !== false)
            writer.tag(2, WireType.Varint).bool(message.created);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MoveTablesCreateResponse.TabletInfo
 */
export const MoveTablesCreateResponse_TabletInfo = new MoveTablesCreateResponse_TabletInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCompleteRequest$Type extends MessageType<MoveTablesCompleteRequest> {
    constructor() {
        super("vtctldata.MoveTablesCompleteRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "keep_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "keep_routing_rules", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "rename_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCompleteRequest>): MoveTablesCompleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.keepData = false;
        message.keepRoutingRules = false;
        message.renameTables = false;
        message.dryRun = false;
        message.shards = [];
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCompleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCompleteRequest): MoveTablesCompleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 3:
                    message.targetKeyspace = reader.string();
                    break;
                case /* bool keep_data */ 4:
                    message.keepData = reader.bool();
                    break;
                case /* bool keep_routing_rules */ 5:
                    message.keepRoutingRules = reader.bool();
                    break;
                case /* bool rename_tables */ 6:
                    message.renameTables = reader.bool();
                    break;
                case /* bool dry_run */ 7:
                    message.dryRun = reader.bool();
                    break;
                case /* repeated string shards */ 8:
                    message.shards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCompleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 3; */
        if (message.targetKeyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.targetKeyspace);
        /* bool keep_data = 4; */
        if (message.keepData !== false)
            writer.tag(4, WireType.Varint).bool(message.keepData);
        /* bool keep_routing_rules = 5; */
        if (message.keepRoutingRules !== false)
            writer.tag(5, WireType.Varint).bool(message.keepRoutingRules);
        /* bool rename_tables = 6; */
        if (message.renameTables !== false)
            writer.tag(6, WireType.Varint).bool(message.renameTables);
        /* bool dry_run = 7; */
        if (message.dryRun !== false)
            writer.tag(7, WireType.Varint).bool(message.dryRun);
        /* repeated string shards = 8; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.shards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MoveTablesCompleteRequest
 */
export const MoveTablesCompleteRequest = new MoveTablesCompleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCompleteResponse$Type extends MessageType<MoveTablesCompleteResponse> {
    constructor() {
        super("vtctldata.MoveTablesCompleteResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dry_run_results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCompleteResponse>): MoveTablesCompleteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.dryRunResults = [];
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCompleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCompleteResponse): MoveTablesCompleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* repeated string dry_run_results */ 2:
                    message.dryRunResults.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCompleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* repeated string dry_run_results = 2; */
        for (let i = 0; i < message.dryRunResults.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.dryRunResults[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.MoveTablesCompleteResponse
 */
export const MoveTablesCompleteResponse = new MoveTablesCompleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingTabletRequest$Type extends MessageType<PingTabletRequest> {
    constructor() {
        super("vtctldata.PingTabletRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<PingTabletRequest>): PingTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PingTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingTabletRequest): PingTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.PingTabletRequest
 */
export const PingTabletRequest = new PingTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingTabletResponse$Type extends MessageType<PingTabletResponse> {
    constructor() {
        super("vtctldata.PingTabletResponse", []);
    }
    create(value?: PartialMessage<PingTabletResponse>): PingTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PingTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingTabletResponse): PingTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.PingTabletResponse
 */
export const PingTabletResponse = new PingTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedReparentShardRequest$Type extends MessageType<PlannedReparentShardRequest> {
    constructor() {
        super("vtctldata.PlannedReparentShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "avoid_primary", kind: "message", T: () => TabletAlias },
            { no: 5, name: "wait_replicas_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "tolerable_replication_lag", kind: "message", T: () => Duration },
            { no: 7, name: "allow_cross_cell_promotion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "expected_primary", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<PlannedReparentShardRequest>): PlannedReparentShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.allowCrossCellPromotion = false;
        if (value !== undefined)
            reflectionMergePartial<PlannedReparentShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedReparentShardRequest): PlannedReparentShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias new_primary */ 3:
                    message.newPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.newPrimary);
                    break;
                case /* topodata.TabletAlias avoid_primary */ 4:
                    message.avoidPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.avoidPrimary);
                    break;
                case /* vttime.Duration wait_replicas_timeout */ 5:
                    message.waitReplicasTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.waitReplicasTimeout);
                    break;
                case /* vttime.Duration tolerable_replication_lag */ 6:
                    message.tolerableReplicationLag = Duration.internalBinaryRead(reader, reader.uint32(), options, message.tolerableReplicationLag);
                    break;
                case /* bool allow_cross_cell_promotion */ 7:
                    message.allowCrossCellPromotion = reader.bool();
                    break;
                case /* topodata.TabletAlias expected_primary */ 8:
                    message.expectedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.expectedPrimary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedReparentShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias new_primary = 3; */
        if (message.newPrimary)
            TabletAlias.internalBinaryWrite(message.newPrimary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletAlias avoid_primary = 4; */
        if (message.avoidPrimary)
            TabletAlias.internalBinaryWrite(message.avoidPrimary, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Duration wait_replicas_timeout = 5; */
        if (message.waitReplicasTimeout)
            Duration.internalBinaryWrite(message.waitReplicasTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Duration tolerable_replication_lag = 6; */
        if (message.tolerableReplicationLag)
            Duration.internalBinaryWrite(message.tolerableReplicationLag, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_cross_cell_promotion = 7; */
        if (message.allowCrossCellPromotion !== false)
            writer.tag(7, WireType.Varint).bool(message.allowCrossCellPromotion);
        /* topodata.TabletAlias expected_primary = 8; */
        if (message.expectedPrimary)
            TabletAlias.internalBinaryWrite(message.expectedPrimary, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.PlannedReparentShardRequest
 */
export const PlannedReparentShardRequest = new PlannedReparentShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedReparentShardResponse$Type extends MessageType<PlannedReparentShardResponse> {
    constructor() {
        super("vtctldata.PlannedReparentShardResponse", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "promoted_primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<PlannedReparentShardResponse>): PlannedReparentShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<PlannedReparentShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedReparentShardResponse): PlannedReparentShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias promoted_primary */ 3:
                    message.promotedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.promotedPrimary);
                    break;
                case /* repeated logutil.Event events */ 4:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedReparentShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias promoted_primary = 3; */
        if (message.promotedPrimary)
            TabletAlias.internalBinaryWrite(message.promotedPrimary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 4; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.PlannedReparentShardResponse
 */
export const PlannedReparentShardResponse = new PlannedReparentShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildKeyspaceGraphRequest$Type extends MessageType<RebuildKeyspaceGraphRequest> {
    constructor() {
        super("vtctldata.RebuildKeyspaceGraphRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allow_partial", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RebuildKeyspaceGraphRequest>): RebuildKeyspaceGraphRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.cells = [];
        message.allowPartial = false;
        if (value !== undefined)
            reflectionMergePartial<RebuildKeyspaceGraphRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildKeyspaceGraphRequest): RebuildKeyspaceGraphRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                case /* bool allow_partial */ 3:
                    message.allowPartial = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildKeyspaceGraphRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        /* bool allow_partial = 3; */
        if (message.allowPartial !== false)
            writer.tag(3, WireType.Varint).bool(message.allowPartial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RebuildKeyspaceGraphRequest
 */
export const RebuildKeyspaceGraphRequest = new RebuildKeyspaceGraphRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildKeyspaceGraphResponse$Type extends MessageType<RebuildKeyspaceGraphResponse> {
    constructor() {
        super("vtctldata.RebuildKeyspaceGraphResponse", []);
    }
    create(value?: PartialMessage<RebuildKeyspaceGraphResponse>): RebuildKeyspaceGraphResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RebuildKeyspaceGraphResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildKeyspaceGraphResponse): RebuildKeyspaceGraphResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildKeyspaceGraphResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RebuildKeyspaceGraphResponse
 */
export const RebuildKeyspaceGraphResponse = new RebuildKeyspaceGraphResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildVSchemaGraphRequest$Type extends MessageType<RebuildVSchemaGraphRequest> {
    constructor() {
        super("vtctldata.RebuildVSchemaGraphRequest", [
            { no: 1, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RebuildVSchemaGraphRequest>): RebuildVSchemaGraphRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<RebuildVSchemaGraphRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildVSchemaGraphRequest): RebuildVSchemaGraphRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cells */ 1:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildVSchemaGraphRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cells = 1; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RebuildVSchemaGraphRequest
 */
export const RebuildVSchemaGraphRequest = new RebuildVSchemaGraphRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildVSchemaGraphResponse$Type extends MessageType<RebuildVSchemaGraphResponse> {
    constructor() {
        super("vtctldata.RebuildVSchemaGraphResponse", []);
    }
    create(value?: PartialMessage<RebuildVSchemaGraphResponse>): RebuildVSchemaGraphResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RebuildVSchemaGraphResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildVSchemaGraphResponse): RebuildVSchemaGraphResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildVSchemaGraphResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RebuildVSchemaGraphResponse
 */
export const RebuildVSchemaGraphResponse = new RebuildVSchemaGraphResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateRequest$Type extends MessageType<RefreshStateRequest> {
    constructor() {
        super("vtctldata.RefreshStateRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<RefreshStateRequest>): RefreshStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RefreshStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateRequest): RefreshStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RefreshStateRequest
 */
export const RefreshStateRequest = new RefreshStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateResponse$Type extends MessageType<RefreshStateResponse> {
    constructor() {
        super("vtctldata.RefreshStateResponse", []);
    }
    create(value?: PartialMessage<RefreshStateResponse>): RefreshStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RefreshStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateResponse): RefreshStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RefreshStateResponse
 */
export const RefreshStateResponse = new RefreshStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateByShardRequest$Type extends MessageType<RefreshStateByShardRequest> {
    constructor() {
        super("vtctldata.RefreshStateByShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshStateByShardRequest>): RefreshStateByShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<RefreshStateByShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateByShardRequest): RefreshStateByShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateByShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RefreshStateByShardRequest
 */
export const RefreshStateByShardRequest = new RefreshStateByShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateByShardResponse$Type extends MessageType<RefreshStateByShardResponse> {
    constructor() {
        super("vtctldata.RefreshStateByShardResponse", [
            { no: 1, name: "is_partial_refresh", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "partial_refresh_details", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshStateByShardResponse>): RefreshStateByShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isPartialRefresh = false;
        message.partialRefreshDetails = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshStateByShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateByShardResponse): RefreshStateByShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_partial_refresh */ 1:
                    message.isPartialRefresh = reader.bool();
                    break;
                case /* string partial_refresh_details */ 2:
                    message.partialRefreshDetails = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateByShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_partial_refresh = 1; */
        if (message.isPartialRefresh !== false)
            writer.tag(1, WireType.Varint).bool(message.isPartialRefresh);
        /* string partial_refresh_details = 2; */
        if (message.partialRefreshDetails !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.partialRefreshDetails);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RefreshStateByShardResponse
 */
export const RefreshStateByShardResponse = new RefreshStateByShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaRequest$Type extends MessageType<ReloadSchemaRequest> {
    constructor() {
        super("vtctldata.ReloadSchemaRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaRequest>): ReloadSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaRequest): ReloadSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaRequest
 */
export const ReloadSchemaRequest = new ReloadSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaResponse$Type extends MessageType<ReloadSchemaResponse> {
    constructor() {
        super("vtctldata.ReloadSchemaResponse", []);
    }
    create(value?: PartialMessage<ReloadSchemaResponse>): ReloadSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaResponse): ReloadSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaResponse
 */
export const ReloadSchemaResponse = new ReloadSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaKeyspaceRequest$Type extends MessageType<ReloadSchemaKeyspaceRequest> {
    constructor() {
        super("vtctldata.ReloadSchemaKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "wait_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaKeyspaceRequest>): ReloadSchemaKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.waitPosition = "";
        message.includePrimary = false;
        message.concurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaKeyspaceRequest): ReloadSchemaKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string wait_position */ 2:
                    message.waitPosition = reader.string();
                    break;
                case /* bool include_primary */ 3:
                    message.includePrimary = reader.bool();
                    break;
                case /* int32 concurrency */ 4:
                    message.concurrency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string wait_position = 2; */
        if (message.waitPosition !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.waitPosition);
        /* bool include_primary = 3; */
        if (message.includePrimary !== false)
            writer.tag(3, WireType.Varint).bool(message.includePrimary);
        /* int32 concurrency = 4; */
        if (message.concurrency !== 0)
            writer.tag(4, WireType.Varint).int32(message.concurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaKeyspaceRequest
 */
export const ReloadSchemaKeyspaceRequest = new ReloadSchemaKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaKeyspaceResponse$Type extends MessageType<ReloadSchemaKeyspaceResponse> {
    constructor() {
        super("vtctldata.ReloadSchemaKeyspaceResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaKeyspaceResponse>): ReloadSchemaKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaKeyspaceResponse): ReloadSchemaKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logutil.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logutil.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaKeyspaceResponse
 */
export const ReloadSchemaKeyspaceResponse = new ReloadSchemaKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaShardRequest$Type extends MessageType<ReloadSchemaShardRequest> {
    constructor() {
        super("vtctldata.ReloadSchemaShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "wait_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "include_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaShardRequest>): ReloadSchemaShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.waitPosition = "";
        message.includePrimary = false;
        message.concurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaShardRequest): ReloadSchemaShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* string wait_position */ 3:
                    message.waitPosition = reader.string();
                    break;
                case /* bool include_primary */ 4:
                    message.includePrimary = reader.bool();
                    break;
                case /* int32 concurrency */ 5:
                    message.concurrency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* string wait_position = 3; */
        if (message.waitPosition !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.waitPosition);
        /* bool include_primary = 4; */
        if (message.includePrimary !== false)
            writer.tag(4, WireType.Varint).bool(message.includePrimary);
        /* int32 concurrency = 5; */
        if (message.concurrency !== 0)
            writer.tag(5, WireType.Varint).int32(message.concurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaShardRequest
 */
export const ReloadSchemaShardRequest = new ReloadSchemaShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaShardResponse$Type extends MessageType<ReloadSchemaShardResponse> {
    constructor() {
        super("vtctldata.ReloadSchemaShardResponse", [
            { no: 2, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaShardResponse>): ReloadSchemaShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaShardResponse): ReloadSchemaShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logutil.Event events */ 2:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logutil.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReloadSchemaShardResponse
 */
export const ReloadSchemaShardResponse = new ReloadSchemaShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveBackupRequest$Type extends MessageType<RemoveBackupRequest> {
    constructor() {
        super("vtctldata.RemoveBackupRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveBackupRequest>): RemoveBackupRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveBackupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveBackupRequest): RemoveBackupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveBackupRequest
 */
export const RemoveBackupRequest = new RemoveBackupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveBackupResponse$Type extends MessageType<RemoveBackupResponse> {
    constructor() {
        super("vtctldata.RemoveBackupResponse", []);
    }
    create(value?: PartialMessage<RemoveBackupResponse>): RemoveBackupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoveBackupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveBackupResponse): RemoveBackupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveBackupResponse
 */
export const RemoveBackupResponse = new RemoveBackupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveKeyspaceCellRequest$Type extends MessageType<RemoveKeyspaceCellRequest> {
    constructor() {
        super("vtctldata.RemoveKeyspaceCellRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveKeyspaceCellRequest>): RemoveKeyspaceCellRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.cell = "";
        message.force = false;
        message.recursive = false;
        if (value !== undefined)
            reflectionMergePartial<RemoveKeyspaceCellRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveKeyspaceCellRequest): RemoveKeyspaceCellRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string cell */ 2:
                    message.cell = reader.string();
                    break;
                case /* bool force */ 3:
                    message.force = reader.bool();
                    break;
                case /* bool recursive */ 4:
                    message.recursive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveKeyspaceCellRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string cell = 2; */
        if (message.cell !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cell);
        /* bool force = 3; */
        if (message.force !== false)
            writer.tag(3, WireType.Varint).bool(message.force);
        /* bool recursive = 4; */
        if (message.recursive !== false)
            writer.tag(4, WireType.Varint).bool(message.recursive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveKeyspaceCellRequest
 */
export const RemoveKeyspaceCellRequest = new RemoveKeyspaceCellRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveKeyspaceCellResponse$Type extends MessageType<RemoveKeyspaceCellResponse> {
    constructor() {
        super("vtctldata.RemoveKeyspaceCellResponse", []);
    }
    create(value?: PartialMessage<RemoveKeyspaceCellResponse>): RemoveKeyspaceCellResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoveKeyspaceCellResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveKeyspaceCellResponse): RemoveKeyspaceCellResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveKeyspaceCellResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveKeyspaceCellResponse
 */
export const RemoveKeyspaceCellResponse = new RemoveKeyspaceCellResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveShardCellRequest$Type extends MessageType<RemoveShardCellRequest> {
    constructor() {
        super("vtctldata.RemoveShardCellRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveShardCellRequest>): RemoveShardCellRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shardName = "";
        message.cell = "";
        message.force = false;
        message.recursive = false;
        if (value !== undefined)
            reflectionMergePartial<RemoveShardCellRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveShardCellRequest): RemoveShardCellRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard_name */ 2:
                    message.shardName = reader.string();
                    break;
                case /* string cell */ 3:
                    message.cell = reader.string();
                    break;
                case /* bool force */ 4:
                    message.force = reader.bool();
                    break;
                case /* bool recursive */ 5:
                    message.recursive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveShardCellRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard_name = 2; */
        if (message.shardName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shardName);
        /* string cell = 3; */
        if (message.cell !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cell);
        /* bool force = 4; */
        if (message.force !== false)
            writer.tag(4, WireType.Varint).bool(message.force);
        /* bool recursive = 5; */
        if (message.recursive !== false)
            writer.tag(5, WireType.Varint).bool(message.recursive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveShardCellRequest
 */
export const RemoveShardCellRequest = new RemoveShardCellRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveShardCellResponse$Type extends MessageType<RemoveShardCellResponse> {
    constructor() {
        super("vtctldata.RemoveShardCellResponse", []);
    }
    create(value?: PartialMessage<RemoveShardCellResponse>): RemoveShardCellResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoveShardCellResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveShardCellResponse): RemoveShardCellResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveShardCellResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RemoveShardCellResponse
 */
export const RemoveShardCellResponse = new RemoveShardCellResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReparentTabletRequest$Type extends MessageType<ReparentTabletRequest> {
    constructor() {
        super("vtctldata.ReparentTabletRequest", [
            { no: 1, name: "tablet", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ReparentTabletRequest>): ReparentTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReparentTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReparentTabletRequest): ReparentTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet */ 1:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReparentTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet = 1; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReparentTabletRequest
 */
export const ReparentTabletRequest = new ReparentTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReparentTabletResponse$Type extends MessageType<ReparentTabletResponse> {
    constructor() {
        super("vtctldata.ReparentTabletResponse", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primary", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ReparentTabletResponse>): ReparentTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ReparentTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReparentTabletResponse): ReparentTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias primary */ 3:
                    message.primary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.primary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReparentTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias primary = 3; */
        if (message.primary)
            TabletAlias.internalBinaryWrite(message.primary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReparentTabletResponse
 */
export const ReparentTabletResponse = new ReparentTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReshardCreateRequest$Type extends MessageType<ReshardCreateRequest> {
    constructor() {
        super("vtctldata.ReshardCreateRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "source_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 7, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 8, name: "skip_schema_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "on_ddl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "stop_after_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "defer_secondary_keys", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "auto_start", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "workflow_options", kind: "message", T: () => WorkflowOptions }
        ]);
    }
    create(value?: PartialMessage<ReshardCreateRequest>): ReshardCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.keyspace = "";
        message.sourceShards = [];
        message.targetShards = [];
        message.cells = [];
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        message.skipSchemaCopy = false;
        message.onDdl = "";
        message.stopAfterCopy = false;
        message.deferSecondaryKeys = false;
        message.autoStart = false;
        if (value !== undefined)
            reflectionMergePartial<ReshardCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReshardCreateRequest): ReshardCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string source_shards */ 3:
                    message.sourceShards.push(reader.string());
                    break;
                case /* repeated string target_shards */ 4:
                    message.targetShards.push(reader.string());
                    break;
                case /* repeated string cells */ 5:
                    message.cells.push(reader.string());
                    break;
                case /* repeated topodata.TabletType tablet_types */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 7:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* bool skip_schema_copy */ 8:
                    message.skipSchemaCopy = reader.bool();
                    break;
                case /* string on_ddl */ 9:
                    message.onDdl = reader.string();
                    break;
                case /* bool stop_after_copy */ 10:
                    message.stopAfterCopy = reader.bool();
                    break;
                case /* bool defer_secondary_keys */ 11:
                    message.deferSecondaryKeys = reader.bool();
                    break;
                case /* bool auto_start */ 12:
                    message.autoStart = reader.bool();
                    break;
                case /* vtctldata.WorkflowOptions workflow_options */ 13:
                    message.workflowOptions = WorkflowOptions.internalBinaryRead(reader, reader.uint32(), options, message.workflowOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReshardCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string source_shards = 3; */
        for (let i = 0; i < message.sourceShards.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.sourceShards[i]);
        /* repeated string target_shards = 4; */
        for (let i = 0; i < message.targetShards.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.targetShards[i]);
        /* repeated string cells = 5; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated topodata.TabletType tablet_types = 6; */
        if (message.tabletTypes.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(7, WireType.Varint).int32(message.tabletSelectionPreference);
        /* bool skip_schema_copy = 8; */
        if (message.skipSchemaCopy !== false)
            writer.tag(8, WireType.Varint).bool(message.skipSchemaCopy);
        /* string on_ddl = 9; */
        if (message.onDdl !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.onDdl);
        /* bool stop_after_copy = 10; */
        if (message.stopAfterCopy !== false)
            writer.tag(10, WireType.Varint).bool(message.stopAfterCopy);
        /* bool defer_secondary_keys = 11; */
        if (message.deferSecondaryKeys !== false)
            writer.tag(11, WireType.Varint).bool(message.deferSecondaryKeys);
        /* bool auto_start = 12; */
        if (message.autoStart !== false)
            writer.tag(12, WireType.Varint).bool(message.autoStart);
        /* vtctldata.WorkflowOptions workflow_options = 13; */
        if (message.workflowOptions)
            WorkflowOptions.internalBinaryWrite(message.workflowOptions, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ReshardCreateRequest
 */
export const ReshardCreateRequest = new ReshardCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreFromBackupRequest$Type extends MessageType<RestoreFromBackupRequest> {
    constructor() {
        super("vtctldata.RestoreFromBackupRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "backup_time", kind: "message", T: () => Time },
            { no: 3, name: "restore_to_pos", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "restore_to_timestamp", kind: "message", T: () => Time },
            { no: 6, name: "allowed_backup_engines", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RestoreFromBackupRequest>): RestoreFromBackupRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.restoreToPos = "";
        message.dryRun = false;
        message.allowedBackupEngines = [];
        if (value !== undefined)
            reflectionMergePartial<RestoreFromBackupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreFromBackupRequest): RestoreFromBackupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* vttime.Time backup_time */ 2:
                    message.backupTime = Time.internalBinaryRead(reader, reader.uint32(), options, message.backupTime);
                    break;
                case /* string restore_to_pos */ 3:
                    message.restoreToPos = reader.string();
                    break;
                case /* bool dry_run */ 4:
                    message.dryRun = reader.bool();
                    break;
                case /* vttime.Time restore_to_timestamp */ 5:
                    message.restoreToTimestamp = Time.internalBinaryRead(reader, reader.uint32(), options, message.restoreToTimestamp);
                    break;
                case /* repeated string allowed_backup_engines */ 6:
                    message.allowedBackupEngines.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreFromBackupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time backup_time = 2; */
        if (message.backupTime)
            Time.internalBinaryWrite(message.backupTime, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string restore_to_pos = 3; */
        if (message.restoreToPos !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.restoreToPos);
        /* bool dry_run = 4; */
        if (message.dryRun !== false)
            writer.tag(4, WireType.Varint).bool(message.dryRun);
        /* vttime.Time restore_to_timestamp = 5; */
        if (message.restoreToTimestamp)
            Time.internalBinaryWrite(message.restoreToTimestamp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string allowed_backup_engines = 6; */
        for (let i = 0; i < message.allowedBackupEngines.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.allowedBackupEngines[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RestoreFromBackupRequest
 */
export const RestoreFromBackupRequest = new RestoreFromBackupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RestoreFromBackupResponse$Type extends MessageType<RestoreFromBackupResponse> {
    constructor() {
        super("vtctldata.RestoreFromBackupResponse", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<RestoreFromBackupResponse>): RestoreFromBackupResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<RestoreFromBackupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RestoreFromBackupResponse): RestoreFromBackupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* logutil.Event event */ 4:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RestoreFromBackupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* logutil.Event event = 4; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RestoreFromBackupResponse
 */
export const RestoreFromBackupResponse = new RestoreFromBackupResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrySchemaMigrationRequest$Type extends MessageType<RetrySchemaMigrationRequest> {
    constructor() {
        super("vtctldata.RetrySchemaMigrationRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RetrySchemaMigrationRequest>): RetrySchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<RetrySchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrySchemaMigrationRequest): RetrySchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrySchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RetrySchemaMigrationRequest
 */
export const RetrySchemaMigrationRequest = new RetrySchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrySchemaMigrationResponse$Type extends MessageType<RetrySchemaMigrationResponse> {
    constructor() {
        super("vtctldata.RetrySchemaMigrationResponse", [
            { no: 1, name: "rows_affected_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ } }
        ]);
    }
    create(value?: PartialMessage<RetrySchemaMigrationResponse>): RetrySchemaMigrationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsAffectedByShard = {};
        if (value !== undefined)
            reflectionMergePartial<RetrySchemaMigrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrySchemaMigrationResponse): RetrySchemaMigrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, uint64> rows_affected_by_shard */ 1:
                    this.binaryReadMap1(message.rowsAffectedByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: RetrySchemaMigrationResponse["rowsAffectedByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RetrySchemaMigrationResponse["rowsAffectedByShard"] | undefined, val: RetrySchemaMigrationResponse["rowsAffectedByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.RetrySchemaMigrationResponse.rows_affected_by_shard");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    internalBinaryWrite(message: RetrySchemaMigrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, uint64> rows_affected_by_shard = 1; */
        for (let k of globalThis.Object.keys(message.rowsAffectedByShard))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.rowsAffectedByShard[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RetrySchemaMigrationResponse
 */
export const RetrySchemaMigrationResponse = new RetrySchemaMigrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunHealthCheckRequest$Type extends MessageType<RunHealthCheckRequest> {
    constructor() {
        super("vtctldata.RunHealthCheckRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<RunHealthCheckRequest>): RunHealthCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunHealthCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunHealthCheckRequest): RunHealthCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunHealthCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RunHealthCheckRequest
 */
export const RunHealthCheckRequest = new RunHealthCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunHealthCheckResponse$Type extends MessageType<RunHealthCheckResponse> {
    constructor() {
        super("vtctldata.RunHealthCheckResponse", []);
    }
    create(value?: PartialMessage<RunHealthCheckResponse>): RunHealthCheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunHealthCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunHealthCheckResponse): RunHealthCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunHealthCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.RunHealthCheckResponse
 */
export const RunHealthCheckResponse = new RunHealthCheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeyspaceDurabilityPolicyRequest$Type extends MessageType<SetKeyspaceDurabilityPolicyRequest> {
    constructor() {
        super("vtctldata.SetKeyspaceDurabilityPolicyRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "durability_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetKeyspaceDurabilityPolicyRequest>): SetKeyspaceDurabilityPolicyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.durabilityPolicy = "";
        if (value !== undefined)
            reflectionMergePartial<SetKeyspaceDurabilityPolicyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetKeyspaceDurabilityPolicyRequest): SetKeyspaceDurabilityPolicyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string durability_policy */ 2:
                    message.durabilityPolicy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetKeyspaceDurabilityPolicyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string durability_policy = 2; */
        if (message.durabilityPolicy !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.durabilityPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetKeyspaceDurabilityPolicyRequest
 */
export const SetKeyspaceDurabilityPolicyRequest = new SetKeyspaceDurabilityPolicyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeyspaceDurabilityPolicyResponse$Type extends MessageType<SetKeyspaceDurabilityPolicyResponse> {
    constructor() {
        super("vtctldata.SetKeyspaceDurabilityPolicyResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace$ }
        ]);
    }
    create(value?: PartialMessage<SetKeyspaceDurabilityPolicyResponse>): SetKeyspaceDurabilityPolicyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetKeyspaceDurabilityPolicyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetKeyspaceDurabilityPolicyResponse): SetKeyspaceDurabilityPolicyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace$.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetKeyspaceDurabilityPolicyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace$.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetKeyspaceDurabilityPolicyResponse
 */
export const SetKeyspaceDurabilityPolicyResponse = new SetKeyspaceDurabilityPolicyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeyspaceShardingInfoRequest$Type extends MessageType<SetKeyspaceShardingInfoRequest> {
    constructor() {
        super("vtctldata.SetKeyspaceShardingInfoRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetKeyspaceShardingInfoRequest>): SetKeyspaceShardingInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<SetKeyspaceShardingInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetKeyspaceShardingInfoRequest): SetKeyspaceShardingInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool force */ 4:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetKeyspaceShardingInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool force = 4; */
        if (message.force !== false)
            writer.tag(4, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetKeyspaceShardingInfoRequest
 */
export const SetKeyspaceShardingInfoRequest = new SetKeyspaceShardingInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeyspaceShardingInfoResponse$Type extends MessageType<SetKeyspaceShardingInfoResponse> {
    constructor() {
        super("vtctldata.SetKeyspaceShardingInfoResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace$ }
        ]);
    }
    create(value?: PartialMessage<SetKeyspaceShardingInfoResponse>): SetKeyspaceShardingInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetKeyspaceShardingInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetKeyspaceShardingInfoResponse): SetKeyspaceShardingInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace$.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetKeyspaceShardingInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace$.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetKeyspaceShardingInfoResponse
 */
export const SetKeyspaceShardingInfoResponse = new SetKeyspaceShardingInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetShardIsPrimaryServingRequest$Type extends MessageType<SetShardIsPrimaryServingRequest> {
    constructor() {
        super("vtctldata.SetShardIsPrimaryServingRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_serving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetShardIsPrimaryServingRequest>): SetShardIsPrimaryServingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.isServing = false;
        if (value !== undefined)
            reflectionMergePartial<SetShardIsPrimaryServingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetShardIsPrimaryServingRequest): SetShardIsPrimaryServingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* bool is_serving */ 3:
                    message.isServing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetShardIsPrimaryServingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* bool is_serving = 3; */
        if (message.isServing !== false)
            writer.tag(3, WireType.Varint).bool(message.isServing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetShardIsPrimaryServingRequest
 */
export const SetShardIsPrimaryServingRequest = new SetShardIsPrimaryServingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetShardIsPrimaryServingResponse$Type extends MessageType<SetShardIsPrimaryServingResponse> {
    constructor() {
        super("vtctldata.SetShardIsPrimaryServingResponse", [
            { no: 1, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<SetShardIsPrimaryServingResponse>): SetShardIsPrimaryServingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetShardIsPrimaryServingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetShardIsPrimaryServingResponse): SetShardIsPrimaryServingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Shard shard */ 1:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetShardIsPrimaryServingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Shard shard = 1; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetShardIsPrimaryServingResponse
 */
export const SetShardIsPrimaryServingResponse = new SetShardIsPrimaryServingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetShardTabletControlRequest$Type extends MessageType<SetShardTabletControlRequest> {
    constructor() {
        super("vtctldata.SetShardTabletControlRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 4, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "denied_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "disable_query_service", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "remove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetShardTabletControlRequest>): SetShardTabletControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.tabletType = 0;
        message.cells = [];
        message.deniedTables = [];
        message.disableQueryService = false;
        message.remove = false;
        if (value !== undefined)
            reflectionMergePartial<SetShardTabletControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetShardTabletControlRequest): SetShardTabletControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletType tablet_type */ 3:
                    message.tabletType = reader.int32();
                    break;
                case /* repeated string cells */ 4:
                    message.cells.push(reader.string());
                    break;
                case /* repeated string denied_tables */ 5:
                    message.deniedTables.push(reader.string());
                    break;
                case /* bool disable_query_service */ 6:
                    message.disableQueryService = reader.bool();
                    break;
                case /* bool remove */ 7:
                    message.remove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetShardTabletControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletType tablet_type = 3; */
        if (message.tabletType !== 0)
            writer.tag(3, WireType.Varint).int32(message.tabletType);
        /* repeated string cells = 4; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated string denied_tables = 5; */
        for (let i = 0; i < message.deniedTables.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.deniedTables[i]);
        /* bool disable_query_service = 6; */
        if (message.disableQueryService !== false)
            writer.tag(6, WireType.Varint).bool(message.disableQueryService);
        /* bool remove = 7; */
        if (message.remove !== false)
            writer.tag(7, WireType.Varint).bool(message.remove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetShardTabletControlRequest
 */
export const SetShardTabletControlRequest = new SetShardTabletControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetShardTabletControlResponse$Type extends MessageType<SetShardTabletControlResponse> {
    constructor() {
        super("vtctldata.SetShardTabletControlResponse", [
            { no: 1, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<SetShardTabletControlResponse>): SetShardTabletControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetShardTabletControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetShardTabletControlResponse): SetShardTabletControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Shard shard */ 1:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetShardTabletControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Shard shard = 1; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetShardTabletControlResponse
 */
export const SetShardTabletControlResponse = new SetShardTabletControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWritableRequest$Type extends MessageType<SetWritableRequest> {
    constructor() {
        super("vtctldata.SetWritableRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "writable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetWritableRequest>): SetWritableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.writable = false;
        if (value !== undefined)
            reflectionMergePartial<SetWritableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWritableRequest): SetWritableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* bool writable */ 2:
                    message.writable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetWritableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool writable = 2; */
        if (message.writable !== false)
            writer.tag(2, WireType.Varint).bool(message.writable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetWritableRequest
 */
export const SetWritableRequest = new SetWritableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetWritableResponse$Type extends MessageType<SetWritableResponse> {
    constructor() {
        super("vtctldata.SetWritableResponse", []);
    }
    create(value?: PartialMessage<SetWritableResponse>): SetWritableResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetWritableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetWritableResponse): SetWritableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetWritableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SetWritableResponse
 */
export const SetWritableResponse = new SetWritableResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationAddRequest$Type extends MessageType<ShardReplicationAddRequest> {
    constructor() {
        super("vtctldata.ShardReplicationAddRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationAddRequest>): ShardReplicationAddRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationAddRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationAddRequest): ShardReplicationAddRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 3:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationAddRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias tablet_alias = 3; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationAddRequest
 */
export const ShardReplicationAddRequest = new ShardReplicationAddRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationAddResponse$Type extends MessageType<ShardReplicationAddResponse> {
    constructor() {
        super("vtctldata.ShardReplicationAddResponse", []);
    }
    create(value?: PartialMessage<ShardReplicationAddResponse>): ShardReplicationAddResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationAddResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationAddResponse): ShardReplicationAddResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationAddResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationAddResponse
 */
export const ShardReplicationAddResponse = new ShardReplicationAddResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationFixRequest$Type extends MessageType<ShardReplicationFixRequest> {
    constructor() {
        super("vtctldata.ShardReplicationFixRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationFixRequest>): ShardReplicationFixRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationFixRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationFixRequest): ShardReplicationFixRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* string cell */ 3:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationFixRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* string cell = 3; */
        if (message.cell !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationFixRequest
 */
export const ShardReplicationFixRequest = new ShardReplicationFixRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationFixResponse$Type extends MessageType<ShardReplicationFixResponse> {
    constructor() {
        super("vtctldata.ShardReplicationFixResponse", [
            { no: 1, name: "error", kind: "message", T: () => ShardReplicationError }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationFixResponse>): ShardReplicationFixResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationFixResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationFixResponse): ShardReplicationFixResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.ShardReplicationError error */ 1:
                    message.error = ShardReplicationError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationFixResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.ShardReplicationError error = 1; */
        if (message.error)
            ShardReplicationError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationFixResponse
 */
export const ShardReplicationFixResponse = new ShardReplicationFixResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationPositionsRequest$Type extends MessageType<ShardReplicationPositionsRequest> {
    constructor() {
        super("vtctldata.ShardReplicationPositionsRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationPositionsRequest>): ShardReplicationPositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationPositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationPositionsRequest): ShardReplicationPositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationPositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationPositionsRequest
 */
export const ShardReplicationPositionsRequest = new ShardReplicationPositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationPositionsResponse$Type extends MessageType<ShardReplicationPositionsResponse> {
    constructor() {
        super("vtctldata.ShardReplicationPositionsResponse", [
            { no: 1, name: "replication_statuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Status } },
            { no: 2, name: "tablet_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Tablet } }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationPositionsResponse>): ShardReplicationPositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.replicationStatuses = {};
        message.tabletMap = {};
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationPositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationPositionsResponse): ShardReplicationPositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, replicationdata.Status> replication_statuses */ 1:
                    this.binaryReadMap1(message.replicationStatuses, reader, options);
                    break;
                case /* map<string, topodata.Tablet> tablet_map */ 2:
                    this.binaryReadMap2(message.tabletMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ShardReplicationPositionsResponse["replicationStatuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShardReplicationPositionsResponse["replicationStatuses"] | undefined, val: ShardReplicationPositionsResponse["replicationStatuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Status.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ShardReplicationPositionsResponse.replication_statuses");
            }
        }
        map[key ?? ""] = val ?? Status.create();
    }
    private binaryReadMap2(map: ShardReplicationPositionsResponse["tabletMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShardReplicationPositionsResponse["tabletMap"] | undefined, val: ShardReplicationPositionsResponse["tabletMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Tablet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ShardReplicationPositionsResponse.tablet_map");
            }
        }
        map[key ?? ""] = val ?? Tablet.create();
    }
    internalBinaryWrite(message: ShardReplicationPositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, replicationdata.Status> replication_statuses = 1; */
        for (let k of globalThis.Object.keys(message.replicationStatuses)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Status.internalBinaryWrite(message.replicationStatuses[k], writer, options);
            writer.join().join();
        }
        /* map<string, topodata.Tablet> tablet_map = 2; */
        for (let k of globalThis.Object.keys(message.tabletMap)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Tablet.internalBinaryWrite(message.tabletMap[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationPositionsResponse
 */
export const ShardReplicationPositionsResponse = new ShardReplicationPositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationRemoveRequest$Type extends MessageType<ShardReplicationRemoveRequest> {
    constructor() {
        super("vtctldata.ShardReplicationRemoveRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationRemoveRequest>): ShardReplicationRemoveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationRemoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationRemoveRequest): ShardReplicationRemoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 3:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationRemoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias tablet_alias = 3; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationRemoveRequest
 */
export const ShardReplicationRemoveRequest = new ShardReplicationRemoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationRemoveResponse$Type extends MessageType<ShardReplicationRemoveResponse> {
    constructor() {
        super("vtctldata.ShardReplicationRemoveResponse", []);
    }
    create(value?: PartialMessage<ShardReplicationRemoveResponse>): ShardReplicationRemoveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationRemoveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationRemoveResponse): ShardReplicationRemoveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationRemoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ShardReplicationRemoveResponse
 */
export const ShardReplicationRemoveResponse = new ShardReplicationRemoveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SleepTabletRequest$Type extends MessageType<SleepTabletRequest> {
    constructor() {
        super("vtctldata.SleepTabletRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "duration", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<SleepTabletRequest>): SleepTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SleepTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SleepTabletRequest): SleepTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* vttime.Duration duration */ 2:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SleepTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Duration duration = 2; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SleepTabletRequest
 */
export const SleepTabletRequest = new SleepTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SleepTabletResponse$Type extends MessageType<SleepTabletResponse> {
    constructor() {
        super("vtctldata.SleepTabletResponse", []);
    }
    create(value?: PartialMessage<SleepTabletResponse>): SleepTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SleepTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SleepTabletResponse): SleepTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SleepTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SleepTabletResponse
 */
export const SleepTabletResponse = new SleepTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceShardAddRequest$Type extends MessageType<SourceShardAddRequest> {
    constructor() {
        super("vtctldata.SourceShardAddRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "source_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "source_shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 7, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SourceShardAddRequest>): SourceShardAddRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.uid = 0;
        message.sourceKeyspace = "";
        message.sourceShard = "";
        message.tables = [];
        if (value !== undefined)
            reflectionMergePartial<SourceShardAddRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceShardAddRequest): SourceShardAddRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* int32 uid */ 3:
                    message.uid = reader.int32();
                    break;
                case /* string source_keyspace */ 4:
                    message.sourceKeyspace = reader.string();
                    break;
                case /* string source_shard */ 5:
                    message.sourceShard = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 6:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* repeated string tables */ 7:
                    message.tables.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceShardAddRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* int32 uid = 3; */
        if (message.uid !== 0)
            writer.tag(3, WireType.Varint).int32(message.uid);
        /* string source_keyspace = 4; */
        if (message.sourceKeyspace !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.sourceKeyspace);
        /* string source_shard = 5; */
        if (message.sourceShard !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sourceShard);
        /* topodata.KeyRange key_range = 6; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tables = 7; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.tables[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SourceShardAddRequest
 */
export const SourceShardAddRequest = new SourceShardAddRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceShardAddResponse$Type extends MessageType<SourceShardAddResponse> {
    constructor() {
        super("vtctldata.SourceShardAddResponse", [
            { no: 1, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<SourceShardAddResponse>): SourceShardAddResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SourceShardAddResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceShardAddResponse): SourceShardAddResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Shard shard */ 1:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceShardAddResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Shard shard = 1; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SourceShardAddResponse
 */
export const SourceShardAddResponse = new SourceShardAddResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceShardDeleteRequest$Type extends MessageType<SourceShardDeleteRequest> {
    constructor() {
        super("vtctldata.SourceShardDeleteRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SourceShardDeleteRequest>): SourceShardDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.uid = 0;
        if (value !== undefined)
            reflectionMergePartial<SourceShardDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceShardDeleteRequest): SourceShardDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* int32 uid */ 3:
                    message.uid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceShardDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* int32 uid = 3; */
        if (message.uid !== 0)
            writer.tag(3, WireType.Varint).int32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SourceShardDeleteRequest
 */
export const SourceShardDeleteRequest = new SourceShardDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceShardDeleteResponse$Type extends MessageType<SourceShardDeleteResponse> {
    constructor() {
        super("vtctldata.SourceShardDeleteResponse", [
            { no: 1, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<SourceShardDeleteResponse>): SourceShardDeleteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SourceShardDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceShardDeleteResponse): SourceShardDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.Shard shard */ 1:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceShardDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.Shard shard = 1; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.SourceShardDeleteResponse
 */
export const SourceShardDeleteResponse = new SourceShardDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartReplicationRequest$Type extends MessageType<StartReplicationRequest> {
    constructor() {
        super("vtctldata.StartReplicationRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<StartReplicationRequest>): StartReplicationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartReplicationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartReplicationRequest): StartReplicationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartReplicationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.StartReplicationRequest
 */
export const StartReplicationRequest = new StartReplicationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartReplicationResponse$Type extends MessageType<StartReplicationResponse> {
    constructor() {
        super("vtctldata.StartReplicationResponse", []);
    }
    create(value?: PartialMessage<StartReplicationResponse>): StartReplicationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartReplicationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartReplicationResponse): StartReplicationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartReplicationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.StartReplicationResponse
 */
export const StartReplicationResponse = new StartReplicationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopReplicationRequest$Type extends MessageType<StopReplicationRequest> {
    constructor() {
        super("vtctldata.StopReplicationRequest", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<StopReplicationRequest>): StopReplicationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopReplicationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopReplicationRequest): StopReplicationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopReplicationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.StopReplicationRequest
 */
export const StopReplicationRequest = new StopReplicationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopReplicationResponse$Type extends MessageType<StopReplicationResponse> {
    constructor() {
        super("vtctldata.StopReplicationResponse", []);
    }
    create(value?: PartialMessage<StopReplicationResponse>): StopReplicationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopReplicationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopReplicationResponse): StopReplicationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopReplicationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.StopReplicationResponse
 */
export const StopReplicationResponse = new StopReplicationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletExternallyReparentedRequest$Type extends MessageType<TabletExternallyReparentedRequest> {
    constructor() {
        super("vtctldata.TabletExternallyReparentedRequest", [
            { no: 1, name: "tablet", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<TabletExternallyReparentedRequest>): TabletExternallyReparentedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TabletExternallyReparentedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletExternallyReparentedRequest): TabletExternallyReparentedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet */ 1:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletExternallyReparentedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet = 1; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.TabletExternallyReparentedRequest
 */
export const TabletExternallyReparentedRequest = new TabletExternallyReparentedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletExternallyReparentedResponse$Type extends MessageType<TabletExternallyReparentedResponse> {
    constructor() {
        super("vtctldata.TabletExternallyReparentedResponse", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "old_primary", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<TabletExternallyReparentedResponse>): TabletExternallyReparentedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<TabletExternallyReparentedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletExternallyReparentedResponse): TabletExternallyReparentedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias new_primary */ 3:
                    message.newPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.newPrimary);
                    break;
                case /* topodata.TabletAlias old_primary */ 4:
                    message.oldPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.oldPrimary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletExternallyReparentedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias new_primary = 3; */
        if (message.newPrimary)
            TabletAlias.internalBinaryWrite(message.newPrimary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletAlias old_primary = 4; */
        if (message.oldPrimary)
            TabletAlias.internalBinaryWrite(message.oldPrimary, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.TabletExternallyReparentedResponse
 */
export const TabletExternallyReparentedResponse = new TabletExternallyReparentedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCellInfoRequest$Type extends MessageType<UpdateCellInfoRequest> {
    constructor() {
        super("vtctldata.UpdateCellInfoRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cell_info", kind: "message", T: () => CellInfo }
        ]);
    }
    create(value?: PartialMessage<UpdateCellInfoRequest>): UpdateCellInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateCellInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCellInfoRequest): UpdateCellInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.CellInfo cell_info */ 2:
                    message.cellInfo = CellInfo.internalBinaryRead(reader, reader.uint32(), options, message.cellInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCellInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.CellInfo cell_info = 2; */
        if (message.cellInfo)
            CellInfo.internalBinaryWrite(message.cellInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateCellInfoRequest
 */
export const UpdateCellInfoRequest = new UpdateCellInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCellInfoResponse$Type extends MessageType<UpdateCellInfoResponse> {
    constructor() {
        super("vtctldata.UpdateCellInfoResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cell_info", kind: "message", T: () => CellInfo }
        ]);
    }
    create(value?: PartialMessage<UpdateCellInfoResponse>): UpdateCellInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateCellInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCellInfoResponse): UpdateCellInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.CellInfo cell_info */ 2:
                    message.cellInfo = CellInfo.internalBinaryRead(reader, reader.uint32(), options, message.cellInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCellInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.CellInfo cell_info = 2; */
        if (message.cellInfo)
            CellInfo.internalBinaryWrite(message.cellInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateCellInfoResponse
 */
export const UpdateCellInfoResponse = new UpdateCellInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCellsAliasRequest$Type extends MessageType<UpdateCellsAliasRequest> {
    constructor() {
        super("vtctldata.UpdateCellsAliasRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells_alias", kind: "message", T: () => CellsAlias }
        ]);
    }
    create(value?: PartialMessage<UpdateCellsAliasRequest>): UpdateCellsAliasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateCellsAliasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCellsAliasRequest): UpdateCellsAliasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.CellsAlias cells_alias */ 2:
                    message.cellsAlias = CellsAlias.internalBinaryRead(reader, reader.uint32(), options, message.cellsAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCellsAliasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.CellsAlias cells_alias = 2; */
        if (message.cellsAlias)
            CellsAlias.internalBinaryWrite(message.cellsAlias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateCellsAliasRequest
 */
export const UpdateCellsAliasRequest = new UpdateCellsAliasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCellsAliasResponse$Type extends MessageType<UpdateCellsAliasResponse> {
    constructor() {
        super("vtctldata.UpdateCellsAliasResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells_alias", kind: "message", T: () => CellsAlias }
        ]);
    }
    create(value?: PartialMessage<UpdateCellsAliasResponse>): UpdateCellsAliasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateCellsAliasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateCellsAliasResponse): UpdateCellsAliasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.CellsAlias cells_alias */ 2:
                    message.cellsAlias = CellsAlias.internalBinaryRead(reader, reader.uint32(), options, message.cellsAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateCellsAliasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.CellsAlias cells_alias = 2; */
        if (message.cellsAlias)
            CellsAlias.internalBinaryWrite(message.cellsAlias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.UpdateCellsAliasResponse
 */
export const UpdateCellsAliasResponse = new UpdateCellsAliasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("vtctldata.ValidateRequest", [
            { no: 1, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool ping_tablets */ 1:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool ping_tablets = 1; */
        if (message.pingTablets !== false)
            writer.tag(1, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateResponse$Type extends MessageType<ValidateResponse> {
    constructor() {
        super("vtctldata.ValidateResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results_by_keyspace", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ValidateKeyspaceResponse } }
        ]);
    }
    create(value?: PartialMessage<ValidateResponse>): ValidateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.resultsByKeyspace = {};
        if (value !== undefined)
            reflectionMergePartial<ValidateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateResponse): ValidateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                case /* map<string, vtctldata.ValidateKeyspaceResponse> results_by_keyspace */ 2:
                    this.binaryReadMap2(message.resultsByKeyspace, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ValidateResponse["resultsByKeyspace"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ValidateResponse["resultsByKeyspace"] | undefined, val: ValidateResponse["resultsByKeyspace"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ValidateKeyspaceResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ValidateResponse.results_by_keyspace");
            }
        }
        map[key ?? ""] = val ?? ValidateKeyspaceResponse.create();
    }
    internalBinaryWrite(message: ValidateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        /* map<string, vtctldata.ValidateKeyspaceResponse> results_by_keyspace = 2; */
        for (let k of globalThis.Object.keys(message.resultsByKeyspace)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ValidateKeyspaceResponse.internalBinaryWrite(message.resultsByKeyspace[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateResponse
 */
export const ValidateResponse = new ValidateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyspaceRequest$Type extends MessageType<ValidateKeyspaceRequest> {
    constructor() {
        super("vtctldata.ValidateKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyspaceRequest>): ValidateKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyspaceRequest): ValidateKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* bool ping_tablets */ 2:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* bool ping_tablets = 2; */
        if (message.pingTablets !== false)
            writer.tag(2, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateKeyspaceRequest
 */
export const ValidateKeyspaceRequest = new ValidateKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyspaceResponse$Type extends MessageType<ValidateKeyspaceResponse> {
    constructor() {
        super("vtctldata.ValidateKeyspaceResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ValidateShardResponse } }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyspaceResponse>): ValidateKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.resultsByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyspaceResponse): ValidateKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                case /* map<string, vtctldata.ValidateShardResponse> results_by_shard */ 2:
                    this.binaryReadMap2(message.resultsByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ValidateKeyspaceResponse["resultsByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ValidateKeyspaceResponse["resultsByShard"] | undefined, val: ValidateKeyspaceResponse["resultsByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ValidateShardResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ValidateKeyspaceResponse.results_by_shard");
            }
        }
        map[key ?? ""] = val ?? ValidateShardResponse.create();
    }
    internalBinaryWrite(message: ValidateKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        /* map<string, vtctldata.ValidateShardResponse> results_by_shard = 2; */
        for (let k of globalThis.Object.keys(message.resultsByShard)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ValidateShardResponse.internalBinaryWrite(message.resultsByShard[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateKeyspaceResponse
 */
export const ValidateKeyspaceResponse = new ValidateKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateSchemaKeyspaceRequest$Type extends MessageType<ValidateSchemaKeyspaceRequest> {
    constructor() {
        super("vtctldata.ValidateSchemaKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "exclude_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_views", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "skip_no_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "include_vschema", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateSchemaKeyspaceRequest>): ValidateSchemaKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.excludeTables = [];
        message.includeViews = false;
        message.skipNoPrimary = false;
        message.includeVschema = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateSchemaKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateSchemaKeyspaceRequest): ValidateSchemaKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string exclude_tables */ 2:
                    message.excludeTables.push(reader.string());
                    break;
                case /* bool include_views */ 3:
                    message.includeViews = reader.bool();
                    break;
                case /* bool skip_no_primary */ 4:
                    message.skipNoPrimary = reader.bool();
                    break;
                case /* bool include_vschema */ 5:
                    message.includeVschema = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateSchemaKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string exclude_tables = 2; */
        for (let i = 0; i < message.excludeTables.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.excludeTables[i]);
        /* bool include_views = 3; */
        if (message.includeViews !== false)
            writer.tag(3, WireType.Varint).bool(message.includeViews);
        /* bool skip_no_primary = 4; */
        if (message.skipNoPrimary !== false)
            writer.tag(4, WireType.Varint).bool(message.skipNoPrimary);
        /* bool include_vschema = 5; */
        if (message.includeVschema !== false)
            writer.tag(5, WireType.Varint).bool(message.includeVschema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateSchemaKeyspaceRequest
 */
export const ValidateSchemaKeyspaceRequest = new ValidateSchemaKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateSchemaKeyspaceResponse$Type extends MessageType<ValidateSchemaKeyspaceResponse> {
    constructor() {
        super("vtctldata.ValidateSchemaKeyspaceResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ValidateShardResponse } }
        ]);
    }
    create(value?: PartialMessage<ValidateSchemaKeyspaceResponse>): ValidateSchemaKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.resultsByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ValidateSchemaKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateSchemaKeyspaceResponse): ValidateSchemaKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                case /* map<string, vtctldata.ValidateShardResponse> results_by_shard */ 2:
                    this.binaryReadMap2(message.resultsByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ValidateSchemaKeyspaceResponse["resultsByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ValidateSchemaKeyspaceResponse["resultsByShard"] | undefined, val: ValidateSchemaKeyspaceResponse["resultsByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ValidateShardResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ValidateSchemaKeyspaceResponse.results_by_shard");
            }
        }
        map[key ?? ""] = val ?? ValidateShardResponse.create();
    }
    internalBinaryWrite(message: ValidateSchemaKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        /* map<string, vtctldata.ValidateShardResponse> results_by_shard = 2; */
        for (let k of globalThis.Object.keys(message.resultsByShard)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ValidateShardResponse.internalBinaryWrite(message.resultsByShard[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateSchemaKeyspaceResponse
 */
export const ValidateSchemaKeyspaceResponse = new ValidateSchemaKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateShardRequest$Type extends MessageType<ValidateShardRequest> {
    constructor() {
        super("vtctldata.ValidateShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateShardRequest>): ValidateShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateShardRequest): ValidateShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* bool ping_tablets */ 3:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* bool ping_tablets = 3; */
        if (message.pingTablets !== false)
            writer.tag(3, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateShardRequest
 */
export const ValidateShardRequest = new ValidateShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateShardResponse$Type extends MessageType<ValidateShardResponse> {
    constructor() {
        super("vtctldata.ValidateShardResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateShardResponse>): ValidateShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<ValidateShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateShardResponse): ValidateShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateShardResponse
 */
export const ValidateShardResponse = new ValidateShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionKeyspaceRequest$Type extends MessageType<ValidateVersionKeyspaceRequest> {
    constructor() {
        super("vtctldata.ValidateVersionKeyspaceRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionKeyspaceRequest>): ValidateVersionKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionKeyspaceRequest): ValidateVersionKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVersionKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVersionKeyspaceRequest
 */
export const ValidateVersionKeyspaceRequest = new ValidateVersionKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionKeyspaceResponse$Type extends MessageType<ValidateVersionKeyspaceResponse> {
    constructor() {
        super("vtctldata.ValidateVersionKeyspaceResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ValidateShardResponse } }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionKeyspaceResponse>): ValidateVersionKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.resultsByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionKeyspaceResponse): ValidateVersionKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                case /* map<string, vtctldata.ValidateShardResponse> results_by_shard */ 2:
                    this.binaryReadMap2(message.resultsByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ValidateVersionKeyspaceResponse["resultsByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ValidateVersionKeyspaceResponse["resultsByShard"] | undefined, val: ValidateVersionKeyspaceResponse["resultsByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ValidateShardResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ValidateVersionKeyspaceResponse.results_by_shard");
            }
        }
        map[key ?? ""] = val ?? ValidateShardResponse.create();
    }
    internalBinaryWrite(message: ValidateVersionKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        /* map<string, vtctldata.ValidateShardResponse> results_by_shard = 2; */
        for (let k of globalThis.Object.keys(message.resultsByShard)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ValidateShardResponse.internalBinaryWrite(message.resultsByShard[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVersionKeyspaceResponse
 */
export const ValidateVersionKeyspaceResponse = new ValidateVersionKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionShardRequest$Type extends MessageType<ValidateVersionShardRequest> {
    constructor() {
        super("vtctldata.ValidateVersionShardRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionShardRequest>): ValidateVersionShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionShardRequest): ValidateVersionShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVersionShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVersionShardRequest
 */
export const ValidateVersionShardRequest = new ValidateVersionShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionShardResponse$Type extends MessageType<ValidateVersionShardResponse> {
    constructor() {
        super("vtctldata.ValidateVersionShardResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionShardResponse>): ValidateVersionShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionShardResponse): ValidateVersionShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVersionShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVersionShardResponse
 */
export const ValidateVersionShardResponse = new ValidateVersionShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVSchemaRequest$Type extends MessageType<ValidateVSchemaRequest> {
    constructor() {
        super("vtctldata.ValidateVSchemaRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "exclude_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "include_views", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVSchemaRequest>): ValidateVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shards = [];
        message.excludeTables = [];
        message.includeViews = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVSchemaRequest): ValidateVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string shards */ 2:
                    message.shards.push(reader.string());
                    break;
                case /* repeated string exclude_tables */ 3:
                    message.excludeTables.push(reader.string());
                    break;
                case /* bool include_views */ 4:
                    message.includeViews = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string shards = 2; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.shards[i]);
        /* repeated string exclude_tables = 3; */
        for (let i = 0; i < message.excludeTables.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.excludeTables[i]);
        /* bool include_views = 4; */
        if (message.includeViews !== false)
            writer.tag(4, WireType.Varint).bool(message.includeViews);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVSchemaRequest
 */
export const ValidateVSchemaRequest = new ValidateVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVSchemaResponse$Type extends MessageType<ValidateVSchemaResponse> {
    constructor() {
        super("vtctldata.ValidateVSchemaResponse", [
            { no: 1, name: "results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "results_by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ValidateShardResponse } }
        ]);
    }
    create(value?: PartialMessage<ValidateVSchemaResponse>): ValidateVSchemaResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        message.resultsByShard = {};
        if (value !== undefined)
            reflectionMergePartial<ValidateVSchemaResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVSchemaResponse): ValidateVSchemaResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string results */ 1:
                    message.results.push(reader.string());
                    break;
                case /* map<string, vtctldata.ValidateShardResponse> results_by_shard */ 2:
                    this.binaryReadMap2(message.resultsByShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ValidateVSchemaResponse["resultsByShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ValidateVSchemaResponse["resultsByShard"] | undefined, val: ValidateVSchemaResponse["resultsByShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ValidateShardResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.ValidateVSchemaResponse.results_by_shard");
            }
        }
        map[key ?? ""] = val ?? ValidateShardResponse.create();
    }
    internalBinaryWrite(message: ValidateVSchemaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string results = 1; */
        for (let i = 0; i < message.results.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.results[i]);
        /* map<string, vtctldata.ValidateShardResponse> results_by_shard = 2; */
        for (let k of globalThis.Object.keys(message.resultsByShard)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ValidateShardResponse.internalBinaryWrite(message.resultsByShard[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.ValidateVSchemaResponse
 */
export const ValidateVSchemaResponse = new ValidateVSchemaResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffCreateRequest$Type extends MessageType<VDiffCreateRequest> {
    constructor() {
        super("vtctldata.VDiffCreateRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "source_cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "target_cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 7, name: "tablet_selection_preference", kind: "enum", T: () => ["tabletmanagerdata.TabletSelectionPreference", TabletSelectionPreference] },
            { no: 8, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "limit", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "filtered_replication_wait_time", kind: "message", T: () => Duration },
            { no: 11, name: "debug_query", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "only_p_ks", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "update_table_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "max_extra_rows_to_compare", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "wait", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "wait_update_interval", kind: "message", T: () => Duration },
            { no: 17, name: "auto_retry", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "verbose", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "max_report_sample_rows", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "max_diff_duration", kind: "message", T: () => Duration },
            { no: 21, name: "row_diff_column_truncate_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "auto_start", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffCreateRequest>): VDiffCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.uuid = "";
        message.sourceCells = [];
        message.targetCells = [];
        message.tabletTypes = [];
        message.tabletSelectionPreference = 0;
        message.tables = [];
        message.limit = 0n;
        message.debugQuery = false;
        message.onlyPKs = false;
        message.updateTableStats = false;
        message.maxExtraRowsToCompare = 0n;
        message.wait = false;
        message.autoRetry = false;
        message.verbose = false;
        message.maxReportSampleRows = 0n;
        message.rowDiffColumnTruncateAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<VDiffCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffCreateRequest): VDiffCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 2:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* repeated string source_cells */ 4:
                    message.sourceCells.push(reader.string());
                    break;
                case /* repeated string target_cells */ 5:
                    message.targetCells.push(reader.string());
                    break;
                case /* repeated topodata.TabletType tablet_types */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference */ 7:
                    message.tabletSelectionPreference = reader.int32();
                    break;
                case /* repeated string tables */ 8:
                    message.tables.push(reader.string());
                    break;
                case /* int64 limit */ 9:
                    message.limit = reader.int64().toBigInt();
                    break;
                case /* vttime.Duration filtered_replication_wait_time */ 10:
                    message.filteredReplicationWaitTime = Duration.internalBinaryRead(reader, reader.uint32(), options, message.filteredReplicationWaitTime);
                    break;
                case /* bool debug_query */ 11:
                    message.debugQuery = reader.bool();
                    break;
                case /* bool only_p_ks */ 12:
                    message.onlyPKs = reader.bool();
                    break;
                case /* bool update_table_stats */ 13:
                    message.updateTableStats = reader.bool();
                    break;
                case /* int64 max_extra_rows_to_compare */ 14:
                    message.maxExtraRowsToCompare = reader.int64().toBigInt();
                    break;
                case /* bool wait */ 15:
                    message.wait = reader.bool();
                    break;
                case /* vttime.Duration wait_update_interval */ 16:
                    message.waitUpdateInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.waitUpdateInterval);
                    break;
                case /* bool auto_retry */ 17:
                    message.autoRetry = reader.bool();
                    break;
                case /* bool verbose */ 18:
                    message.verbose = reader.bool();
                    break;
                case /* int64 max_report_sample_rows */ 19:
                    message.maxReportSampleRows = reader.int64().toBigInt();
                    break;
                case /* vttime.Duration max_diff_duration */ 20:
                    message.maxDiffDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxDiffDuration);
                    break;
                case /* int64 row_diff_column_truncate_at */ 21:
                    message.rowDiffColumnTruncateAt = reader.int64().toBigInt();
                    break;
                case /* optional bool auto_start */ 22:
                    message.autoStart = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 2; */
        if (message.targetKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* repeated string source_cells = 4; */
        for (let i = 0; i < message.sourceCells.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.sourceCells[i]);
        /* repeated string target_cells = 5; */
        for (let i = 0; i < message.targetCells.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.targetCells[i]);
        /* repeated topodata.TabletType tablet_types = 6; */
        if (message.tabletTypes.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* tabletmanagerdata.TabletSelectionPreference tablet_selection_preference = 7; */
        if (message.tabletSelectionPreference !== 0)
            writer.tag(7, WireType.Varint).int32(message.tabletSelectionPreference);
        /* repeated string tables = 8; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.tables[i]);
        /* int64 limit = 9; */
        if (message.limit !== 0n)
            writer.tag(9, WireType.Varint).int64(message.limit);
        /* vttime.Duration filtered_replication_wait_time = 10; */
        if (message.filteredReplicationWaitTime)
            Duration.internalBinaryWrite(message.filteredReplicationWaitTime, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool debug_query = 11; */
        if (message.debugQuery !== false)
            writer.tag(11, WireType.Varint).bool(message.debugQuery);
        /* bool only_p_ks = 12; */
        if (message.onlyPKs !== false)
            writer.tag(12, WireType.Varint).bool(message.onlyPKs);
        /* bool update_table_stats = 13; */
        if (message.updateTableStats !== false)
            writer.tag(13, WireType.Varint).bool(message.updateTableStats);
        /* int64 max_extra_rows_to_compare = 14; */
        if (message.maxExtraRowsToCompare !== 0n)
            writer.tag(14, WireType.Varint).int64(message.maxExtraRowsToCompare);
        /* bool wait = 15; */
        if (message.wait !== false)
            writer.tag(15, WireType.Varint).bool(message.wait);
        /* vttime.Duration wait_update_interval = 16; */
        if (message.waitUpdateInterval)
            Duration.internalBinaryWrite(message.waitUpdateInterval, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* bool auto_retry = 17; */
        if (message.autoRetry !== false)
            writer.tag(17, WireType.Varint).bool(message.autoRetry);
        /* bool verbose = 18; */
        if (message.verbose !== false)
            writer.tag(18, WireType.Varint).bool(message.verbose);
        /* int64 max_report_sample_rows = 19; */
        if (message.maxReportSampleRows !== 0n)
            writer.tag(19, WireType.Varint).int64(message.maxReportSampleRows);
        /* vttime.Duration max_diff_duration = 20; */
        if (message.maxDiffDuration)
            Duration.internalBinaryWrite(message.maxDiffDuration, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* int64 row_diff_column_truncate_at = 21; */
        if (message.rowDiffColumnTruncateAt !== 0n)
            writer.tag(21, WireType.Varint).int64(message.rowDiffColumnTruncateAt);
        /* optional bool auto_start = 22; */
        if (message.autoStart !== undefined)
            writer.tag(22, WireType.Varint).bool(message.autoStart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffCreateRequest
 */
export const VDiffCreateRequest = new VDiffCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffCreateResponse$Type extends MessageType<VDiffCreateResponse> {
    constructor() {
        super("vtctldata.VDiffCreateResponse", [
            { no: 1, name: "UUID", kind: "scalar", jsonName: "UUID", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffCreateResponse>): VDiffCreateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uUID = "";
        if (value !== undefined)
            reflectionMergePartial<VDiffCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffCreateResponse): VDiffCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string UUID = 1 [json_name = "UUID"];*/ 1:
                    message.uUID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string UUID = 1 [json_name = "UUID"]; */
        if (message.uUID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uUID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffCreateResponse
 */
export const VDiffCreateResponse = new VDiffCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffDeleteRequest$Type extends MessageType<VDiffDeleteRequest> {
    constructor() {
        super("vtctldata.VDiffDeleteRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffDeleteRequest>): VDiffDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.arg = "";
        if (value !== undefined)
            reflectionMergePartial<VDiffDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffDeleteRequest): VDiffDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 2:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string arg */ 3:
                    message.arg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 2; */
        if (message.targetKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string arg = 3; */
        if (message.arg !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.arg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffDeleteRequest
 */
export const VDiffDeleteRequest = new VDiffDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffDeleteResponse$Type extends MessageType<VDiffDeleteResponse> {
    constructor() {
        super("vtctldata.VDiffDeleteResponse", []);
    }
    create(value?: PartialMessage<VDiffDeleteResponse>): VDiffDeleteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VDiffDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffDeleteResponse): VDiffDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffDeleteResponse
 */
export const VDiffDeleteResponse = new VDiffDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffResumeRequest$Type extends MessageType<VDiffResumeRequest> {
    constructor() {
        super("vtctldata.VDiffResumeRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffResumeRequest>): VDiffResumeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.uuid = "";
        message.targetShards = [];
        if (value !== undefined)
            reflectionMergePartial<VDiffResumeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffResumeRequest): VDiffResumeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 2:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* repeated string target_shards */ 4:
                    message.targetShards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffResumeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 2; */
        if (message.targetKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* repeated string target_shards = 4; */
        for (let i = 0; i < message.targetShards.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.targetShards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffResumeRequest
 */
export const VDiffResumeRequest = new VDiffResumeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffResumeResponse$Type extends MessageType<VDiffResumeResponse> {
    constructor() {
        super("vtctldata.VDiffResumeResponse", []);
    }
    create(value?: PartialMessage<VDiffResumeResponse>): VDiffResumeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VDiffResumeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffResumeResponse): VDiffResumeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffResumeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffResumeResponse
 */
export const VDiffResumeResponse = new VDiffResumeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffShowRequest$Type extends MessageType<VDiffShowRequest> {
    constructor() {
        super("vtctldata.VDiffShowRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffShowRequest>): VDiffShowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.arg = "";
        if (value !== undefined)
            reflectionMergePartial<VDiffShowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffShowRequest): VDiffShowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 2:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string arg */ 3:
                    message.arg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffShowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 2; */
        if (message.targetKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string arg = 3; */
        if (message.arg !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.arg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffShowRequest
 */
export const VDiffShowRequest = new VDiffShowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffShowResponse$Type extends MessageType<VDiffShowResponse> {
    constructor() {
        super("vtctldata.VDiffShowResponse", [
            { no: 1, name: "tablet_responses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => VDiffResponse } }
        ]);
    }
    create(value?: PartialMessage<VDiffShowResponse>): VDiffShowResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tabletResponses = {};
        if (value !== undefined)
            reflectionMergePartial<VDiffShowResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffShowResponse): VDiffShowResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, tabletmanagerdata.VDiffResponse> tablet_responses */ 1:
                    this.binaryReadMap1(message.tabletResponses, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: VDiffShowResponse["tabletResponses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof VDiffShowResponse["tabletResponses"] | undefined, val: VDiffShowResponse["tabletResponses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = VDiffResponse.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.VDiffShowResponse.tablet_responses");
            }
        }
        map[key ?? ""] = val ?? VDiffResponse.create();
    }
    internalBinaryWrite(message: VDiffShowResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, tabletmanagerdata.VDiffResponse> tablet_responses = 1; */
        for (let k of globalThis.Object.keys(message.tabletResponses)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            VDiffResponse.internalBinaryWrite(message.tabletResponses[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffShowResponse
 */
export const VDiffShowResponse = new VDiffShowResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffStopRequest$Type extends MessageType<VDiffStopRequest> {
    constructor() {
        super("vtctldata.VDiffStopRequest", [
            { no: 1, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "target_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VDiffStopRequest>): VDiffStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflow = "";
        message.targetKeyspace = "";
        message.uuid = "";
        message.targetShards = [];
        if (value !== undefined)
            reflectionMergePartial<VDiffStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffStopRequest): VDiffStopRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string workflow */ 1:
                    message.workflow = reader.string();
                    break;
                case /* string target_keyspace */ 2:
                    message.targetKeyspace = reader.string();
                    break;
                case /* string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* repeated string target_shards */ 4:
                    message.targetShards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string workflow = 1; */
        if (message.workflow !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workflow);
        /* string target_keyspace = 2; */
        if (message.targetKeyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.targetKeyspace);
        /* string uuid = 3; */
        if (message.uuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.uuid);
        /* repeated string target_shards = 4; */
        for (let i = 0; i < message.targetShards.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.targetShards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffStopRequest
 */
export const VDiffStopRequest = new VDiffStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VDiffStopResponse$Type extends MessageType<VDiffStopResponse> {
    constructor() {
        super("vtctldata.VDiffStopResponse", []);
    }
    create(value?: PartialMessage<VDiffStopResponse>): VDiffStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VDiffStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VDiffStopResponse): VDiffStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VDiffStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.VDiffStopResponse
 */
export const VDiffStopResponse = new VDiffStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowDeleteRequest$Type extends MessageType<WorkflowDeleteRequest> {
    constructor() {
        super("vtctldata.WorkflowDeleteRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keep_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "keep_routing_rules", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowDeleteRequest>): WorkflowDeleteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.workflow = "";
        message.keepData = false;
        message.keepRoutingRules = false;
        message.shards = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowDeleteRequest): WorkflowDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 2:
                    message.workflow = reader.string();
                    break;
                case /* bool keep_data */ 3:
                    message.keepData = reader.bool();
                    break;
                case /* bool keep_routing_rules */ 4:
                    message.keepRoutingRules = reader.bool();
                    break;
                case /* repeated string shards */ 5:
                    message.shards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 2; */
        if (message.workflow !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflow);
        /* bool keep_data = 3; */
        if (message.keepData !== false)
            writer.tag(3, WireType.Varint).bool(message.keepData);
        /* bool keep_routing_rules = 4; */
        if (message.keepRoutingRules !== false)
            writer.tag(4, WireType.Varint).bool(message.keepRoutingRules);
        /* repeated string shards = 5; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.shards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowDeleteRequest
 */
export const WorkflowDeleteRequest = new WorkflowDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowDeleteResponse$Type extends MessageType<WorkflowDeleteResponse> {
    constructor() {
        super("vtctldata.WorkflowDeleteResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "details", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowDeleteResponse_TabletInfo }
        ]);
    }
    create(value?: PartialMessage<WorkflowDeleteResponse>): WorkflowDeleteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.details = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowDeleteResponse): WorkflowDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* repeated vtctldata.WorkflowDeleteResponse.TabletInfo details */ 2:
                    message.details.push(WorkflowDeleteResponse_TabletInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* repeated vtctldata.WorkflowDeleteResponse.TabletInfo details = 2; */
        for (let i = 0; i < message.details.length; i++)
            WorkflowDeleteResponse_TabletInfo.internalBinaryWrite(message.details[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowDeleteResponse
 */
export const WorkflowDeleteResponse = new WorkflowDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowDeleteResponse_TabletInfo$Type extends MessageType<WorkflowDeleteResponse_TabletInfo> {
    constructor() {
        super("vtctldata.WorkflowDeleteResponse.TabletInfo", [
            { no: 1, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 2, name: "deleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowDeleteResponse_TabletInfo>): WorkflowDeleteResponse_TabletInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deleted = false;
        if (value !== undefined)
            reflectionMergePartial<WorkflowDeleteResponse_TabletInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowDeleteResponse_TabletInfo): WorkflowDeleteResponse_TabletInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet */ 1:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* bool deleted */ 2:
                    message.deleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowDeleteResponse_TabletInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet = 1; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool deleted = 2; */
        if (message.deleted !== false)
            writer.tag(2, WireType.Varint).bool(message.deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowDeleteResponse.TabletInfo
 */
export const WorkflowDeleteResponse_TabletInfo = new WorkflowDeleteResponse_TabletInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatusRequest$Type extends MessageType<WorkflowStatusRequest> {
    constructor() {
        super("vtctldata.WorkflowStatusRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatusRequest>): WorkflowStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.workflow = "";
        message.shards = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatusRequest): WorkflowStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 2:
                    message.workflow = reader.string();
                    break;
                case /* repeated string shards */ 3:
                    message.shards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 2; */
        if (message.workflow !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflow);
        /* repeated string shards = 3; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.shards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowStatusRequest
 */
export const WorkflowStatusRequest = new WorkflowStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatusResponse$Type extends MessageType<WorkflowStatusResponse> {
    constructor() {
        super("vtctldata.WorkflowStatusResponse", [
            { no: 1, name: "table_copy_state", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => WorkflowStatusResponse_TableCopyState } },
            { no: 2, name: "shard_streams", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => WorkflowStatusResponse_ShardStreams } },
            { no: 3, name: "traffic_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatusResponse>): WorkflowStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableCopyState = {};
        message.shardStreams = {};
        message.trafficState = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatusResponse): WorkflowStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vtctldata.WorkflowStatusResponse.TableCopyState> table_copy_state */ 1:
                    this.binaryReadMap1(message.tableCopyState, reader, options);
                    break;
                case /* map<string, vtctldata.WorkflowStatusResponse.ShardStreams> shard_streams */ 2:
                    this.binaryReadMap2(message.shardStreams, reader, options);
                    break;
                case /* string traffic_state */ 3:
                    message.trafficState = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: WorkflowStatusResponse["tableCopyState"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WorkflowStatusResponse["tableCopyState"] | undefined, val: WorkflowStatusResponse["tableCopyState"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = WorkflowStatusResponse_TableCopyState.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.WorkflowStatusResponse.table_copy_state");
            }
        }
        map[key ?? ""] = val ?? WorkflowStatusResponse_TableCopyState.create();
    }
    private binaryReadMap2(map: WorkflowStatusResponse["shardStreams"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WorkflowStatusResponse["shardStreams"] | undefined, val: WorkflowStatusResponse["shardStreams"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = WorkflowStatusResponse_ShardStreams.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtctldata.WorkflowStatusResponse.shard_streams");
            }
        }
        map[key ?? ""] = val ?? WorkflowStatusResponse_ShardStreams.create();
    }
    internalBinaryWrite(message: WorkflowStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vtctldata.WorkflowStatusResponse.TableCopyState> table_copy_state = 1; */
        for (let k of globalThis.Object.keys(message.tableCopyState)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            WorkflowStatusResponse_TableCopyState.internalBinaryWrite(message.tableCopyState[k], writer, options);
            writer.join().join();
        }
        /* map<string, vtctldata.WorkflowStatusResponse.ShardStreams> shard_streams = 2; */
        for (let k of globalThis.Object.keys(message.shardStreams)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            WorkflowStatusResponse_ShardStreams.internalBinaryWrite(message.shardStreams[k], writer, options);
            writer.join().join();
        }
        /* string traffic_state = 3; */
        if (message.trafficState !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.trafficState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowStatusResponse
 */
export const WorkflowStatusResponse = new WorkflowStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatusResponse_TableCopyState$Type extends MessageType<WorkflowStatusResponse_TableCopyState> {
    constructor() {
        super("vtctldata.WorkflowStatusResponse.TableCopyState", [
            { no: 1, name: "rows_copied", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rows_total", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "rows_percentage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bytes_copied", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "bytes_total", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "bytes_percentage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatusResponse_TableCopyState>): WorkflowStatusResponse_TableCopyState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowsCopied = 0n;
        message.rowsTotal = 0n;
        message.rowsPercentage = 0;
        message.bytesCopied = 0n;
        message.bytesTotal = 0n;
        message.bytesPercentage = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatusResponse_TableCopyState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatusResponse_TableCopyState): WorkflowStatusResponse_TableCopyState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 rows_copied */ 1:
                    message.rowsCopied = reader.int64().toBigInt();
                    break;
                case /* int64 rows_total */ 2:
                    message.rowsTotal = reader.int64().toBigInt();
                    break;
                case /* float rows_percentage */ 3:
                    message.rowsPercentage = reader.float();
                    break;
                case /* int64 bytes_copied */ 4:
                    message.bytesCopied = reader.int64().toBigInt();
                    break;
                case /* int64 bytes_total */ 5:
                    message.bytesTotal = reader.int64().toBigInt();
                    break;
                case /* float bytes_percentage */ 6:
                    message.bytesPercentage = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatusResponse_TableCopyState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 rows_copied = 1; */
        if (message.rowsCopied !== 0n)
            writer.tag(1, WireType.Varint).int64(message.rowsCopied);
        /* int64 rows_total = 2; */
        if (message.rowsTotal !== 0n)
            writer.tag(2, WireType.Varint).int64(message.rowsTotal);
        /* float rows_percentage = 3; */
        if (message.rowsPercentage !== 0)
            writer.tag(3, WireType.Bit32).float(message.rowsPercentage);
        /* int64 bytes_copied = 4; */
        if (message.bytesCopied !== 0n)
            writer.tag(4, WireType.Varint).int64(message.bytesCopied);
        /* int64 bytes_total = 5; */
        if (message.bytesTotal !== 0n)
            writer.tag(5, WireType.Varint).int64(message.bytesTotal);
        /* float bytes_percentage = 6; */
        if (message.bytesPercentage !== 0)
            writer.tag(6, WireType.Bit32).float(message.bytesPercentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowStatusResponse.TableCopyState
 */
export const WorkflowStatusResponse_TableCopyState = new WorkflowStatusResponse_TableCopyState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatusResponse_ShardStreamState$Type extends MessageType<WorkflowStatusResponse_ShardStreamState> {
    constructor() {
        super("vtctldata.WorkflowStatusResponse.ShardStreamState", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 3, name: "source_shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatusResponse_ShardStreamState>): WorkflowStatusResponse_ShardStreamState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.sourceShard = "";
        message.position = "";
        message.status = "";
        message.info = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatusResponse_ShardStreamState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatusResponse_ShardStreamState): WorkflowStatusResponse_ShardStreamState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* topodata.TabletAlias tablet */ 2:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* string source_shard */ 3:
                    message.sourceShard = reader.string();
                    break;
                case /* string position */ 4:
                    message.position = reader.string();
                    break;
                case /* string status */ 5:
                    message.status = reader.string();
                    break;
                case /* string info */ 6:
                    message.info = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatusResponse_ShardStreamState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* topodata.TabletAlias tablet = 2; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string source_shard = 3; */
        if (message.sourceShard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sourceShard);
        /* string position = 4; */
        if (message.position !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.position);
        /* string status = 5; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* string info = 6; */
        if (message.info !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.info);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowStatusResponse.ShardStreamState
 */
export const WorkflowStatusResponse_ShardStreamState = new WorkflowStatusResponse_ShardStreamState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowStatusResponse_ShardStreams$Type extends MessageType<WorkflowStatusResponse_ShardStreams> {
    constructor() {
        super("vtctldata.WorkflowStatusResponse.ShardStreams", [
            { no: 2, name: "streams", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowStatusResponse_ShardStreamState }
        ]);
    }
    create(value?: PartialMessage<WorkflowStatusResponse_ShardStreams>): WorkflowStatusResponse_ShardStreams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streams = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowStatusResponse_ShardStreams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowStatusResponse_ShardStreams): WorkflowStatusResponse_ShardStreams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtctldata.WorkflowStatusResponse.ShardStreamState streams */ 2:
                    message.streams.push(WorkflowStatusResponse_ShardStreamState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowStatusResponse_ShardStreams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtctldata.WorkflowStatusResponse.ShardStreamState streams = 2; */
        for (let i = 0; i < message.streams.length; i++)
            WorkflowStatusResponse_ShardStreamState.internalBinaryWrite(message.streams[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowStatusResponse.ShardStreams
 */
export const WorkflowStatusResponse_ShardStreams = new WorkflowStatusResponse_ShardStreams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowSwitchTrafficRequest$Type extends MessageType<WorkflowSwitchTrafficRequest> {
    constructor() {
        super("vtctldata.WorkflowSwitchTrafficRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 5, name: "max_replication_lag_allowed", kind: "message", T: () => Duration },
            { no: 6, name: "enable_reverse_replication", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "direction", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "timeout", kind: "message", T: () => Duration },
            { no: 9, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "initialize_target_sequences", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowSwitchTrafficRequest>): WorkflowSwitchTrafficRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.workflow = "";
        message.cells = [];
        message.tabletTypes = [];
        message.enableReverseReplication = false;
        message.direction = 0;
        message.dryRun = false;
        message.initializeTargetSequences = false;
        message.shards = [];
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<WorkflowSwitchTrafficRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowSwitchTrafficRequest): WorkflowSwitchTrafficRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 2:
                    message.workflow = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                case /* repeated topodata.TabletType tablet_types */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* vttime.Duration max_replication_lag_allowed */ 5:
                    message.maxReplicationLagAllowed = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxReplicationLagAllowed);
                    break;
                case /* bool enable_reverse_replication */ 6:
                    message.enableReverseReplication = reader.bool();
                    break;
                case /* int32 direction */ 7:
                    message.direction = reader.int32();
                    break;
                case /* vttime.Duration timeout */ 8:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* bool dry_run */ 9:
                    message.dryRun = reader.bool();
                    break;
                case /* bool initialize_target_sequences */ 10:
                    message.initializeTargetSequences = reader.bool();
                    break;
                case /* repeated string shards */ 11:
                    message.shards.push(reader.string());
                    break;
                case /* bool force */ 12:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowSwitchTrafficRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 2; */
        if (message.workflow !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflow);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated topodata.TabletType tablet_types = 4; */
        if (message.tabletTypes.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* vttime.Duration max_replication_lag_allowed = 5; */
        if (message.maxReplicationLagAllowed)
            Duration.internalBinaryWrite(message.maxReplicationLagAllowed, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_reverse_replication = 6; */
        if (message.enableReverseReplication !== false)
            writer.tag(6, WireType.Varint).bool(message.enableReverseReplication);
        /* int32 direction = 7; */
        if (message.direction !== 0)
            writer.tag(7, WireType.Varint).int32(message.direction);
        /* vttime.Duration timeout = 8; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool dry_run = 9; */
        if (message.dryRun !== false)
            writer.tag(9, WireType.Varint).bool(message.dryRun);
        /* bool initialize_target_sequences = 10; */
        if (message.initializeTargetSequences !== false)
            writer.tag(10, WireType.Varint).bool(message.initializeTargetSequences);
        /* repeated string shards = 11; */
        for (let i = 0; i < message.shards.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.shards[i]);
        /* bool force = 12; */
        if (message.force !== false)
            writer.tag(12, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowSwitchTrafficRequest
 */
export const WorkflowSwitchTrafficRequest = new WorkflowSwitchTrafficRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowSwitchTrafficResponse$Type extends MessageType<WorkflowSwitchTrafficResponse> {
    constructor() {
        super("vtctldata.WorkflowSwitchTrafficResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dry_run_results", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowSwitchTrafficResponse>): WorkflowSwitchTrafficResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.startState = "";
        message.currentState = "";
        message.dryRunResults = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowSwitchTrafficResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowSwitchTrafficResponse): WorkflowSwitchTrafficResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* string start_state */ 2:
                    message.startState = reader.string();
                    break;
                case /* string current_state */ 3:
                    message.currentState = reader.string();
                    break;
                case /* repeated string dry_run_results */ 4:
                    message.dryRunResults.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowSwitchTrafficResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* string start_state = 2; */
        if (message.startState !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.startState);
        /* string current_state = 3; */
        if (message.currentState !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentState);
        /* repeated string dry_run_results = 4; */
        for (let i = 0; i < message.dryRunResults.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.dryRunResults[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowSwitchTrafficResponse
 */
export const WorkflowSwitchTrafficResponse = new WorkflowSwitchTrafficResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowUpdateRequest$Type extends MessageType<WorkflowUpdateRequest> {
    constructor() {
        super("vtctldata.WorkflowUpdateRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tablet_request", kind: "message", T: () => UpdateVReplicationWorkflowRequest }
        ]);
    }
    create(value?: PartialMessage<WorkflowUpdateRequest>): WorkflowUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowUpdateRequest): WorkflowUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request */ 2:
                    message.tabletRequest = UpdateVReplicationWorkflowRequest.internalBinaryRead(reader, reader.uint32(), options, message.tabletRequest);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* tabletmanagerdata.UpdateVReplicationWorkflowRequest tablet_request = 2; */
        if (message.tabletRequest)
            UpdateVReplicationWorkflowRequest.internalBinaryWrite(message.tabletRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowUpdateRequest
 */
export const WorkflowUpdateRequest = new WorkflowUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowUpdateResponse$Type extends MessageType<WorkflowUpdateResponse> {
    constructor() {
        super("vtctldata.WorkflowUpdateResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "details", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WorkflowUpdateResponse_TabletInfo }
        ]);
    }
    create(value?: PartialMessage<WorkflowUpdateResponse>): WorkflowUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.details = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowUpdateResponse): WorkflowUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* repeated vtctldata.WorkflowUpdateResponse.TabletInfo details */ 2:
                    message.details.push(WorkflowUpdateResponse_TabletInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* repeated vtctldata.WorkflowUpdateResponse.TabletInfo details = 2; */
        for (let i = 0; i < message.details.length; i++)
            WorkflowUpdateResponse_TabletInfo.internalBinaryWrite(message.details[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowUpdateResponse
 */
export const WorkflowUpdateResponse = new WorkflowUpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowUpdateResponse_TabletInfo$Type extends MessageType<WorkflowUpdateResponse_TabletInfo> {
    constructor() {
        super("vtctldata.WorkflowUpdateResponse.TabletInfo", [
            { no: 1, name: "tablet", kind: "message", T: () => TabletAlias },
            { no: 2, name: "changed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowUpdateResponse_TabletInfo>): WorkflowUpdateResponse_TabletInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.changed = false;
        if (value !== undefined)
            reflectionMergePartial<WorkflowUpdateResponse_TabletInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowUpdateResponse_TabletInfo): WorkflowUpdateResponse_TabletInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet */ 1:
                    message.tablet = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* bool changed */ 2:
                    message.changed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowUpdateResponse_TabletInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet = 1; */
        if (message.tablet)
            TabletAlias.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool changed = 2; */
        if (message.changed !== false)
            writer.tag(2, WireType.Varint).bool(message.changed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowUpdateResponse.TabletInfo
 */
export const WorkflowUpdateResponse_TabletInfo = new WorkflowUpdateResponse_TabletInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMirrorRulesRequest$Type extends MessageType<GetMirrorRulesRequest> {
    constructor() {
        super("vtctldata.GetMirrorRulesRequest", []);
    }
    create(value?: PartialMessage<GetMirrorRulesRequest>): GetMirrorRulesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMirrorRulesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMirrorRulesRequest): GetMirrorRulesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMirrorRulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetMirrorRulesRequest
 */
export const GetMirrorRulesRequest = new GetMirrorRulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMirrorRulesResponse$Type extends MessageType<GetMirrorRulesResponse> {
    constructor() {
        super("vtctldata.GetMirrorRulesResponse", [
            { no: 1, name: "mirror_rules", kind: "message", T: () => MirrorRules }
        ]);
    }
    create(value?: PartialMessage<GetMirrorRulesResponse>): GetMirrorRulesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetMirrorRulesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMirrorRulesResponse): GetMirrorRulesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vschema.MirrorRules mirror_rules */ 1:
                    message.mirrorRules = MirrorRules.internalBinaryRead(reader, reader.uint32(), options, message.mirrorRules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMirrorRulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vschema.MirrorRules mirror_rules = 1; */
        if (message.mirrorRules)
            MirrorRules.internalBinaryWrite(message.mirrorRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.GetMirrorRulesResponse
 */
export const GetMirrorRulesResponse = new GetMirrorRulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowMirrorTrafficRequest$Type extends MessageType<WorkflowMirrorTrafficRequest> {
    constructor() {
        super("vtctldata.WorkflowMirrorTrafficRequest", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_types", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["topodata.TabletType", TabletType] },
            { no: 4, name: "percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowMirrorTrafficRequest>): WorkflowMirrorTrafficRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.workflow = "";
        message.tabletTypes = [];
        message.percent = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkflowMirrorTrafficRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowMirrorTrafficRequest): WorkflowMirrorTrafficRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 2:
                    message.workflow = reader.string();
                    break;
                case /* repeated topodata.TabletType tablet_types */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tabletTypes.push(reader.int32());
                    else
                        message.tabletTypes.push(reader.int32());
                    break;
                case /* float percent */ 4:
                    message.percent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowMirrorTrafficRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 2; */
        if (message.workflow !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflow);
        /* repeated topodata.TabletType tablet_types = 3; */
        if (message.tabletTypes.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tabletTypes.length; i++)
                writer.int32(message.tabletTypes[i]);
            writer.join();
        }
        /* float percent = 4; */
        if (message.percent !== 0)
            writer.tag(4, WireType.Bit32).float(message.percent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowMirrorTrafficRequest
 */
export const WorkflowMirrorTrafficRequest = new WorkflowMirrorTrafficRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowMirrorTrafficResponse$Type extends MessageType<WorkflowMirrorTrafficResponse> {
    constructor() {
        super("vtctldata.WorkflowMirrorTrafficResponse", [
            { no: 1, name: "summary", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "current_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowMirrorTrafficResponse>): WorkflowMirrorTrafficResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.summary = "";
        message.startState = "";
        message.currentState = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowMirrorTrafficResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowMirrorTrafficResponse): WorkflowMirrorTrafficResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string summary */ 1:
                    message.summary = reader.string();
                    break;
                case /* string start_state */ 2:
                    message.startState = reader.string();
                    break;
                case /* string current_state */ 3:
                    message.currentState = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowMirrorTrafficResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string summary = 1; */
        if (message.summary !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.summary);
        /* string start_state = 2; */
        if (message.startState !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.startState);
        /* string current_state = 3; */
        if (message.currentState !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currentState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtctldata.WorkflowMirrorTrafficResponse
 */
export const WorkflowMirrorTrafficResponse = new WorkflowMirrorTrafficResponse$Type();
