// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtadmin.proto" (package "vtadmin", syntax proto3)
// tslint:disable
//
//
//Copyright 2020 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This package contains the types used by VTAdmin (and later an RPC service).
//
import { ValidateVersionShardResponse } from "./vtctldata";
import { ValidateVersionKeyspaceResponse } from "./vtctldata";
import { ValidateShardResponse } from "./vtctldata";
import { ValidateSchemaKeyspaceResponse } from "./vtctldata";
import { ValidateKeyspaceResponse } from "./vtctldata";
import { ValidateResponse } from "./vtctldata";
import { RetrySchemaMigrationResponse } from "./vtctldata";
import { LaunchSchemaMigrationResponse } from "./vtctldata";
import { WorkflowUpdateResponse } from "./vtctldata";
import { WorkflowStatusResponse } from "./vtctldata";
import { GetUnresolvedTransactionsResponse } from "./vtctldata";
import { GetTopologyPathResponse } from "./vtctldata";
import { GetFullStatusResponse } from "./vtctldata";
import { DeleteShardsResponse } from "./vtctldata";
import { DeleteKeyspaceResponse } from "./vtctldata";
import { CreateShardResponse } from "./vtctldata";
import { ConcludeTransactionResponse } from "./vtctldata";
import { CompleteSchemaMigrationResponse } from "./vtctldata";
import { CleanupSchemaMigrationResponse } from "./vtctldata";
import { CancelSchemaMigrationResponse } from "./vtctldata";
import { ApplySchemaResponse } from "./vtctldata";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RetrySchemaMigrationRequest as RetrySchemaMigrationRequest$ } from "./vtctldata";
import { PlannedReparentShardRequest } from "./vtctldata";
import { MoveTablesCreateRequest as MoveTablesCreateRequest$ } from "./vtctldata";
import { LaunchSchemaMigrationRequest as LaunchSchemaMigrationRequest$ } from "./vtctldata";
import { GetSrvKeyspacesResponse as GetSrvKeyspacesResponse$ } from "./vtctldata";
import { GetSchemaMigrationsRequest as GetSchemaMigrationsRequest$ } from "./vtctldata";
import { GetBackupsRequest as GetBackupsRequest$ } from "./vtctldata";
import { Event } from "./logutil";
import { EmergencyReparentShardRequest } from "./vtctldata";
import { TabletAlias } from "./topodata";
import { DeleteShardsRequest as DeleteShardsRequest$ } from "./vtctldata";
import { DeleteKeyspaceRequest as DeleteKeyspaceRequest$ } from "./vtctldata";
import { CreateShardRequest as CreateShardRequest$ } from "./vtctldata";
import { CreateKeyspaceRequest as CreateKeyspaceRequest$ } from "./vtctldata";
import { CompleteSchemaMigrationRequest as CompleteSchemaMigrationRequest$ } from "./vtctldata";
import { CleanupSchemaMigrationRequest as CleanupSchemaMigrationRequest$ } from "./vtctldata";
import { CancelSchemaMigrationRequest as CancelSchemaMigrationRequest$ } from "./vtctldata";
import { ApplySchemaRequest as ApplySchemaRequest$ } from "./vtctldata";
import { Workflow as Workflow$ } from "./vtctldata";
import { Keyspace as Keyspace$2 } from "./vschema";
import { Tablet as Tablet$ } from "./topodata";
import { SrvVSchema as SrvVSchema$ } from "./vschema";
import { SchemaMigration as SchemaMigration$ } from "./vtctldata";
import { TableDefinition } from "./tabletmanagerdata";
import { Shard as Shard$ } from "./vtctldata";
import { Keyspace as Keyspace$ } from "./vtctldata";
import { ShardReplicationPositionsResponse } from "./vtctldata";
import { CellInfo } from "./topodata";
import { CellsAlias } from "./topodata";
import { BackupInfo } from "./mysqlctl";
// Data types 

/**
 * Cluster represents information about a Vitess cluster.
 *
 * @generated from protobuf message vtadmin.Cluster
 */
export interface Cluster {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message vtadmin.ClusterBackup
 */
export interface ClusterBackup {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: mysqlctl.BackupInfo backup = 2;
     */
    backup?: BackupInfo;
}
/**
 * @generated from protobuf message vtadmin.ClusterCellsAliases
 */
export interface ClusterCellsAliases {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: map<string, topodata.CellsAlias> aliases = 2;
     */
    aliases: {
        [key: string]: CellsAlias;
    };
}
/**
 * @generated from protobuf message vtadmin.ClusterCellInfo
 */
export interface ClusterCellInfo {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * CellInfo contains the data for the cell.
     *
     * It may be nil if the GetCellsInfosRequest specified NamesOnly.
     *
     * @generated from protobuf field: topodata.CellInfo cell_info = 3;
     */
    cellInfo?: CellInfo;
}
/**
 * @generated from protobuf message vtadmin.ClusterShardReplicationPosition
 */
export interface ClusterShardReplicationPosition {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: vtctldata.ShardReplicationPositionsResponse position_info = 4;
     */
    positionInfo?: ShardReplicationPositionsResponse;
}
/**
 * @generated from protobuf message vtadmin.ClusterWorkflows
 */
export interface ClusterWorkflows {
    /**
     * @generated from protobuf field: repeated vtadmin.Workflow workflows = 1;
     */
    workflows: Workflow[];
    /**
     * Warnings is a list of non-fatal errors encountered when fetching
     * workflows for a particular cluster.
     *
     * @generated from protobuf field: repeated string warnings = 2;
     */
    warnings: string[];
}
/**
 * Keyspace represents information about a keyspace in a particular Vitess
 * cluster.
 *
 * @generated from protobuf message vtadmin.Keyspace
 */
export interface Keyspace {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: vtctldata.Keyspace keyspace = 2;
     */
    keyspace?: Keyspace$;
    /**
     * @generated from protobuf field: map<string, vtctldata.Shard> shards = 3;
     */
    shards: {
        [key: string]: Shard$;
    };
}
/**
 * @generated from protobuf message vtadmin.Schema
 */
export interface Schema {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated tabletmanagerdata.TableDefinition table_definitions = 3;
     */
    tableDefinitions: TableDefinition[];
    /**
     * TableSizes is a mapping of table name to TableSize information.
     *
     * @generated from protobuf field: map<string, vtadmin.Schema.TableSize> table_sizes = 4;
     */
    tableSizes: {
        [key: string]: Schema_TableSize;
    };
}
/**
 * @generated from protobuf message vtadmin.Schema.ShardTableSize
 */
export interface Schema_ShardTableSize {
    /**
     * @generated from protobuf field: uint64 row_count = 1;
     */
    rowCount: bigint;
    /**
     * @generated from protobuf field: uint64 data_length = 2;
     */
    dataLength: bigint;
}
/**
 * TableSize aggregates table size information across all shards containing
 * in the given keyspace and cluster, as well as per-shard size information.
 *
 * @generated from protobuf message vtadmin.Schema.TableSize
 */
export interface Schema_TableSize {
    /**
     * @generated from protobuf field: uint64 row_count = 1;
     */
    rowCount: bigint;
    /**
     * @generated from protobuf field: uint64 data_length = 2;
     */
    dataLength: bigint;
    /**
     * @generated from protobuf field: map<string, vtadmin.Schema.ShardTableSize> by_shard = 3;
     */
    byShard: {
        [key: string]: Schema_ShardTableSize;
    };
}
/**
 * @generated from protobuf message vtadmin.SchemaMigration
 */
export interface SchemaMigration {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: vtctldata.SchemaMigration schema_migration = 2;
     */
    schemaMigration?: SchemaMigration$;
}
/**
 * Shard groups the vtctldata information about a shard record together with
 * the Vitess cluster it belongs to.
 *
 * @generated from protobuf message vtadmin.Shard
 */
export interface Shard {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: vtctldata.Shard shard = 2;
     */
    shard?: Shard$;
}
/**
 * @generated from protobuf message vtadmin.SrvVSchema
 */
export interface SrvVSchema {
    /**
     * @generated from protobuf field: string cell = 1;
     */
    cell: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: vschema.SrvVSchema srv_v_schema = 3;
     */
    srvVSchema?: SrvVSchema$;
}
/**
 * Tablet groups the topo information of a tablet together with the Vitess
 * cluster it belongs to.
 *
 * @generated from protobuf message vtadmin.Tablet
 */
export interface Tablet {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: topodata.Tablet tablet = 2;
     */
    tablet?: Tablet$;
    /**
     * @generated from protobuf field: vtadmin.Tablet.ServingState state = 3;
     */
    state: Tablet_ServingState;
    /**
     * @generated from protobuf field: string FQDN = 4 [json_name = "FQDN"];
     */
    fQDN: string;
}
/**
 * @generated from protobuf enum vtadmin.Tablet.ServingState
 */
export enum Tablet_ServingState {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SERVING = 1;
     */
    SERVING = 1,
    /**
     * @generated from protobuf enum value: NOT_SERVING = 2;
     */
    NOT_SERVING = 2
}
/**
 * VSchema represents the vschema for a keyspace in the cluster it belongs to.
 *
 * @generated from protobuf message vtadmin.VSchema
 */
export interface VSchema {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * Name is the name of the keyspace this VSchema is for.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: vschema.Keyspace v_schema = 3;
     */
    vSchema?: Keyspace$2;
}
/**
 * Vtctld represents information about a single Vtctld host.
 *
 * @generated from protobuf message vtadmin.Vtctld
 */
export interface Vtctld {
    /**
     * @generated from protobuf field: string hostname = 1;
     */
    hostname: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string FQDN = 3 [json_name = "FQDN"];
     */
    fQDN: string;
}
/**
 * VTGate represents information about a single VTGate host.
 *
 * @generated from protobuf message vtadmin.VTGate
 */
export interface VTGate {
    /**
     * Hostname is the shortname of the VTGate.
     *
     * @generated from protobuf field: string hostname = 1;
     */
    hostname: string;
    /**
     * Pool is group the VTGate serves queries for. Some deployments segment
     * VTGates into groups or pools, based on the workloads they serve queries
     * for. Use of this field is optional.
     *
     * @generated from protobuf field: string pool = 2;
     */
    pool: string;
    /**
     * Cell is the topology cell the VTGate is in.
     *
     * @generated from protobuf field: string cell = 3;
     */
    cell: string;
    /**
     * Cluster is the cluster the VTGate serves.
     *
     * @generated from protobuf field: vtadmin.Cluster cluster = 4;
     */
    cluster?: Cluster;
    /**
     * Keyspaces is the list of keyspaces-to-watch for the VTGate.
     *
     * @generated from protobuf field: repeated string keyspaces = 5;
     */
    keyspaces: string[];
    /**
     * @generated from protobuf field: string FQDN = 6 [json_name = "FQDN"];
     */
    fQDN: string;
}
/**
 * @generated from protobuf message vtadmin.Workflow
 */
export interface Workflow {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: vtctldata.Workflow workflow = 3;
     */
    workflow?: Workflow$;
}
// Request/Response types 

/**
 * @generated from protobuf message vtadmin.ApplySchemaRequest
 */
export interface ApplySchemaRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.ApplySchemaRequest request = 2;
     */
    request?: ApplySchemaRequest$;
}
/**
 * @generated from protobuf message vtadmin.CancelSchemaMigrationRequest
 */
export interface CancelSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.CancelSchemaMigrationRequest request = 2;
     */
    request?: CancelSchemaMigrationRequest$;
}
/**
 * @generated from protobuf message vtadmin.CleanupSchemaMigrationRequest
 */
export interface CleanupSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.CleanupSchemaMigrationRequest request = 2;
     */
    request?: CleanupSchemaMigrationRequest$;
}
/**
 * @generated from protobuf message vtadmin.CompleteSchemaMigrationRequest
 */
export interface CompleteSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.CompleteSchemaMigrationRequest request = 2;
     */
    request?: CompleteSchemaMigrationRequest$;
}
/**
 * @generated from protobuf message vtadmin.ConcludeTransactionRequest
 */
export interface ConcludeTransactionRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string dtid = 2;
     */
    dtid: string;
}
/**
 * @generated from protobuf message vtadmin.CreateKeyspaceRequest
 */
export interface CreateKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.CreateKeyspaceRequest options = 2;
     */
    options?: CreateKeyspaceRequest$;
}
/**
 * @generated from protobuf message vtadmin.CreateKeyspaceResponse
 */
export interface CreateKeyspaceResponse {
    /**
     * @generated from protobuf field: vtadmin.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace;
}
/**
 * @generated from protobuf message vtadmin.CreateShardRequest
 */
export interface CreateShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.CreateShardRequest options = 2;
     */
    options?: CreateShardRequest$;
}
/**
 * @generated from protobuf message vtadmin.DeleteKeyspaceRequest
 */
export interface DeleteKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.DeleteKeyspaceRequest options = 2;
     */
    options?: DeleteKeyspaceRequest$;
}
/**
 * @generated from protobuf message vtadmin.DeleteShardsRequest
 */
export interface DeleteShardsRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.DeleteShardsRequest options = 2;
     */
    options?: DeleteShardsRequest$;
}
/**
 * @generated from protobuf message vtadmin.DeleteTabletRequest
 */
export interface DeleteTabletRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
    /**
     * @generated from protobuf field: bool allow_primary = 3;
     */
    allowPrimary: boolean;
}
/**
 * @generated from protobuf message vtadmin.DeleteTabletResponse
 */
export interface DeleteTabletResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.EmergencyFailoverShardRequest
 */
export interface EmergencyFailoverShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.EmergencyReparentShardRequest options = 2;
     */
    options?: EmergencyReparentShardRequest;
}
/**
 * @generated from protobuf message vtadmin.EmergencyFailoverShardResponse
 */
export interface EmergencyFailoverShardResponse {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * PromotedPrimary is the tablet alias that was promoted to shard primary.
     * If NewPrimary was set in the request options, then this will be the
     * same tablet alias. Otherwise, it will be the alias of the tablet found
     * to be most up-to-date in the shard.
     *
     * @generated from protobuf field: topodata.TabletAlias promoted_primary = 4;
     */
    promotedPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 5;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtadmin.FindSchemaRequest
 */
export interface FindSchemaRequest {
    /**
     * @generated from protobuf field: string table = 1;
     */
    table: string;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
    /**
     * @generated from protobuf field: vtadmin.GetSchemaTableSizeOptions table_size_options = 3;
     */
    tableSizeOptions?: GetSchemaTableSizeOptions;
}
/**
 * @generated from protobuf message vtadmin.GetBackupsRequest
 */
export interface GetBackupsRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * Keyspaces, if set, limits backups to just the specified keyspaces.
     * Applies to all clusters in the request.
     *
     * @generated from protobuf field: repeated string keyspaces = 2;
     */
    keyspaces: string[];
    /**
     * KeyspaceShards, if set, limits backups to just the specified
     * keyspace/shards. Applies to all clusters in the request.
     *
     * This field takes precedence over Keyspaces. If KeyspaceShards is set,
     * Keyspaces is ignored.
     *
     * @generated from protobuf field: repeated string keyspace_shards = 3;
     */
    keyspaceShards: string[];
    /**
     * RequestOptions controls the per-shard request options when making
     * GetBackups requests to vtctlds. Note that the Keyspace and Shard fields
     * of this field are ignored; it is used only to specify Limit and Detailed
     * fields.
     *
     * @generated from protobuf field: vtctldata.GetBackupsRequest request_options = 4;
     */
    requestOptions?: GetBackupsRequest$;
}
/**
 * @generated from protobuf message vtadmin.GetBackupsResponse
 */
export interface GetBackupsResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.ClusterBackup backups = 1;
     */
    backups: ClusterBackup[];
}
/**
 * @generated from protobuf message vtadmin.GetCellInfosRequest
 */
export interface GetCellInfosRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * Cells, if specified, limits the response to include only CellInfo objects
     * with those names. If omitted, all CellInfo objects in each cluster are
     * returned.
     *
     * Mutually-exclusive with NamesOnly. If both are set, this field takes
     * precedence.
     *
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
    /**
     * Return only the cell names in each cluster; the actual CellInfo objects
     * will be empty.
     *
     * @generated from protobuf field: bool names_only = 3;
     */
    namesOnly: boolean;
}
/**
 * @generated from protobuf message vtadmin.GetCellInfosResponse
 */
export interface GetCellInfosResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.ClusterCellInfo cell_infos = 1;
     */
    cellInfos: ClusterCellInfo[];
}
/**
 * @generated from protobuf message vtadmin.GetCellsAliasesRequest
 */
export interface GetCellsAliasesRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetCellsAliasesResponse
 */
export interface GetCellsAliasesResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.ClusterCellsAliases aliases = 1;
     */
    aliases: ClusterCellsAliases[];
}
/**
 * @generated from protobuf message vtadmin.GetClustersRequest
 */
export interface GetClustersRequest {
}
/**
 * @generated from protobuf message vtadmin.GetClustersResponse
 */
export interface GetClustersResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.Cluster clusters = 1;
     */
    clusters: Cluster[];
}
/**
 * @generated from protobuf message vtadmin.GetFullStatusRequest
 */
export interface GetFullStatusRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 2;
     */
    alias?: TabletAlias;
}
/**
 * @generated from protobuf message vtadmin.GetGatesRequest
 */
export interface GetGatesRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetGatesResponse
 */
export interface GetGatesResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.VTGate gates = 1;
     */
    gates: VTGate[];
}
/**
 * @generated from protobuf message vtadmin.GetKeyspaceRequest
 */
export interface GetKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtadmin.GetKeyspacesRequest
 */
export interface GetKeyspacesRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetKeyspacesResponse
 */
export interface GetKeyspacesResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.Keyspace keyspaces = 1;
     */
    keyspaces: Keyspace[];
}
/**
 * @generated from protobuf message vtadmin.GetSchemaRequest
 */
export interface GetSchemaRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string table = 3;
     */
    table: string;
    /**
     * @generated from protobuf field: vtadmin.GetSchemaTableSizeOptions table_size_options = 4;
     */
    tableSizeOptions?: GetSchemaTableSizeOptions;
}
/**
 * @generated from protobuf message vtadmin.GetSchemasRequest
 */
export interface GetSchemasRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * @generated from protobuf field: vtadmin.GetSchemaTableSizeOptions table_size_options = 2;
     */
    tableSizeOptions?: GetSchemaTableSizeOptions;
}
/**
 * @generated from protobuf message vtadmin.GetSchemasResponse
 */
export interface GetSchemasResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.Schema schemas = 1;
     */
    schemas: Schema[];
}
/**
 * @generated from protobuf message vtadmin.GetSchemaMigrationsRequest
 */
export interface GetSchemaMigrationsRequest {
    /**
     * @generated from protobuf field: repeated vtadmin.GetSchemaMigrationsRequest.ClusterRequest cluster_requests = 1;
     */
    clusterRequests: GetSchemaMigrationsRequest_ClusterRequest[];
}
/**
 * @generated from protobuf message vtadmin.GetSchemaMigrationsRequest.ClusterRequest
 */
export interface GetSchemaMigrationsRequest_ClusterRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.GetSchemaMigrationsRequest request = 2;
     */
    request?: GetSchemaMigrationsRequest$;
}
/**
 * @generated from protobuf message vtadmin.GetSchemaMigrationsResponse
 */
export interface GetSchemaMigrationsResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.SchemaMigration schema_migrations = 1;
     */
    schemaMigrations: SchemaMigration[];
}
/**
 * @generated from protobuf message vtadmin.GetShardReplicationPositionsRequest
 */
export interface GetShardReplicationPositionsRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * Keyspaces, if set, limits replication positions to just the specified
     * keyspaces. Applies to all clusters in the request.
     *
     * @generated from protobuf field: repeated string keyspaces = 2;
     */
    keyspaces: string[];
    /**
     * KeyspaceShards, if set, limits replicatin positions to just the specified
     * keyspace/shards. Applies to all clusters in the request.
     *
     * This field takes precedence over Keyspaces. If KeyspaceShards is set,
     * Keyspaces is ignored.
     *
     * @generated from protobuf field: repeated string keyspace_shards = 3;
     */
    keyspaceShards: string[];
}
/**
 * @generated from protobuf message vtadmin.GetShardReplicationPositionsResponse
 */
export interface GetShardReplicationPositionsResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.ClusterShardReplicationPosition replication_positions = 1;
     */
    replicationPositions: ClusterShardReplicationPosition[];
}
/**
 * @generated from protobuf message vtadmin.GetSrvKeyspaceRequest
 */
export interface GetSrvKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
     * equivalent to specifying all cells in the topo.
     *
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtadmin.GetSrvKeyspacesRequest
 */
export interface GetSrvKeyspacesRequest {
    /**
     * An optional list of cluster IDs to filter specific clusters
     *
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * Cells is a list of cells to lookup a SrvKeyspace for. Leaving this empty is
     * equivalent to specifying all cells in the topo.
     *
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtadmin.GetSrvKeyspacesResponse
 */
export interface GetSrvKeyspacesResponse {
    /**
     * GetSrvKeyspaces responses for each keyspace
     *
     * @generated from protobuf field: map<string, vtctldata.GetSrvKeyspacesResponse> srv_keyspaces = 1;
     */
    srvKeyspaces: {
        [key: string]: GetSrvKeyspacesResponse$;
    };
}
/**
 * @generated from protobuf message vtadmin.GetSrvVSchemaRequest
 */
export interface GetSrvVSchemaRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string cell = 2;
     */
    cell: string;
}
/**
 * @generated from protobuf message vtadmin.GetSrvVSchemasRequest
 */
export interface GetSrvVSchemasRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message vtadmin.GetSrvVSchemasResponse
 */
export interface GetSrvVSchemasResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.SrvVSchema srv_v_schemas = 1;
     */
    srvVSchemas: SrvVSchema[];
}
/**
 * @generated from protobuf message vtadmin.GetSchemaTableSizeOptions
 */
export interface GetSchemaTableSizeOptions {
    /**
     * @generated from protobuf field: bool aggregate_sizes = 1;
     */
    aggregateSizes: boolean;
    /**
     * @generated from protobuf field: bool include_non_serving_shards = 2;
     */
    includeNonServingShards: boolean;
}
/**
 * @generated from protobuf message vtadmin.GetTabletRequest
 */
export interface GetTabletRequest {
    /**
     * Unique (per cluster) tablet alias.
     *
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * ClusterIDs is an optional parameter to narrow the scope of the search, if
     * the caller knows which cluster the tablet may be in, or, to disambiguate
     * if multiple clusters have a tablet with the same hostname.
     *
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetTabletsRequest
 */
export interface GetTabletsRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetTabletsResponse
 */
export interface GetTabletsResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.Tablet tablets = 1;
     */
    tablets: Tablet[];
}
/**
 * @generated from protobuf message vtadmin.GetTopologyPathRequest
 */
export interface GetTopologyPathRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
}
/**
 * @generated from protobuf message vtadmin.GetUnresolvedTransactionsRequest
 */
export interface GetUnresolvedTransactionsRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: int64 abandon_age = 3;
     */
    abandonAge: bigint;
}
/**
 * @generated from protobuf message vtadmin.GetVSchemaRequest
 */
export interface GetVSchemaRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtadmin.GetVSchemasRequest
 */
export interface GetVSchemasRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetVSchemasResponse
 */
export interface GetVSchemasResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.VSchema v_schemas = 1;
     */
    vSchemas: VSchema[];
}
/**
 * @generated from protobuf message vtadmin.GetVtctldsRequest
 */
export interface GetVtctldsRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.GetVtctldsResponse
 */
export interface GetVtctldsResponse {
    /**
     * @generated from protobuf field: repeated vtadmin.Vtctld vtctlds = 1;
     */
    vtctlds: Vtctld[];
}
/**
 * @generated from protobuf message vtadmin.GetWorkflowRequest
 */
export interface GetWorkflowRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: bool active_only = 4;
     */
    activeOnly: boolean;
}
/**
 * @generated from protobuf message vtadmin.GetWorkflowStatusRequest
 */
export interface GetWorkflowStatusRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message vtadmin.StartWorkflowRequest
 */
export interface StartWorkflowRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 3;
     */
    workflow: string;
}
/**
 * @generated from protobuf message vtadmin.StopWorkflowRequest
 */
export interface StopWorkflowRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string workflow = 3;
     */
    workflow: string;
}
/**
 * @generated from protobuf message vtadmin.GetWorkflowsRequest
 */
export interface GetWorkflowsRequest {
    /**
     * @generated from protobuf field: repeated string cluster_ids = 1;
     */
    clusterIds: string[];
    /**
     * ActiveOnly specifies whether to return workflows that are currently
     * active (running or paused) instead of all workflows.
     *
     * @generated from protobuf field: bool active_only = 2;
     */
    activeOnly: boolean;
    /**
     * Keyspaces is a list of keyspaces to restrict the workflow search to. Note
     * that the keyspaces list applies across all cluster IDs in the request.
     *
     * If, for example, you have two clusters, each with a keyspace called "foo"
     * and want the workflows from "foo" in cluster1 but not from cluster2, you
     * must make two requests.
     *
     * Keyspaces and IgnoreKeyspaces are mutually-exclusive, and Keyspaces takes
     * precedence; if Keyspaces is a non-empty list, then IgnoreKeyspaces is
     * ignored completely.
     *
     * @generated from protobuf field: repeated string keyspaces = 3;
     */
    keyspaces: string[];
    /**
     * IgnoreKeyspaces is a list of keyspaces to skip during the workflow
     * search. It has the same semantics as the Keyspaces parameter, so refer to
     * that documentation for more details.
     *
     * @generated from protobuf field: repeated string ignore_keyspaces = 4;
     */
    ignoreKeyspaces: string[];
}
/**
 * @generated from protobuf message vtadmin.GetWorkflowsResponse
 */
export interface GetWorkflowsResponse {
    /**
     * @generated from protobuf field: map<string, vtadmin.ClusterWorkflows> workflows_by_cluster = 1;
     */
    workflowsByCluster: {
        [key: string]: ClusterWorkflows;
    };
}
/**
 * @generated from protobuf message vtadmin.LaunchSchemaMigrationRequest
 */
export interface LaunchSchemaMigrationRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.LaunchSchemaMigrationRequest request = 2;
     */
    request?: LaunchSchemaMigrationRequest$;
}
/**
 * @generated from protobuf message vtadmin.MoveTablesCreateRequest
 */
export interface MoveTablesCreateRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.MoveTablesCreateRequest request = 2;
     */
    request?: MoveTablesCreateRequest$;
}
/**
 * @generated from protobuf message vtadmin.PingTabletRequest
 */
export interface PingTabletRequest {
    /**
     * Unique (per cluster) tablet alias of the standard form: "$cell-$uid"
     *
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * ClusterIDs is an optional parameter to narrow the scope of the search, if
     * the caller knows which cluster the tablet may be in, or, to disambiguate
     * if multiple clusters have a tablet with the same hostname.
     *
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.PingTabletResponse
 */
export interface PingTabletResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.PlannedFailoverShardRequest
 */
export interface PlannedFailoverShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.PlannedReparentShardRequest options = 2;
     */
    options?: PlannedReparentShardRequest;
}
/**
 * @generated from protobuf message vtadmin.PlannedFailoverShardResponse
 */
export interface PlannedFailoverShardResponse {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * PromotedPrimary is the tablet alias that was promoted to shard primary.
     * If NewPrimary was set in the request options, then this will be the
     * same tablet alias. Otherwise, it will be the alias of the tablet found
     * to be most up-to-date in the shard.
     *
     * @generated from protobuf field: topodata.TabletAlias promoted_primary = 4;
     */
    promotedPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 5;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtadmin.RebuildKeyspaceGraphRequest
 */
export interface RebuildKeyspaceGraphRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: repeated string cells = 3;
     */
    cells: string[];
    /**
     * @generated from protobuf field: bool allow_partial = 4;
     */
    allowPartial: boolean;
}
/**
 * @generated from protobuf message vtadmin.RebuildKeyspaceGraphResponse
 */
export interface RebuildKeyspaceGraphResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message vtadmin.RefreshStateRequest
 */
export interface RefreshStateRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.RefreshStateResponse
 */
export interface RefreshStateResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.ReloadSchemasRequest
 */
export interface ReloadSchemasRequest {
    /**
     * Keyspaces, if set, will reload schemas across one or more keyspaces. A
     * keyspace not existing in a cluster will not fail the overall request.
     *
     * Superceded by KeyspaceShards and Tablets, in that order.
     *
     * @generated from protobuf field: repeated string keyspaces = 1;
     */
    keyspaces: string[];
    /**
     * KeyspaceShards, if set, will reload schemas across one or more shards.
     * Each element must be a valid keyspace/shard according to
     * topoproto.ParseKeyspaceShard. A shard not existing in a cluster will not
     * fail the overall request.
     *
     * Supercedes Keyspaces, and is superceded by Tablets.
     *
     * @generated from protobuf field: repeated string keyspace_shards = 2;
     */
    keyspaceShards: string[];
    /**
     * Tablets, if set will reload schemas across one or more tablets.
     * Supercedes both Keyspaces and KeyspaceShards.
     *
     * @generated from protobuf field: repeated topodata.TabletAlias tablets = 3;
     */
    tablets: TabletAlias[];
    /**
     * ClusterIds optionally restricts the reload operation to clusters with
     * the specified IDs. An empty list of ClusterIds will operate on all
     * clusters.
     *
     * @generated from protobuf field: repeated string cluster_ids = 4;
     */
    clusterIds: string[];
    /**
     * Concurrency controls the number of tablets to reload at any given time.
     * Its semantics depend on whether the request is for keyspace, shard, or
     * tablet mode.
     *
     * In Keyspaces mode, Concurrency is the number of tablets to reload at once
     * *per keyspace*.
     *
     * In KeyspaceShards mode, Concurrency is the number of tablets to reload at
     * once *per shard*.
     *
     * In Tablets mode, Concurrency is the number of tablets to reload at once
     * *per cluster*.
     *
     * @generated from protobuf field: int32 concurrency = 5;
     */
    concurrency: number;
    /**
     * WaitPosition is the replication position that replicating tablets should
     * reach prior to reloading their schemas.
     *
     * Does not apply in Tablets mode.
     *
     * @generated from protobuf field: string wait_position = 6;
     */
    waitPosition: string;
    /**
     * IncludePrimary, if set, will reload the schemas on PRIMARY tablets as
     * well as REPLICA and RDONLY.
     *
     * Does not apply in Tablets mode.
     *
     * @generated from protobuf field: bool include_primary = 7;
     */
    includePrimary: boolean;
}
/**
 * @generated from protobuf message vtadmin.ReloadSchemasResponse
 */
export interface ReloadSchemasResponse {
    /**
     * KeyspaceResults is the list of KeyspaceResult objects for a ReloadSchemas
     * operation. It is only set when the request mandates Keyspaces mode (see
     * ReloadSchemasRequest).
     *
     * @generated from protobuf field: repeated vtadmin.ReloadSchemasResponse.KeyspaceResult keyspace_results = 1;
     */
    keyspaceResults: ReloadSchemasResponse_KeyspaceResult[];
    /**
     * ShardResults is the list of ShardResult objects for a ReloadSchemas
     * operation. It is only set when the request mandates KeyspaceShards mode
     * (see ReloadSchemasRequest).
     *
     * @generated from protobuf field: repeated vtadmin.ReloadSchemasResponse.ShardResult shard_results = 2;
     */
    shardResults: ReloadSchemasResponse_ShardResult[];
    /**
     * TabletResults is the list of TabletResult objects for a ReloadSchemas
     * operation. It is only set when the request mandates Tablets mode (see
     * ReloadSchemasRequest).
     *
     * @generated from protobuf field: repeated vtadmin.ReloadSchemasResponse.TabletResult tablet_results = 3;
     */
    tabletResults: ReloadSchemasResponse_TabletResult[];
}
/**
 * KeyspaceResult is a grouping of a Keyspace and any log events that
 * occurred in that keyspace during a schema reload (usually associated with
 * partial errors - ReloadSchemas requests are best-effort).
 *
 * It is only set when a ReloadSchemas request mandates Keyspaces mode
 * (see ReloadSchemasRequest).
 *
 * @generated from protobuf message vtadmin.ReloadSchemasResponse.KeyspaceResult
 */
export interface ReloadSchemasResponse_KeyspaceResult {
    /**
     * @generated from protobuf field: vtadmin.Keyspace keyspace = 1;
     */
    keyspace?: Keyspace;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 2;
     */
    events: Event[];
}
/**
 * ShardResult is a grouping of a Shard and any log events that occurred in
 * that shard during a schema reload (usually associated with partial
 * errors - ReloadSchemas requests are best-effort).
 *
 * It is only set when a ReloadSchemas request mandates KeyspaceShards mode
 * (see ReloadSchemasRequest).
 *
 * @generated from protobuf message vtadmin.ReloadSchemasResponse.ShardResult
 */
export interface ReloadSchemasResponse_ShardResult {
    /**
     * @generated from protobuf field: vtadmin.Shard shard = 1;
     */
    shard?: Shard;
    /**
     * @generated from protobuf field: repeated logutil.Event events = 2;
     */
    events: Event[];
}
/**
 * TabletResult is a grouping of a Tablet and the result of reloading that
 * Tablet's schema. Result will either be the string "ok", or the error
 * message from that tablet. Note ReloadSchemas is best-effort, so tablet's
 * failing to reload is not treated as an overall failure.
 *
 * It is only set when a ReloadSchemas request mandates Tablets mode (see
 * ReloadSchemasRequest).
 *
 * @generated from protobuf message vtadmin.ReloadSchemasResponse.TabletResult
 */
export interface ReloadSchemasResponse_TabletResult {
    /**
     * @generated from protobuf field: vtadmin.Tablet tablet = 1;
     */
    tablet?: Tablet;
    /**
     * @generated from protobuf field: string result = 2;
     */
    result: string;
}
/**
 * @generated from protobuf message vtadmin.ReloadSchemaShardRequest
 */
export interface ReloadSchemaShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: string wait_position = 4;
     */
    waitPosition: string;
    /**
     * @generated from protobuf field: bool include_primary = 5;
     */
    includePrimary: boolean;
    /**
     * @generated from protobuf field: int32 concurrency = 6;
     */
    concurrency: number;
}
/**
 * @generated from protobuf message vtadmin.ReloadSchemaShardResponse
 */
export interface ReloadSchemaShardResponse {
    /**
     * @generated from protobuf field: repeated logutil.Event events = 1;
     */
    events: Event[];
}
/**
 * @generated from protobuf message vtadmin.RefreshTabletReplicationSourceRequest
 */
export interface RefreshTabletReplicationSourceRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.RefreshTabletReplicationSourceResponse
 */
export interface RefreshTabletReplicationSourceResponse {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias primary = 3;
     */
    primary?: TabletAlias;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 4;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.RemoveKeyspaceCellRequest
 */
export interface RemoveKeyspaceCellRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string cell = 3;
     */
    cell: string;
    /**
     * @generated from protobuf field: bool force = 4;
     */
    force: boolean;
    /**
     * @generated from protobuf field: bool recursive = 5;
     */
    recursive: boolean;
}
/**
 * @generated from protobuf message vtadmin.RemoveKeyspaceCellResponse
 */
export interface RemoveKeyspaceCellResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
}
/**
 * @generated from protobuf message vtadmin.RetrySchemaMigrationRequest
 */
export interface RetrySchemaMigrationRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: vtctldata.RetrySchemaMigrationRequest request = 2;
     */
    request?: RetrySchemaMigrationRequest$;
}
/**
 * @generated from protobuf message vtadmin.RunHealthCheckRequest
 */
export interface RunHealthCheckRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.RunHealthCheckResponse
 */
export interface RunHealthCheckResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.SetReadOnlyRequest
 */
export interface SetReadOnlyRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.SetReadOnlyResponse
 */
export interface SetReadOnlyResponse {
}
/**
 * @generated from protobuf message vtadmin.SetReadWriteRequest
 */
export interface SetReadWriteRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.SetReadWriteResponse
 */
export interface SetReadWriteResponse {
}
/**
 * @generated from protobuf message vtadmin.StartReplicationRequest
 */
export interface StartReplicationRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.StartReplicationResponse
 */
export interface StartReplicationResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.StopReplicationRequest
 */
export interface StopReplicationRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.StopReplicationResponse
 */
export interface StopReplicationResponse {
    /**
     * @generated from protobuf field: string status = 1;
     */
    status: string;
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 2;
     */
    cluster?: Cluster;
}
/**
 * @generated from protobuf message vtadmin.TabletExternallyPromotedRequest
 */
export interface TabletExternallyPromotedRequest {
    /**
     * Tablet is the alias of the tablet that was promoted externally and should
     * be updated to the shard primary in the topo.
     *
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.TabletExternallyPromotedResponse
 */
export interface TabletExternallyPromotedResponse {
    /**
     * @generated from protobuf field: vtadmin.Cluster cluster = 1;
     */
    cluster?: Cluster;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: topodata.TabletAlias new_primary = 4;
     */
    newPrimary?: TabletAlias;
    /**
     * @generated from protobuf field: topodata.TabletAlias old_primary = 5;
     */
    oldPrimary?: TabletAlias;
}
/**
 * @generated from protobuf message vtadmin.TabletExternallyReparentedRequest
 */
export interface TabletExternallyReparentedRequest {
    /**
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * @generated from protobuf field: repeated string cluster_ids = 2;
     */
    clusterIds: string[];
}
/**
 * @generated from protobuf message vtadmin.ValidateRequest
 */
export interface ValidateRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: bool ping_tablets = 2;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtadmin.ValidateKeyspaceRequest
 */
export interface ValidateKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: bool ping_tablets = 3;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtadmin.ValidateSchemaKeyspaceRequest
 */
export interface ValidateSchemaKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtadmin.ValidateShardRequest
 */
export interface ValidateShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * @generated from protobuf field: bool ping_tablets = 4;
     */
    pingTablets: boolean;
}
/**
 * @generated from protobuf message vtadmin.ValidateVersionKeyspaceRequest
 */
export interface ValidateVersionKeyspaceRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
}
/**
 * @generated from protobuf message vtadmin.ValidateVersionShardRequest
 */
export interface ValidateVersionShardRequest {
    /**
     * @generated from protobuf field: string cluster_id = 1;
     */
    clusterId: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
}
/**
 * @generated from protobuf message vtadmin.VTExplainRequest
 */
export interface VTExplainRequest {
    /**
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string sql = 3;
     */
    sql: string;
}
/**
 * @generated from protobuf message vtadmin.VTExplainResponse
 */
export interface VTExplainResponse {
    /**
     * @generated from protobuf field: string response = 1;
     */
    response: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Cluster$Type extends MessageType<Cluster> {
    constructor() {
        super("vtadmin.Cluster", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Cluster>): Cluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Cluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cluster): Cluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Cluster
 */
export const Cluster = new Cluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterBackup$Type extends MessageType<ClusterBackup> {
    constructor() {
        super("vtadmin.ClusterBackup", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "backup", kind: "message", T: () => BackupInfo }
        ]);
    }
    create(value?: PartialMessage<ClusterBackup>): ClusterBackup {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClusterBackup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterBackup): ClusterBackup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* mysqlctl.BackupInfo backup */ 2:
                    message.backup = BackupInfo.internalBinaryRead(reader, reader.uint32(), options, message.backup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterBackup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mysqlctl.BackupInfo backup = 2; */
        if (message.backup)
            BackupInfo.internalBinaryWrite(message.backup, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ClusterBackup
 */
export const ClusterBackup = new ClusterBackup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterCellsAliases$Type extends MessageType<ClusterCellsAliases> {
    constructor() {
        super("vtadmin.ClusterCellsAliases", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "aliases", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CellsAlias } }
        ]);
    }
    create(value?: PartialMessage<ClusterCellsAliases>): ClusterCellsAliases {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aliases = {};
        if (value !== undefined)
            reflectionMergePartial<ClusterCellsAliases>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterCellsAliases): ClusterCellsAliases {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* map<string, topodata.CellsAlias> aliases */ 2:
                    this.binaryReadMap2(message.aliases, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ClusterCellsAliases["aliases"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ClusterCellsAliases["aliases"] | undefined, val: ClusterCellsAliases["aliases"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CellsAlias.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.ClusterCellsAliases.aliases");
            }
        }
        map[key ?? ""] = val ?? CellsAlias.create();
    }
    internalBinaryWrite(message: ClusterCellsAliases, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, topodata.CellsAlias> aliases = 2; */
        for (let k of globalThis.Object.keys(message.aliases)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CellsAlias.internalBinaryWrite(message.aliases[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ClusterCellsAliases
 */
export const ClusterCellsAliases = new ClusterCellsAliases$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterCellInfo$Type extends MessageType<ClusterCellInfo> {
    constructor() {
        super("vtadmin.ClusterCellInfo", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cell_info", kind: "message", T: () => CellInfo }
        ]);
    }
    create(value?: PartialMessage<ClusterCellInfo>): ClusterCellInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterCellInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterCellInfo): ClusterCellInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* topodata.CellInfo cell_info */ 3:
                    message.cellInfo = CellInfo.internalBinaryRead(reader, reader.uint32(), options, message.cellInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterCellInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* topodata.CellInfo cell_info = 3; */
        if (message.cellInfo)
            CellInfo.internalBinaryWrite(message.cellInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ClusterCellInfo
 */
export const ClusterCellInfo = new ClusterCellInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterShardReplicationPosition$Type extends MessageType<ClusterShardReplicationPosition> {
    constructor() {
        super("vtadmin.ClusterShardReplicationPosition", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "position_info", kind: "message", T: () => ShardReplicationPositionsResponse }
        ]);
    }
    create(value?: PartialMessage<ClusterShardReplicationPosition>): ClusterShardReplicationPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterShardReplicationPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterShardReplicationPosition): ClusterShardReplicationPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* vtctldata.ShardReplicationPositionsResponse position_info */ 4:
                    message.positionInfo = ShardReplicationPositionsResponse.internalBinaryRead(reader, reader.uint32(), options, message.positionInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterShardReplicationPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* vtctldata.ShardReplicationPositionsResponse position_info = 4; */
        if (message.positionInfo)
            ShardReplicationPositionsResponse.internalBinaryWrite(message.positionInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ClusterShardReplicationPosition
 */
export const ClusterShardReplicationPosition = new ClusterShardReplicationPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterWorkflows$Type extends MessageType<ClusterWorkflows> {
    constructor() {
        super("vtadmin.ClusterWorkflows", [
            { no: 1, name: "workflows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Workflow },
            { no: 2, name: "warnings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClusterWorkflows>): ClusterWorkflows {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflows = [];
        message.warnings = [];
        if (value !== undefined)
            reflectionMergePartial<ClusterWorkflows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterWorkflows): ClusterWorkflows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Workflow workflows */ 1:
                    message.workflows.push(Workflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string warnings */ 2:
                    message.warnings.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterWorkflows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Workflow workflows = 1; */
        for (let i = 0; i < message.workflows.length; i++)
            Workflow.internalBinaryWrite(message.workflows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string warnings = 2; */
        for (let i = 0; i < message.warnings.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.warnings[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ClusterWorkflows
 */
export const ClusterWorkflows = new ClusterWorkflows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Keyspace$Type extends MessageType<Keyspace> {
    constructor() {
        super("vtadmin.Keyspace", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "message", T: () => Keyspace$ },
            { no: 3, name: "shards", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Shard$ } }
        ]);
    }
    create(value?: PartialMessage<Keyspace>): Keyspace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shards = {};
        if (value !== undefined)
            reflectionMergePartial<Keyspace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Keyspace): Keyspace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* vtctldata.Keyspace keyspace */ 2:
                    message.keyspace = Keyspace$.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                case /* map<string, vtctldata.Shard> shards */ 3:
                    this.binaryReadMap3(message.shards, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Keyspace["shards"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Keyspace["shards"] | undefined, val: Keyspace["shards"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Shard$.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.Keyspace.shards");
            }
        }
        map[key ?? ""] = val ?? Shard$.create();
    }
    internalBinaryWrite(message: Keyspace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.Keyspace keyspace = 2; */
        if (message.keyspace)
            Keyspace$.internalBinaryWrite(message.keyspace, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, vtctldata.Shard> shards = 3; */
        for (let k of globalThis.Object.keys(message.shards)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Shard$.internalBinaryWrite(message.shards[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Keyspace
 */
export const Keyspace = new Keyspace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema$Type extends MessageType<Schema> {
    constructor() {
        super("vtadmin.Schema", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table_definitions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TableDefinition },
            { no: 4, name: "table_sizes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Schema_TableSize } }
        ]);
    }
    create(value?: PartialMessage<Schema>): Schema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.tableDefinitions = [];
        message.tableSizes = {};
        if (value !== undefined)
            reflectionMergePartial<Schema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema): Schema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* repeated tabletmanagerdata.TableDefinition table_definitions */ 3:
                    message.tableDefinitions.push(TableDefinition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, vtadmin.Schema.TableSize> table_sizes */ 4:
                    this.binaryReadMap4(message.tableSizes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: Schema["tableSizes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Schema["tableSizes"] | undefined, val: Schema["tableSizes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Schema_TableSize.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.Schema.table_sizes");
            }
        }
        map[key ?? ""] = val ?? Schema_TableSize.create();
    }
    internalBinaryWrite(message: Schema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* repeated tabletmanagerdata.TableDefinition table_definitions = 3; */
        for (let i = 0; i < message.tableDefinitions.length; i++)
            TableDefinition.internalBinaryWrite(message.tableDefinitions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* map<string, vtadmin.Schema.TableSize> table_sizes = 4; */
        for (let k of globalThis.Object.keys(message.tableSizes)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Schema_TableSize.internalBinaryWrite(message.tableSizes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Schema
 */
export const Schema = new Schema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema_ShardTableSize$Type extends MessageType<Schema_ShardTableSize> {
    constructor() {
        super("vtadmin.Schema.ShardTableSize", [
            { no: 1, name: "row_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "data_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Schema_ShardTableSize>): Schema_ShardTableSize {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowCount = 0n;
        message.dataLength = 0n;
        if (value !== undefined)
            reflectionMergePartial<Schema_ShardTableSize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema_ShardTableSize): Schema_ShardTableSize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 row_count */ 1:
                    message.rowCount = reader.uint64().toBigInt();
                    break;
                case /* uint64 data_length */ 2:
                    message.dataLength = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Schema_ShardTableSize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 row_count = 1; */
        if (message.rowCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rowCount);
        /* uint64 data_length = 2; */
        if (message.dataLength !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.dataLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Schema.ShardTableSize
 */
export const Schema_ShardTableSize = new Schema_ShardTableSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Schema_TableSize$Type extends MessageType<Schema_TableSize> {
    constructor() {
        super("vtadmin.Schema.TableSize", [
            { no: 1, name: "row_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "data_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "by_shard", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Schema_ShardTableSize } }
        ]);
    }
    create(value?: PartialMessage<Schema_TableSize>): Schema_TableSize {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rowCount = 0n;
        message.dataLength = 0n;
        message.byShard = {};
        if (value !== undefined)
            reflectionMergePartial<Schema_TableSize>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Schema_TableSize): Schema_TableSize {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 row_count */ 1:
                    message.rowCount = reader.uint64().toBigInt();
                    break;
                case /* uint64 data_length */ 2:
                    message.dataLength = reader.uint64().toBigInt();
                    break;
                case /* map<string, vtadmin.Schema.ShardTableSize> by_shard */ 3:
                    this.binaryReadMap3(message.byShard, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Schema_TableSize["byShard"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Schema_TableSize["byShard"] | undefined, val: Schema_TableSize["byShard"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Schema_ShardTableSize.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.Schema.TableSize.by_shard");
            }
        }
        map[key ?? ""] = val ?? Schema_ShardTableSize.create();
    }
    internalBinaryWrite(message: Schema_TableSize, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 row_count = 1; */
        if (message.rowCount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rowCount);
        /* uint64 data_length = 2; */
        if (message.dataLength !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.dataLength);
        /* map<string, vtadmin.Schema.ShardTableSize> by_shard = 3; */
        for (let k of globalThis.Object.keys(message.byShard)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Schema_ShardTableSize.internalBinaryWrite(message.byShard[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Schema.TableSize
 */
export const Schema_TableSize = new Schema_TableSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaMigration$Type extends MessageType<SchemaMigration> {
    constructor() {
        super("vtadmin.SchemaMigration", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "schema_migration", kind: "message", T: () => SchemaMigration$ }
        ]);
    }
    create(value?: PartialMessage<SchemaMigration>): SchemaMigration {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SchemaMigration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaMigration): SchemaMigration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* vtctldata.SchemaMigration schema_migration */ 2:
                    message.schemaMigration = SchemaMigration$.internalBinaryRead(reader, reader.uint32(), options, message.schemaMigration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaMigration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.SchemaMigration schema_migration = 2; */
        if (message.schemaMigration)
            SchemaMigration$.internalBinaryWrite(message.schemaMigration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SchemaMigration
 */
export const SchemaMigration = new SchemaMigration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shard$Type extends MessageType<Shard> {
    constructor() {
        super("vtadmin.Shard", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "shard", kind: "message", T: () => Shard$ }
        ]);
    }
    create(value?: PartialMessage<Shard>): Shard {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Shard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shard): Shard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* vtctldata.Shard shard */ 2:
                    message.shard = Shard$.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtctldata.Shard shard = 2; */
        if (message.shard)
            Shard$.internalBinaryWrite(message.shard, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Shard
 */
export const Shard = new Shard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SrvVSchema$Type extends MessageType<SrvVSchema> {
    constructor() {
        super("vtadmin.SrvVSchema", [
            { no: 1, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster },
            { no: 3, name: "srv_v_schema", kind: "message", T: () => SrvVSchema$ }
        ]);
    }
    create(value?: PartialMessage<SrvVSchema>): SrvVSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<SrvVSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SrvVSchema): SrvVSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cell */ 1:
                    message.cell = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* vschema.SrvVSchema srv_v_schema */ 3:
                    message.srvVSchema = SrvVSchema$.internalBinaryRead(reader, reader.uint32(), options, message.srvVSchema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SrvVSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cell = 1; */
        if (message.cell !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cell);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vschema.SrvVSchema srv_v_schema = 3; */
        if (message.srvVSchema)
            SrvVSchema$.internalBinaryWrite(message.srvVSchema, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SrvVSchema
 */
export const SrvVSchema = new SrvVSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tablet$Type extends MessageType<Tablet> {
    constructor() {
        super("vtadmin.Tablet", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "tablet", kind: "message", T: () => Tablet$ },
            { no: 3, name: "state", kind: "enum", T: () => ["vtadmin.Tablet.ServingState", Tablet_ServingState] },
            { no: 4, name: "FQDN", kind: "scalar", jsonName: "FQDN", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Tablet>): Tablet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.fQDN = "";
        if (value !== undefined)
            reflectionMergePartial<Tablet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tablet): Tablet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* topodata.Tablet tablet */ 2:
                    message.tablet = Tablet$.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* vtadmin.Tablet.ServingState state */ 3:
                    message.state = reader.int32();
                    break;
                case /* string FQDN = 4 [json_name = "FQDN"];*/ 4:
                    message.fQDN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tablet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* topodata.Tablet tablet = 2; */
        if (message.tablet)
            Tablet$.internalBinaryWrite(message.tablet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vtadmin.Tablet.ServingState state = 3; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* string FQDN = 4 [json_name = "FQDN"]; */
        if (message.fQDN !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fQDN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Tablet
 */
export const Tablet = new Tablet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VSchema$Type extends MessageType<VSchema> {
    constructor() {
        super("vtadmin.VSchema", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "v_schema", kind: "message", T: () => Keyspace$2 }
        ]);
    }
    create(value?: PartialMessage<VSchema>): VSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<VSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VSchema): VSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* vschema.Keyspace v_schema */ 3:
                    message.vSchema = Keyspace$2.internalBinaryRead(reader, reader.uint32(), options, message.vSchema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* vschema.Keyspace v_schema = 3; */
        if (message.vSchema)
            Keyspace$2.internalBinaryWrite(message.vSchema, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.VSchema
 */
export const VSchema = new VSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Vtctld$Type extends MessageType<Vtctld> {
    constructor() {
        super("vtadmin.Vtctld", [
            { no: 1, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster },
            { no: 3, name: "FQDN", kind: "scalar", jsonName: "FQDN", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Vtctld>): Vtctld {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.fQDN = "";
        if (value !== undefined)
            reflectionMergePartial<Vtctld>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vtctld): Vtctld {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string FQDN = 3 [json_name = "FQDN"];*/ 3:
                    message.fQDN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vtctld, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hostname = 1; */
        if (message.hostname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string FQDN = 3 [json_name = "FQDN"]; */
        if (message.fQDN !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fQDN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Vtctld
 */
export const Vtctld = new Vtctld$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VTGate$Type extends MessageType<VTGate> {
    constructor() {
        super("vtadmin.VTGate", [
            { no: 1, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pool", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cluster", kind: "message", T: () => Cluster },
            { no: 5, name: "keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "FQDN", kind: "scalar", jsonName: "FQDN", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VTGate>): VTGate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.pool = "";
        message.cell = "";
        message.keyspaces = [];
        message.fQDN = "";
        if (value !== undefined)
            reflectionMergePartial<VTGate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VTGate): VTGate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                case /* string pool */ 2:
                    message.pool = reader.string();
                    break;
                case /* string cell */ 3:
                    message.cell = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 4:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* repeated string keyspaces */ 5:
                    message.keyspaces.push(reader.string());
                    break;
                case /* string FQDN = 6 [json_name = "FQDN"];*/ 6:
                    message.fQDN = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VTGate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hostname = 1; */
        if (message.hostname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        /* string pool = 2; */
        if (message.pool !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pool);
        /* string cell = 3; */
        if (message.cell !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cell);
        /* vtadmin.Cluster cluster = 4; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string keyspaces = 5; */
        for (let i = 0; i < message.keyspaces.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.keyspaces[i]);
        /* string FQDN = 6 [json_name = "FQDN"]; */
        if (message.fQDN !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fQDN);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.VTGate
 */
export const VTGate = new VTGate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow$Type extends MessageType<Workflow> {
    constructor() {
        super("vtadmin.Workflow", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow", kind: "message", T: () => Workflow$ }
        ]);
    }
    create(value?: PartialMessage<Workflow>): Workflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<Workflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow): Workflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* vtctldata.Workflow workflow */ 3:
                    message.workflow = Workflow$.internalBinaryRead(reader, reader.uint32(), options, message.workflow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* vtctldata.Workflow workflow = 3; */
        if (message.workflow)
            Workflow$.internalBinaryWrite(message.workflow, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.Workflow
 */
export const Workflow = new Workflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplySchemaRequest$Type extends MessageType<ApplySchemaRequest> {
    constructor() {
        super("vtadmin.ApplySchemaRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => ApplySchemaRequest$ }
        ]);
    }
    create(value?: PartialMessage<ApplySchemaRequest>): ApplySchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<ApplySchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplySchemaRequest): ApplySchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.ApplySchemaRequest request */ 2:
                    message.request = ApplySchemaRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplySchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.ApplySchemaRequest request = 2; */
        if (message.request)
            ApplySchemaRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ApplySchemaRequest
 */
export const ApplySchemaRequest = new ApplySchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelSchemaMigrationRequest$Type extends MessageType<CancelSchemaMigrationRequest> {
    constructor() {
        super("vtadmin.CancelSchemaMigrationRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => CancelSchemaMigrationRequest$ }
        ]);
    }
    create(value?: PartialMessage<CancelSchemaMigrationRequest>): CancelSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<CancelSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelSchemaMigrationRequest): CancelSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.CancelSchemaMigrationRequest request */ 2:
                    message.request = CancelSchemaMigrationRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.CancelSchemaMigrationRequest request = 2; */
        if (message.request)
            CancelSchemaMigrationRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CancelSchemaMigrationRequest
 */
export const CancelSchemaMigrationRequest = new CancelSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CleanupSchemaMigrationRequest$Type extends MessageType<CleanupSchemaMigrationRequest> {
    constructor() {
        super("vtadmin.CleanupSchemaMigrationRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => CleanupSchemaMigrationRequest$ }
        ]);
    }
    create(value?: PartialMessage<CleanupSchemaMigrationRequest>): CleanupSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<CleanupSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CleanupSchemaMigrationRequest): CleanupSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.CleanupSchemaMigrationRequest request */ 2:
                    message.request = CleanupSchemaMigrationRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CleanupSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.CleanupSchemaMigrationRequest request = 2; */
        if (message.request)
            CleanupSchemaMigrationRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CleanupSchemaMigrationRequest
 */
export const CleanupSchemaMigrationRequest = new CleanupSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompleteSchemaMigrationRequest$Type extends MessageType<CompleteSchemaMigrationRequest> {
    constructor() {
        super("vtadmin.CompleteSchemaMigrationRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => CompleteSchemaMigrationRequest$ }
        ]);
    }
    create(value?: PartialMessage<CompleteSchemaMigrationRequest>): CompleteSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<CompleteSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompleteSchemaMigrationRequest): CompleteSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.CompleteSchemaMigrationRequest request */ 2:
                    message.request = CompleteSchemaMigrationRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompleteSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.CompleteSchemaMigrationRequest request = 2; */
        if (message.request)
            CompleteSchemaMigrationRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CompleteSchemaMigrationRequest
 */
export const CompleteSchemaMigrationRequest = new CompleteSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcludeTransactionRequest$Type extends MessageType<ConcludeTransactionRequest> {
    constructor() {
        super("vtadmin.ConcludeTransactionRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConcludeTransactionRequest>): ConcludeTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<ConcludeTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcludeTransactionRequest): ConcludeTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string dtid */ 2:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcludeTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string dtid = 2; */
        if (message.dtid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ConcludeTransactionRequest
 */
export const ConcludeTransactionRequest = new ConcludeTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyspaceRequest$Type extends MessageType<CreateKeyspaceRequest> {
    constructor() {
        super("vtadmin.CreateKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => CreateKeyspaceRequest$ }
        ]);
    }
    create(value?: PartialMessage<CreateKeyspaceRequest>): CreateKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyspaceRequest): CreateKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.CreateKeyspaceRequest options */ 2:
                    message.options = CreateKeyspaceRequest$.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.CreateKeyspaceRequest options = 2; */
        if (message.options)
            CreateKeyspaceRequest$.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CreateKeyspaceRequest
 */
export const CreateKeyspaceRequest = new CreateKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateKeyspaceResponse$Type extends MessageType<CreateKeyspaceResponse> {
    constructor() {
        super("vtadmin.CreateKeyspaceResponse", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace }
        ]);
    }
    create(value?: PartialMessage<CreateKeyspaceResponse>): CreateKeyspaceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateKeyspaceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateKeyspaceResponse): CreateKeyspaceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateKeyspaceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CreateKeyspaceResponse
 */
export const CreateKeyspaceResponse = new CreateKeyspaceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateShardRequest$Type extends MessageType<CreateShardRequest> {
    constructor() {
        super("vtadmin.CreateShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => CreateShardRequest$ }
        ]);
    }
    create(value?: PartialMessage<CreateShardRequest>): CreateShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateShardRequest): CreateShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.CreateShardRequest options */ 2:
                    message.options = CreateShardRequest$.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.CreateShardRequest options = 2; */
        if (message.options)
            CreateShardRequest$.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.CreateShardRequest
 */
export const CreateShardRequest = new CreateShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteKeyspaceRequest$Type extends MessageType<DeleteKeyspaceRequest> {
    constructor() {
        super("vtadmin.DeleteKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => DeleteKeyspaceRequest$ }
        ]);
    }
    create(value?: PartialMessage<DeleteKeyspaceRequest>): DeleteKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteKeyspaceRequest): DeleteKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.DeleteKeyspaceRequest options */ 2:
                    message.options = DeleteKeyspaceRequest$.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.DeleteKeyspaceRequest options = 2; */
        if (message.options)
            DeleteKeyspaceRequest$.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.DeleteKeyspaceRequest
 */
export const DeleteKeyspaceRequest = new DeleteKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteShardsRequest$Type extends MessageType<DeleteShardsRequest> {
    constructor() {
        super("vtadmin.DeleteShardsRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => DeleteShardsRequest$ }
        ]);
    }
    create(value?: PartialMessage<DeleteShardsRequest>): DeleteShardsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteShardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteShardsRequest): DeleteShardsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.DeleteShardsRequest options */ 2:
                    message.options = DeleteShardsRequest$.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteShardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.DeleteShardsRequest options = 2; */
        if (message.options)
            DeleteShardsRequest$.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.DeleteShardsRequest
 */
export const DeleteShardsRequest = new DeleteShardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTabletRequest$Type extends MessageType<DeleteTabletRequest> {
    constructor() {
        super("vtadmin.DeleteTabletRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allow_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTabletRequest>): DeleteTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.allowPrimary = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTabletRequest): DeleteTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                case /* bool allow_primary */ 3:
                    message.allowPrimary = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* bool allow_primary = 3; */
        if (message.allowPrimary !== false)
            writer.tag(3, WireType.Varint).bool(message.allowPrimary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.DeleteTabletRequest
 */
export const DeleteTabletRequest = new DeleteTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTabletResponse$Type extends MessageType<DeleteTabletResponse> {
    constructor() {
        super("vtadmin.DeleteTabletResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<DeleteTabletResponse>): DeleteTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTabletResponse): DeleteTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.DeleteTabletResponse
 */
export const DeleteTabletResponse = new DeleteTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyFailoverShardRequest$Type extends MessageType<EmergencyFailoverShardRequest> {
    constructor() {
        super("vtadmin.EmergencyFailoverShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => EmergencyReparentShardRequest }
        ]);
    }
    create(value?: PartialMessage<EmergencyFailoverShardRequest>): EmergencyFailoverShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<EmergencyFailoverShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyFailoverShardRequest): EmergencyFailoverShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.EmergencyReparentShardRequest options */ 2:
                    message.options = EmergencyReparentShardRequest.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyFailoverShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.EmergencyReparentShardRequest options = 2; */
        if (message.options)
            EmergencyReparentShardRequest.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.EmergencyFailoverShardRequest
 */
export const EmergencyFailoverShardRequest = new EmergencyFailoverShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyFailoverShardResponse$Type extends MessageType<EmergencyFailoverShardResponse> {
    constructor() {
        super("vtadmin.EmergencyFailoverShardResponse", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "promoted_primary", kind: "message", T: () => TabletAlias },
            { no: 5, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<EmergencyFailoverShardResponse>): EmergencyFailoverShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<EmergencyFailoverShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyFailoverShardResponse): EmergencyFailoverShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias promoted_primary */ 4:
                    message.promotedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.promotedPrimary);
                    break;
                case /* repeated logutil.Event events */ 5:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyFailoverShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias promoted_primary = 4; */
        if (message.promotedPrimary)
            TabletAlias.internalBinaryWrite(message.promotedPrimary, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 5; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.EmergencyFailoverShardResponse
 */
export const EmergencyFailoverShardResponse = new EmergencyFailoverShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindSchemaRequest$Type extends MessageType<FindSchemaRequest> {
    constructor() {
        super("vtadmin.FindSchemaRequest", [
            { no: 1, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table_size_options", kind: "message", T: () => GetSchemaTableSizeOptions }
        ]);
    }
    create(value?: PartialMessage<FindSchemaRequest>): FindSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.table = "";
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<FindSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindSchemaRequest): FindSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table */ 1:
                    message.table = reader.string();
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                case /* vtadmin.GetSchemaTableSizeOptions table_size_options */ 3:
                    message.tableSizeOptions = GetSchemaTableSizeOptions.internalBinaryRead(reader, reader.uint32(), options, message.tableSizeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table = 1; */
        if (message.table !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.table);
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* vtadmin.GetSchemaTableSizeOptions table_size_options = 3; */
        if (message.tableSizeOptions)
            GetSchemaTableSizeOptions.internalBinaryWrite(message.tableSizeOptions, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.FindSchemaRequest
 */
export const FindSchemaRequest = new FindSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBackupsRequest$Type extends MessageType<GetBackupsRequest> {
    constructor() {
        super("vtadmin.GetBackupsRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keyspace_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "request_options", kind: "message", T: () => GetBackupsRequest$ }
        ]);
    }
    create(value?: PartialMessage<GetBackupsRequest>): GetBackupsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.keyspaces = [];
        message.keyspaceShards = [];
        if (value !== undefined)
            reflectionMergePartial<GetBackupsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBackupsRequest): GetBackupsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* repeated string keyspaces */ 2:
                    message.keyspaces.push(reader.string());
                    break;
                case /* repeated string keyspace_shards */ 3:
                    message.keyspaceShards.push(reader.string());
                    break;
                case /* vtctldata.GetBackupsRequest request_options */ 4:
                    message.requestOptions = GetBackupsRequest$.internalBinaryRead(reader, reader.uint32(), options, message.requestOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBackupsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* repeated string keyspaces = 2; */
        for (let i = 0; i < message.keyspaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.keyspaces[i]);
        /* repeated string keyspace_shards = 3; */
        for (let i = 0; i < message.keyspaceShards.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.keyspaceShards[i]);
        /* vtctldata.GetBackupsRequest request_options = 4; */
        if (message.requestOptions)
            GetBackupsRequest$.internalBinaryWrite(message.requestOptions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetBackupsRequest
 */
export const GetBackupsRequest = new GetBackupsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBackupsResponse$Type extends MessageType<GetBackupsResponse> {
    constructor() {
        super("vtadmin.GetBackupsResponse", [
            { no: 1, name: "backups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterBackup }
        ]);
    }
    create(value?: PartialMessage<GetBackupsResponse>): GetBackupsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.backups = [];
        if (value !== undefined)
            reflectionMergePartial<GetBackupsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBackupsResponse): GetBackupsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.ClusterBackup backups */ 1:
                    message.backups.push(ClusterBackup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBackupsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.ClusterBackup backups = 1; */
        for (let i = 0; i < message.backups.length; i++)
            ClusterBackup.internalBinaryWrite(message.backups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetBackupsResponse
 */
export const GetBackupsResponse = new GetBackupsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfosRequest$Type extends MessageType<GetCellInfosRequest> {
    constructor() {
        super("vtadmin.GetCellInfosRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "names_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetCellInfosRequest>): GetCellInfosRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.cells = [];
        message.namesOnly = false;
        if (value !== undefined)
            reflectionMergePartial<GetCellInfosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfosRequest): GetCellInfosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                case /* bool names_only */ 3:
                    message.namesOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        /* bool names_only = 3; */
        if (message.namesOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.namesOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetCellInfosRequest
 */
export const GetCellInfosRequest = new GetCellInfosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellInfosResponse$Type extends MessageType<GetCellInfosResponse> {
    constructor() {
        super("vtadmin.GetCellInfosResponse", [
            { no: 1, name: "cell_infos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterCellInfo }
        ]);
    }
    create(value?: PartialMessage<GetCellInfosResponse>): GetCellInfosResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cellInfos = [];
        if (value !== undefined)
            reflectionMergePartial<GetCellInfosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellInfosResponse): GetCellInfosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.ClusterCellInfo cell_infos */ 1:
                    message.cellInfos.push(ClusterCellInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellInfosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.ClusterCellInfo cell_infos = 1; */
        for (let i = 0; i < message.cellInfos.length; i++)
            ClusterCellInfo.internalBinaryWrite(message.cellInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetCellInfosResponse
 */
export const GetCellInfosResponse = new GetCellInfosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellsAliasesRequest$Type extends MessageType<GetCellsAliasesRequest> {
    constructor() {
        super("vtadmin.GetCellsAliasesRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCellsAliasesRequest>): GetCellsAliasesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetCellsAliasesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellsAliasesRequest): GetCellsAliasesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellsAliasesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetCellsAliasesRequest
 */
export const GetCellsAliasesRequest = new GetCellsAliasesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCellsAliasesResponse$Type extends MessageType<GetCellsAliasesResponse> {
    constructor() {
        super("vtadmin.GetCellsAliasesResponse", [
            { no: 1, name: "aliases", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterCellsAliases }
        ]);
    }
    create(value?: PartialMessage<GetCellsAliasesResponse>): GetCellsAliasesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aliases = [];
        if (value !== undefined)
            reflectionMergePartial<GetCellsAliasesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCellsAliasesResponse): GetCellsAliasesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.ClusterCellsAliases aliases */ 1:
                    message.aliases.push(ClusterCellsAliases.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCellsAliasesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.ClusterCellsAliases aliases = 1; */
        for (let i = 0; i < message.aliases.length; i++)
            ClusterCellsAliases.internalBinaryWrite(message.aliases[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetCellsAliasesResponse
 */
export const GetCellsAliasesResponse = new GetCellsAliasesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClustersRequest$Type extends MessageType<GetClustersRequest> {
    constructor() {
        super("vtadmin.GetClustersRequest", []);
    }
    create(value?: PartialMessage<GetClustersRequest>): GetClustersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetClustersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClustersRequest): GetClustersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClustersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetClustersRequest
 */
export const GetClustersRequest = new GetClustersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetClustersResponse$Type extends MessageType<GetClustersResponse> {
    constructor() {
        super("vtadmin.GetClustersResponse", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<GetClustersResponse>): GetClustersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<GetClustersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetClustersResponse): GetClustersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Cluster clusters */ 1:
                    message.clusters.push(Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetClustersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Cluster clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            Cluster.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetClustersResponse
 */
export const GetClustersResponse = new GetClustersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFullStatusRequest$Type extends MessageType<GetFullStatusRequest> {
    constructor() {
        super("vtadmin.GetFullStatusRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<GetFullStatusRequest>): GetFullStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<GetFullStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFullStatusRequest): GetFullStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* topodata.TabletAlias alias */ 2:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFullStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* topodata.TabletAlias alias = 2; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetFullStatusRequest
 */
export const GetFullStatusRequest = new GetFullStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGatesRequest$Type extends MessageType<GetGatesRequest> {
    constructor() {
        super("vtadmin.GetGatesRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetGatesRequest>): GetGatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetGatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGatesRequest): GetGatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetGatesRequest
 */
export const GetGatesRequest = new GetGatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGatesResponse$Type extends MessageType<GetGatesResponse> {
    constructor() {
        super("vtadmin.GetGatesResponse", [
            { no: 1, name: "gates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VTGate }
        ]);
    }
    create(value?: PartialMessage<GetGatesResponse>): GetGatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gates = [];
        if (value !== undefined)
            reflectionMergePartial<GetGatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGatesResponse): GetGatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.VTGate gates */ 1:
                    message.gates.push(VTGate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.VTGate gates = 1; */
        for (let i = 0; i < message.gates.length; i++)
            VTGate.internalBinaryWrite(message.gates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetGatesResponse
 */
export const GetGatesResponse = new GetGatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspaceRequest$Type extends MessageType<GetKeyspaceRequest> {
    constructor() {
        super("vtadmin.GetKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKeyspaceRequest>): GetKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<GetKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspaceRequest): GetKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetKeyspaceRequest
 */
export const GetKeyspaceRequest = new GetKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspacesRequest$Type extends MessageType<GetKeyspacesRequest> {
    constructor() {
        super("vtadmin.GetKeyspacesRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKeyspacesRequest>): GetKeyspacesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetKeyspacesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspacesRequest): GetKeyspacesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspacesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetKeyspacesRequest
 */
export const GetKeyspacesRequest = new GetKeyspacesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeyspacesResponse$Type extends MessageType<GetKeyspacesResponse> {
    constructor() {
        super("vtadmin.GetKeyspacesResponse", [
            { no: 1, name: "keyspaces", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Keyspace }
        ]);
    }
    create(value?: PartialMessage<GetKeyspacesResponse>): GetKeyspacesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaces = [];
        if (value !== undefined)
            reflectionMergePartial<GetKeyspacesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeyspacesResponse): GetKeyspacesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Keyspace keyspaces */ 1:
                    message.keyspaces.push(Keyspace.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeyspacesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Keyspace keyspaces = 1; */
        for (let i = 0; i < message.keyspaces.length; i++)
            Keyspace.internalBinaryWrite(message.keyspaces[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetKeyspacesResponse
 */
export const GetKeyspacesResponse = new GetKeyspacesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaRequest$Type extends MessageType<GetSchemaRequest> {
    constructor() {
        super("vtadmin.GetSchemaRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "table", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "table_size_options", kind: "message", T: () => GetSchemaTableSizeOptions }
        ]);
    }
    create(value?: PartialMessage<GetSchemaRequest>): GetSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.table = "";
        if (value !== undefined)
            reflectionMergePartial<GetSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaRequest): GetSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string table */ 3:
                    message.table = reader.string();
                    break;
                case /* vtadmin.GetSchemaTableSizeOptions table_size_options */ 4:
                    message.tableSizeOptions = GetSchemaTableSizeOptions.internalBinaryRead(reader, reader.uint32(), options, message.tableSizeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string table = 3; */
        if (message.table !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.table);
        /* vtadmin.GetSchemaTableSizeOptions table_size_options = 4; */
        if (message.tableSizeOptions)
            GetSchemaTableSizeOptions.internalBinaryWrite(message.tableSizeOptions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemaRequest
 */
export const GetSchemaRequest = new GetSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemasRequest$Type extends MessageType<GetSchemasRequest> {
    constructor() {
        super("vtadmin.GetSchemasRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "table_size_options", kind: "message", T: () => GetSchemaTableSizeOptions }
        ]);
    }
    create(value?: PartialMessage<GetSchemasRequest>): GetSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemasRequest): GetSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* vtadmin.GetSchemaTableSizeOptions table_size_options */ 2:
                    message.tableSizeOptions = GetSchemaTableSizeOptions.internalBinaryRead(reader, reader.uint32(), options, message.tableSizeOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* vtadmin.GetSchemaTableSizeOptions table_size_options = 2; */
        if (message.tableSizeOptions)
            GetSchemaTableSizeOptions.internalBinaryWrite(message.tableSizeOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemasRequest
 */
export const GetSchemasRequest = new GetSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemasResponse$Type extends MessageType<GetSchemasResponse> {
    constructor() {
        super("vtadmin.GetSchemasResponse", [
            { no: 1, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Schema }
        ]);
    }
    create(value?: PartialMessage<GetSchemasResponse>): GetSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemas = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemasResponse): GetSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Schema schemas */ 1:
                    message.schemas.push(Schema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Schema schemas = 1; */
        for (let i = 0; i < message.schemas.length; i++)
            Schema.internalBinaryWrite(message.schemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemasResponse
 */
export const GetSchemasResponse = new GetSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaMigrationsRequest$Type extends MessageType<GetSchemaMigrationsRequest> {
    constructor() {
        super("vtadmin.GetSchemaMigrationsRequest", [
            { no: 1, name: "cluster_requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetSchemaMigrationsRequest_ClusterRequest }
        ]);
    }
    create(value?: PartialMessage<GetSchemaMigrationsRequest>): GetSchemaMigrationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterRequests = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemaMigrationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaMigrationsRequest): GetSchemaMigrationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.GetSchemaMigrationsRequest.ClusterRequest cluster_requests */ 1:
                    message.clusterRequests.push(GetSchemaMigrationsRequest_ClusterRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaMigrationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.GetSchemaMigrationsRequest.ClusterRequest cluster_requests = 1; */
        for (let i = 0; i < message.clusterRequests.length; i++)
            GetSchemaMigrationsRequest_ClusterRequest.internalBinaryWrite(message.clusterRequests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemaMigrationsRequest
 */
export const GetSchemaMigrationsRequest = new GetSchemaMigrationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaMigrationsRequest_ClusterRequest$Type extends MessageType<GetSchemaMigrationsRequest_ClusterRequest> {
    constructor() {
        super("vtadmin.GetSchemaMigrationsRequest.ClusterRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => GetSchemaMigrationsRequest$ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaMigrationsRequest_ClusterRequest>): GetSchemaMigrationsRequest_ClusterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<GetSchemaMigrationsRequest_ClusterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaMigrationsRequest_ClusterRequest): GetSchemaMigrationsRequest_ClusterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.GetSchemaMigrationsRequest request */ 2:
                    message.request = GetSchemaMigrationsRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaMigrationsRequest_ClusterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.GetSchemaMigrationsRequest request = 2; */
        if (message.request)
            GetSchemaMigrationsRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemaMigrationsRequest.ClusterRequest
 */
export const GetSchemaMigrationsRequest_ClusterRequest = new GetSchemaMigrationsRequest_ClusterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaMigrationsResponse$Type extends MessageType<GetSchemaMigrationsResponse> {
    constructor() {
        super("vtadmin.GetSchemaMigrationsResponse", [
            { no: 1, name: "schema_migrations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaMigration }
        ]);
    }
    create(value?: PartialMessage<GetSchemaMigrationsResponse>): GetSchemaMigrationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemaMigrations = [];
        if (value !== undefined)
            reflectionMergePartial<GetSchemaMigrationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaMigrationsResponse): GetSchemaMigrationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.SchemaMigration schema_migrations */ 1:
                    message.schemaMigrations.push(SchemaMigration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaMigrationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.SchemaMigration schema_migrations = 1; */
        for (let i = 0; i < message.schemaMigrations.length; i++)
            SchemaMigration.internalBinaryWrite(message.schemaMigrations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemaMigrationsResponse
 */
export const GetSchemaMigrationsResponse = new GetSchemaMigrationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardReplicationPositionsRequest$Type extends MessageType<GetShardReplicationPositionsRequest> {
    constructor() {
        super("vtadmin.GetShardReplicationPositionsRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keyspace_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetShardReplicationPositionsRequest>): GetShardReplicationPositionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.keyspaces = [];
        message.keyspaceShards = [];
        if (value !== undefined)
            reflectionMergePartial<GetShardReplicationPositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardReplicationPositionsRequest): GetShardReplicationPositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* repeated string keyspaces */ 2:
                    message.keyspaces.push(reader.string());
                    break;
                case /* repeated string keyspace_shards */ 3:
                    message.keyspaceShards.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardReplicationPositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* repeated string keyspaces = 2; */
        for (let i = 0; i < message.keyspaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.keyspaces[i]);
        /* repeated string keyspace_shards = 3; */
        for (let i = 0; i < message.keyspaceShards.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.keyspaceShards[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetShardReplicationPositionsRequest
 */
export const GetShardReplicationPositionsRequest = new GetShardReplicationPositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetShardReplicationPositionsResponse$Type extends MessageType<GetShardReplicationPositionsResponse> {
    constructor() {
        super("vtadmin.GetShardReplicationPositionsResponse", [
            { no: 1, name: "replication_positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterShardReplicationPosition }
        ]);
    }
    create(value?: PartialMessage<GetShardReplicationPositionsResponse>): GetShardReplicationPositionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.replicationPositions = [];
        if (value !== undefined)
            reflectionMergePartial<GetShardReplicationPositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetShardReplicationPositionsResponse): GetShardReplicationPositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.ClusterShardReplicationPosition replication_positions */ 1:
                    message.replicationPositions.push(ClusterShardReplicationPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetShardReplicationPositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.ClusterShardReplicationPosition replication_positions = 1; */
        for (let i = 0; i < message.replicationPositions.length; i++)
            ClusterShardReplicationPosition.internalBinaryWrite(message.replicationPositions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetShardReplicationPositionsResponse
 */
export const GetShardReplicationPositionsResponse = new GetShardReplicationPositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspaceRequest$Type extends MessageType<GetSrvKeyspaceRequest> {
    constructor() {
        super("vtadmin.GetSrvKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspaceRequest>): GetSrvKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspaceRequest): GetSrvKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvKeyspaceRequest
 */
export const GetSrvKeyspaceRequest = new GetSrvKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspacesRequest$Type extends MessageType<GetSrvKeyspacesRequest> {
    constructor() {
        super("vtadmin.GetSrvKeyspacesRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspacesRequest>): GetSrvKeyspacesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspacesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspacesRequest): GetSrvKeyspacesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvKeyspacesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvKeyspacesRequest
 */
export const GetSrvKeyspacesRequest = new GetSrvKeyspacesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvKeyspacesResponse$Type extends MessageType<GetSrvKeyspacesResponse> {
    constructor() {
        super("vtadmin.GetSrvKeyspacesResponse", [
            { no: 1, name: "srv_keyspaces", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => GetSrvKeyspacesResponse$ } }
        ]);
    }
    create(value?: PartialMessage<GetSrvKeyspacesResponse>): GetSrvKeyspacesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srvKeyspaces = {};
        if (value !== undefined)
            reflectionMergePartial<GetSrvKeyspacesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvKeyspacesResponse): GetSrvKeyspacesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vtctldata.GetSrvKeyspacesResponse> srv_keyspaces */ 1:
                    this.binaryReadMap1(message.srvKeyspaces, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetSrvKeyspacesResponse["srvKeyspaces"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetSrvKeyspacesResponse["srvKeyspaces"] | undefined, val: GetSrvKeyspacesResponse["srvKeyspaces"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = GetSrvKeyspacesResponse$.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.GetSrvKeyspacesResponse.srv_keyspaces");
            }
        }
        map[key ?? ""] = val ?? GetSrvKeyspacesResponse$.create();
    }
    internalBinaryWrite(message: GetSrvKeyspacesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vtctldata.GetSrvKeyspacesResponse> srv_keyspaces = 1; */
        for (let k of globalThis.Object.keys(message.srvKeyspaces)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            GetSrvKeyspacesResponse$.internalBinaryWrite(message.srvKeyspaces[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvKeyspacesResponse
 */
export const GetSrvKeyspacesResponse = new GetSrvKeyspacesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemaRequest$Type extends MessageType<GetSrvVSchemaRequest> {
    constructor() {
        super("vtadmin.GetSrvVSchemaRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemaRequest>): GetSrvVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.cell = "";
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemaRequest): GetSrvVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string cell */ 2:
                    message.cell = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string cell = 2; */
        if (message.cell !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cell);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvVSchemaRequest
 */
export const GetSrvVSchemaRequest = new GetSrvVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemasRequest$Type extends MessageType<GetSrvVSchemasRequest> {
    constructor() {
        super("vtadmin.GetSrvVSchemasRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemasRequest>): GetSrvVSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemasRequest): GetSrvVSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvVSchemasRequest
 */
export const GetSrvVSchemasRequest = new GetSrvVSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSrvVSchemasResponse$Type extends MessageType<GetSrvVSchemasResponse> {
    constructor() {
        super("vtadmin.GetSrvVSchemasResponse", [
            { no: 1, name: "srv_v_schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SrvVSchema }
        ]);
    }
    create(value?: PartialMessage<GetSrvVSchemasResponse>): GetSrvVSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srvVSchemas = [];
        if (value !== undefined)
            reflectionMergePartial<GetSrvVSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSrvVSchemasResponse): GetSrvVSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.SrvVSchema srv_v_schemas */ 1:
                    message.srvVSchemas.push(SrvVSchema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSrvVSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.SrvVSchema srv_v_schemas = 1; */
        for (let i = 0; i < message.srvVSchemas.length; i++)
            SrvVSchema.internalBinaryWrite(message.srvVSchemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSrvVSchemasResponse
 */
export const GetSrvVSchemasResponse = new GetSrvVSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSchemaTableSizeOptions$Type extends MessageType<GetSchemaTableSizeOptions> {
    constructor() {
        super("vtadmin.GetSchemaTableSizeOptions", [
            { no: 1, name: "aggregate_sizes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "include_non_serving_shards", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetSchemaTableSizeOptions>): GetSchemaTableSizeOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aggregateSizes = false;
        message.includeNonServingShards = false;
        if (value !== undefined)
            reflectionMergePartial<GetSchemaTableSizeOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSchemaTableSizeOptions): GetSchemaTableSizeOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool aggregate_sizes */ 1:
                    message.aggregateSizes = reader.bool();
                    break;
                case /* bool include_non_serving_shards */ 2:
                    message.includeNonServingShards = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSchemaTableSizeOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool aggregate_sizes = 1; */
        if (message.aggregateSizes !== false)
            writer.tag(1, WireType.Varint).bool(message.aggregateSizes);
        /* bool include_non_serving_shards = 2; */
        if (message.includeNonServingShards !== false)
            writer.tag(2, WireType.Varint).bool(message.includeNonServingShards);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetSchemaTableSizeOptions
 */
export const GetSchemaTableSizeOptions = new GetSchemaTableSizeOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletRequest$Type extends MessageType<GetTabletRequest> {
    constructor() {
        super("vtadmin.GetTabletRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTabletRequest>): GetTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletRequest): GetTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetTabletRequest
 */
export const GetTabletRequest = new GetTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletsRequest$Type extends MessageType<GetTabletsRequest> {
    constructor() {
        super("vtadmin.GetTabletsRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTabletsRequest>): GetTabletsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetTabletsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletsRequest): GetTabletsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetTabletsRequest
 */
export const GetTabletsRequest = new GetTabletsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTabletsResponse$Type extends MessageType<GetTabletsResponse> {
    constructor() {
        super("vtadmin.GetTabletsResponse", [
            { no: 1, name: "tablets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tablet }
        ]);
    }
    create(value?: PartialMessage<GetTabletsResponse>): GetTabletsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tablets = [];
        if (value !== undefined)
            reflectionMergePartial<GetTabletsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTabletsResponse): GetTabletsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Tablet tablets */ 1:
                    message.tablets.push(Tablet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTabletsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Tablet tablets = 1; */
        for (let i = 0; i < message.tablets.length; i++)
            Tablet.internalBinaryWrite(message.tablets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetTabletsResponse
 */
export const GetTabletsResponse = new GetTabletsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTopologyPathRequest$Type extends MessageType<GetTopologyPathRequest> {
    constructor() {
        super("vtadmin.GetTopologyPathRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTopologyPathRequest>): GetTopologyPathRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<GetTopologyPathRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTopologyPathRequest): GetTopologyPathRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTopologyPathRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetTopologyPathRequest
 */
export const GetTopologyPathRequest = new GetTopologyPathRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUnresolvedTransactionsRequest$Type extends MessageType<GetUnresolvedTransactionsRequest> {
    constructor() {
        super("vtadmin.GetUnresolvedTransactionsRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "abandon_age", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetUnresolvedTransactionsRequest>): GetUnresolvedTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.abandonAge = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetUnresolvedTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUnresolvedTransactionsRequest): GetUnresolvedTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* int64 abandon_age */ 3:
                    message.abandonAge = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUnresolvedTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* int64 abandon_age = 3; */
        if (message.abandonAge !== 0n)
            writer.tag(3, WireType.Varint).int64(message.abandonAge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetUnresolvedTransactionsRequest
 */
export const GetUnresolvedTransactionsRequest = new GetUnresolvedTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVSchemaRequest$Type extends MessageType<GetVSchemaRequest> {
    constructor() {
        super("vtadmin.GetVSchemaRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVSchemaRequest>): GetVSchemaRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<GetVSchemaRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVSchemaRequest): GetVSchemaRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVSchemaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetVSchemaRequest
 */
export const GetVSchemaRequest = new GetVSchemaRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVSchemasRequest$Type extends MessageType<GetVSchemasRequest> {
    constructor() {
        super("vtadmin.GetVSchemasRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVSchemasRequest>): GetVSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetVSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVSchemasRequest): GetVSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetVSchemasRequest
 */
export const GetVSchemasRequest = new GetVSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVSchemasResponse$Type extends MessageType<GetVSchemasResponse> {
    constructor() {
        super("vtadmin.GetVSchemasResponse", [
            { no: 1, name: "v_schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VSchema }
        ]);
    }
    create(value?: PartialMessage<GetVSchemasResponse>): GetVSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vSchemas = [];
        if (value !== undefined)
            reflectionMergePartial<GetVSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVSchemasResponse): GetVSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.VSchema v_schemas */ 1:
                    message.vSchemas.push(VSchema.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.VSchema v_schemas = 1; */
        for (let i = 0; i < message.vSchemas.length; i++)
            VSchema.internalBinaryWrite(message.vSchemas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetVSchemasResponse
 */
export const GetVSchemasResponse = new GetVSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVtctldsRequest$Type extends MessageType<GetVtctldsRequest> {
    constructor() {
        super("vtadmin.GetVtctldsRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetVtctldsRequest>): GetVtctldsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetVtctldsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVtctldsRequest): GetVtctldsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVtctldsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetVtctldsRequest
 */
export const GetVtctldsRequest = new GetVtctldsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVtctldsResponse$Type extends MessageType<GetVtctldsResponse> {
    constructor() {
        super("vtadmin.GetVtctldsResponse", [
            { no: 1, name: "vtctlds", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Vtctld }
        ]);
    }
    create(value?: PartialMessage<GetVtctldsResponse>): GetVtctldsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vtctlds = [];
        if (value !== undefined)
            reflectionMergePartial<GetVtctldsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVtctldsResponse): GetVtctldsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.Vtctld vtctlds */ 1:
                    message.vtctlds.push(Vtctld.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVtctldsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.Vtctld vtctlds = 1; */
        for (let i = 0; i < message.vtctlds.length; i++)
            Vtctld.internalBinaryWrite(message.vtctlds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetVtctldsResponse
 */
export const GetVtctldsResponse = new GetVtctldsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowRequest$Type extends MessageType<GetWorkflowRequest> {
    constructor() {
        super("vtadmin.GetWorkflowRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "active_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowRequest>): GetWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.name = "";
        message.activeOnly = false;
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowRequest): GetWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* bool active_only */ 4:
                    message.activeOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* bool active_only = 4; */
        if (message.activeOnly !== false)
            writer.tag(4, WireType.Varint).bool(message.activeOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetWorkflowRequest
 */
export const GetWorkflowRequest = new GetWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowStatusRequest$Type extends MessageType<GetWorkflowStatusRequest> {
    constructor() {
        super("vtadmin.GetWorkflowStatusRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowStatusRequest>): GetWorkflowStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowStatusRequest): GetWorkflowStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetWorkflowStatusRequest
 */
export const GetWorkflowStatusRequest = new GetWorkflowStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartWorkflowRequest$Type extends MessageType<StartWorkflowRequest> {
    constructor() {
        super("vtadmin.StartWorkflowRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartWorkflowRequest>): StartWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.workflow = "";
        if (value !== undefined)
            reflectionMergePartial<StartWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartWorkflowRequest): StartWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 3:
                    message.workflow = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 3; */
        if (message.workflow !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.workflow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StartWorkflowRequest
 */
export const StartWorkflowRequest = new StartWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopWorkflowRequest$Type extends MessageType<StopWorkflowRequest> {
    constructor() {
        super("vtadmin.StopWorkflowRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopWorkflowRequest>): StopWorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.workflow = "";
        if (value !== undefined)
            reflectionMergePartial<StopWorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopWorkflowRequest): StopWorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string workflow */ 3:
                    message.workflow = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopWorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string workflow = 3; */
        if (message.workflow !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.workflow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StopWorkflowRequest
 */
export const StopWorkflowRequest = new StopWorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowsRequest$Type extends MessageType<GetWorkflowsRequest> {
    constructor() {
        super("vtadmin.GetWorkflowsRequest", [
            { no: 1, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ignore_keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowsRequest>): GetWorkflowsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        message.activeOnly = false;
        message.keyspaces = [];
        message.ignoreKeyspaces = [];
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowsRequest): GetWorkflowsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cluster_ids */ 1:
                    message.clusterIds.push(reader.string());
                    break;
                case /* bool active_only */ 2:
                    message.activeOnly = reader.bool();
                    break;
                case /* repeated string keyspaces */ 3:
                    message.keyspaces.push(reader.string());
                    break;
                case /* repeated string ignore_keyspaces */ 4:
                    message.ignoreKeyspaces.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkflowsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cluster_ids = 1; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* bool active_only = 2; */
        if (message.activeOnly !== false)
            writer.tag(2, WireType.Varint).bool(message.activeOnly);
        /* repeated string keyspaces = 3; */
        for (let i = 0; i < message.keyspaces.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.keyspaces[i]);
        /* repeated string ignore_keyspaces = 4; */
        for (let i = 0; i < message.ignoreKeyspaces.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.ignoreKeyspaces[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetWorkflowsRequest
 */
export const GetWorkflowsRequest = new GetWorkflowsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkflowsResponse$Type extends MessageType<GetWorkflowsResponse> {
    constructor() {
        super("vtadmin.GetWorkflowsResponse", [
            { no: 1, name: "workflows_by_cluster", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ClusterWorkflows } }
        ]);
    }
    create(value?: PartialMessage<GetWorkflowsResponse>): GetWorkflowsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowsByCluster = {};
        if (value !== undefined)
            reflectionMergePartial<GetWorkflowsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkflowsResponse): GetWorkflowsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, vtadmin.ClusterWorkflows> workflows_by_cluster */ 1:
                    this.binaryReadMap1(message.workflowsByCluster, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetWorkflowsResponse["workflowsByCluster"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetWorkflowsResponse["workflowsByCluster"] | undefined, val: GetWorkflowsResponse["workflowsByCluster"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ClusterWorkflows.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtadmin.GetWorkflowsResponse.workflows_by_cluster");
            }
        }
        map[key ?? ""] = val ?? ClusterWorkflows.create();
    }
    internalBinaryWrite(message: GetWorkflowsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, vtadmin.ClusterWorkflows> workflows_by_cluster = 1; */
        for (let k of globalThis.Object.keys(message.workflowsByCluster)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ClusterWorkflows.internalBinaryWrite(message.workflowsByCluster[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.GetWorkflowsResponse
 */
export const GetWorkflowsResponse = new GetWorkflowsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchSchemaMigrationRequest$Type extends MessageType<LaunchSchemaMigrationRequest> {
    constructor() {
        super("vtadmin.LaunchSchemaMigrationRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => LaunchSchemaMigrationRequest$ }
        ]);
    }
    create(value?: PartialMessage<LaunchSchemaMigrationRequest>): LaunchSchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<LaunchSchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchSchemaMigrationRequest): LaunchSchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.LaunchSchemaMigrationRequest request */ 2:
                    message.request = LaunchSchemaMigrationRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LaunchSchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.LaunchSchemaMigrationRequest request = 2; */
        if (message.request)
            LaunchSchemaMigrationRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.LaunchSchemaMigrationRequest
 */
export const LaunchSchemaMigrationRequest = new LaunchSchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveTablesCreateRequest$Type extends MessageType<MoveTablesCreateRequest> {
    constructor() {
        super("vtadmin.MoveTablesCreateRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => MoveTablesCreateRequest$ }
        ]);
    }
    create(value?: PartialMessage<MoveTablesCreateRequest>): MoveTablesCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<MoveTablesCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveTablesCreateRequest): MoveTablesCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.MoveTablesCreateRequest request */ 2:
                    message.request = MoveTablesCreateRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveTablesCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.MoveTablesCreateRequest request = 2; */
        if (message.request)
            MoveTablesCreateRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.MoveTablesCreateRequest
 */
export const MoveTablesCreateRequest = new MoveTablesCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingTabletRequest$Type extends MessageType<PingTabletRequest> {
    constructor() {
        super("vtadmin.PingTabletRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PingTabletRequest>): PingTabletRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<PingTabletRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingTabletRequest): PingTabletRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingTabletRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.PingTabletRequest
 */
export const PingTabletRequest = new PingTabletRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingTabletResponse$Type extends MessageType<PingTabletResponse> {
    constructor() {
        super("vtadmin.PingTabletResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<PingTabletResponse>): PingTabletResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<PingTabletResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingTabletResponse): PingTabletResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingTabletResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.PingTabletResponse
 */
export const PingTabletResponse = new PingTabletResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedFailoverShardRequest$Type extends MessageType<PlannedFailoverShardRequest> {
    constructor() {
        super("vtadmin.PlannedFailoverShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => PlannedReparentShardRequest }
        ]);
    }
    create(value?: PartialMessage<PlannedFailoverShardRequest>): PlannedFailoverShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<PlannedFailoverShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedFailoverShardRequest): PlannedFailoverShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.PlannedReparentShardRequest options */ 2:
                    message.options = PlannedReparentShardRequest.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedFailoverShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.PlannedReparentShardRequest options = 2; */
        if (message.options)
            PlannedReparentShardRequest.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.PlannedFailoverShardRequest
 */
export const PlannedFailoverShardRequest = new PlannedFailoverShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlannedFailoverShardResponse$Type extends MessageType<PlannedFailoverShardResponse> {
    constructor() {
        super("vtadmin.PlannedFailoverShardResponse", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "promoted_primary", kind: "message", T: () => TabletAlias },
            { no: 5, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<PlannedFailoverShardResponse>): PlannedFailoverShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<PlannedFailoverShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedFailoverShardResponse): PlannedFailoverShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias promoted_primary */ 4:
                    message.promotedPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.promotedPrimary);
                    break;
                case /* repeated logutil.Event events */ 5:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlannedFailoverShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias promoted_primary = 4; */
        if (message.promotedPrimary)
            TabletAlias.internalBinaryWrite(message.promotedPrimary, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 5; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.PlannedFailoverShardResponse
 */
export const PlannedFailoverShardResponse = new PlannedFailoverShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildKeyspaceGraphRequest$Type extends MessageType<RebuildKeyspaceGraphRequest> {
    constructor() {
        super("vtadmin.RebuildKeyspaceGraphRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "allow_partial", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RebuildKeyspaceGraphRequest>): RebuildKeyspaceGraphRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.cells = [];
        message.allowPartial = false;
        if (value !== undefined)
            reflectionMergePartial<RebuildKeyspaceGraphRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildKeyspaceGraphRequest): RebuildKeyspaceGraphRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* repeated string cells */ 3:
                    message.cells.push(reader.string());
                    break;
                case /* bool allow_partial */ 4:
                    message.allowPartial = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildKeyspaceGraphRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* repeated string cells = 3; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cells[i]);
        /* bool allow_partial = 4; */
        if (message.allowPartial !== false)
            writer.tag(4, WireType.Varint).bool(message.allowPartial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RebuildKeyspaceGraphRequest
 */
export const RebuildKeyspaceGraphRequest = new RebuildKeyspaceGraphRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebuildKeyspaceGraphResponse$Type extends MessageType<RebuildKeyspaceGraphResponse> {
    constructor() {
        super("vtadmin.RebuildKeyspaceGraphResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RebuildKeyspaceGraphResponse>): RebuildKeyspaceGraphResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<RebuildKeyspaceGraphResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebuildKeyspaceGraphResponse): RebuildKeyspaceGraphResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebuildKeyspaceGraphResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RebuildKeyspaceGraphResponse
 */
export const RebuildKeyspaceGraphResponse = new RebuildKeyspaceGraphResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateRequest$Type extends MessageType<RefreshStateRequest> {
    constructor() {
        super("vtadmin.RefreshStateRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshStateRequest>): RefreshStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<RefreshStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateRequest): RefreshStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RefreshStateRequest
 */
export const RefreshStateRequest = new RefreshStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshStateResponse$Type extends MessageType<RefreshStateResponse> {
    constructor() {
        super("vtadmin.RefreshStateResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<RefreshStateResponse>): RefreshStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshStateResponse): RefreshStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RefreshStateResponse
 */
export const RefreshStateResponse = new RefreshStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemasRequest$Type extends MessageType<ReloadSchemasRequest> {
    constructor() {
        super("vtadmin.ReloadSchemasRequest", [
            { no: 1, name: "keyspaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace_shards", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TabletAlias },
            { no: 4, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "wait_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "include_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemasRequest>): ReloadSchemasRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaces = [];
        message.keyspaceShards = [];
        message.tablets = [];
        message.clusterIds = [];
        message.concurrency = 0;
        message.waitPosition = "";
        message.includePrimary = false;
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemasRequest): ReloadSchemasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keyspaces */ 1:
                    message.keyspaces.push(reader.string());
                    break;
                case /* repeated string keyspace_shards */ 2:
                    message.keyspaceShards.push(reader.string());
                    break;
                case /* repeated topodata.TabletAlias tablets */ 3:
                    message.tablets.push(TabletAlias.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string cluster_ids */ 4:
                    message.clusterIds.push(reader.string());
                    break;
                case /* int32 concurrency */ 5:
                    message.concurrency = reader.int32();
                    break;
                case /* string wait_position */ 6:
                    message.waitPosition = reader.string();
                    break;
                case /* bool include_primary */ 7:
                    message.includePrimary = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keyspaces = 1; */
        for (let i = 0; i < message.keyspaces.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keyspaces[i]);
        /* repeated string keyspace_shards = 2; */
        for (let i = 0; i < message.keyspaceShards.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.keyspaceShards[i]);
        /* repeated topodata.TabletAlias tablets = 3; */
        for (let i = 0; i < message.tablets.length; i++)
            TabletAlias.internalBinaryWrite(message.tablets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 4; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.clusterIds[i]);
        /* int32 concurrency = 5; */
        if (message.concurrency !== 0)
            writer.tag(5, WireType.Varint).int32(message.concurrency);
        /* string wait_position = 6; */
        if (message.waitPosition !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.waitPosition);
        /* bool include_primary = 7; */
        if (message.includePrimary !== false)
            writer.tag(7, WireType.Varint).bool(message.includePrimary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemasRequest
 */
export const ReloadSchemasRequest = new ReloadSchemasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemasResponse$Type extends MessageType<ReloadSchemasResponse> {
    constructor() {
        super("vtadmin.ReloadSchemasResponse", [
            { no: 1, name: "keyspace_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReloadSchemasResponse_KeyspaceResult },
            { no: 2, name: "shard_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReloadSchemasResponse_ShardResult },
            { no: 3, name: "tablet_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReloadSchemasResponse_TabletResult }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemasResponse>): ReloadSchemasResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaceResults = [];
        message.shardResults = [];
        message.tabletResults = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemasResponse): ReloadSchemasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated vtadmin.ReloadSchemasResponse.KeyspaceResult keyspace_results */ 1:
                    message.keyspaceResults.push(ReloadSchemasResponse_KeyspaceResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vtadmin.ReloadSchemasResponse.ShardResult shard_results */ 2:
                    message.shardResults.push(ReloadSchemasResponse_ShardResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vtadmin.ReloadSchemasResponse.TabletResult tablet_results */ 3:
                    message.tabletResults.push(ReloadSchemasResponse_TabletResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated vtadmin.ReloadSchemasResponse.KeyspaceResult keyspace_results = 1; */
        for (let i = 0; i < message.keyspaceResults.length; i++)
            ReloadSchemasResponse_KeyspaceResult.internalBinaryWrite(message.keyspaceResults[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated vtadmin.ReloadSchemasResponse.ShardResult shard_results = 2; */
        for (let i = 0; i < message.shardResults.length; i++)
            ReloadSchemasResponse_ShardResult.internalBinaryWrite(message.shardResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated vtadmin.ReloadSchemasResponse.TabletResult tablet_results = 3; */
        for (let i = 0; i < message.tabletResults.length; i++)
            ReloadSchemasResponse_TabletResult.internalBinaryWrite(message.tabletResults[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemasResponse
 */
export const ReloadSchemasResponse = new ReloadSchemasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemasResponse_KeyspaceResult$Type extends MessageType<ReloadSchemasResponse_KeyspaceResult> {
    constructor() {
        super("vtadmin.ReloadSchemasResponse.KeyspaceResult", [
            { no: 1, name: "keyspace", kind: "message", T: () => Keyspace },
            { no: 2, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemasResponse_KeyspaceResult>): ReloadSchemasResponse_KeyspaceResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemasResponse_KeyspaceResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemasResponse_KeyspaceResult): ReloadSchemasResponse_KeyspaceResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Keyspace keyspace */ 1:
                    message.keyspace = Keyspace.internalBinaryRead(reader, reader.uint32(), options, message.keyspace);
                    break;
                case /* repeated logutil.Event events */ 2:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemasResponse_KeyspaceResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Keyspace keyspace = 1; */
        if (message.keyspace)
            Keyspace.internalBinaryWrite(message.keyspace, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemasResponse.KeyspaceResult
 */
export const ReloadSchemasResponse_KeyspaceResult = new ReloadSchemasResponse_KeyspaceResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemasResponse_ShardResult$Type extends MessageType<ReloadSchemasResponse_ShardResult> {
    constructor() {
        super("vtadmin.ReloadSchemasResponse.ShardResult", [
            { no: 1, name: "shard", kind: "message", T: () => Shard },
            { no: 2, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemasResponse_ShardResult>): ReloadSchemasResponse_ShardResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemasResponse_ShardResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemasResponse_ShardResult): ReloadSchemasResponse_ShardResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Shard shard */ 1:
                    message.shard = Shard.internalBinaryRead(reader, reader.uint32(), options, message.shard);
                    break;
                case /* repeated logutil.Event events */ 2:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemasResponse_ShardResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Shard shard = 1; */
        if (message.shard)
            Shard.internalBinaryWrite(message.shard, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated logutil.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemasResponse.ShardResult
 */
export const ReloadSchemasResponse_ShardResult = new ReloadSchemasResponse_ShardResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemasResponse_TabletResult$Type extends MessageType<ReloadSchemasResponse_TabletResult> {
    constructor() {
        super("vtadmin.ReloadSchemasResponse.TabletResult", [
            { no: 1, name: "tablet", kind: "message", T: () => Tablet },
            { no: 2, name: "result", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemasResponse_TabletResult>): ReloadSchemasResponse_TabletResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = "";
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemasResponse_TabletResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemasResponse_TabletResult): ReloadSchemasResponse_TabletResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Tablet tablet */ 1:
                    message.tablet = Tablet.internalBinaryRead(reader, reader.uint32(), options, message.tablet);
                    break;
                case /* string result */ 2:
                    message.result = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemasResponse_TabletResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Tablet tablet = 1; */
        if (message.tablet)
            Tablet.internalBinaryWrite(message.tablet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string result = 2; */
        if (message.result !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemasResponse.TabletResult
 */
export const ReloadSchemasResponse_TabletResult = new ReloadSchemasResponse_TabletResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaShardRequest$Type extends MessageType<ReloadSchemaShardRequest> {
    constructor() {
        super("vtadmin.ReloadSchemaShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "wait_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "include_primary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaShardRequest>): ReloadSchemaShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.shard = "";
        message.waitPosition = "";
        message.includePrimary = false;
        message.concurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaShardRequest): ReloadSchemaShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* string wait_position */ 4:
                    message.waitPosition = reader.string();
                    break;
                case /* bool include_primary */ 5:
                    message.includePrimary = reader.bool();
                    break;
                case /* int32 concurrency */ 6:
                    message.concurrency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* string wait_position = 4; */
        if (message.waitPosition !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.waitPosition);
        /* bool include_primary = 5; */
        if (message.includePrimary !== false)
            writer.tag(5, WireType.Varint).bool(message.includePrimary);
        /* int32 concurrency = 6; */
        if (message.concurrency !== 0)
            writer.tag(6, WireType.Varint).int32(message.concurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemaShardRequest
 */
export const ReloadSchemaShardRequest = new ReloadSchemaShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadSchemaShardResponse$Type extends MessageType<ReloadSchemaShardResponse> {
    constructor() {
        super("vtadmin.ReloadSchemaShardResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<ReloadSchemaShardResponse>): ReloadSchemaShardResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<ReloadSchemaShardResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadSchemaShardResponse): ReloadSchemaShardResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logutil.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReloadSchemaShardResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logutil.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ReloadSchemaShardResponse
 */
export const ReloadSchemaShardResponse = new ReloadSchemaShardResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshTabletReplicationSourceRequest$Type extends MessageType<RefreshTabletReplicationSourceRequest> {
    constructor() {
        super("vtadmin.RefreshTabletReplicationSourceRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RefreshTabletReplicationSourceRequest>): RefreshTabletReplicationSourceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<RefreshTabletReplicationSourceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshTabletReplicationSourceRequest): RefreshTabletReplicationSourceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshTabletReplicationSourceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RefreshTabletReplicationSourceRequest
 */
export const RefreshTabletReplicationSourceRequest = new RefreshTabletReplicationSourceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshTabletReplicationSourceResponse$Type extends MessageType<RefreshTabletReplicationSourceResponse> {
    constructor() {
        super("vtadmin.RefreshTabletReplicationSourceResponse", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "primary", kind: "message", T: () => TabletAlias },
            { no: 4, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<RefreshTabletReplicationSourceResponse>): RefreshTabletReplicationSourceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<RefreshTabletReplicationSourceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshTabletReplicationSourceResponse): RefreshTabletReplicationSourceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias primary */ 3:
                    message.primary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.primary);
                    break;
                case /* vtadmin.Cluster cluster */ 4:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshTabletReplicationSourceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias primary = 3; */
        if (message.primary)
            TabletAlias.internalBinaryWrite(message.primary, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* vtadmin.Cluster cluster = 4; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RefreshTabletReplicationSourceResponse
 */
export const RefreshTabletReplicationSourceResponse = new RefreshTabletReplicationSourceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveKeyspaceCellRequest$Type extends MessageType<RemoveKeyspaceCellRequest> {
    constructor() {
        super("vtadmin.RemoveKeyspaceCellRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveKeyspaceCellRequest>): RemoveKeyspaceCellRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.cell = "";
        message.force = false;
        message.recursive = false;
        if (value !== undefined)
            reflectionMergePartial<RemoveKeyspaceCellRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveKeyspaceCellRequest): RemoveKeyspaceCellRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string cell */ 3:
                    message.cell = reader.string();
                    break;
                case /* bool force */ 4:
                    message.force = reader.bool();
                    break;
                case /* bool recursive */ 5:
                    message.recursive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveKeyspaceCellRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string cell = 3; */
        if (message.cell !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cell);
        /* bool force = 4; */
        if (message.force !== false)
            writer.tag(4, WireType.Varint).bool(message.force);
        /* bool recursive = 5; */
        if (message.recursive !== false)
            writer.tag(5, WireType.Varint).bool(message.recursive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RemoveKeyspaceCellRequest
 */
export const RemoveKeyspaceCellRequest = new RemoveKeyspaceCellRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveKeyspaceCellResponse$Type extends MessageType<RemoveKeyspaceCellResponse> {
    constructor() {
        super("vtadmin.RemoveKeyspaceCellResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveKeyspaceCellResponse>): RemoveKeyspaceCellResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveKeyspaceCellResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveKeyspaceCellResponse): RemoveKeyspaceCellResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveKeyspaceCellResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RemoveKeyspaceCellResponse
 */
export const RemoveKeyspaceCellResponse = new RemoveKeyspaceCellResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrySchemaMigrationRequest$Type extends MessageType<RetrySchemaMigrationRequest> {
    constructor() {
        super("vtadmin.RetrySchemaMigrationRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => RetrySchemaMigrationRequest$ }
        ]);
    }
    create(value?: PartialMessage<RetrySchemaMigrationRequest>): RetrySchemaMigrationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        if (value !== undefined)
            reflectionMergePartial<RetrySchemaMigrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrySchemaMigrationRequest): RetrySchemaMigrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* vtctldata.RetrySchemaMigrationRequest request */ 2:
                    message.request = RetrySchemaMigrationRequest$.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrySchemaMigrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* vtctldata.RetrySchemaMigrationRequest request = 2; */
        if (message.request)
            RetrySchemaMigrationRequest$.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RetrySchemaMigrationRequest
 */
export const RetrySchemaMigrationRequest = new RetrySchemaMigrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunHealthCheckRequest$Type extends MessageType<RunHealthCheckRequest> {
    constructor() {
        super("vtadmin.RunHealthCheckRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunHealthCheckRequest>): RunHealthCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<RunHealthCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunHealthCheckRequest): RunHealthCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunHealthCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RunHealthCheckRequest
 */
export const RunHealthCheckRequest = new RunHealthCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunHealthCheckResponse$Type extends MessageType<RunHealthCheckResponse> {
    constructor() {
        super("vtadmin.RunHealthCheckResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<RunHealthCheckResponse>): RunHealthCheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<RunHealthCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunHealthCheckResponse): RunHealthCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunHealthCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.RunHealthCheckResponse
 */
export const RunHealthCheckResponse = new RunHealthCheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadOnlyRequest$Type extends MessageType<SetReadOnlyRequest> {
    constructor() {
        super("vtadmin.SetReadOnlyRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadOnlyRequest>): SetReadOnlyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<SetReadOnlyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadOnlyRequest): SetReadOnlyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadOnlyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SetReadOnlyRequest
 */
export const SetReadOnlyRequest = new SetReadOnlyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadOnlyResponse$Type extends MessageType<SetReadOnlyResponse> {
    constructor() {
        super("vtadmin.SetReadOnlyResponse", []);
    }
    create(value?: PartialMessage<SetReadOnlyResponse>): SetReadOnlyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetReadOnlyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadOnlyResponse): SetReadOnlyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadOnlyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SetReadOnlyResponse
 */
export const SetReadOnlyResponse = new SetReadOnlyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadWriteRequest$Type extends MessageType<SetReadWriteRequest> {
    constructor() {
        super("vtadmin.SetReadWriteRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetReadWriteRequest>): SetReadWriteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<SetReadWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadWriteRequest): SetReadWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SetReadWriteRequest
 */
export const SetReadWriteRequest = new SetReadWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReadWriteResponse$Type extends MessageType<SetReadWriteResponse> {
    constructor() {
        super("vtadmin.SetReadWriteResponse", []);
    }
    create(value?: PartialMessage<SetReadWriteResponse>): SetReadWriteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetReadWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReadWriteResponse): SetReadWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReadWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.SetReadWriteResponse
 */
export const SetReadWriteResponse = new SetReadWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartReplicationRequest$Type extends MessageType<StartReplicationRequest> {
    constructor() {
        super("vtadmin.StartReplicationRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartReplicationRequest>): StartReplicationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<StartReplicationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartReplicationRequest): StartReplicationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartReplicationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StartReplicationRequest
 */
export const StartReplicationRequest = new StartReplicationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartReplicationResponse$Type extends MessageType<StartReplicationResponse> {
    constructor() {
        super("vtadmin.StartReplicationResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<StartReplicationResponse>): StartReplicationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<StartReplicationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartReplicationResponse): StartReplicationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartReplicationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StartReplicationResponse
 */
export const StartReplicationResponse = new StartReplicationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopReplicationRequest$Type extends MessageType<StopReplicationRequest> {
    constructor() {
        super("vtadmin.StopReplicationRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StopReplicationRequest>): StopReplicationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<StopReplicationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopReplicationRequest): StopReplicationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopReplicationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StopReplicationRequest
 */
export const StopReplicationRequest = new StopReplicationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopReplicationResponse$Type extends MessageType<StopReplicationResponse> {
    constructor() {
        super("vtadmin.StopReplicationResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Cluster }
        ]);
    }
    create(value?: PartialMessage<StopReplicationResponse>): StopReplicationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<StopReplicationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopReplicationResponse): StopReplicationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* vtadmin.Cluster cluster */ 2:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopReplicationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* vtadmin.Cluster cluster = 2; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.StopReplicationResponse
 */
export const StopReplicationResponse = new StopReplicationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletExternallyPromotedRequest$Type extends MessageType<TabletExternallyPromotedRequest> {
    constructor() {
        super("vtadmin.TabletExternallyPromotedRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TabletExternallyPromotedRequest>): TabletExternallyPromotedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<TabletExternallyPromotedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletExternallyPromotedRequest): TabletExternallyPromotedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletExternallyPromotedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.TabletExternallyPromotedRequest
 */
export const TabletExternallyPromotedRequest = new TabletExternallyPromotedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletExternallyPromotedResponse$Type extends MessageType<TabletExternallyPromotedResponse> {
    constructor() {
        super("vtadmin.TabletExternallyPromotedResponse", [
            { no: 1, name: "cluster", kind: "message", T: () => Cluster },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "new_primary", kind: "message", T: () => TabletAlias },
            { no: 5, name: "old_primary", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<TabletExternallyPromotedResponse>): TabletExternallyPromotedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<TabletExternallyPromotedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletExternallyPromotedResponse): TabletExternallyPromotedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtadmin.Cluster cluster */ 1:
                    message.cluster = Cluster.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias new_primary */ 4:
                    message.newPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.newPrimary);
                    break;
                case /* topodata.TabletAlias old_primary */ 5:
                    message.oldPrimary = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.oldPrimary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletExternallyPromotedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtadmin.Cluster cluster = 1; */
        if (message.cluster)
            Cluster.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias new_primary = 4; */
        if (message.newPrimary)
            TabletAlias.internalBinaryWrite(message.newPrimary, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletAlias old_primary = 5; */
        if (message.oldPrimary)
            TabletAlias.internalBinaryWrite(message.oldPrimary, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.TabletExternallyPromotedResponse
 */
export const TabletExternallyPromotedResponse = new TabletExternallyPromotedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletExternallyReparentedRequest$Type extends MessageType<TabletExternallyReparentedRequest> {
    constructor() {
        super("vtadmin.TabletExternallyReparentedRequest", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "cluster_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TabletExternallyReparentedRequest>): TabletExternallyReparentedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterIds = [];
        if (value !== undefined)
            reflectionMergePartial<TabletExternallyReparentedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletExternallyReparentedRequest): TabletExternallyReparentedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* repeated string cluster_ids */ 2:
                    message.clusterIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletExternallyReparentedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string cluster_ids = 2; */
        for (let i = 0; i < message.clusterIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.TabletExternallyReparentedRequest
 */
export const TabletExternallyReparentedRequest = new TabletExternallyReparentedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateRequest$Type extends MessageType<ValidateRequest> {
    constructor() {
        super("vtadmin.ValidateRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateRequest>): ValidateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateRequest): ValidateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* bool ping_tablets */ 2:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* bool ping_tablets = 2; */
        if (message.pingTablets !== false)
            writer.tag(2, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateRequest
 */
export const ValidateRequest = new ValidateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyspaceRequest$Type extends MessageType<ValidateKeyspaceRequest> {
    constructor() {
        super("vtadmin.ValidateKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyspaceRequest>): ValidateKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyspaceRequest): ValidateKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* bool ping_tablets */ 3:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* bool ping_tablets = 3; */
        if (message.pingTablets !== false)
            writer.tag(3, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateKeyspaceRequest
 */
export const ValidateKeyspaceRequest = new ValidateKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateSchemaKeyspaceRequest$Type extends MessageType<ValidateSchemaKeyspaceRequest> {
    constructor() {
        super("vtadmin.ValidateSchemaKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateSchemaKeyspaceRequest>): ValidateSchemaKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateSchemaKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateSchemaKeyspaceRequest): ValidateSchemaKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateSchemaKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateSchemaKeyspaceRequest
 */
export const ValidateSchemaKeyspaceRequest = new ValidateSchemaKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateShardRequest$Type extends MessageType<ValidateShardRequest> {
    constructor() {
        super("vtadmin.ValidateShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ping_tablets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateShardRequest>): ValidateShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.shard = "";
        message.pingTablets = false;
        if (value !== undefined)
            reflectionMergePartial<ValidateShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateShardRequest): ValidateShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* bool ping_tablets */ 4:
                    message.pingTablets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* bool ping_tablets = 4; */
        if (message.pingTablets !== false)
            writer.tag(4, WireType.Varint).bool(message.pingTablets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateShardRequest
 */
export const ValidateShardRequest = new ValidateShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionKeyspaceRequest$Type extends MessageType<ValidateVersionKeyspaceRequest> {
    constructor() {
        super("vtadmin.ValidateVersionKeyspaceRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionKeyspaceRequest>): ValidateVersionKeyspaceRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionKeyspaceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionKeyspaceRequest): ValidateVersionKeyspaceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVersionKeyspaceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateVersionKeyspaceRequest
 */
export const ValidateVersionKeyspaceRequest = new ValidateVersionKeyspaceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateVersionShardRequest$Type extends MessageType<ValidateVersionShardRequest> {
    constructor() {
        super("vtadmin.ValidateVersionShardRequest", [
            { no: 1, name: "cluster_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateVersionShardRequest>): ValidateVersionShardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterId = "";
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<ValidateVersionShardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateVersionShardRequest): ValidateVersionShardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_id */ 1:
                    message.clusterId = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateVersionShardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_id = 1; */
        if (message.clusterId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterId);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.ValidateVersionShardRequest
 */
export const ValidateVersionShardRequest = new ValidateVersionShardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VTExplainRequest$Type extends MessageType<VTExplainRequest> {
    constructor() {
        super("vtadmin.VTExplainRequest", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sql", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VTExplainRequest>): VTExplainRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.keyspace = "";
        message.sql = "";
        if (value !== undefined)
            reflectionMergePartial<VTExplainRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VTExplainRequest): VTExplainRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string sql */ 3:
                    message.sql = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VTExplainRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string sql = 3; */
        if (message.sql !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sql);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.VTExplainRequest
 */
export const VTExplainRequest = new VTExplainRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VTExplainResponse$Type extends MessageType<VTExplainResponse> {
    constructor() {
        super("vtadmin.VTExplainResponse", [
            { no: 1, name: "response", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VTExplainResponse>): VTExplainResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = "";
        if (value !== undefined)
            reflectionMergePartial<VTExplainResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VTExplainResponse): VTExplainResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string response */ 1:
                    message.response = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VTExplainResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string response = 1; */
        if (message.response !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.response);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtadmin.VTExplainResponse
 */
export const VTExplainResponse = new VTExplainResponse$Type();
/**
 * @generated ServiceType for protobuf service vtadmin.VTAdmin
 */
export const VTAdmin = new ServiceType("vtadmin.VTAdmin", [
    { name: "ApplySchema", options: {}, I: ApplySchemaRequest, O: ApplySchemaResponse },
    { name: "CancelSchemaMigration", options: {}, I: CancelSchemaMigrationRequest, O: CancelSchemaMigrationResponse },
    { name: "CleanupSchemaMigration", options: {}, I: CleanupSchemaMigrationRequest, O: CleanupSchemaMigrationResponse },
    { name: "CompleteSchemaMigration", options: {}, I: CompleteSchemaMigrationRequest, O: CompleteSchemaMigrationResponse },
    { name: "ConcludeTransaction", options: {}, I: ConcludeTransactionRequest, O: ConcludeTransactionResponse },
    { name: "CreateKeyspace", options: {}, I: CreateKeyspaceRequest, O: CreateKeyspaceResponse },
    { name: "CreateShard", options: {}, I: CreateShardRequest, O: CreateShardResponse },
    { name: "DeleteKeyspace", options: {}, I: DeleteKeyspaceRequest, O: DeleteKeyspaceResponse },
    { name: "DeleteShards", options: {}, I: DeleteShardsRequest, O: DeleteShardsResponse },
    { name: "DeleteTablet", options: {}, I: DeleteTabletRequest, O: DeleteTabletResponse },
    { name: "EmergencyFailoverShard", options: {}, I: EmergencyFailoverShardRequest, O: EmergencyFailoverShardResponse },
    { name: "FindSchema", options: {}, I: FindSchemaRequest, O: Schema },
    { name: "GetBackups", options: {}, I: GetBackupsRequest, O: GetBackupsResponse },
    { name: "GetCellInfos", options: {}, I: GetCellInfosRequest, O: GetCellInfosResponse },
    { name: "GetCellsAliases", options: {}, I: GetCellsAliasesRequest, O: GetCellsAliasesResponse },
    { name: "GetClusters", options: {}, I: GetClustersRequest, O: GetClustersResponse },
    { name: "GetFullStatus", options: {}, I: GetFullStatusRequest, O: GetFullStatusResponse },
    { name: "GetGates", options: {}, I: GetGatesRequest, O: GetGatesResponse },
    { name: "GetKeyspace", options: {}, I: GetKeyspaceRequest, O: Keyspace },
    { name: "GetKeyspaces", options: {}, I: GetKeyspacesRequest, O: GetKeyspacesResponse },
    { name: "GetSchema", options: {}, I: GetSchemaRequest, O: Schema },
    { name: "GetSchemas", options: {}, I: GetSchemasRequest, O: GetSchemasResponse },
    { name: "GetSchemaMigrations", options: {}, I: GetSchemaMigrationsRequest, O: GetSchemaMigrationsResponse },
    { name: "GetShardReplicationPositions", options: {}, I: GetShardReplicationPositionsRequest, O: GetShardReplicationPositionsResponse },
    { name: "GetSrvKeyspace", options: {}, I: GetSrvKeyspaceRequest, O: GetSrvKeyspacesResponse$ },
    { name: "GetSrvKeyspaces", options: {}, I: GetSrvKeyspacesRequest, O: GetSrvKeyspacesResponse },
    { name: "GetSrvVSchema", options: {}, I: GetSrvVSchemaRequest, O: SrvVSchema },
    { name: "GetSrvVSchemas", options: {}, I: GetSrvVSchemasRequest, O: GetSrvVSchemasResponse },
    { name: "GetTablet", options: {}, I: GetTabletRequest, O: Tablet },
    { name: "GetTablets", options: {}, I: GetTabletsRequest, O: GetTabletsResponse },
    { name: "GetTopologyPath", options: {}, I: GetTopologyPathRequest, O: GetTopologyPathResponse },
    { name: "GetUnresolvedTransactions", options: {}, I: GetUnresolvedTransactionsRequest, O: GetUnresolvedTransactionsResponse },
    { name: "GetVSchema", options: {}, I: GetVSchemaRequest, O: VSchema },
    { name: "GetVSchemas", options: {}, I: GetVSchemasRequest, O: GetVSchemasResponse },
    { name: "GetVtctlds", options: {}, I: GetVtctldsRequest, O: GetVtctldsResponse },
    { name: "GetWorkflow", options: {}, I: GetWorkflowRequest, O: Workflow },
    { name: "GetWorkflows", options: {}, I: GetWorkflowsRequest, O: GetWorkflowsResponse },
    { name: "GetWorkflowStatus", options: {}, I: GetWorkflowStatusRequest, O: WorkflowStatusResponse },
    { name: "StartWorkflow", options: {}, I: StartWorkflowRequest, O: WorkflowUpdateResponse },
    { name: "StopWorkflow", options: {}, I: StopWorkflowRequest, O: WorkflowUpdateResponse },
    { name: "LaunchSchemaMigration", options: {}, I: LaunchSchemaMigrationRequest, O: LaunchSchemaMigrationResponse },
    { name: "MoveTablesCreate", options: {}, I: MoveTablesCreateRequest, O: WorkflowStatusResponse },
    { name: "PingTablet", options: {}, I: PingTabletRequest, O: PingTabletResponse },
    { name: "PlannedFailoverShard", options: {}, I: PlannedFailoverShardRequest, O: PlannedFailoverShardResponse },
    { name: "RebuildKeyspaceGraph", options: {}, I: RebuildKeyspaceGraphRequest, O: RebuildKeyspaceGraphResponse },
    { name: "RefreshState", options: {}, I: RefreshStateRequest, O: RefreshStateResponse },
    { name: "RefreshTabletReplicationSource", options: {}, I: RefreshTabletReplicationSourceRequest, O: RefreshTabletReplicationSourceResponse },
    { name: "ReloadSchemas", options: {}, I: ReloadSchemasRequest, O: ReloadSchemasResponse },
    { name: "ReloadSchemaShard", options: {}, I: ReloadSchemaShardRequest, O: ReloadSchemaShardResponse },
    { name: "RemoveKeyspaceCell", options: {}, I: RemoveKeyspaceCellRequest, O: RemoveKeyspaceCellResponse },
    { name: "RetrySchemaMigration", options: {}, I: RetrySchemaMigrationRequest, O: RetrySchemaMigrationResponse },
    { name: "RunHealthCheck", options: {}, I: RunHealthCheckRequest, O: RunHealthCheckResponse },
    { name: "SetReadOnly", options: {}, I: SetReadOnlyRequest, O: SetReadOnlyResponse },
    { name: "SetReadWrite", options: {}, I: SetReadWriteRequest, O: SetReadWriteResponse },
    { name: "StartReplication", options: {}, I: StartReplicationRequest, O: StartReplicationResponse },
    { name: "StopReplication", options: {}, I: StopReplicationRequest, O: StopReplicationResponse },
    { name: "TabletExternallyPromoted", options: {}, I: TabletExternallyPromotedRequest, O: TabletExternallyPromotedResponse },
    { name: "Validate", options: {}, I: ValidateRequest, O: ValidateResponse },
    { name: "ValidateKeyspace", options: {}, I: ValidateKeyspaceRequest, O: ValidateKeyspaceResponse },
    { name: "ValidateSchemaKeyspace", options: {}, I: ValidateSchemaKeyspaceRequest, O: ValidateSchemaKeyspaceResponse },
    { name: "ValidateShard", options: {}, I: ValidateShardRequest, O: ValidateShardResponse },
    { name: "ValidateVersionKeyspace", options: {}, I: ValidateVersionKeyspaceRequest, O: ValidateVersionKeyspaceResponse },
    { name: "ValidateVersionShard", options: {}, I: ValidateVersionShardRequest, O: ValidateVersionShardResponse },
    { name: "VTExplain", options: {}, I: VTExplainRequest, O: VTExplainResponse }
]);
