// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "mysqlctl.proto" (package "mysqlctl", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains the service definition for making management API
// calls to mysqlctld.
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TabletAlias } from "./topodata";
import { RPCError } from "./vtrpc";
import { Time } from "./vttime";
import { Duration } from "./vttime";
/**
 * @generated from protobuf message mysqlctl.StartRequest
 */
export interface StartRequest {
    /**
     * @generated from protobuf field: repeated string mysqld_args = 1;
     */
    mysqldArgs: string[];
}
/**
 * @generated from protobuf message mysqlctl.StartResponse
 */
export interface StartResponse {
}
/**
 * @generated from protobuf message mysqlctl.ShutdownRequest
 */
export interface ShutdownRequest {
    /**
     * @generated from protobuf field: bool wait_for_mysqld = 1;
     */
    waitForMysqld: boolean;
    /**
     * @generated from protobuf field: vttime.Duration mysql_shutdown_timeout = 2;
     */
    mysqlShutdownTimeout?: Duration;
}
/**
 * @generated from protobuf message mysqlctl.ShutdownResponse
 */
export interface ShutdownResponse {
}
/**
 * @generated from protobuf message mysqlctl.RunMysqlUpgradeRequest
 */
export interface RunMysqlUpgradeRequest {
}
/**
 * @generated from protobuf message mysqlctl.RunMysqlUpgradeResponse
 */
export interface RunMysqlUpgradeResponse {
}
/**
 * @generated from protobuf message mysqlctl.ApplyBinlogFileRequest
 */
export interface ApplyBinlogFileRequest {
    /**
     * @generated from protobuf field: string binlog_file_name = 1;
     */
    binlogFileName: string;
    /**
     * @generated from protobuf field: string binlog_restore_position = 2;
     */
    binlogRestorePosition: string;
    /**
     * @generated from protobuf field: vttime.Time binlog_restore_datetime = 3;
     */
    binlogRestoreDatetime?: Time;
}
/**
 * @generated from protobuf message mysqlctl.ApplyBinlogFileResponse
 */
export interface ApplyBinlogFileResponse {
}
/**
 * @generated from protobuf message mysqlctl.ReadBinlogFilesTimestampsRequest
 */
export interface ReadBinlogFilesTimestampsRequest {
    /**
     * @generated from protobuf field: repeated string binlog_file_names = 1;
     */
    binlogFileNames: string[];
}
/**
 * @generated from protobuf message mysqlctl.ReadBinlogFilesTimestampsResponse
 */
export interface ReadBinlogFilesTimestampsResponse {
    /**
     * FirstTimestamp is the timestamp of the first found transaction searching in order of given binlog files
     *
     * @generated from protobuf field: vttime.Time first_timestamp = 1;
     */
    firstTimestamp?: Time;
    /**
     * FirstTimestampBinlog is the name of the binary log in which the first timestamp is found
     *
     * @generated from protobuf field: string first_timestamp_binlog = 2;
     */
    firstTimestampBinlog: string;
    /**
     * LastTimestamp is the timestamp of the last found transaction in given binlog files
     *
     * @generated from protobuf field: vttime.Time last_timestamp = 3;
     */
    lastTimestamp?: Time;
    /**
     * LastTimestampBinlog is the name of the binary log in which the last timestamp is found
     *
     * @generated from protobuf field: string last_timestamp_binlog = 4;
     */
    lastTimestampBinlog: string;
}
/**
 * @generated from protobuf message mysqlctl.ReinitConfigRequest
 */
export interface ReinitConfigRequest {
}
/**
 * @generated from protobuf message mysqlctl.ReinitConfigResponse
 */
export interface ReinitConfigResponse {
}
/**
 * @generated from protobuf message mysqlctl.RefreshConfigRequest
 */
export interface RefreshConfigRequest {
}
/**
 * @generated from protobuf message mysqlctl.RefreshConfigResponse
 */
export interface RefreshConfigResponse {
}
/**
 * @generated from protobuf message mysqlctl.VersionStringRequest
 */
export interface VersionStringRequest {
}
/**
 * @generated from protobuf message mysqlctl.VersionStringResponse
 */
export interface VersionStringResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * @generated from protobuf message mysqlctl.HostMetricsRequest
 */
export interface HostMetricsRequest {
}
/**
 * @generated from protobuf message mysqlctl.HostMetricsResponse
 */
export interface HostMetricsResponse {
    /**
     * Metrics is a map (metric name -> metric value/error) so that the client has as much
     * information as possible about all the checked metrics.
     *
     * @generated from protobuf field: map<string, mysqlctl.HostMetricsResponse.Metric> metrics = 1;
     */
    metrics: {
        [key: string]: HostMetricsResponse_Metric;
    };
}
/**
 * @generated from protobuf message mysqlctl.HostMetricsResponse.Metric
 */
export interface HostMetricsResponse_Metric {
    /**
     * Name of the metric
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Value is the metric value
     *
     * @generated from protobuf field: double value = 2;
     */
    value: number;
    /**
     * Error indicates an error retrieving the value
     *
     * @generated from protobuf field: vtrpc.RPCError error = 3;
     */
    error?: RPCError;
}
/**
 * BackupInfo is the read-only attributes of a mysqlctl/backupstorage.BackupHandle.
 *
 * @generated from protobuf message mysqlctl.BackupInfo
 */
export interface BackupInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string directory = 2;
     */
    directory: string;
    /**
     * @generated from protobuf field: string keyspace = 3;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 4;
     */
    shard: string;
    // The following fields will be extracted from the .Name field. If an error
    // occurs during extraction/parsing, these fields may not be set, but
    // VtctldServer.GetBackups will not fail.

    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;
    /**
     * @generated from protobuf field: vttime.Time time = 6;
     */
    time?: Time;
    // The following fields are may or may not be currently set. Work is inflight
    // to fully-support these fields in all backupengine/storage implementations.
    // See https://github.com/vitessio/vitess/issues/8332.

    /**
     * Engine is the name of the backupengine implementation used to create
     * this backup.
     *
     * @generated from protobuf field: string engine = 7;
     */
    engine: string;
    /**
     * @generated from protobuf field: mysqlctl.BackupInfo.Status status = 8;
     */
    status: BackupInfo_Status;
}
/**
 * Status is an enum representing the possible status of a backup.
 *
 * @generated from protobuf enum mysqlctl.BackupInfo.Status
 */
export enum BackupInfo_Status {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: INCOMPLETE = 1;
     */
    INCOMPLETE = 1,
    /**
     * @generated from protobuf enum value: COMPLETE = 2;
     */
    COMPLETE = 2,
    /**
     * A backup status of INVALID should be set if the backup is complete
     * but unusable in some way (partial upload, corrupt file, etc).
     *
     * @generated from protobuf enum value: INVALID = 3;
     */
    INVALID = 3,
    /**
     * A backup status of VALID should be set if the backup is both
     * complete and usuable.
     *
     * @generated from protobuf enum value: VALID = 4;
     */
    VALID = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class StartRequest$Type extends MessageType<StartRequest> {
    constructor() {
        super("mysqlctl.StartRequest", [
            { no: 1, name: "mysqld_args", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartRequest>): StartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mysqldArgs = [];
        if (value !== undefined)
            reflectionMergePartial<StartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartRequest): StartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string mysqld_args */ 1:
                    message.mysqldArgs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string mysqld_args = 1; */
        for (let i = 0; i < message.mysqldArgs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.mysqldArgs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.StartRequest
 */
export const StartRequest = new StartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartResponse$Type extends MessageType<StartResponse> {
    constructor() {
        super("mysqlctl.StartResponse", []);
    }
    create(value?: PartialMessage<StartResponse>): StartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartResponse): StartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.StartResponse
 */
export const StartResponse = new StartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownRequest$Type extends MessageType<ShutdownRequest> {
    constructor() {
        super("mysqlctl.ShutdownRequest", [
            { no: 1, name: "wait_for_mysqld", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "mysql_shutdown_timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<ShutdownRequest>): ShutdownRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.waitForMysqld = false;
        if (value !== undefined)
            reflectionMergePartial<ShutdownRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShutdownRequest): ShutdownRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool wait_for_mysqld */ 1:
                    message.waitForMysqld = reader.bool();
                    break;
                case /* vttime.Duration mysql_shutdown_timeout */ 2:
                    message.mysqlShutdownTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.mysqlShutdownTimeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShutdownRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool wait_for_mysqld = 1; */
        if (message.waitForMysqld !== false)
            writer.tag(1, WireType.Varint).bool(message.waitForMysqld);
        /* vttime.Duration mysql_shutdown_timeout = 2; */
        if (message.mysqlShutdownTimeout)
            Duration.internalBinaryWrite(message.mysqlShutdownTimeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ShutdownRequest
 */
export const ShutdownRequest = new ShutdownRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownResponse$Type extends MessageType<ShutdownResponse> {
    constructor() {
        super("mysqlctl.ShutdownResponse", []);
    }
    create(value?: PartialMessage<ShutdownResponse>): ShutdownResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShutdownResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShutdownResponse): ShutdownResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShutdownResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ShutdownResponse
 */
export const ShutdownResponse = new ShutdownResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunMysqlUpgradeRequest$Type extends MessageType<RunMysqlUpgradeRequest> {
    constructor() {
        super("mysqlctl.RunMysqlUpgradeRequest", []);
    }
    create(value?: PartialMessage<RunMysqlUpgradeRequest>): RunMysqlUpgradeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunMysqlUpgradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunMysqlUpgradeRequest): RunMysqlUpgradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunMysqlUpgradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.RunMysqlUpgradeRequest
 */
export const RunMysqlUpgradeRequest = new RunMysqlUpgradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunMysqlUpgradeResponse$Type extends MessageType<RunMysqlUpgradeResponse> {
    constructor() {
        super("mysqlctl.RunMysqlUpgradeResponse", []);
    }
    create(value?: PartialMessage<RunMysqlUpgradeResponse>): RunMysqlUpgradeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RunMysqlUpgradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunMysqlUpgradeResponse): RunMysqlUpgradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunMysqlUpgradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.RunMysqlUpgradeResponse
 */
export const RunMysqlUpgradeResponse = new RunMysqlUpgradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyBinlogFileRequest$Type extends MessageType<ApplyBinlogFileRequest> {
    constructor() {
        super("mysqlctl.ApplyBinlogFileRequest", [
            { no: 1, name: "binlog_file_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "binlog_restore_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "binlog_restore_datetime", kind: "message", T: () => Time }
        ]);
    }
    create(value?: PartialMessage<ApplyBinlogFileRequest>): ApplyBinlogFileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.binlogFileName = "";
        message.binlogRestorePosition = "";
        if (value !== undefined)
            reflectionMergePartial<ApplyBinlogFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyBinlogFileRequest): ApplyBinlogFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string binlog_file_name */ 1:
                    message.binlogFileName = reader.string();
                    break;
                case /* string binlog_restore_position */ 2:
                    message.binlogRestorePosition = reader.string();
                    break;
                case /* vttime.Time binlog_restore_datetime */ 3:
                    message.binlogRestoreDatetime = Time.internalBinaryRead(reader, reader.uint32(), options, message.binlogRestoreDatetime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyBinlogFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string binlog_file_name = 1; */
        if (message.binlogFileName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.binlogFileName);
        /* string binlog_restore_position = 2; */
        if (message.binlogRestorePosition !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.binlogRestorePosition);
        /* vttime.Time binlog_restore_datetime = 3; */
        if (message.binlogRestoreDatetime)
            Time.internalBinaryWrite(message.binlogRestoreDatetime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ApplyBinlogFileRequest
 */
export const ApplyBinlogFileRequest = new ApplyBinlogFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyBinlogFileResponse$Type extends MessageType<ApplyBinlogFileResponse> {
    constructor() {
        super("mysqlctl.ApplyBinlogFileResponse", []);
    }
    create(value?: PartialMessage<ApplyBinlogFileResponse>): ApplyBinlogFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ApplyBinlogFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyBinlogFileResponse): ApplyBinlogFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyBinlogFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ApplyBinlogFileResponse
 */
export const ApplyBinlogFileResponse = new ApplyBinlogFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadBinlogFilesTimestampsRequest$Type extends MessageType<ReadBinlogFilesTimestampsRequest> {
    constructor() {
        super("mysqlctl.ReadBinlogFilesTimestampsRequest", [
            { no: 1, name: "binlog_file_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadBinlogFilesTimestampsRequest>): ReadBinlogFilesTimestampsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.binlogFileNames = [];
        if (value !== undefined)
            reflectionMergePartial<ReadBinlogFilesTimestampsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadBinlogFilesTimestampsRequest): ReadBinlogFilesTimestampsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string binlog_file_names */ 1:
                    message.binlogFileNames.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadBinlogFilesTimestampsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string binlog_file_names = 1; */
        for (let i = 0; i < message.binlogFileNames.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.binlogFileNames[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ReadBinlogFilesTimestampsRequest
 */
export const ReadBinlogFilesTimestampsRequest = new ReadBinlogFilesTimestampsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadBinlogFilesTimestampsResponse$Type extends MessageType<ReadBinlogFilesTimestampsResponse> {
    constructor() {
        super("mysqlctl.ReadBinlogFilesTimestampsResponse", [
            { no: 1, name: "first_timestamp", kind: "message", T: () => Time },
            { no: 2, name: "first_timestamp_binlog", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_timestamp", kind: "message", T: () => Time },
            { no: 4, name: "last_timestamp_binlog", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReadBinlogFilesTimestampsResponse>): ReadBinlogFilesTimestampsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.firstTimestampBinlog = "";
        message.lastTimestampBinlog = "";
        if (value !== undefined)
            reflectionMergePartial<ReadBinlogFilesTimestampsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadBinlogFilesTimestampsResponse): ReadBinlogFilesTimestampsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vttime.Time first_timestamp */ 1:
                    message.firstTimestamp = Time.internalBinaryRead(reader, reader.uint32(), options, message.firstTimestamp);
                    break;
                case /* string first_timestamp_binlog */ 2:
                    message.firstTimestampBinlog = reader.string();
                    break;
                case /* vttime.Time last_timestamp */ 3:
                    message.lastTimestamp = Time.internalBinaryRead(reader, reader.uint32(), options, message.lastTimestamp);
                    break;
                case /* string last_timestamp_binlog */ 4:
                    message.lastTimestampBinlog = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadBinlogFilesTimestampsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vttime.Time first_timestamp = 1; */
        if (message.firstTimestamp)
            Time.internalBinaryWrite(message.firstTimestamp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string first_timestamp_binlog = 2; */
        if (message.firstTimestampBinlog !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.firstTimestampBinlog);
        /* vttime.Time last_timestamp = 3; */
        if (message.lastTimestamp)
            Time.internalBinaryWrite(message.lastTimestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string last_timestamp_binlog = 4; */
        if (message.lastTimestampBinlog !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.lastTimestampBinlog);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ReadBinlogFilesTimestampsResponse
 */
export const ReadBinlogFilesTimestampsResponse = new ReadBinlogFilesTimestampsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReinitConfigRequest$Type extends MessageType<ReinitConfigRequest> {
    constructor() {
        super("mysqlctl.ReinitConfigRequest", []);
    }
    create(value?: PartialMessage<ReinitConfigRequest>): ReinitConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReinitConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReinitConfigRequest): ReinitConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReinitConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ReinitConfigRequest
 */
export const ReinitConfigRequest = new ReinitConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReinitConfigResponse$Type extends MessageType<ReinitConfigResponse> {
    constructor() {
        super("mysqlctl.ReinitConfigResponse", []);
    }
    create(value?: PartialMessage<ReinitConfigResponse>): ReinitConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReinitConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReinitConfigResponse): ReinitConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReinitConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.ReinitConfigResponse
 */
export const ReinitConfigResponse = new ReinitConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshConfigRequest$Type extends MessageType<RefreshConfigRequest> {
    constructor() {
        super("mysqlctl.RefreshConfigRequest", []);
    }
    create(value?: PartialMessage<RefreshConfigRequest>): RefreshConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RefreshConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshConfigRequest): RefreshConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.RefreshConfigRequest
 */
export const RefreshConfigRequest = new RefreshConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefreshConfigResponse$Type extends MessageType<RefreshConfigResponse> {
    constructor() {
        super("mysqlctl.RefreshConfigResponse", []);
    }
    create(value?: PartialMessage<RefreshConfigResponse>): RefreshConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RefreshConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefreshConfigResponse): RefreshConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefreshConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.RefreshConfigResponse
 */
export const RefreshConfigResponse = new RefreshConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionStringRequest$Type extends MessageType<VersionStringRequest> {
    constructor() {
        super("mysqlctl.VersionStringRequest", []);
    }
    create(value?: PartialMessage<VersionStringRequest>): VersionStringRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VersionStringRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VersionStringRequest): VersionStringRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VersionStringRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.VersionStringRequest
 */
export const VersionStringRequest = new VersionStringRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionStringResponse$Type extends MessageType<VersionStringResponse> {
    constructor() {
        super("mysqlctl.VersionStringResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VersionStringResponse>): VersionStringResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<VersionStringResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VersionStringResponse): VersionStringResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VersionStringResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.VersionStringResponse
 */
export const VersionStringResponse = new VersionStringResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostMetricsRequest$Type extends MessageType<HostMetricsRequest> {
    constructor() {
        super("mysqlctl.HostMetricsRequest", []);
    }
    create(value?: PartialMessage<HostMetricsRequest>): HostMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HostMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostMetricsRequest): HostMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.HostMetricsRequest
 */
export const HostMetricsRequest = new HostMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostMetricsResponse$Type extends MessageType<HostMetricsResponse> {
    constructor() {
        super("mysqlctl.HostMetricsResponse", [
            { no: 1, name: "metrics", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => HostMetricsResponse_Metric } }
        ]);
    }
    create(value?: PartialMessage<HostMetricsResponse>): HostMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.metrics = {};
        if (value !== undefined)
            reflectionMergePartial<HostMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostMetricsResponse): HostMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, mysqlctl.HostMetricsResponse.Metric> metrics */ 1:
                    this.binaryReadMap1(message.metrics, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HostMetricsResponse["metrics"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HostMetricsResponse["metrics"] | undefined, val: HostMetricsResponse["metrics"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = HostMetricsResponse_Metric.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field mysqlctl.HostMetricsResponse.metrics");
            }
        }
        map[key ?? ""] = val ?? HostMetricsResponse_Metric.create();
    }
    internalBinaryWrite(message: HostMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, mysqlctl.HostMetricsResponse.Metric> metrics = 1; */
        for (let k of globalThis.Object.keys(message.metrics)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            HostMetricsResponse_Metric.internalBinaryWrite(message.metrics[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.HostMetricsResponse
 */
export const HostMetricsResponse = new HostMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostMetricsResponse_Metric$Type extends MessageType<HostMetricsResponse_Metric> {
    constructor() {
        super("mysqlctl.HostMetricsResponse.Metric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "error", kind: "message", T: () => RPCError }
        ]);
    }
    create(value?: PartialMessage<HostMetricsResponse_Metric>): HostMetricsResponse_Metric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<HostMetricsResponse_Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostMetricsResponse_Metric): HostMetricsResponse_Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                case /* vtrpc.RPCError error */ 3:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostMetricsResponse_Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        /* vtrpc.RPCError error = 3; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.HostMetricsResponse.Metric
 */
export const HostMetricsResponse_Metric = new HostMetricsResponse_Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BackupInfo$Type extends MessageType<BackupInfo> {
    constructor() {
        super("mysqlctl.BackupInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "directory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 6, name: "time", kind: "message", T: () => Time },
            { no: 7, name: "engine", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "status", kind: "enum", T: () => ["mysqlctl.BackupInfo.Status", BackupInfo_Status] }
        ]);
    }
    create(value?: PartialMessage<BackupInfo>): BackupInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.directory = "";
        message.keyspace = "";
        message.shard = "";
        message.engine = "";
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<BackupInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackupInfo): BackupInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string directory */ 2:
                    message.directory = reader.string();
                    break;
                case /* string keyspace */ 3:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 4:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 5:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* vttime.Time time */ 6:
                    message.time = Time.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string engine */ 7:
                    message.engine = reader.string();
                    break;
                case /* mysqlctl.BackupInfo.Status status */ 8:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackupInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string directory = 2; */
        if (message.directory !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.directory);
        /* string keyspace = 3; */
        if (message.keyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 4; */
        if (message.shard !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletAlias tablet_alias = 5; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time time = 6; */
        if (message.time)
            Time.internalBinaryWrite(message.time, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string engine = 7; */
        if (message.engine !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.engine);
        /* mysqlctl.BackupInfo.Status status = 8; */
        if (message.status !== 0)
            writer.tag(8, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mysqlctl.BackupInfo
 */
export const BackupInfo = new BackupInfo$Type();
/**
 * @generated ServiceType for protobuf service mysqlctl.MysqlCtl
 */
export const MysqlCtl = new ServiceType("mysqlctl.MysqlCtl", [
    { name: "Start", options: {}, I: StartRequest, O: StartResponse },
    { name: "Shutdown", options: {}, I: ShutdownRequest, O: ShutdownResponse },
    { name: "RunMysqlUpgrade", options: {}, I: RunMysqlUpgradeRequest, O: RunMysqlUpgradeResponse },
    { name: "ApplyBinlogFile", options: {}, I: ApplyBinlogFileRequest, O: ApplyBinlogFileResponse },
    { name: "ReadBinlogFilesTimestamps", options: {}, I: ReadBinlogFilesTimestampsRequest, O: ReadBinlogFilesTimestampsResponse },
    { name: "ReinitConfig", options: {}, I: ReinitConfigRequest, O: ReinitConfigResponse },
    { name: "RefreshConfig", options: {}, I: RefreshConfigRequest, O: RefreshConfigResponse },
    { name: "VersionString", options: {}, I: VersionStringRequest, O: VersionStringResponse },
    { name: "HostMetrics", options: {}, I: HostMetricsRequest, O: HostMetricsResponse }
]);
