//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains all the types necessary to make
// RPC calls to Vttablet.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file query.proto (package query, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { TabletAlias, TabletAliasJson, TabletType, TabletTypeJson } from "./topodata_pb";
import { file_topodata } from "./topodata_pb";
import type { CallerID, CallerIDJson, RPCError, RPCErrorJson } from "./vtrpc_pb";
import { file_vtrpc } from "./vtrpc_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file query.proto.
 */
export const file_query: GenFile = /*@__PURE__*/
  fileDesc("CgtxdWVyeS5wcm90bxIFcXVlcnkiYgoGVGFyZ2V0EhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEikKC3RhYmxldF90eXBlGAMgASgOMhQudG9wb2RhdGEuVGFibGV0VHlwZRIMCgRjZWxsGAQgASgJIjIKDlZUR2F0ZUNhbGxlcklEEhAKCHVzZXJuYW1lGAEgASgJEg4KBmdyb3VwcxgCIAMoCSJACgpFdmVudFRva2VuEhEKCXRpbWVzdGFtcBgBIAEoAxINCgVzaGFyZBgCIAEoCRIQCghwb3NpdGlvbhgDIAEoCSIxCgVWYWx1ZRIZCgR0eXBlGAEgASgOMgsucXVlcnkuVHlwZRINCgV2YWx1ZRgCIAEoDCJWCgxCaW5kVmFyaWFibGUSGQoEdHlwZRgBIAEoDjILLnF1ZXJ5LlR5cGUSDQoFdmFsdWUYAiABKAwSHAoGdmFsdWVzGAMgAygLMgwucXVlcnkuVmFsdWUiogEKCkJvdW5kUXVlcnkSCwoDc3FsGAEgASgJEjwKDmJpbmRfdmFyaWFibGVzGAIgAygLMiQucXVlcnkuQm91bmRRdWVyeS5CaW5kVmFyaWFibGVzRW50cnkaSQoSQmluZFZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRIiCgV2YWx1ZRgCIAEoCzITLnF1ZXJ5LkJpbmRWYXJpYWJsZToCOAEi/AkKDkV4ZWN1dGVPcHRpb25zEj0KD2luY2x1ZGVkX2ZpZWxkcxgEIAEoDjIkLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zLkluY2x1ZGVkRmllbGRzEhkKEWNsaWVudF9mb3VuZF9yb3dzGAUgASgIEjAKCHdvcmtsb2FkGAYgASgOMh4ucXVlcnkuRXhlY3V0ZU9wdGlvbnMuV29ya2xvYWQSGAoQc3FsX3NlbGVjdF9saW1pdBgIIAEoAxJJChV0cmFuc2FjdGlvbl9pc29sYXRpb24YCSABKA4yKi5xdWVyeS5FeGVjdXRlT3B0aW9ucy5UcmFuc2FjdGlvbklzb2xhdGlvbhIdChVza2lwX3F1ZXJ5X3BsYW5fY2FjaGUYCiABKAgSPQoPcGxhbm5lcl92ZXJzaW9uGAsgASgOMiQucXVlcnkuRXhlY3V0ZU9wdGlvbnMuUGxhbm5lclZlcnNpb24SHwoXaGFzX2NyZWF0ZWRfdGVtcF90YWJsZXMYDCABKAgSOAoMY29uc29saWRhdG9yGA0gASgOMiIucXVlcnkuRXhlY3V0ZU9wdGlvbnMuQ29uc29saWRhdG9yEkwKF3RyYW5zYWN0aW9uX2FjY2Vzc19tb2RlGA4gAygOMisucXVlcnkuRXhlY3V0ZU9wdGlvbnMuVHJhbnNhY3Rpb25BY2Nlc3NNb2RlEhQKDFdvcmtsb2FkTmFtZRgPIAEoCRIQCghwcmlvcml0eRgQIAEoCRIfChVhdXRob3JpdGF0aXZlX3RpbWVvdXQYESABKANIACI7Cg5JbmNsdWRlZEZpZWxkcxIRCg1UWVBFX0FORF9OQU1FEAASDQoJVFlQRV9PTkxZEAESBwoDQUxMEAIiOAoIV29ya2xvYWQSDwoLVU5TUEVDSUZJRUQQABIICgRPTFRQEAESCAoET0xBUBACEgcKA0RCQRADIqcBChRUcmFuc2FjdGlvbklzb2xhdGlvbhILCgdERUZBVUxUEAASEwoPUkVQRUFUQUJMRV9SRUFEEAESEgoOUkVBRF9DT01NSVRURUQQAhIUChBSRUFEX1VOQ09NTUlUVEVEEAMSEAoMU0VSSUFMSVpBQkxFEAQSIQodQ09OU0lTVEVOVF9TTkFQU0hPVF9SRUFEX09OTFkQBRIOCgpBVVRPQ09NTUlUEAYikgEKDlBsYW5uZXJWZXJzaW9uEhMKD0RFRkFVTFRfUExBTk5FUhAAEgYKAlYzEAESCAoER2VuNBACEg4KCkdlbjRHcmVlZHkQAxISCg5HZW40TGVmdDJSaWdodBAEEhQKEEdlbjRXaXRoRmFsbGJhY2sQBRIRCg1HZW40Q29tcGFyZVYzEAYSDAoIVjNJbnNlcnQQByKEAQoMQ29uc29saWRhdG9yEhwKGENPTlNPTElEQVRPUl9VTlNQRUNJRklFRBAAEhkKFUNPTlNPTElEQVRPUl9ESVNBQkxFRBABEhgKFENPTlNPTElEQVRPUl9FTkFCTEVEEAISIQodQ09OU09MSURBVE9SX0VOQUJMRURfUkVQTElDQVMQAyJPChVUcmFuc2FjdGlvbkFjY2Vzc01vZGUSFwoTQ09OU0lTVEVOVF9TTkFQU0hPVBAAEg4KClJFQURfV1JJVEUQARINCglSRUFEX09OTFkQAkIJCgd0aW1lb3V0SgQIARACSgQIAhADSgQIAxAEItQBCgVGaWVsZBIMCgRuYW1lGAEgASgJEhkKBHR5cGUYAiABKA4yCy5xdWVyeS5UeXBlEg0KBXRhYmxlGAMgASgJEhEKCW9yZ190YWJsZRgEIAEoCRIQCghkYXRhYmFzZRgFIAEoCRIQCghvcmdfbmFtZRgGIAEoCRIVCg1jb2x1bW5fbGVuZ3RoGAcgASgNEg8KB2NoYXJzZXQYCCABKA0SEAoIZGVjaW1hbHMYCSABKA0SDQoFZmxhZ3MYCiABKA0SEwoLY29sdW1uX3R5cGUYCyABKAkiJgoDUm93Eg8KB2xlbmd0aHMYASADKBISDgoGdmFsdWVzGAIgASgMIqIBCgtRdWVyeVJlc3VsdBIcCgZmaWVsZHMYASADKAsyDC5xdWVyeS5GaWVsZBIVCg1yb3dzX2FmZmVjdGVkGAIgASgEEhEKCWluc2VydF9pZBgDIAEoBBIYCgRyb3dzGAQgAygLMgoucXVlcnkuUm93EgwKBGluZm8YBiABKAkSHQoVc2Vzc2lvbl9zdGF0ZV9jaGFuZ2VzGAcgASgJSgQIBRAGIi0KDFF1ZXJ5V2FybmluZxIMCgRjb2RlGAEgASgNEg8KB21lc3NhZ2UYAiABKAkiygIKC1N0cmVhbUV2ZW50EjAKCnN0YXRlbWVudHMYASADKAsyHC5xdWVyeS5TdHJlYW1FdmVudC5TdGF0ZW1lbnQSJgoLZXZlbnRfdG9rZW4YAiABKAsyES5xdWVyeS5FdmVudFRva2VuGuABCglTdGF0ZW1lbnQSNwoIY2F0ZWdvcnkYASABKA4yJS5xdWVyeS5TdHJlYW1FdmVudC5TdGF0ZW1lbnQuQ2F0ZWdvcnkSEgoKdGFibGVfbmFtZRgCIAEoCRIoChJwcmltYXJ5X2tleV9maWVsZHMYAyADKAsyDC5xdWVyeS5GaWVsZBImChJwcmltYXJ5X2tleV92YWx1ZXMYBCADKAsyCi5xdWVyeS5Sb3cSCwoDc3FsGAUgASgMIicKCENhdGVnb3J5EgkKBUVycm9yEAASBwoDRE1MEAESBwoDRERMEAIiiAIKDkV4ZWN1dGVSZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EiAKBXF1ZXJ5GAQgASgLMhEucXVlcnkuQm91bmRRdWVyeRIWCg50cmFuc2FjdGlvbl9pZBgFIAEoAxImCgdvcHRpb25zGAYgASgLMhUucXVlcnkuRXhlY3V0ZU9wdGlvbnMSEwoLcmVzZXJ2ZWRfaWQYByABKAMiNQoPRXhlY3V0ZVJlc3BvbnNlEiIKBnJlc3VsdBgBIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0IlUKD1Jlc3VsdFdpdGhFcnJvchIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiIKBnJlc3VsdBgCIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0Io4CChRTdHJlYW1FeGVjdXRlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIgCgVxdWVyeRgEIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSJgoHb3B0aW9ucxgFIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEhYKDnRyYW5zYWN0aW9uX2lkGAYgASgDEhMKC3Jlc2VydmVkX2lkGAcgASgDIjsKFVN0cmVhbUV4ZWN1dGVSZXNwb25zZRIiCgZyZXN1bHQYASABKAsyEi5xdWVyeS5RdWVyeVJlc3VsdCK3AQoMQmVnaW5SZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EiYKB29wdGlvbnMYBCABKAsyFS5xdWVyeS5FeGVjdXRlT3B0aW9ucyJzCg1CZWdpblJlc3BvbnNlEhYKDnRyYW5zYWN0aW9uX2lkGAEgASgDEisKDHRhYmxldF9hbGlhcxgCIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEh0KFXNlc3Npb25fc3RhdGVfY2hhbmdlcxgDIAEoCSKoAQoNQ29tbWl0UmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIWCg50cmFuc2FjdGlvbl9pZBgEIAEoAyIlCg5Db21taXRSZXNwb25zZRITCgtyZXNlcnZlZF9pZBgBIAEoAyKqAQoPUm9sbGJhY2tSZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EhYKDnRyYW5zYWN0aW9uX2lkGAQgASgDIicKEFJvbGxiYWNrUmVzcG9uc2USEwoLcmVzZXJ2ZWRfaWQYASABKAMitwEKDlByZXBhcmVSZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EhYKDnRyYW5zYWN0aW9uX2lkGAQgASgDEgwKBGR0aWQYBSABKAkiEQoPUHJlcGFyZVJlc3BvbnNlIqYBChVDb21taXRQcmVwYXJlZFJlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSDAoEZHRpZBgEIAEoCSIYChZDb21taXRQcmVwYXJlZFJlc3BvbnNlIsABChdSb2xsYmFja1ByZXBhcmVkUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIWCg50cmFuc2FjdGlvbl9pZBgEIAEoAxIMCgRkdGlkGAUgASgJIhoKGFJvbGxiYWNrUHJlcGFyZWRSZXNwb25zZSLOAQoYQ3JlYXRlVHJhbnNhY3Rpb25SZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EgwKBGR0aWQYBCABKAkSIwoMcGFydGljaXBhbnRzGAUgAygLMg0ucXVlcnkuVGFyZ2V0IhsKGUNyZWF0ZVRyYW5zYWN0aW9uUmVzcG9uc2UiuwEKElN0YXJ0Q29tbWl0UmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIWCg50cmFuc2FjdGlvbl9pZBgEIAEoAxIMCgRkdGlkGAUgASgJIhUKE1N0YXJ0Q29tbWl0UmVzcG9uc2UiuwEKElNldFJvbGxiYWNrUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIWCg50cmFuc2FjdGlvbl9pZBgEIAEoAxIMCgRkdGlkGAUgASgJIhUKE1NldFJvbGxiYWNrUmVzcG9uc2UiqwEKGkNvbmNsdWRlVHJhbnNhY3Rpb25SZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EgwKBGR0aWQYBCABKAkiHQobQ29uY2x1ZGVUcmFuc2FjdGlvblJlc3BvbnNlIqcBChZSZWFkVHJhbnNhY3Rpb25SZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EgwKBGR0aWQYBCABKAkiRwoXUmVhZFRyYW5zYWN0aW9uUmVzcG9uc2USLAoIbWV0YWRhdGEYASABKAsyGi5xdWVyeS5UcmFuc2FjdGlvbk1ldGFkYXRhIrUBCh1VbnJlc29sdmVkVHJhbnNhY3Rpb25zUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBITCgthYmFuZG9uX2FnZRgEIAEoAyJSCh5VbnJlc29sdmVkVHJhbnNhY3Rpb25zUmVzcG9uc2USMAoMdHJhbnNhY3Rpb25zGAEgAygLMhoucXVlcnkuVHJhbnNhY3Rpb25NZXRhZGF0YSKKAgoTQmVnaW5FeGVjdXRlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIgCgVxdWVyeRgEIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSJgoHb3B0aW9ucxgFIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEhMKC3Jlc2VydmVkX2lkGAYgASgDEhMKC3ByZV9xdWVyaWVzGAcgAygJIr4BChRCZWdpbkV4ZWN1dGVSZXNwb25zZRIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiIKBnJlc3VsdBgCIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0EhYKDnRyYW5zYWN0aW9uX2lkGAMgASgDEisKDHRhYmxldF9hbGlhcxgEIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEh0KFXNlc3Npb25fc3RhdGVfY2hhbmdlcxgFIAEoCSKQAgoZQmVnaW5TdHJlYW1FeGVjdXRlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIgCgVxdWVyeRgEIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSJgoHb3B0aW9ucxgFIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEhMKC3ByZV9xdWVyaWVzGAYgAygJEhMKC3Jlc2VydmVkX2lkGAcgASgDIsQBChpCZWdpblN0cmVhbUV4ZWN1dGVSZXNwb25zZRIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiIKBnJlc3VsdBgCIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0EhYKDnRyYW5zYWN0aW9uX2lkGAMgASgDEisKDHRhYmxldF9hbGlhcxgEIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzEh0KFXNlc3Npb25fc3RhdGVfY2hhbmdlcxgFIAEoCSKlAQoUTWVzc2FnZVN0cmVhbVJlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSDAoEbmFtZRgEIAEoCSI7ChVNZXNzYWdlU3RyZWFtUmVzcG9uc2USIgoGcmVzdWx0GAEgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQivQEKEU1lc3NhZ2VBY2tSZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EgwKBG5hbWUYBCABKAkSGQoDaWRzGAUgAygLMgwucXVlcnkuVmFsdWUiOAoSTWVzc2FnZUFja1Jlc3BvbnNlEiIKBnJlc3VsdBgBIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0Io8CChVSZXNlcnZlRXhlY3V0ZVJlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSIAoFcXVlcnkYBCABKAsyES5xdWVyeS5Cb3VuZFF1ZXJ5EhYKDnRyYW5zYWN0aW9uX2lkGAUgASgDEiYKB29wdGlvbnMYBiABKAsyFS5xdWVyeS5FeGVjdXRlT3B0aW9ucxITCgtwcmVfcXVlcmllcxgHIAMoCSKeAQoWUmVzZXJ2ZUV4ZWN1dGVSZXNwb25zZRIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiIKBnJlc3VsdBgCIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0EhMKC3Jlc2VydmVkX2lkGAMgASgDEisKDHRhYmxldF9hbGlhcxgEIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIpUCChtSZXNlcnZlU3RyZWFtRXhlY3V0ZVJlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSIAoFcXVlcnkYBCABKAsyES5xdWVyeS5Cb3VuZFF1ZXJ5EiYKB29wdGlvbnMYBSABKAsyFS5xdWVyeS5FeGVjdXRlT3B0aW9ucxIWCg50cmFuc2FjdGlvbl9pZBgGIAEoAxITCgtwcmVfcXVlcmllcxgHIAMoCSKkAQocUmVzZXJ2ZVN0cmVhbUV4ZWN1dGVSZXNwb25zZRIeCgVlcnJvchgBIAEoCzIPLnZ0cnBjLlJQQ0Vycm9yEiIKBnJlc3VsdBgCIAEoCzISLnF1ZXJ5LlF1ZXJ5UmVzdWx0EhMKC3Jlc2VydmVkX2lkGAMgASgDEisKDHRhYmxldF9hbGlhcxgEIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzIpgCChpSZXNlcnZlQmVnaW5FeGVjdXRlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIgCgVxdWVyeRgEIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSJgoHb3B0aW9ucxgFIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEhMKC3ByZV9xdWVyaWVzGAYgAygJEhoKEnBvc3RfYmVnaW5fcXVlcmllcxgHIAMoCSLaAQobUmVzZXJ2ZUJlZ2luRXhlY3V0ZVJlc3BvbnNlEh4KBWVycm9yGAEgASgLMg8udnRycGMuUlBDRXJyb3ISIgoGcmVzdWx0GAIgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQSFgoOdHJhbnNhY3Rpb25faWQYAyABKAMSEwoLcmVzZXJ2ZWRfaWQYBCABKAMSKwoMdGFibGV0X2FsaWFzGAUgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSHQoVc2Vzc2lvbl9zdGF0ZV9jaGFuZ2VzGAYgASgJIp4CCiBSZXNlcnZlQmVnaW5TdHJlYW1FeGVjdXRlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIgCgVxdWVyeRgEIAEoCzIRLnF1ZXJ5LkJvdW5kUXVlcnkSJgoHb3B0aW9ucxgFIAEoCzIVLnF1ZXJ5LkV4ZWN1dGVPcHRpb25zEhMKC3ByZV9xdWVyaWVzGAYgAygJEhoKEnBvc3RfYmVnaW5fcXVlcmllcxgHIAMoCSLgAQohUmVzZXJ2ZUJlZ2luU3RyZWFtRXhlY3V0ZVJlc3BvbnNlEh4KBWVycm9yGAEgASgLMg8udnRycGMuUlBDRXJyb3ISIgoGcmVzdWx0GAIgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQSFgoOdHJhbnNhY3Rpb25faWQYAyABKAMSEwoLcmVzZXJ2ZWRfaWQYBCABKAMSKwoMdGFibGV0X2FsaWFzGAUgASgLMhUudG9wb2RhdGEuVGFibGV0QWxpYXMSHQoVc2Vzc2lvbl9zdGF0ZV9jaGFuZ2VzGAYgASgJIr4BCg5SZWxlYXNlUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBIWCg50cmFuc2FjdGlvbl9pZBgEIAEoAxITCgtyZXNlcnZlZF9pZBgFIAEoAyIRCg9SZWxlYXNlUmVzcG9uc2UiFQoTU3RyZWFtSGVhbHRoUmVxdWVzdCKWAgoNUmVhbHRpbWVTdGF0cxIUCgxoZWFsdGhfZXJyb3IYASABKAkSHwoXcmVwbGljYXRpb25fbGFnX3NlY29uZHMYAiABKA0SHAoUYmlubG9nX3BsYXllcnNfY291bnQYAyABKAUSKAogZmlsdGVyZWRfcmVwbGljYXRpb25fbGFnX3NlY29uZHMYBCABKAMSEQoJY3B1X3VzYWdlGAUgASgBEgsKA3FwcxgGIAEoARIcChR0YWJsZV9zY2hlbWFfY2hhbmdlZBgHIAMoCRIbChN2aWV3X3NjaGVtYV9jaGFuZ2VkGAggAygJEhQKDHVkZnNfY2hhbmdlZBgJIAEoCBIVCg10eF91bnJlc29sdmVkGAogASgIIpgBCg5BZ2dyZWdhdGVTdGF0cxIcChRoZWFsdGh5X3RhYmxldF9jb3VudBgBIAEoBRIeChZ1bmhlYWx0aHlfdGFibGV0X2NvdW50GAIgASgFEiMKG3JlcGxpY2F0aW9uX2xhZ19zZWNvbmRzX21pbhgDIAEoDRIjChtyZXBsaWNhdGlvbl9sYWdfc2Vjb25kc19tYXgYBCABKA0izQEKFFN0cmVhbUhlYWx0aFJlc3BvbnNlEh0KBnRhcmdldBgBIAEoCzINLnF1ZXJ5LlRhcmdldBIPCgdzZXJ2aW5nGAIgASgIEiQKHHByaW1hcnlfdGVybV9zdGFydF90aW1lc3RhbXAYAyABKAMSLAoOcmVhbHRpbWVfc3RhdHMYBCABKAsyFC5xdWVyeS5SZWFsdGltZVN0YXRzEisKDHRhYmxldF9hbGlhcxgFIAEoCzIVLnRvcG9kYXRhLlRhYmxldEFsaWFzSgQIBhAHIoYBChNUcmFuc2FjdGlvbk1ldGFkYXRhEgwKBGR0aWQYASABKAkSJgoFc3RhdGUYAiABKA4yFy5xdWVyeS5UcmFuc2FjdGlvblN0YXRlEhQKDHRpbWVfY3JlYXRlZBgDIAEoAxIjCgxwYXJ0aWNpcGFudHMYBCADKAsyDS5xdWVyeS5UYXJnZXQicgoQR2V0U2NoZW1hUmVxdWVzdBIdCgZ0YXJnZXQYASABKAsyDS5xdWVyeS5UYXJnZXQSKgoKdGFibGVfdHlwZRgCIAEoDjIWLnF1ZXJ5LlNjaGVtYVRhYmxlVHlwZRITCgt0YWJsZV9uYW1lcxgDIAMoCSJOCgdVREZJbmZvEgwKBG5hbWUYASABKAkSEwoLYWdncmVnYXRpbmcYAiABKAgSIAoLcmV0dXJuX3R5cGUYAyABKA4yCy5xdWVyeS5UeXBlIrIBChFHZXRTY2hlbWFSZXNwb25zZRIcCgR1ZGZzGAEgAygLMg4ucXVlcnkuVURGSW5mbxJHChB0YWJsZV9kZWZpbml0aW9uGAIgAygLMi0ucXVlcnkuR2V0U2NoZW1hUmVzcG9uc2UuVGFibGVEZWZpbml0aW9uRW50cnkaNgoUVGFibGVEZWZpbml0aW9uRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASqSAwoJTXlTcWxGbGFnEgkKBUVNUFRZEAASEQoNTk9UX05VTExfRkxBRxABEhAKDFBSSV9LRVlfRkxBRxACEhMKD1VOSVFVRV9LRVlfRkxBRxAEEhUKEU1VTFRJUExFX0tFWV9GTEFHEAgSDQoJQkxPQl9GTEFHEBASEQoNVU5TSUdORURfRkxBRxAgEhEKDVpFUk9GSUxMX0ZMQUcQQBIQCgtCSU5BUllfRkxBRxCAARIOCglFTlVNX0ZMQUcQgAISGAoTQVVUT19JTkNSRU1FTlRfRkxBRxCABBITCg5USU1FU1RBTVBfRkxBRxCACBINCghTRVRfRkxBRxCAEBIaChVOT19ERUZBVUxUX1ZBTFVFX0ZMQUcQgCASFwoST05fVVBEQVRFX05PV19GTEFHEIBAEg4KCE5VTV9GTEFHEICAAhITCg1QQVJUX0tFWV9GTEFHEICAARIQCgpHUk9VUF9GTEFHEICAAhIRCgtVTklRVUVfRkxBRxCAgAQSEQoLQklOQ01QX0ZMQUcQgIAIGgIQASprCgRGbGFnEggKBE5PTkUQABIPCgpJU0lOVEVHUkFMEIACEg8KCklTVU5TSUdORUQQgAQSDAoHSVNGTE9BVBCACBINCghJU1FVT1RFRBCAEBILCgZJU1RFWFQQgCASDQoISVNCSU5BUlkQgEAq1wMKBFR5cGUSDQoJTlVMTF9UWVBFEAASCQoESU5UOBCBAhIKCgVVSU5UOBCCBhIKCgVJTlQxNhCDAhILCgZVSU5UMTYQhAYSCgoFSU5UMjQQhQISCwoGVUlOVDI0EIYGEgoKBUlOVDMyEIcCEgsKBlVJTlQzMhCIBhIKCgVJTlQ2NBCJAhILCgZVSU5UNjQQigYSDAoHRkxPQVQzMhCLCBIMCgdGTE9BVDY0EIwIEg4KCVRJTUVTVEFNUBCNEBIJCgREQVRFEI4QEgkKBFRJTUUQjxASDQoIREFURVRJTUUQkBASCQoEWUVBUhCRBhILCgdERUNJTUFMEBISCQoEVEVYVBCTMBIJCgRCTE9CEJRQEgwKB1ZBUkNIQVIQlTASDgoJVkFSQklOQVJZEJZQEgkKBENIQVIQlzASCwoGQklOQVJZEJhQEggKA0JJVBCZEBIJCgRFTlVNEJoQEggKA1NFVBCbEBIJCgVUVVBMRRAcEg0KCEdFT01FVFJZEJ0QEgkKBEpTT04QnhASDgoKRVhQUkVTU0lPThAfEgsKBkhFWE5VTRCgIBILCgZIRVhWQUwQoSASCwoGQklUTlVNEKIgEgsKBlZFQ1RPUhCjEBIICgNSQVcQpBAqRgoQVHJhbnNhY3Rpb25TdGF0ZRILCgdVTktOT1dOEAASCwoHUFJFUEFSRRABEgwKCFJPTExCQUNLEAISCgoGQ09NTUlUEAMqOwoPU2NoZW1hVGFibGVUeXBlEgkKBVZJRVdTEAASCgoGVEFCTEVTEAESBwoDQUxMEAISCAoEVURGUxADQjUKD2lvLnZpdGVzcy5wcm90b1oidml0ZXNzLmlvL3ZpdGVzcy9nby92dC9wcm90by9xdWVyeWIGcHJvdG8z", [file_topodata, file_vtrpc]);

/**
 * Target describes what the client expects the tablet is.
 * If the tablet does not match, an error is returned.
 *
 * @generated from message query.Target
 */
export type Target = Message<"query.Target"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType: TabletType;

  /**
   * cell is used for routing queries between vtgate and vttablets. It
   * is not used when Target is part of the Session sent by the client.
   *
   * @generated from field: string cell = 4;
   */
  cell: string;
};

/**
 * Target describes what the client expects the tablet is.
 * If the tablet does not match, an error is returned.
 *
 * @generated from message query.Target
 */
export type TargetJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType?: TabletTypeJson;

  /**
   * cell is used for routing queries between vtgate and vttablets. It
   * is not used when Target is part of the Session sent by the client.
   *
   * @generated from field: string cell = 4;
   */
  cell?: string;
};

/**
 * Describes the message query.Target.
 * Use `create(TargetSchema)` to create a new message.
 */
export const TargetSchema: GenMessage<Target, TargetJson> = /*@__PURE__*/
  messageDesc(file_query, 0);

/**
 * VTGateCallerID is sent by VTGate to VTTablet to describe the
 * caller. If possible, this information is secure. For instance,
 * if using unique certificates that guarantee that VTGate->VTTablet
 * traffic cannot be spoofed, then VTTablet can trust this information,
 * and VTTablet will use it for tablet ACLs, for instance.
 * Because of this security guarantee, this is different than the CallerID
 * structure, which is not secure at all, because it is provided
 * by the Vitess client.
 *
 * @generated from message query.VTGateCallerID
 */
export type VTGateCallerID = Message<"query.VTGateCallerID"> & {
  /**
   * @generated from field: string username = 1;
   */
  username: string;

  /**
   * @generated from field: repeated string groups = 2;
   */
  groups: string[];
};

/**
 * VTGateCallerID is sent by VTGate to VTTablet to describe the
 * caller. If possible, this information is secure. For instance,
 * if using unique certificates that guarantee that VTGate->VTTablet
 * traffic cannot be spoofed, then VTTablet can trust this information,
 * and VTTablet will use it for tablet ACLs, for instance.
 * Because of this security guarantee, this is different than the CallerID
 * structure, which is not secure at all, because it is provided
 * by the Vitess client.
 *
 * @generated from message query.VTGateCallerID
 */
export type VTGateCallerIDJson = {
  /**
   * @generated from field: string username = 1;
   */
  username?: string;

  /**
   * @generated from field: repeated string groups = 2;
   */
  groups?: string[];
};

/**
 * Describes the message query.VTGateCallerID.
 * Use `create(VTGateCallerIDSchema)` to create a new message.
 */
export const VTGateCallerIDSchema: GenMessage<VTGateCallerID, VTGateCallerIDJson> = /*@__PURE__*/
  messageDesc(file_query, 1);

/**
 * EventToken is a structure that describes a point in time in a
 * replication stream on one shard. The most recent known replication
 * position can be retrieved from vttablet when executing a query. It
 * is also sent with the replication streams from the binlog service.
 *
 * @generated from message query.EventToken
 */
export type EventToken = Message<"query.EventToken"> & {
  /**
   * timestamp is the MySQL timestamp of the statements. Seconds since Epoch.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The shard name that applied the statements. Note this is not set when
   * streaming from a vttablet. It is only used on the client -> vtgate link.
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * The position on the replication stream after this statement was applied.
   * It is not the transaction ID / GTID, but the position / GTIDSet.
   *
   * @generated from field: string position = 3;
   */
  position: string;
};

/**
 * EventToken is a structure that describes a point in time in a
 * replication stream on one shard. The most recent known replication
 * position can be retrieved from vttablet when executing a query. It
 * is also sent with the replication streams from the binlog service.
 *
 * @generated from message query.EventToken
 */
export type EventTokenJson = {
  /**
   * timestamp is the MySQL timestamp of the statements. Seconds since Epoch.
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp?: string;

  /**
   * The shard name that applied the statements. Note this is not set when
   * streaming from a vttablet. It is only used on the client -> vtgate link.
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * The position on the replication stream after this statement was applied.
   * It is not the transaction ID / GTID, but the position / GTIDSet.
   *
   * @generated from field: string position = 3;
   */
  position?: string;
};

/**
 * Describes the message query.EventToken.
 * Use `create(EventTokenSchema)` to create a new message.
 */
export const EventTokenSchema: GenMessage<EventToken, EventTokenJson> = /*@__PURE__*/
  messageDesc(file_query, 2);

/**
 * Value represents a typed value.
 *
 * @generated from message query.Value
 */
export type Value = Message<"query.Value"> & {
  /**
   * @generated from field: query.Type type = 1;
   */
  type: Type;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;
};

/**
 * Value represents a typed value.
 *
 * @generated from message query.Value
 */
export type ValueJson = {
  /**
   * @generated from field: query.Type type = 1;
   */
  type?: TypeJson;

  /**
   * @generated from field: bytes value = 2;
   */
  value?: string;
};

/**
 * Describes the message query.Value.
 * Use `create(ValueSchema)` to create a new message.
 */
export const ValueSchema: GenMessage<Value, ValueJson> = /*@__PURE__*/
  messageDesc(file_query, 3);

/**
 * BindVariable represents a single bind variable in a Query.
 *
 * @generated from message query.BindVariable
 */
export type BindVariable = Message<"query.BindVariable"> & {
  /**
   * @generated from field: query.Type type = 1;
   */
  type: Type;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  /**
   * values are set if type is TUPLE.
   *
   * @generated from field: repeated query.Value values = 3;
   */
  values: Value[];
};

/**
 * BindVariable represents a single bind variable in a Query.
 *
 * @generated from message query.BindVariable
 */
export type BindVariableJson = {
  /**
   * @generated from field: query.Type type = 1;
   */
  type?: TypeJson;

  /**
   * @generated from field: bytes value = 2;
   */
  value?: string;

  /**
   * values are set if type is TUPLE.
   *
   * @generated from field: repeated query.Value values = 3;
   */
  values?: ValueJson[];
};

/**
 * Describes the message query.BindVariable.
 * Use `create(BindVariableSchema)` to create a new message.
 */
export const BindVariableSchema: GenMessage<BindVariable, BindVariableJson> = /*@__PURE__*/
  messageDesc(file_query, 4);

/**
 * BoundQuery is a query with its bind variables
 *
 * @generated from message query.BoundQuery
 */
export type BoundQuery = Message<"query.BoundQuery"> & {
  /**
   * sql is the SQL query to execute
   *
   * @generated from field: string sql = 1;
   */
  sql: string;

  /**
   * bind_variables is a map of all bind variables to expand in the query.
   * nil values are not allowed. Use NULL_TYPE to express a NULL value.
   *
   * @generated from field: map<string, query.BindVariable> bind_variables = 2;
   */
  bindVariables: { [key: string]: BindVariable };
};

/**
 * BoundQuery is a query with its bind variables
 *
 * @generated from message query.BoundQuery
 */
export type BoundQueryJson = {
  /**
   * sql is the SQL query to execute
   *
   * @generated from field: string sql = 1;
   */
  sql?: string;

  /**
   * bind_variables is a map of all bind variables to expand in the query.
   * nil values are not allowed. Use NULL_TYPE to express a NULL value.
   *
   * @generated from field: map<string, query.BindVariable> bind_variables = 2;
   */
  bindVariables?: { [key: string]: BindVariableJson };
};

/**
 * Describes the message query.BoundQuery.
 * Use `create(BoundQuerySchema)` to create a new message.
 */
export const BoundQuerySchema: GenMessage<BoundQuery, BoundQueryJson> = /*@__PURE__*/
  messageDesc(file_query, 5);

/**
 * ExecuteOptions is passed around for all Execute calls.
 *
 * @generated from message query.ExecuteOptions
 */
export type ExecuteOptions = Message<"query.ExecuteOptions"> & {
  /**
   * Controls what fields are returned in Field message responses from mysql, i.e.
   * field name, table name, etc. This is an optimization for high-QPS queries where
   * the client knows what it's getting
   *
   * @generated from field: query.ExecuteOptions.IncludedFields included_fields = 4;
   */
  includedFields: ExecuteOptions_IncludedFields;

  /**
   * client_rows_found specifies if rows_affected should return
   * rows found instead of rows affected. Behavior is defined
   * by MySQL's CLIENT_FOUND_ROWS flag.
   *
   * @generated from field: bool client_found_rows = 5;
   */
  clientFoundRows: boolean;

  /**
   * workload specifies the type of workload:
   * OLTP: DMLs allowed, results have row count limit, and
   * query timeouts are shorter.
   * OLAP: DMLS not allowed, no limit on row count, timeouts
   * can be as high as desired.
   * DBA: no limit on rowcount or timeout, all queries allowed
   * but intended for long DMLs and DDLs.
   *
   * @generated from field: query.ExecuteOptions.Workload workload = 6;
   */
  workload: ExecuteOptions_Workload;

  /**
   * sql_select_limit sets an implicit limit on all select statements. Since
   * vitess also sets a rowcount limit on queries, the smallest value wins.
   *
   * @generated from field: int64 sql_select_limit = 8;
   */
  sqlSelectLimit: bigint;

  /**
   * @generated from field: query.ExecuteOptions.TransactionIsolation transaction_isolation = 9;
   */
  transactionIsolation: ExecuteOptions_TransactionIsolation;

  /**
   * skip_query_plan_cache specifies if the query plan should be cached by vitess.
   * By default all query plans are cached.
   *
   * @generated from field: bool skip_query_plan_cache = 10;
   */
  skipQueryPlanCache: boolean;

  /**
   * PlannerVersion specifies which planner to use.
   * If DEFAULT is chosen, whatever vtgate was started with will be used
   *
   * @generated from field: query.ExecuteOptions.PlannerVersion planner_version = 11;
   */
  plannerVersion: ExecuteOptions_PlannerVersion;

  /**
   * has_created_temp_tables signals whether plans created in this session should be cached or not
   * if the user has created temp tables, Vitess will not reuse plans created for this session in other sessions.
   * The current session can still use other sessions cached plans.
   *
   * @generated from field: bool has_created_temp_tables = 12;
   */
  hasCreatedTempTables: boolean;

  /**
   * @generated from field: query.ExecuteOptions.Consolidator consolidator = 13;
   */
  consolidator: ExecuteOptions_Consolidator;

  /**
   * TransactionAccessMode specifies the access modes to be used while starting the transaction i.e. READ WRITE/READ ONLY/WITH CONSISTENT SNAPSHOT
   * If not specified, the transaction will be started with the default access mode on the connection.
   *
   * @generated from field: repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode = 14;
   */
  transactionAccessMode: ExecuteOptions_TransactionAccessMode[];

  /**
   * WorkloadName specifies the name of the workload as indicated in query directives. This is used for instrumentation
   * in metrics and tracing spans.
   *
   * @generated from field: string WorkloadName = 15;
   */
  WorkloadName: string;

  /**
   * priority specifies the priority of the query, between 0 and 100. This is leveraged by the transaction
   * throttler to determine whether, under resource contention, a query should or should not be throttled.
   *
   * @generated from field: string priority = 16;
   */
  priority: string;

  /**
   * timeout specifies the query timeout in milliseconds. If not set, the default timeout is used.
   *
   * @generated from oneof query.ExecuteOptions.timeout
   */
  timeout: {
    /**
     * @generated from field: int64 authoritative_timeout = 17;
     */
    value: bigint;
    case: "authoritativeTimeout";
  } | { case: undefined; value?: undefined };
};

/**
 * ExecuteOptions is passed around for all Execute calls.
 *
 * @generated from message query.ExecuteOptions
 */
export type ExecuteOptionsJson = {
  /**
   * Controls what fields are returned in Field message responses from mysql, i.e.
   * field name, table name, etc. This is an optimization for high-QPS queries where
   * the client knows what it's getting
   *
   * @generated from field: query.ExecuteOptions.IncludedFields included_fields = 4;
   */
  includedFields?: ExecuteOptions_IncludedFieldsJson;

  /**
   * client_rows_found specifies if rows_affected should return
   * rows found instead of rows affected. Behavior is defined
   * by MySQL's CLIENT_FOUND_ROWS flag.
   *
   * @generated from field: bool client_found_rows = 5;
   */
  clientFoundRows?: boolean;

  /**
   * workload specifies the type of workload:
   * OLTP: DMLs allowed, results have row count limit, and
   * query timeouts are shorter.
   * OLAP: DMLS not allowed, no limit on row count, timeouts
   * can be as high as desired.
   * DBA: no limit on rowcount or timeout, all queries allowed
   * but intended for long DMLs and DDLs.
   *
   * @generated from field: query.ExecuteOptions.Workload workload = 6;
   */
  workload?: ExecuteOptions_WorkloadJson;

  /**
   * sql_select_limit sets an implicit limit on all select statements. Since
   * vitess also sets a rowcount limit on queries, the smallest value wins.
   *
   * @generated from field: int64 sql_select_limit = 8;
   */
  sqlSelectLimit?: string;

  /**
   * @generated from field: query.ExecuteOptions.TransactionIsolation transaction_isolation = 9;
   */
  transactionIsolation?: ExecuteOptions_TransactionIsolationJson;

  /**
   * skip_query_plan_cache specifies if the query plan should be cached by vitess.
   * By default all query plans are cached.
   *
   * @generated from field: bool skip_query_plan_cache = 10;
   */
  skipQueryPlanCache?: boolean;

  /**
   * PlannerVersion specifies which planner to use.
   * If DEFAULT is chosen, whatever vtgate was started with will be used
   *
   * @generated from field: query.ExecuteOptions.PlannerVersion planner_version = 11;
   */
  plannerVersion?: ExecuteOptions_PlannerVersionJson;

  /**
   * has_created_temp_tables signals whether plans created in this session should be cached or not
   * if the user has created temp tables, Vitess will not reuse plans created for this session in other sessions.
   * The current session can still use other sessions cached plans.
   *
   * @generated from field: bool has_created_temp_tables = 12;
   */
  hasCreatedTempTables?: boolean;

  /**
   * @generated from field: query.ExecuteOptions.Consolidator consolidator = 13;
   */
  consolidator?: ExecuteOptions_ConsolidatorJson;

  /**
   * TransactionAccessMode specifies the access modes to be used while starting the transaction i.e. READ WRITE/READ ONLY/WITH CONSISTENT SNAPSHOT
   * If not specified, the transaction will be started with the default access mode on the connection.
   *
   * @generated from field: repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode = 14;
   */
  transactionAccessMode?: ExecuteOptions_TransactionAccessModeJson[];

  /**
   * WorkloadName specifies the name of the workload as indicated in query directives. This is used for instrumentation
   * in metrics and tracing spans.
   *
   * @generated from field: string WorkloadName = 15;
   */
  WorkloadName?: string;

  /**
   * priority specifies the priority of the query, between 0 and 100. This is leveraged by the transaction
   * throttler to determine whether, under resource contention, a query should or should not be throttled.
   *
   * @generated from field: string priority = 16;
   */
  priority?: string;

  /**
   * @generated from field: int64 authoritative_timeout = 17;
   */
  authoritativeTimeout?: string;
};

/**
 * Describes the message query.ExecuteOptions.
 * Use `create(ExecuteOptionsSchema)` to create a new message.
 */
export const ExecuteOptionsSchema: GenMessage<ExecuteOptions, ExecuteOptionsJson> = /*@__PURE__*/
  messageDesc(file_query, 6);

/**
 * @generated from enum query.ExecuteOptions.IncludedFields
 */
export enum ExecuteOptions_IncludedFields {
  /**
   * @generated from enum value: TYPE_AND_NAME = 0;
   */
  TYPE_AND_NAME = 0,

  /**
   * @generated from enum value: TYPE_ONLY = 1;
   */
  TYPE_ONLY = 1,

  /**
   * @generated from enum value: ALL = 2;
   */
  ALL = 2,
}

/**
 * @generated from enum query.ExecuteOptions.IncludedFields
 */
export type ExecuteOptions_IncludedFieldsJson = "TYPE_AND_NAME" | "TYPE_ONLY" | "ALL";

/**
 * Describes the enum query.ExecuteOptions.IncludedFields.
 */
export const ExecuteOptions_IncludedFieldsSchema: GenEnum<ExecuteOptions_IncludedFields, ExecuteOptions_IncludedFieldsJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 0);

/**
 * @generated from enum query.ExecuteOptions.Workload
 */
export enum ExecuteOptions_Workload {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OLTP = 1;
   */
  OLTP = 1,

  /**
   * @generated from enum value: OLAP = 2;
   */
  OLAP = 2,

  /**
   * @generated from enum value: DBA = 3;
   */
  DBA = 3,
}

/**
 * @generated from enum query.ExecuteOptions.Workload
 */
export type ExecuteOptions_WorkloadJson = "UNSPECIFIED" | "OLTP" | "OLAP" | "DBA";

/**
 * Describes the enum query.ExecuteOptions.Workload.
 */
export const ExecuteOptions_WorkloadSchema: GenEnum<ExecuteOptions_Workload, ExecuteOptions_WorkloadJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 1);

/**
 * @generated from enum query.ExecuteOptions.TransactionIsolation
 */
export enum ExecuteOptions_TransactionIsolation {
  /**
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: REPEATABLE_READ = 1;
   */
  REPEATABLE_READ = 1,

  /**
   * @generated from enum value: READ_COMMITTED = 2;
   */
  READ_COMMITTED = 2,

  /**
   * @generated from enum value: READ_UNCOMMITTED = 3;
   */
  READ_UNCOMMITTED = 3,

  /**
   * @generated from enum value: SERIALIZABLE = 4;
   */
  SERIALIZABLE = 4,

  /**
   * This is not an "official" transaction level but it will do a
   * START TRANSACTION WITH CONSISTENT SNAPSHOT, READ ONLY
   *
   * @generated from enum value: CONSISTENT_SNAPSHOT_READ_ONLY = 5;
   */
  CONSISTENT_SNAPSHOT_READ_ONLY = 5,

  /**
   * This not an "official" transaction level, it will send queries to mysql
   * without wrapping them in a transaction
   *
   * @generated from enum value: AUTOCOMMIT = 6;
   */
  AUTOCOMMIT = 6,
}

/**
 * @generated from enum query.ExecuteOptions.TransactionIsolation
 */
export type ExecuteOptions_TransactionIsolationJson = "DEFAULT" | "REPEATABLE_READ" | "READ_COMMITTED" | "READ_UNCOMMITTED" | "SERIALIZABLE" | "CONSISTENT_SNAPSHOT_READ_ONLY" | "AUTOCOMMIT";

/**
 * Describes the enum query.ExecuteOptions.TransactionIsolation.
 */
export const ExecuteOptions_TransactionIsolationSchema: GenEnum<ExecuteOptions_TransactionIsolation, ExecuteOptions_TransactionIsolationJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 2);

/**
 * @generated from enum query.ExecuteOptions.PlannerVersion
 */
export enum ExecuteOptions_PlannerVersion {
  /**
   * @generated from enum value: DEFAULT_PLANNER = 0;
   */
  DEFAULT_PLANNER = 0,

  /**
   * @generated from enum value: V3 = 1;
   */
  V3 = 1,

  /**
   * @generated from enum value: Gen4 = 2;
   */
  Gen4 = 2,

  /**
   * @generated from enum value: Gen4Greedy = 3;
   */
  Gen4Greedy = 3,

  /**
   * @generated from enum value: Gen4Left2Right = 4;
   */
  Gen4Left2Right = 4,

  /**
   * @generated from enum value: Gen4WithFallback = 5;
   */
  Gen4WithFallback = 5,

  /**
   * @generated from enum value: Gen4CompareV3 = 6;
   */
  Gen4CompareV3 = 6,

  /**
   * @generated from enum value: V3Insert = 7;
   */
  V3Insert = 7,
}

/**
 * @generated from enum query.ExecuteOptions.PlannerVersion
 */
export type ExecuteOptions_PlannerVersionJson = "DEFAULT_PLANNER" | "V3" | "Gen4" | "Gen4Greedy" | "Gen4Left2Right" | "Gen4WithFallback" | "Gen4CompareV3" | "V3Insert";

/**
 * Describes the enum query.ExecuteOptions.PlannerVersion.
 */
export const ExecuteOptions_PlannerVersionSchema: GenEnum<ExecuteOptions_PlannerVersion, ExecuteOptions_PlannerVersionJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 3);

/**
 * @generated from enum query.ExecuteOptions.Consolidator
 */
export enum ExecuteOptions_Consolidator {
  /**
   * @generated from enum value: CONSOLIDATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CONSOLIDATOR_DISABLED = 1;
   */
  DISABLED = 1,

  /**
   * @generated from enum value: CONSOLIDATOR_ENABLED = 2;
   */
  ENABLED = 2,

  /**
   * @generated from enum value: CONSOLIDATOR_ENABLED_REPLICAS = 3;
   */
  ENABLED_REPLICAS = 3,
}

/**
 * @generated from enum query.ExecuteOptions.Consolidator
 */
export type ExecuteOptions_ConsolidatorJson = "CONSOLIDATOR_UNSPECIFIED" | "CONSOLIDATOR_DISABLED" | "CONSOLIDATOR_ENABLED" | "CONSOLIDATOR_ENABLED_REPLICAS";

/**
 * Describes the enum query.ExecuteOptions.Consolidator.
 */
export const ExecuteOptions_ConsolidatorSchema: GenEnum<ExecuteOptions_Consolidator, ExecuteOptions_ConsolidatorJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 4);

/**
 * @generated from enum query.ExecuteOptions.TransactionAccessMode
 */
export enum ExecuteOptions_TransactionAccessMode {
  /**
   * @generated from enum value: CONSISTENT_SNAPSHOT = 0;
   */
  CONSISTENT_SNAPSHOT = 0,

  /**
   * @generated from enum value: READ_WRITE = 1;
   */
  READ_WRITE = 1,

  /**
   * @generated from enum value: READ_ONLY = 2;
   */
  READ_ONLY = 2,
}

/**
 * @generated from enum query.ExecuteOptions.TransactionAccessMode
 */
export type ExecuteOptions_TransactionAccessModeJson = "CONSISTENT_SNAPSHOT" | "READ_WRITE" | "READ_ONLY";

/**
 * Describes the enum query.ExecuteOptions.TransactionAccessMode.
 */
export const ExecuteOptions_TransactionAccessModeSchema: GenEnum<ExecuteOptions_TransactionAccessMode, ExecuteOptions_TransactionAccessModeJson> = /*@__PURE__*/
  enumDesc(file_query, 6, 5);

/**
 * Field describes a single column returned by a query
 *
 * @generated from message query.Field
 */
export type Field = Message<"query.Field"> & {
  /**
   * name of the field as returned by mysql C API
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * vitess-defined type. Conversion function is in sqltypes package.
   *
   * @generated from field: query.Type type = 2;
   */
  type: Type;

  /**
   * Remaining fields from mysql C API.
   * These fields are only populated when ExecuteOptions.included_fields
   * is set to IncludedFields.ALL.
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * @generated from field: string org_table = 4;
   */
  orgTable: string;

  /**
   * @generated from field: string database = 5;
   */
  database: string;

  /**
   * @generated from field: string org_name = 6;
   */
  orgName: string;

  /**
   * column_length is really a uint32. All 32 bits can be used.
   *
   * @generated from field: uint32 column_length = 7;
   */
  columnLength: number;

  /**
   * charset is actually a uint16. Only the lower 16 bits are used.
   *
   * @generated from field: uint32 charset = 8;
   */
  charset: number;

  /**
   * decimals is actually a uint8. Only the lower 8 bits are used.
   *
   * @generated from field: uint32 decimals = 9;
   */
  decimals: number;

  /**
   * flags is actually a uint16. Only the lower 16 bits are used.
   *
   * @generated from field: uint32 flags = 10;
   */
  flags: number;

  /**
   * column_type is optionally populated from information_schema.columns
   *
   * @generated from field: string column_type = 11;
   */
  columnType: string;
};

/**
 * Field describes a single column returned by a query
 *
 * @generated from message query.Field
 */
export type FieldJson = {
  /**
   * name of the field as returned by mysql C API
   *
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * vitess-defined type. Conversion function is in sqltypes package.
   *
   * @generated from field: query.Type type = 2;
   */
  type?: TypeJson;

  /**
   * Remaining fields from mysql C API.
   * These fields are only populated when ExecuteOptions.included_fields
   * is set to IncludedFields.ALL.
   *
   * @generated from field: string table = 3;
   */
  table?: string;

  /**
   * @generated from field: string org_table = 4;
   */
  orgTable?: string;

  /**
   * @generated from field: string database = 5;
   */
  database?: string;

  /**
   * @generated from field: string org_name = 6;
   */
  orgName?: string;

  /**
   * column_length is really a uint32. All 32 bits can be used.
   *
   * @generated from field: uint32 column_length = 7;
   */
  columnLength?: number;

  /**
   * charset is actually a uint16. Only the lower 16 bits are used.
   *
   * @generated from field: uint32 charset = 8;
   */
  charset?: number;

  /**
   * decimals is actually a uint8. Only the lower 8 bits are used.
   *
   * @generated from field: uint32 decimals = 9;
   */
  decimals?: number;

  /**
   * flags is actually a uint16. Only the lower 16 bits are used.
   *
   * @generated from field: uint32 flags = 10;
   */
  flags?: number;

  /**
   * column_type is optionally populated from information_schema.columns
   *
   * @generated from field: string column_type = 11;
   */
  columnType?: string;
};

/**
 * Describes the message query.Field.
 * Use `create(FieldSchema)` to create a new message.
 */
export const FieldSchema: GenMessage<Field, FieldJson> = /*@__PURE__*/
  messageDesc(file_query, 7);

/**
 * Row is a database row.
 *
 * @generated from message query.Row
 */
export type Row = Message<"query.Row"> & {
  /**
   * lengths contains the length of each value in values.
   * A length of -1 means that the field is NULL. While
   * reading values, you have to accummulate the length
   * to know the offset where the next value begins in values.
   *
   * @generated from field: repeated sint64 lengths = 1;
   */
  lengths: bigint[];

  /**
   * values contains a concatenation of all values in the row.
   *
   * @generated from field: bytes values = 2;
   */
  values: Uint8Array;
};

/**
 * Row is a database row.
 *
 * @generated from message query.Row
 */
export type RowJson = {
  /**
   * lengths contains the length of each value in values.
   * A length of -1 means that the field is NULL. While
   * reading values, you have to accummulate the length
   * to know the offset where the next value begins in values.
   *
   * @generated from field: repeated sint64 lengths = 1;
   */
  lengths?: string[];

  /**
   * values contains a concatenation of all values in the row.
   *
   * @generated from field: bytes values = 2;
   */
  values?: string;
};

/**
 * Describes the message query.Row.
 * Use `create(RowSchema)` to create a new message.
 */
export const RowSchema: GenMessage<Row, RowJson> = /*@__PURE__*/
  messageDesc(file_query, 8);

/**
 * QueryResult is returned by Execute and ExecuteStream.
 *
 * As returned by Execute, len(fields) is always equal to len(row)
 * (for each row in rows).
 *
 * As returned by StreamExecute, the first QueryResult has the fields
 * set, and subsequent QueryResult have rows set. And as Execute,
 * len(QueryResult[0].fields) is always equal to len(row) (for each
 * row in rows for each QueryResult in QueryResult[1:]).
 *
 * @generated from message query.QueryResult
 */
export type QueryResult = Message<"query.QueryResult"> & {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields: Field[];

  /**
   * @generated from field: uint64 rows_affected = 2;
   */
  rowsAffected: bigint;

  /**
   * @generated from field: uint64 insert_id = 3;
   */
  insertId: bigint;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows: Row[];

  /**
   * @generated from field: string info = 6;
   */
  info: string;

  /**
   * @generated from field: string session_state_changes = 7;
   */
  sessionStateChanges: string;
};

/**
 * QueryResult is returned by Execute and ExecuteStream.
 *
 * As returned by Execute, len(fields) is always equal to len(row)
 * (for each row in rows).
 *
 * As returned by StreamExecute, the first QueryResult has the fields
 * set, and subsequent QueryResult have rows set. And as Execute,
 * len(QueryResult[0].fields) is always equal to len(row) (for each
 * row in rows for each QueryResult in QueryResult[1:]).
 *
 * @generated from message query.QueryResult
 */
export type QueryResultJson = {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: uint64 rows_affected = 2;
   */
  rowsAffected?: string;

  /**
   * @generated from field: uint64 insert_id = 3;
   */
  insertId?: string;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows?: RowJson[];

  /**
   * @generated from field: string info = 6;
   */
  info?: string;

  /**
   * @generated from field: string session_state_changes = 7;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.QueryResult.
 * Use `create(QueryResultSchema)` to create a new message.
 */
export const QueryResultSchema: GenMessage<QueryResult, QueryResultJson> = /*@__PURE__*/
  messageDesc(file_query, 9);

/**
 * QueryWarning is used to convey out of band query execution warnings
 * by storing in the vtgate.Session
 *
 * @generated from message query.QueryWarning
 */
export type QueryWarning = Message<"query.QueryWarning"> & {
  /**
   * @generated from field: uint32 code = 1;
   */
  code: number;

  /**
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * QueryWarning is used to convey out of band query execution warnings
 * by storing in the vtgate.Session
 *
 * @generated from message query.QueryWarning
 */
export type QueryWarningJson = {
  /**
   * @generated from field: uint32 code = 1;
   */
  code?: number;

  /**
   * @generated from field: string message = 2;
   */
  message?: string;
};

/**
 * Describes the message query.QueryWarning.
 * Use `create(QueryWarningSchema)` to create a new message.
 */
export const QueryWarningSchema: GenMessage<QueryWarning, QueryWarningJson> = /*@__PURE__*/
  messageDesc(file_query, 10);

/**
 * StreamEvent describes a set of transformations that happened as a
 * single transactional unit on a server. It is streamed back by the
 * Update Stream calls.
 *
 * @generated from message query.StreamEvent
 */
export type StreamEvent = Message<"query.StreamEvent"> & {
  /**
   * The statements in this transaction.
   *
   * @generated from field: repeated query.StreamEvent.Statement statements = 1;
   */
  statements: StreamEvent_Statement[];

  /**
   * The Event Token for this event.
   *
   * @generated from field: query.EventToken event_token = 2;
   */
  eventToken?: EventToken;
};

/**
 * StreamEvent describes a set of transformations that happened as a
 * single transactional unit on a server. It is streamed back by the
 * Update Stream calls.
 *
 * @generated from message query.StreamEvent
 */
export type StreamEventJson = {
  /**
   * The statements in this transaction.
   *
   * @generated from field: repeated query.StreamEvent.Statement statements = 1;
   */
  statements?: StreamEvent_StatementJson[];

  /**
   * The Event Token for this event.
   *
   * @generated from field: query.EventToken event_token = 2;
   */
  eventToken?: EventTokenJson;
};

/**
 * Describes the message query.StreamEvent.
 * Use `create(StreamEventSchema)` to create a new message.
 */
export const StreamEventSchema: GenMessage<StreamEvent, StreamEventJson> = /*@__PURE__*/
  messageDesc(file_query, 11);

/**
 * One individual Statement in a transaction.
 *
 * @generated from message query.StreamEvent.Statement
 */
export type StreamEvent_Statement = Message<"query.StreamEvent.Statement"> & {
  /**
   * @generated from field: query.StreamEvent.Statement.Category category = 1;
   */
  category: StreamEvent_Statement_Category;

  /**
   * table_name, primary_key_fields and primary_key_values are set for DML.
   *
   * @generated from field: string table_name = 2;
   */
  tableName: string;

  /**
   * @generated from field: repeated query.Field primary_key_fields = 3;
   */
  primaryKeyFields: Field[];

  /**
   * @generated from field: repeated query.Row primary_key_values = 4;
   */
  primaryKeyValues: Row[];

  /**
   * sql is set for all queries.
   * FIXME(alainjobart) we may not need it for DMLs.
   *
   * @generated from field: bytes sql = 5;
   */
  sql: Uint8Array;
};

/**
 * One individual Statement in a transaction.
 *
 * @generated from message query.StreamEvent.Statement
 */
export type StreamEvent_StatementJson = {
  /**
   * @generated from field: query.StreamEvent.Statement.Category category = 1;
   */
  category?: StreamEvent_Statement_CategoryJson;

  /**
   * table_name, primary_key_fields and primary_key_values are set for DML.
   *
   * @generated from field: string table_name = 2;
   */
  tableName?: string;

  /**
   * @generated from field: repeated query.Field primary_key_fields = 3;
   */
  primaryKeyFields?: FieldJson[];

  /**
   * @generated from field: repeated query.Row primary_key_values = 4;
   */
  primaryKeyValues?: RowJson[];

  /**
   * sql is set for all queries.
   * FIXME(alainjobart) we may not need it for DMLs.
   *
   * @generated from field: bytes sql = 5;
   */
  sql?: string;
};

/**
 * Describes the message query.StreamEvent.Statement.
 * Use `create(StreamEvent_StatementSchema)` to create a new message.
 */
export const StreamEvent_StatementSchema: GenMessage<StreamEvent_Statement, StreamEvent_StatementJson> = /*@__PURE__*/
  messageDesc(file_query, 11, 0);

/**
 * The category of one statement.
 *
 * @generated from enum query.StreamEvent.Statement.Category
 */
export enum StreamEvent_Statement_Category {
  /**
   * @generated from enum value: Error = 0;
   */
  Error = 0,

  /**
   * @generated from enum value: DML = 1;
   */
  DML = 1,

  /**
   * @generated from enum value: DDL = 2;
   */
  DDL = 2,
}

/**
 * The category of one statement.
 *
 * @generated from enum query.StreamEvent.Statement.Category
 */
export type StreamEvent_Statement_CategoryJson = "Error" | "DML" | "DDL";

/**
 * Describes the enum query.StreamEvent.Statement.Category.
 */
export const StreamEvent_Statement_CategorySchema: GenEnum<StreamEvent_Statement_Category, StreamEvent_Statement_CategoryJson> = /*@__PURE__*/
  enumDesc(file_query, 11, 0, 0);

/**
 * ExecuteRequest is the payload to Execute
 *
 * @generated from message query.ExecuteRequest
 */
export type ExecuteRequest = Message<"query.ExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: int64 transaction_id = 5;
   */
  transactionId: bigint;

  /**
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId: bigint;
};

/**
 * ExecuteRequest is the payload to Execute
 *
 * @generated from message query.ExecuteRequest
 */
export type ExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: int64 transaction_id = 5;
   */
  transactionId?: string;

  /**
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId?: string;
};

/**
 * Describes the message query.ExecuteRequest.
 * Use `create(ExecuteRequestSchema)` to create a new message.
 */
export const ExecuteRequestSchema: GenMessage<ExecuteRequest, ExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 12);

/**
 * ExecuteResponse is the returned value from Execute
 *
 * @generated from message query.ExecuteResponse
 */
export type ExecuteResponse = Message<"query.ExecuteResponse"> & {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * ExecuteResponse is the returned value from Execute
 *
 * @generated from message query.ExecuteResponse
 */
export type ExecuteResponseJson = {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message query.ExecuteResponse.
 * Use `create(ExecuteResponseSchema)` to create a new message.
 */
export const ExecuteResponseSchema: GenMessage<ExecuteResponse, ExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 13);

/**
 * ResultWithError represents a query response
 * in the form of result or error but not both.
 * TODO: To be used in ExecuteBatchResponse and BeginExecuteBatchResponse.
 *
 * @generated from message query.ResultWithError
 */
export type ResultWithError = Message<"query.ResultWithError"> & {
  /**
   * error contains an query level error, only set if result is unset.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * result contains the query result, only set if error is unset.
   *
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;
};

/**
 * ResultWithError represents a query response
 * in the form of result or error but not both.
 * TODO: To be used in ExecuteBatchResponse and BeginExecuteBatchResponse.
 *
 * @generated from message query.ResultWithError
 */
export type ResultWithErrorJson = {
  /**
   * error contains an query level error, only set if result is unset.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * result contains the query result, only set if error is unset.
   *
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message query.ResultWithError.
 * Use `create(ResultWithErrorSchema)` to create a new message.
 */
export const ResultWithErrorSchema: GenMessage<ResultWithError, ResultWithErrorJson> = /*@__PURE__*/
  messageDesc(file_query, 14);

/**
 * StreamExecuteRequest is the payload to StreamExecute
 *
 * @generated from message query.StreamExecuteRequest
 */
export type StreamExecuteRequest = Message<"query.StreamExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: int64 transaction_id = 6;
   */
  transactionId: bigint;

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId: bigint;
};

/**
 * StreamExecuteRequest is the payload to StreamExecute
 *
 * @generated from message query.StreamExecuteRequest
 */
export type StreamExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: int64 transaction_id = 6;
   */
  transactionId?: string;

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId?: string;
};

/**
 * Describes the message query.StreamExecuteRequest.
 * Use `create(StreamExecuteRequestSchema)` to create a new message.
 */
export const StreamExecuteRequestSchema: GenMessage<StreamExecuteRequest, StreamExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 15);

/**
 * StreamExecuteResponse is the returned value from StreamExecute
 *
 * @generated from message query.StreamExecuteResponse
 */
export type StreamExecuteResponse = Message<"query.StreamExecuteResponse"> & {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * StreamExecuteResponse is the returned value from StreamExecute
 *
 * @generated from message query.StreamExecuteResponse
 */
export type StreamExecuteResponseJson = {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message query.StreamExecuteResponse.
 * Use `create(StreamExecuteResponseSchema)` to create a new message.
 */
export const StreamExecuteResponseSchema: GenMessage<StreamExecuteResponse, StreamExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 16);

/**
 * BeginRequest is the payload to Begin
 *
 * @generated from message query.BeginRequest
 */
export type BeginRequest = Message<"query.BeginRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.ExecuteOptions options = 4;
   */
  options?: ExecuteOptions;
};

/**
 * BeginRequest is the payload to Begin
 *
 * @generated from message query.BeginRequest
 */
export type BeginRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.ExecuteOptions options = 4;
   */
  options?: ExecuteOptionsJson;
};

/**
 * Describes the message query.BeginRequest.
 * Use `create(BeginRequestSchema)` to create a new message.
 */
export const BeginRequestSchema: GenMessage<BeginRequest, BeginRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 17);

/**
 * BeginResponse is the returned value from Begin
 *
 * @generated from message query.BeginResponse
 */
export type BeginResponse = Message<"query.BeginResponse"> & {
  /**
   * @generated from field: int64 transaction_id = 1;
   */
  transactionId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 2;
   */
  tabletAlias?: TabletAlias;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 3;
   */
  sessionStateChanges: string;
};

/**
 * BeginResponse is the returned value from Begin
 *
 * @generated from message query.BeginResponse
 */
export type BeginResponseJson = {
  /**
   * @generated from field: int64 transaction_id = 1;
   */
  transactionId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 2;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 3;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.BeginResponse.
 * Use `create(BeginResponseSchema)` to create a new message.
 */
export const BeginResponseSchema: GenMessage<BeginResponse, BeginResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 18);

/**
 * CommitRequest is the payload to Commit
 *
 * @generated from message query.CommitRequest
 */
export type CommitRequest = Message<"query.CommitRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;
};

/**
 * CommitRequest is the payload to Commit
 *
 * @generated from message query.CommitRequest
 */
export type CommitRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;
};

/**
 * Describes the message query.CommitRequest.
 * Use `create(CommitRequestSchema)` to create a new message.
 */
export const CommitRequestSchema: GenMessage<CommitRequest, CommitRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 19);

/**
 * CommitResponse is the returned value from Commit
 *
 * @generated from message query.CommitResponse
 */
export type CommitResponse = Message<"query.CommitResponse"> & {
  /**
   * @generated from field: int64 reserved_id = 1;
   */
  reservedId: bigint;
};

/**
 * CommitResponse is the returned value from Commit
 *
 * @generated from message query.CommitResponse
 */
export type CommitResponseJson = {
  /**
   * @generated from field: int64 reserved_id = 1;
   */
  reservedId?: string;
};

/**
 * Describes the message query.CommitResponse.
 * Use `create(CommitResponseSchema)` to create a new message.
 */
export const CommitResponseSchema: GenMessage<CommitResponse, CommitResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 20);

/**
 * RollbackRequest is the payload to Rollback
 *
 * @generated from message query.RollbackRequest
 */
export type RollbackRequest = Message<"query.RollbackRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;
};

/**
 * RollbackRequest is the payload to Rollback
 *
 * @generated from message query.RollbackRequest
 */
export type RollbackRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;
};

/**
 * Describes the message query.RollbackRequest.
 * Use `create(RollbackRequestSchema)` to create a new message.
 */
export const RollbackRequestSchema: GenMessage<RollbackRequest, RollbackRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 21);

/**
 * RollbackResponse is the returned value from Rollback
 *
 * @generated from message query.RollbackResponse
 */
export type RollbackResponse = Message<"query.RollbackResponse"> & {
  /**
   * @generated from field: int64 reserved_id = 1;
   */
  reservedId: bigint;
};

/**
 * RollbackResponse is the returned value from Rollback
 *
 * @generated from message query.RollbackResponse
 */
export type RollbackResponseJson = {
  /**
   * @generated from field: int64 reserved_id = 1;
   */
  reservedId?: string;
};

/**
 * Describes the message query.RollbackResponse.
 * Use `create(RollbackResponseSchema)` to create a new message.
 */
export const RollbackResponseSchema: GenMessage<RollbackResponse, RollbackResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 22);

/**
 * PrepareRequest is the payload to Prepare
 *
 * @generated from message query.PrepareRequest
 */
export type PrepareRequest = Message<"query.PrepareRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid: string;
};

/**
 * PrepareRequest is the payload to Prepare
 *
 * @generated from message query.PrepareRequest
 */
export type PrepareRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid?: string;
};

/**
 * Describes the message query.PrepareRequest.
 * Use `create(PrepareRequestSchema)` to create a new message.
 */
export const PrepareRequestSchema: GenMessage<PrepareRequest, PrepareRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 23);

/**
 * PrepareResponse is the returned value from Prepare
 *
 * @generated from message query.PrepareResponse
 */
export type PrepareResponse = Message<"query.PrepareResponse"> & {
};

/**
 * PrepareResponse is the returned value from Prepare
 *
 * @generated from message query.PrepareResponse
 */
export type PrepareResponseJson = {
};

/**
 * Describes the message query.PrepareResponse.
 * Use `create(PrepareResponseSchema)` to create a new message.
 */
export const PrepareResponseSchema: GenMessage<PrepareResponse, PrepareResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 24);

/**
 * CommitPreparedRequest is the payload to CommitPrepared
 *
 * @generated from message query.CommitPreparedRequest
 */
export type CommitPreparedRequest = Message<"query.CommitPreparedRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid: string;
};

/**
 * CommitPreparedRequest is the payload to CommitPrepared
 *
 * @generated from message query.CommitPreparedRequest
 */
export type CommitPreparedRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid?: string;
};

/**
 * Describes the message query.CommitPreparedRequest.
 * Use `create(CommitPreparedRequestSchema)` to create a new message.
 */
export const CommitPreparedRequestSchema: GenMessage<CommitPreparedRequest, CommitPreparedRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 25);

/**
 * CommitPreparedResponse is the returned value from CommitPrepared
 *
 * @generated from message query.CommitPreparedResponse
 */
export type CommitPreparedResponse = Message<"query.CommitPreparedResponse"> & {
};

/**
 * CommitPreparedResponse is the returned value from CommitPrepared
 *
 * @generated from message query.CommitPreparedResponse
 */
export type CommitPreparedResponseJson = {
};

/**
 * Describes the message query.CommitPreparedResponse.
 * Use `create(CommitPreparedResponseSchema)` to create a new message.
 */
export const CommitPreparedResponseSchema: GenMessage<CommitPreparedResponse, CommitPreparedResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 26);

/**
 * RollbackPreparedRequest is the payload to RollbackPrepared
 *
 * @generated from message query.RollbackPreparedRequest
 */
export type RollbackPreparedRequest = Message<"query.RollbackPreparedRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid: string;
};

/**
 * RollbackPreparedRequest is the payload to RollbackPrepared
 *
 * @generated from message query.RollbackPreparedRequest
 */
export type RollbackPreparedRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid?: string;
};

/**
 * Describes the message query.RollbackPreparedRequest.
 * Use `create(RollbackPreparedRequestSchema)` to create a new message.
 */
export const RollbackPreparedRequestSchema: GenMessage<RollbackPreparedRequest, RollbackPreparedRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 27);

/**
 * RollbackPreparedResponse is the returned value from RollbackPrepared
 *
 * @generated from message query.RollbackPreparedResponse
 */
export type RollbackPreparedResponse = Message<"query.RollbackPreparedResponse"> & {
};

/**
 * RollbackPreparedResponse is the returned value from RollbackPrepared
 *
 * @generated from message query.RollbackPreparedResponse
 */
export type RollbackPreparedResponseJson = {
};

/**
 * Describes the message query.RollbackPreparedResponse.
 * Use `create(RollbackPreparedResponseSchema)` to create a new message.
 */
export const RollbackPreparedResponseSchema: GenMessage<RollbackPreparedResponse, RollbackPreparedResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 28);

/**
 * CreateTransactionRequest is the payload to CreateTransaction
 *
 * @generated from message query.CreateTransactionRequest
 */
export type CreateTransactionRequest = Message<"query.CreateTransactionRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid: string;

  /**
   * @generated from field: repeated query.Target participants = 5;
   */
  participants: Target[];
};

/**
 * CreateTransactionRequest is the payload to CreateTransaction
 *
 * @generated from message query.CreateTransactionRequest
 */
export type CreateTransactionRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid?: string;

  /**
   * @generated from field: repeated query.Target participants = 5;
   */
  participants?: TargetJson[];
};

/**
 * Describes the message query.CreateTransactionRequest.
 * Use `create(CreateTransactionRequestSchema)` to create a new message.
 */
export const CreateTransactionRequestSchema: GenMessage<CreateTransactionRequest, CreateTransactionRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 29);

/**
 * CreateTransactionResponse is the returned value from CreateTransaction
 *
 * @generated from message query.CreateTransactionResponse
 */
export type CreateTransactionResponse = Message<"query.CreateTransactionResponse"> & {
};

/**
 * CreateTransactionResponse is the returned value from CreateTransaction
 *
 * @generated from message query.CreateTransactionResponse
 */
export type CreateTransactionResponseJson = {
};

/**
 * Describes the message query.CreateTransactionResponse.
 * Use `create(CreateTransactionResponseSchema)` to create a new message.
 */
export const CreateTransactionResponseSchema: GenMessage<CreateTransactionResponse, CreateTransactionResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 30);

/**
 * StartCommitRequest is the payload to StartCommit
 *
 * @generated from message query.StartCommitRequest
 */
export type StartCommitRequest = Message<"query.StartCommitRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid: string;
};

/**
 * StartCommitRequest is the payload to StartCommit
 *
 * @generated from message query.StartCommitRequest
 */
export type StartCommitRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid?: string;
};

/**
 * Describes the message query.StartCommitRequest.
 * Use `create(StartCommitRequestSchema)` to create a new message.
 */
export const StartCommitRequestSchema: GenMessage<StartCommitRequest, StartCommitRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 31);

/**
 * StartCommitResponse is the returned value from StartCommit
 *
 * @generated from message query.StartCommitResponse
 */
export type StartCommitResponse = Message<"query.StartCommitResponse"> & {
};

/**
 * StartCommitResponse is the returned value from StartCommit
 *
 * @generated from message query.StartCommitResponse
 */
export type StartCommitResponseJson = {
};

/**
 * Describes the message query.StartCommitResponse.
 * Use `create(StartCommitResponseSchema)` to create a new message.
 */
export const StartCommitResponseSchema: GenMessage<StartCommitResponse, StartCommitResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 32);

/**
 * SetRollbackRequest is the payload to SetRollback
 *
 * @generated from message query.SetRollbackRequest
 */
export type SetRollbackRequest = Message<"query.SetRollbackRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid: string;
};

/**
 * SetRollbackRequest is the payload to SetRollback
 *
 * @generated from message query.SetRollbackRequest
 */
export type SetRollbackRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;

  /**
   * @generated from field: string dtid = 5;
   */
  dtid?: string;
};

/**
 * Describes the message query.SetRollbackRequest.
 * Use `create(SetRollbackRequestSchema)` to create a new message.
 */
export const SetRollbackRequestSchema: GenMessage<SetRollbackRequest, SetRollbackRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 33);

/**
 * SetRollbackResponse is the returned value from SetRollback
 *
 * @generated from message query.SetRollbackResponse
 */
export type SetRollbackResponse = Message<"query.SetRollbackResponse"> & {
};

/**
 * SetRollbackResponse is the returned value from SetRollback
 *
 * @generated from message query.SetRollbackResponse
 */
export type SetRollbackResponseJson = {
};

/**
 * Describes the message query.SetRollbackResponse.
 * Use `create(SetRollbackResponseSchema)` to create a new message.
 */
export const SetRollbackResponseSchema: GenMessage<SetRollbackResponse, SetRollbackResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 34);

/**
 * ConcludeTransactionRequest is the payload to ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionRequest
 */
export type ConcludeTransactionRequest = Message<"query.ConcludeTransactionRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid: string;
};

/**
 * ConcludeTransactionRequest is the payload to ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionRequest
 */
export type ConcludeTransactionRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid?: string;
};

/**
 * Describes the message query.ConcludeTransactionRequest.
 * Use `create(ConcludeTransactionRequestSchema)` to create a new message.
 */
export const ConcludeTransactionRequestSchema: GenMessage<ConcludeTransactionRequest, ConcludeTransactionRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 35);

/**
 * ConcludeTransactionResponse is the returned value from ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionResponse
 */
export type ConcludeTransactionResponse = Message<"query.ConcludeTransactionResponse"> & {
};

/**
 * ConcludeTransactionResponse is the returned value from ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionResponse
 */
export type ConcludeTransactionResponseJson = {
};

/**
 * Describes the message query.ConcludeTransactionResponse.
 * Use `create(ConcludeTransactionResponseSchema)` to create a new message.
 */
export const ConcludeTransactionResponseSchema: GenMessage<ConcludeTransactionResponse, ConcludeTransactionResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 36);

/**
 * ReadTransactionRequest is the payload to ReadTransaction
 *
 * @generated from message query.ReadTransactionRequest
 */
export type ReadTransactionRequest = Message<"query.ReadTransactionRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid: string;
};

/**
 * ReadTransactionRequest is the payload to ReadTransaction
 *
 * @generated from message query.ReadTransactionRequest
 */
export type ReadTransactionRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string dtid = 4;
   */
  dtid?: string;
};

/**
 * Describes the message query.ReadTransactionRequest.
 * Use `create(ReadTransactionRequestSchema)` to create a new message.
 */
export const ReadTransactionRequestSchema: GenMessage<ReadTransactionRequest, ReadTransactionRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 37);

/**
 * ReadTransactionResponse is the returned value from ReadTransaction
 *
 * @generated from message query.ReadTransactionResponse
 */
export type ReadTransactionResponse = Message<"query.ReadTransactionResponse"> & {
  /**
   * @generated from field: query.TransactionMetadata metadata = 1;
   */
  metadata?: TransactionMetadata;
};

/**
 * ReadTransactionResponse is the returned value from ReadTransaction
 *
 * @generated from message query.ReadTransactionResponse
 */
export type ReadTransactionResponseJson = {
  /**
   * @generated from field: query.TransactionMetadata metadata = 1;
   */
  metadata?: TransactionMetadataJson;
};

/**
 * Describes the message query.ReadTransactionResponse.
 * Use `create(ReadTransactionResponseSchema)` to create a new message.
 */
export const ReadTransactionResponseSchema: GenMessage<ReadTransactionResponse, ReadTransactionResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 38);

/**
 * UnresolvedTransactionsRequest is the payload to UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsRequest
 */
export type UnresolvedTransactionsRequest = Message<"query.UnresolvedTransactionsRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * Unresolved Transactions older than this (in seconds).
   *
   * @generated from field: int64 abandon_age = 4;
   */
  abandonAge: bigint;
};

/**
 * UnresolvedTransactionsRequest is the payload to UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsRequest
 */
export type UnresolvedTransactionsRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * Unresolved Transactions older than this (in seconds).
   *
   * @generated from field: int64 abandon_age = 4;
   */
  abandonAge?: string;
};

/**
 * Describes the message query.UnresolvedTransactionsRequest.
 * Use `create(UnresolvedTransactionsRequestSchema)` to create a new message.
 */
export const UnresolvedTransactionsRequestSchema: GenMessage<UnresolvedTransactionsRequest, UnresolvedTransactionsRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 39);

/**
 * UnresolvedTransactionsResponse is the returned value from UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsResponse
 */
export type UnresolvedTransactionsResponse = Message<"query.UnresolvedTransactionsResponse"> & {
  /**
   * @generated from field: repeated query.TransactionMetadata transactions = 1;
   */
  transactions: TransactionMetadata[];
};

/**
 * UnresolvedTransactionsResponse is the returned value from UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsResponse
 */
export type UnresolvedTransactionsResponseJson = {
  /**
   * @generated from field: repeated query.TransactionMetadata transactions = 1;
   */
  transactions?: TransactionMetadataJson[];
};

/**
 * Describes the message query.UnresolvedTransactionsResponse.
 * Use `create(UnresolvedTransactionsResponseSchema)` to create a new message.
 */
export const UnresolvedTransactionsResponseSchema: GenMessage<UnresolvedTransactionsResponse, UnresolvedTransactionsResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 40);

/**
 * BeginExecuteRequest is the payload to BeginExecute
 *
 * @generated from message query.BeginExecuteRequest
 */
export type BeginExecuteRequest = Message<"query.BeginExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: int64 reserved_id = 6;
   */
  reservedId: bigint;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries: string[];
};

/**
 * BeginExecuteRequest is the payload to BeginExecute
 *
 * @generated from message query.BeginExecuteRequest
 */
export type BeginExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: int64 reserved_id = 6;
   */
  reservedId?: string;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries?: string[];
};

/**
 * Describes the message query.BeginExecuteRequest.
 * Use `create(BeginExecuteRequestSchema)` to create a new message.
 */
export const BeginExecuteRequestSchema: GenMessage<BeginExecuteRequest, BeginExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 41);

/**
 * BeginExecuteResponse is the returned value from BeginExecute
 *
 * @generated from message query.BeginExecuteResponse
 */
export type BeginExecuteResponse = Message<"query.BeginExecuteResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * transaction_id might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAlias;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 5;
   */
  sessionStateChanges: string;
};

/**
 * BeginExecuteResponse is the returned value from BeginExecute
 *
 * @generated from message query.BeginExecuteResponse
 */
export type BeginExecuteResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * transaction_id might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 5;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.BeginExecuteResponse.
 * Use `create(BeginExecuteResponseSchema)` to create a new message.
 */
export const BeginExecuteResponseSchema: GenMessage<BeginExecuteResponse, BeginExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 42);

/**
 * BeginStreamExecuteRequest is the payload to BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteRequest
 */
export type BeginStreamExecuteRequest = Message<"query.BeginStreamExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries: string[];

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId: bigint;
};

/**
 * BeginStreamExecuteRequest is the payload to BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteRequest
 */
export type BeginStreamExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries?: string[];

  /**
   * @generated from field: int64 reserved_id = 7;
   */
  reservedId?: string;
};

/**
 * Describes the message query.BeginStreamExecuteRequest.
 * Use `create(BeginStreamExecuteRequestSchema)` to create a new message.
 */
export const BeginStreamExecuteRequestSchema: GenMessage<BeginStreamExecuteRequest, BeginStreamExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 43);

/**
 * BeginStreamExecuteResponse is the returned value from BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteResponse
 */
export type BeginStreamExecuteResponse = Message<"query.BeginStreamExecuteResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the stream execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * transaction_id might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAlias;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 5;
   */
  sessionStateChanges: string;
};

/**
 * BeginStreamExecuteResponse is the returned value from BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteResponse
 */
export type BeginStreamExecuteResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the stream execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * transaction_id might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 5;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.BeginStreamExecuteResponse.
 * Use `create(BeginStreamExecuteResponseSchema)` to create a new message.
 */
export const BeginStreamExecuteResponseSchema: GenMessage<BeginStreamExecuteResponse, BeginStreamExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 44);

/**
 * MessageStreamRequest is the request payload for MessageStream.
 *
 * @generated from message query.MessageStreamRequest
 */
export type MessageStreamRequest = Message<"query.MessageStreamRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * name is the message table name.
   *
   * @generated from field: string name = 4;
   */
  name: string;
};

/**
 * MessageStreamRequest is the request payload for MessageStream.
 *
 * @generated from message query.MessageStreamRequest
 */
export type MessageStreamRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * name is the message table name.
   *
   * @generated from field: string name = 4;
   */
  name?: string;
};

/**
 * Describes the message query.MessageStreamRequest.
 * Use `create(MessageStreamRequestSchema)` to create a new message.
 */
export const MessageStreamRequestSchema: GenMessage<MessageStreamRequest, MessageStreamRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 45);

/**
 * MessageStreamResponse is a response for MessageStream.
 *
 * @generated from message query.MessageStreamResponse
 */
export type MessageStreamResponse = Message<"query.MessageStreamResponse"> & {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * MessageStreamResponse is a response for MessageStream.
 *
 * @generated from message query.MessageStreamResponse
 */
export type MessageStreamResponseJson = {
  /**
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message query.MessageStreamResponse.
 * Use `create(MessageStreamResponseSchema)` to create a new message.
 */
export const MessageStreamResponseSchema: GenMessage<MessageStreamResponse, MessageStreamResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 46);

/**
 * MessageAckRequest is the request payload for MessageAck.
 *
 * @generated from message query.MessageAckRequest
 */
export type MessageAckRequest = Message<"query.MessageAckRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * name is the message table name.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * @generated from field: repeated query.Value ids = 5;
   */
  ids: Value[];
};

/**
 * MessageAckRequest is the request payload for MessageAck.
 *
 * @generated from message query.MessageAckRequest
 */
export type MessageAckRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * name is the message table name.
   *
   * @generated from field: string name = 4;
   */
  name?: string;

  /**
   * @generated from field: repeated query.Value ids = 5;
   */
  ids?: ValueJson[];
};

/**
 * Describes the message query.MessageAckRequest.
 * Use `create(MessageAckRequestSchema)` to create a new message.
 */
export const MessageAckRequestSchema: GenMessage<MessageAckRequest, MessageAckRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 47);

/**
 * MessageAckResponse is the response for MessageAck.
 *
 * @generated from message query.MessageAckResponse
 */
export type MessageAckResponse = Message<"query.MessageAckResponse"> & {
  /**
   * result contains the result of the ack operation.
   * Since this acts like a DML, only
   * RowsAffected is returned in the result.
   *
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResult;
};

/**
 * MessageAckResponse is the response for MessageAck.
 *
 * @generated from message query.MessageAckResponse
 */
export type MessageAckResponseJson = {
  /**
   * result contains the result of the ack operation.
   * Since this acts like a DML, only
   * RowsAffected is returned in the result.
   *
   * @generated from field: query.QueryResult result = 1;
   */
  result?: QueryResultJson;
};

/**
 * Describes the message query.MessageAckResponse.
 * Use `create(MessageAckResponseSchema)` to create a new message.
 */
export const MessageAckResponseSchema: GenMessage<MessageAckResponse, MessageAckResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 48);

/**
 * ReserveExecuteRequest is the payload to ReserveExecute
 *
 * @generated from message query.ReserveExecuteRequest
 */
export type ReserveExecuteRequest = Message<"query.ReserveExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: int64 transaction_id = 5;
   */
  transactionId: bigint;

  /**
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries: string[];
};

/**
 * ReserveExecuteRequest is the payload to ReserveExecute
 *
 * @generated from message query.ReserveExecuteRequest
 */
export type ReserveExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: int64 transaction_id = 5;
   */
  transactionId?: string;

  /**
   * @generated from field: query.ExecuteOptions options = 6;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries?: string[];
};

/**
 * Describes the message query.ReserveExecuteRequest.
 * Use `create(ReserveExecuteRequestSchema)` to create a new message.
 */
export const ReserveExecuteRequestSchema: GenMessage<ReserveExecuteRequest, ReserveExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 49);

/**
 * ReserveExecuteResponse is the returned value from ReserveExecute
 *
 * @generated from message query.ReserveExecuteResponse
 */
export type ReserveExecuteResponse = Message<"query.ReserveExecuteResponse"> & {
  /**
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 reserved_id = 3;
   */
  reservedId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAlias;
};

/**
 * ReserveExecuteResponse is the returned value from ReserveExecute
 *
 * @generated from message query.ReserveExecuteResponse
 */
export type ReserveExecuteResponseJson = {
  /**
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 reserved_id = 3;
   */
  reservedId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message query.ReserveExecuteResponse.
 * Use `create(ReserveExecuteResponseSchema)` to create a new message.
 */
export const ReserveExecuteResponseSchema: GenMessage<ReserveExecuteResponse, ReserveExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 50);

/**
 * ReserveStreamExecuteRequest is the payload to ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteRequest
 */
export type ReserveStreamExecuteRequest = Message<"query.ReserveStreamExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: int64 transaction_id = 6;
   */
  transactionId: bigint;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries: string[];
};

/**
 * ReserveStreamExecuteRequest is the payload to ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteRequest
 */
export type ReserveStreamExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: int64 transaction_id = 6;
   */
  transactionId?: string;

  /**
   * @generated from field: repeated string pre_queries = 7;
   */
  preQueries?: string[];
};

/**
 * Describes the message query.ReserveStreamExecuteRequest.
 * Use `create(ReserveStreamExecuteRequestSchema)` to create a new message.
 */
export const ReserveStreamExecuteRequestSchema: GenMessage<ReserveStreamExecuteRequest, ReserveStreamExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 51);

/**
 * ReserveStreamExecuteResponse is the returned value from ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteResponse
 */
export type ReserveStreamExecuteResponse = Message<"query.ReserveStreamExecuteResponse"> & {
  /**
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 reserved_id = 3;
   */
  reservedId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAlias;
};

/**
 * ReserveStreamExecuteResponse is the returned value from ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteResponse
 */
export type ReserveStreamExecuteResponseJson = {
  /**
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 reserved_id = 3;
   */
  reservedId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 4;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message query.ReserveStreamExecuteResponse.
 * Use `create(ReserveStreamExecuteResponseSchema)` to create a new message.
 */
export const ReserveStreamExecuteResponseSchema: GenMessage<ReserveStreamExecuteResponse, ReserveStreamExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 52);

/**
 * ReserveBeginExecuteRequest is the payload to ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteRequest
 */
export type ReserveBeginExecuteRequest = Message<"query.ReserveBeginExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries: string[];

  /**
   * @generated from field: repeated string post_begin_queries = 7;
   */
  postBeginQueries: string[];
};

/**
 * ReserveBeginExecuteRequest is the payload to ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteRequest
 */
export type ReserveBeginExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries?: string[];

  /**
   * @generated from field: repeated string post_begin_queries = 7;
   */
  postBeginQueries?: string[];
};

/**
 * Describes the message query.ReserveBeginExecuteRequest.
 * Use `create(ReserveBeginExecuteRequestSchema)` to create a new message.
 */
export const ReserveBeginExecuteRequestSchema: GenMessage<ReserveBeginExecuteRequest, ReserveBeginExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 53);

/**
 * ReserveBeginExecuteResponse is the returned value from ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteResponse
 */
export type ReserveBeginExecuteResponse = Message<"query.ReserveBeginExecuteResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId: bigint;

  /**
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAlias;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 6;
   */
  sessionStateChanges: string;
};

/**
 * ReserveBeginExecuteResponse is the returned value from ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteResponse
 */
export type ReserveBeginExecuteResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId?: string;

  /**
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 6;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.ReserveBeginExecuteResponse.
 * Use `create(ReserveBeginExecuteResponseSchema)` to create a new message.
 */
export const ReserveBeginExecuteResponseSchema: GenMessage<ReserveBeginExecuteResponse, ReserveBeginExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 54);

/**
 * ReserveBeginStreamExecuteRequest is the payload to ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteRequest
 */
export type ReserveBeginStreamExecuteRequest = Message<"query.ReserveBeginStreamExecuteRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQuery;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptions;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries: string[];

  /**
   * @generated from field: repeated string post_begin_queries = 7;
   */
  postBeginQueries: string[];
};

/**
 * ReserveBeginStreamExecuteRequest is the payload to ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteRequest
 */
export type ReserveBeginStreamExecuteRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.BoundQuery query = 4;
   */
  query?: BoundQueryJson;

  /**
   * @generated from field: query.ExecuteOptions options = 5;
   */
  options?: ExecuteOptionsJson;

  /**
   * @generated from field: repeated string pre_queries = 6;
   */
  preQueries?: string[];

  /**
   * @generated from field: repeated string post_begin_queries = 7;
   */
  postBeginQueries?: string[];
};

/**
 * Describes the message query.ReserveBeginStreamExecuteRequest.
 * Use `create(ReserveBeginStreamExecuteRequestSchema)` to create a new message.
 */
export const ReserveBeginStreamExecuteRequestSchema: GenMessage<ReserveBeginStreamExecuteRequest, ReserveBeginStreamExecuteRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 55);

/**
 * ReserveBeginStreamExecuteResponse is the returned value from ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteResponse
 */
export type ReserveBeginStreamExecuteResponse = Message<"query.ReserveBeginStreamExecuteResponse"> & {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the stream execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCError;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResult;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId: bigint;

  /**
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId: bigint;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAlias;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 6;
   */
  sessionStateChanges: string;
};

/**
 * ReserveBeginStreamExecuteResponse is the returned value from ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteResponse
 */
export type ReserveBeginStreamExecuteResponseJson = {
  /**
   * error contains an application level error if necessary. Note the
   * transaction_id may be set, even when an error is returned, if the begin
   * worked but the stream execute failed.
   *
   * @generated from field: vtrpc.RPCError error = 1;
   */
  error?: RPCErrorJson;

  /**
   * @generated from field: query.QueryResult result = 2;
   */
  result?: QueryResultJson;

  /**
   * The following fields might be non-zero even if an error is present.
   *
   * @generated from field: int64 transaction_id = 3;
   */
  transactionId?: string;

  /**
   * @generated from field: int64 reserved_id = 4;
   */
  reservedId?: string;

  /**
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAliasJson;

  /**
   * The session_state_changes might be set if the transaction is a snapshot transaction
   * and the MySQL implementation supports getting a start gtid on snapshot
   *
   * @generated from field: string session_state_changes = 6;
   */
  sessionStateChanges?: string;
};

/**
 * Describes the message query.ReserveBeginStreamExecuteResponse.
 * Use `create(ReserveBeginStreamExecuteResponseSchema)` to create a new message.
 */
export const ReserveBeginStreamExecuteResponseSchema: GenMessage<ReserveBeginStreamExecuteResponse, ReserveBeginStreamExecuteResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 56);

/**
 * ReleaseRequest is the payload to Release
 *
 * @generated from message query.ReleaseRequest
 */
export type ReleaseRequest = Message<"query.ReleaseRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId: bigint;

  /**
   * @generated from field: int64 reserved_id = 5;
   */
  reservedId: bigint;
};

/**
 * ReleaseRequest is the payload to Release
 *
 * @generated from message query.ReleaseRequest
 */
export type ReleaseRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: int64 transaction_id = 4;
   */
  transactionId?: string;

  /**
   * @generated from field: int64 reserved_id = 5;
   */
  reservedId?: string;
};

/**
 * Describes the message query.ReleaseRequest.
 * Use `create(ReleaseRequestSchema)` to create a new message.
 */
export const ReleaseRequestSchema: GenMessage<ReleaseRequest, ReleaseRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 57);

/**
 * ReleaseResponse is the returned value from Release
 *
 * @generated from message query.ReleaseResponse
 */
export type ReleaseResponse = Message<"query.ReleaseResponse"> & {
};

/**
 * ReleaseResponse is the returned value from Release
 *
 * @generated from message query.ReleaseResponse
 */
export type ReleaseResponseJson = {
};

/**
 * Describes the message query.ReleaseResponse.
 * Use `create(ReleaseResponseSchema)` to create a new message.
 */
export const ReleaseResponseSchema: GenMessage<ReleaseResponse, ReleaseResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 58);

/**
 * StreamHealthRequest is the payload for StreamHealth
 *
 * @generated from message query.StreamHealthRequest
 */
export type StreamHealthRequest = Message<"query.StreamHealthRequest"> & {
};

/**
 * StreamHealthRequest is the payload for StreamHealth
 *
 * @generated from message query.StreamHealthRequest
 */
export type StreamHealthRequestJson = {
};

/**
 * Describes the message query.StreamHealthRequest.
 * Use `create(StreamHealthRequestSchema)` to create a new message.
 */
export const StreamHealthRequestSchema: GenMessage<StreamHealthRequest, StreamHealthRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 59);

/**
 * RealtimeStats contains information about the tablet status.
 * It is only valid for a single tablet.
 *
 * @generated from message query.RealtimeStats
 */
export type RealtimeStats = Message<"query.RealtimeStats"> & {
  /**
   * health_error is the last error we got from health check,
   * or empty is the server is healthy. This is used for subset selection,
   * we do not send queries to servers that are not healthy.
   *
   * @generated from field: string health_error = 1;
   */
  healthError: string;

  /**
   * replication_lag_seconds is populated for replicas only. It indicates
   * how far behind on (MySQL) replication a replica currently is.  It is used
   * by clients for subset selection (so we don't try to send traffic
   * to tablets that are too far behind).
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   * TODO(mberlin): Let's switch it to int64 instead?
   *
   * @generated from field: uint32 replication_lag_seconds = 2;
   */
  replicationLagSeconds: number;

  /**
   * bin_log_players_count is the number of currently running binlog players.
   * if the value is 0, it means that filtered replication is currently not
   * running on the tablet. If >0, filtered replication is running.
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   *
   * @generated from field: int32 binlog_players_count = 3;
   */
  binlogPlayersCount: number;

  /**
   * filtered_replication_lag_seconds is populated for the receiving
   * primary of an ongoing filtered replication only.
   * It specifies how far the receiving primary lags behind the sending primary.
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   * NOTE: This field must not be evaluated if "bin_log_players_count" is 0.
   *
   * @generated from field: int64 filtered_replication_lag_seconds = 4;
   */
  filteredReplicationLagSeconds: bigint;

  /**
   * cpu_usage is used for load-based balancing
   *
   * @generated from field: double cpu_usage = 5;
   */
  cpuUsage: number;

  /**
   * qps is the average QPS (queries per second) rate in the last XX seconds
   * where XX is usually 60 (See query_service_stats.go).
   *
   * @generated from field: double qps = 6;
   */
  qps: number;

  /**
   * table_schema_changed is to provide list of tables that have schema changes detected by the tablet.
   *
   * @generated from field: repeated string table_schema_changed = 7;
   */
  tableSchemaChanged: string[];

  /**
   * view_schema_changed is to provide list of views that have schema changes detected by the tablet.
   *
   * @generated from field: repeated string view_schema_changed = 8;
   */
  viewSchemaChanged: string[];

  /**
   * udfs_changed is used to signal that the UDFs have changed on the tablet.
   *
   * @generated from field: bool udfs_changed = 9;
   */
  udfsChanged: boolean;

  /**
   * @generated from field: bool tx_unresolved = 10;
   */
  txUnresolved: boolean;
};

/**
 * RealtimeStats contains information about the tablet status.
 * It is only valid for a single tablet.
 *
 * @generated from message query.RealtimeStats
 */
export type RealtimeStatsJson = {
  /**
   * health_error is the last error we got from health check,
   * or empty is the server is healthy. This is used for subset selection,
   * we do not send queries to servers that are not healthy.
   *
   * @generated from field: string health_error = 1;
   */
  healthError?: string;

  /**
   * replication_lag_seconds is populated for replicas only. It indicates
   * how far behind on (MySQL) replication a replica currently is.  It is used
   * by clients for subset selection (so we don't try to send traffic
   * to tablets that are too far behind).
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   * TODO(mberlin): Let's switch it to int64 instead?
   *
   * @generated from field: uint32 replication_lag_seconds = 2;
   */
  replicationLagSeconds?: number;

  /**
   * bin_log_players_count is the number of currently running binlog players.
   * if the value is 0, it means that filtered replication is currently not
   * running on the tablet. If >0, filtered replication is running.
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   *
   * @generated from field: int32 binlog_players_count = 3;
   */
  binlogPlayersCount?: number;

  /**
   * filtered_replication_lag_seconds is populated for the receiving
   * primary of an ongoing filtered replication only.
   * It specifies how far the receiving primary lags behind the sending primary.
   * NOTE: This field must not be evaluated if "health_error" is not empty.
   * NOTE: This field must not be evaluated if "bin_log_players_count" is 0.
   *
   * @generated from field: int64 filtered_replication_lag_seconds = 4;
   */
  filteredReplicationLagSeconds?: string;

  /**
   * cpu_usage is used for load-based balancing
   *
   * @generated from field: double cpu_usage = 5;
   */
  cpuUsage?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * qps is the average QPS (queries per second) rate in the last XX seconds
   * where XX is usually 60 (See query_service_stats.go).
   *
   * @generated from field: double qps = 6;
   */
  qps?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * table_schema_changed is to provide list of tables that have schema changes detected by the tablet.
   *
   * @generated from field: repeated string table_schema_changed = 7;
   */
  tableSchemaChanged?: string[];

  /**
   * view_schema_changed is to provide list of views that have schema changes detected by the tablet.
   *
   * @generated from field: repeated string view_schema_changed = 8;
   */
  viewSchemaChanged?: string[];

  /**
   * udfs_changed is used to signal that the UDFs have changed on the tablet.
   *
   * @generated from field: bool udfs_changed = 9;
   */
  udfsChanged?: boolean;

  /**
   * @generated from field: bool tx_unresolved = 10;
   */
  txUnresolved?: boolean;
};

/**
 * Describes the message query.RealtimeStats.
 * Use `create(RealtimeStatsSchema)` to create a new message.
 */
export const RealtimeStatsSchema: GenMessage<RealtimeStats, RealtimeStatsJson> = /*@__PURE__*/
  messageDesc(file_query, 60);

/**
 * AggregateStats contains information about the health of a group of
 * tablets for a Target.  It is used to propagate stats from a vtgate
 * to another, or from the Gateway layer of a vtgate to the routing
 * layer.
 *
 * @generated from message query.AggregateStats
 */
export type AggregateStats = Message<"query.AggregateStats"> & {
  /**
   * healthy_tablet_count is the number of healthy tablets in the group.
   *
   * @generated from field: int32 healthy_tablet_count = 1;
   */
  healthyTabletCount: number;

  /**
   * unhealthy_tablet_count is the number of unhealthy tablets in the group.
   *
   * @generated from field: int32 unhealthy_tablet_count = 2;
   */
  unhealthyTabletCount: number;

  /**
   * replication_lag_seconds_min is the minimum of the
   * replication_lag_seconds values of the healthy tablets. It is unset
   * if the tablet type is primary.
   *
   * @generated from field: uint32 replication_lag_seconds_min = 3;
   */
  replicationLagSecondsMin: number;

  /**
   * replication_lag_seconds_max is the maximum of the
   * replication_lag_seconds values of the healthy tablets. It is unset
   * if the tablet type is primary.
   *
   * @generated from field: uint32 replication_lag_seconds_max = 4;
   */
  replicationLagSecondsMax: number;
};

/**
 * AggregateStats contains information about the health of a group of
 * tablets for a Target.  It is used to propagate stats from a vtgate
 * to another, or from the Gateway layer of a vtgate to the routing
 * layer.
 *
 * @generated from message query.AggregateStats
 */
export type AggregateStatsJson = {
  /**
   * healthy_tablet_count is the number of healthy tablets in the group.
   *
   * @generated from field: int32 healthy_tablet_count = 1;
   */
  healthyTabletCount?: number;

  /**
   * unhealthy_tablet_count is the number of unhealthy tablets in the group.
   *
   * @generated from field: int32 unhealthy_tablet_count = 2;
   */
  unhealthyTabletCount?: number;

  /**
   * replication_lag_seconds_min is the minimum of the
   * replication_lag_seconds values of the healthy tablets. It is unset
   * if the tablet type is primary.
   *
   * @generated from field: uint32 replication_lag_seconds_min = 3;
   */
  replicationLagSecondsMin?: number;

  /**
   * replication_lag_seconds_max is the maximum of the
   * replication_lag_seconds values of the healthy tablets. It is unset
   * if the tablet type is primary.
   *
   * @generated from field: uint32 replication_lag_seconds_max = 4;
   */
  replicationLagSecondsMax?: number;
};

/**
 * Describes the message query.AggregateStats.
 * Use `create(AggregateStatsSchema)` to create a new message.
 */
export const AggregateStatsSchema: GenMessage<AggregateStats, AggregateStatsJson> = /*@__PURE__*/
  messageDesc(file_query, 61);

/**
 * StreamHealthResponse is streamed by StreamHealth on a regular basis.
 * It is expected to be used between a vtgate and vttablet:
 * - target describes the tablet.
 * - realtime_stats is set.
 * - aggregate_stats is not set (deprecated)
 *
 * @generated from message query.StreamHealthResponse
 */
export type StreamHealthResponse = Message<"query.StreamHealthResponse"> & {
  /**
   * target is the current server type. Only queries with that exact Target
   * record will be accepted (the cell may not match, however).
   *
   * @generated from field: query.Target target = 1;
   */
  target?: Target;

  /**
   * serving is true iff the tablet is serving. A tablet may not be serving
   * if filtered replication is enabled on a primary for instance,
   * or if a replica should not be used because the keyspace is being resharded.
   *
   * @generated from field: bool serving = 2;
   */
  serving: boolean;

  /**
   * primary_term_start_timestamp can be interpreted as the
   * last time we knew that this tablet was promoted to a PRIMARY of this shard
   * (if StreamHealthResponse describes a group of tablets, between
   * two vtgates, only one primary will be present in the group, and
   * this is this primary's value).
   *
   * It is used by vtgate when determining the current PRIMARY of a shard.
   * If vtgate sees more than one PRIMARY tablet, this timestamp is used
   * as tiebreaker where the PRIMARY with the highest timestamp wins.
   * Another usage of this timestamp is in go/vt/vtgate/buffer to detect the end
   * of a reparent (failover) and stop buffering.
   *
   * In practice, this field is set to:
   * a) the last time the RPC tabletmanager.TabletExternallyReparented was
   *    called on this tablet (usually done by an external failover tool e.g.
   *    Orchestrator). The failover tool can call this as long as we are the
   *    primary i.e. even ages after the last reparent occurred.
   * OR
   * b) the last time an active reparent was executed through a vtctl command
   *    (InitShardPrimary, PlannedReparentShard, EmergencyReparentShard)
   * OR
   * c) the last time vttablet was started and it initialized its tablet type
   *    as PRIMARY because it was recorded as the shard's current primary in the
   *    topology (see go/vt/vttablet/tabletmanager/init_tablet.go)
   * OR
   * d) 0 if the vttablet is not a PRIMARY.
   *
   * @generated from field: int64 primary_term_start_timestamp = 3;
   */
  primaryTermStartTimestamp: bigint;

  /**
   * realtime_stats contains information about the tablet status.
   * It is only filled in if the information is about a tablet.
   *
   * @generated from field: query.RealtimeStats realtime_stats = 4;
   */
  realtimeStats?: RealtimeStats;

  /**
   * tablet_alias is the alias of the sending tablet. The discovery/healthcheck.go
   * code uses it to verify that it's talking to the correct tablet and that it
   * hasn't changed in the meantime e.g. due to tablet restarts where ports or
   * ips have been reused but assigned differently.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAlias;
};

/**
 * StreamHealthResponse is streamed by StreamHealth on a regular basis.
 * It is expected to be used between a vtgate and vttablet:
 * - target describes the tablet.
 * - realtime_stats is set.
 * - aggregate_stats is not set (deprecated)
 *
 * @generated from message query.StreamHealthResponse
 */
export type StreamHealthResponseJson = {
  /**
   * target is the current server type. Only queries with that exact Target
   * record will be accepted (the cell may not match, however).
   *
   * @generated from field: query.Target target = 1;
   */
  target?: TargetJson;

  /**
   * serving is true iff the tablet is serving. A tablet may not be serving
   * if filtered replication is enabled on a primary for instance,
   * or if a replica should not be used because the keyspace is being resharded.
   *
   * @generated from field: bool serving = 2;
   */
  serving?: boolean;

  /**
   * primary_term_start_timestamp can be interpreted as the
   * last time we knew that this tablet was promoted to a PRIMARY of this shard
   * (if StreamHealthResponse describes a group of tablets, between
   * two vtgates, only one primary will be present in the group, and
   * this is this primary's value).
   *
   * It is used by vtgate when determining the current PRIMARY of a shard.
   * If vtgate sees more than one PRIMARY tablet, this timestamp is used
   * as tiebreaker where the PRIMARY with the highest timestamp wins.
   * Another usage of this timestamp is in go/vt/vtgate/buffer to detect the end
   * of a reparent (failover) and stop buffering.
   *
   * In practice, this field is set to:
   * a) the last time the RPC tabletmanager.TabletExternallyReparented was
   *    called on this tablet (usually done by an external failover tool e.g.
   *    Orchestrator). The failover tool can call this as long as we are the
   *    primary i.e. even ages after the last reparent occurred.
   * OR
   * b) the last time an active reparent was executed through a vtctl command
   *    (InitShardPrimary, PlannedReparentShard, EmergencyReparentShard)
   * OR
   * c) the last time vttablet was started and it initialized its tablet type
   *    as PRIMARY because it was recorded as the shard's current primary in the
   *    topology (see go/vt/vttablet/tabletmanager/init_tablet.go)
   * OR
   * d) 0 if the vttablet is not a PRIMARY.
   *
   * @generated from field: int64 primary_term_start_timestamp = 3;
   */
  primaryTermStartTimestamp?: string;

  /**
   * realtime_stats contains information about the tablet status.
   * It is only filled in if the information is about a tablet.
   *
   * @generated from field: query.RealtimeStats realtime_stats = 4;
   */
  realtimeStats?: RealtimeStatsJson;

  /**
   * tablet_alias is the alias of the sending tablet. The discovery/healthcheck.go
   * code uses it to verify that it's talking to the correct tablet and that it
   * hasn't changed in the meantime e.g. due to tablet restarts where ports or
   * ips have been reused but assigned differently.
   *
   * @generated from field: topodata.TabletAlias tablet_alias = 5;
   */
  tabletAlias?: TabletAliasJson;
};

/**
 * Describes the message query.StreamHealthResponse.
 * Use `create(StreamHealthResponseSchema)` to create a new message.
 */
export const StreamHealthResponseSchema: GenMessage<StreamHealthResponse, StreamHealthResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 62);

/**
 * TransactionMetadata contains the metadata for a distributed transaction.
 *
 * @generated from message query.TransactionMetadata
 */
export type TransactionMetadata = Message<"query.TransactionMetadata"> & {
  /**
   * @generated from field: string dtid = 1;
   */
  dtid: string;

  /**
   * @generated from field: query.TransactionState state = 2;
   */
  state: TransactionState;

  /**
   * @generated from field: int64 time_created = 3;
   */
  timeCreated: bigint;

  /**
   * @generated from field: repeated query.Target participants = 4;
   */
  participants: Target[];
};

/**
 * TransactionMetadata contains the metadata for a distributed transaction.
 *
 * @generated from message query.TransactionMetadata
 */
export type TransactionMetadataJson = {
  /**
   * @generated from field: string dtid = 1;
   */
  dtid?: string;

  /**
   * @generated from field: query.TransactionState state = 2;
   */
  state?: TransactionStateJson;

  /**
   * @generated from field: int64 time_created = 3;
   */
  timeCreated?: string;

  /**
   * @generated from field: repeated query.Target participants = 4;
   */
  participants?: TargetJson[];
};

/**
 * Describes the message query.TransactionMetadata.
 * Use `create(TransactionMetadataSchema)` to create a new message.
 */
export const TransactionMetadataSchema: GenMessage<TransactionMetadata, TransactionMetadataJson> = /*@__PURE__*/
  messageDesc(file_query, 63);

/**
 * GetSchemaRequest is the payload to GetSchema
 *
 * @generated from message query.GetSchemaRequest
 */
export type GetSchemaRequest = Message<"query.GetSchemaRequest"> & {
  /**
   * @generated from field: query.Target target = 1;
   */
  target?: Target;

  /**
   * @generated from field: query.SchemaTableType table_type = 2;
   */
  tableType: SchemaTableType;

  /**
   * @generated from field: repeated string table_names = 3;
   */
  tableNames: string[];
};

/**
 * GetSchemaRequest is the payload to GetSchema
 *
 * @generated from message query.GetSchemaRequest
 */
export type GetSchemaRequestJson = {
  /**
   * @generated from field: query.Target target = 1;
   */
  target?: TargetJson;

  /**
   * @generated from field: query.SchemaTableType table_type = 2;
   */
  tableType?: SchemaTableTypeJson;

  /**
   * @generated from field: repeated string table_names = 3;
   */
  tableNames?: string[];
};

/**
 * Describes the message query.GetSchemaRequest.
 * Use `create(GetSchemaRequestSchema)` to create a new message.
 */
export const GetSchemaRequestSchema: GenMessage<GetSchemaRequest, GetSchemaRequestJson> = /*@__PURE__*/
  messageDesc(file_query, 64);

/**
 * UDFInfo represents the information about a UDF.
 *
 * @generated from message query.UDFInfo
 */
export type UDFInfo = Message<"query.UDFInfo"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: bool aggregating = 2;
   */
  aggregating: boolean;

  /**
   * @generated from field: query.Type return_type = 3;
   */
  returnType: Type;
};

/**
 * UDFInfo represents the information about a UDF.
 *
 * @generated from message query.UDFInfo
 */
export type UDFInfoJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: bool aggregating = 2;
   */
  aggregating?: boolean;

  /**
   * @generated from field: query.Type return_type = 3;
   */
  returnType?: TypeJson;
};

/**
 * Describes the message query.UDFInfo.
 * Use `create(UDFInfoSchema)` to create a new message.
 */
export const UDFInfoSchema: GenMessage<UDFInfo, UDFInfoJson> = /*@__PURE__*/
  messageDesc(file_query, 65);

/**
 * GetSchemaResponse is the returned value from GetSchema
 *
 * @generated from message query.GetSchemaResponse
 */
export type GetSchemaResponse = Message<"query.GetSchemaResponse"> & {
  /**
   * @generated from field: repeated query.UDFInfo udfs = 1;
   */
  udfs: UDFInfo[];

  /**
   * this is for the schema definition for the requested tables and views.
   *
   * @generated from field: map<string, string> table_definition = 2;
   */
  tableDefinition: { [key: string]: string };
};

/**
 * GetSchemaResponse is the returned value from GetSchema
 *
 * @generated from message query.GetSchemaResponse
 */
export type GetSchemaResponseJson = {
  /**
   * @generated from field: repeated query.UDFInfo udfs = 1;
   */
  udfs?: UDFInfoJson[];

  /**
   * this is for the schema definition for the requested tables and views.
   *
   * @generated from field: map<string, string> table_definition = 2;
   */
  tableDefinition?: { [key: string]: string };
};

/**
 * Describes the message query.GetSchemaResponse.
 * Use `create(GetSchemaResponseSchema)` to create a new message.
 */
export const GetSchemaResponseSchema: GenMessage<GetSchemaResponse, GetSchemaResponseJson> = /*@__PURE__*/
  messageDesc(file_query, 66);

/**
 * Flags sent from the MySQL C API
 *
 * @generated from enum query.MySqlFlag
 */
export enum MySqlFlag {
  /**
   * @generated from enum value: EMPTY = 0;
   */
  EMPTY = 0,

  /**
   * @generated from enum value: NOT_NULL_FLAG = 1;
   */
  NOT_NULL_FLAG = 1,

  /**
   * @generated from enum value: PRI_KEY_FLAG = 2;
   */
  PRI_KEY_FLAG = 2,

  /**
   * @generated from enum value: UNIQUE_KEY_FLAG = 4;
   */
  UNIQUE_KEY_FLAG = 4,

  /**
   * @generated from enum value: MULTIPLE_KEY_FLAG = 8;
   */
  MULTIPLE_KEY_FLAG = 8,

  /**
   * @generated from enum value: BLOB_FLAG = 16;
   */
  BLOB_FLAG = 16,

  /**
   * @generated from enum value: UNSIGNED_FLAG = 32;
   */
  UNSIGNED_FLAG = 32,

  /**
   * @generated from enum value: ZEROFILL_FLAG = 64;
   */
  ZEROFILL_FLAG = 64,

  /**
   * @generated from enum value: BINARY_FLAG = 128;
   */
  BINARY_FLAG = 128,

  /**
   * @generated from enum value: ENUM_FLAG = 256;
   */
  ENUM_FLAG = 256,

  /**
   * @generated from enum value: AUTO_INCREMENT_FLAG = 512;
   */
  AUTO_INCREMENT_FLAG = 512,

  /**
   * @generated from enum value: TIMESTAMP_FLAG = 1024;
   */
  TIMESTAMP_FLAG = 1024,

  /**
   * @generated from enum value: SET_FLAG = 2048;
   */
  SET_FLAG = 2048,

  /**
   * @generated from enum value: NO_DEFAULT_VALUE_FLAG = 4096;
   */
  NO_DEFAULT_VALUE_FLAG = 4096,

  /**
   * @generated from enum value: ON_UPDATE_NOW_FLAG = 8192;
   */
  ON_UPDATE_NOW_FLAG = 8192,

  /**
   * @generated from enum value: NUM_FLAG = 32768;
   */
  NUM_FLAG = 32768,

  /**
   * @generated from enum value: PART_KEY_FLAG = 16384;
   */
  PART_KEY_FLAG = 16384,

  /**
   * @generated from enum value: GROUP_FLAG = 32768;
   */
  GROUP_FLAG = 32768,

  /**
   * @generated from enum value: UNIQUE_FLAG = 65536;
   */
  UNIQUE_FLAG = 65536,

  /**
   * @generated from enum value: BINCMP_FLAG = 131072;
   */
  BINCMP_FLAG = 131072,
}

/**
 * Flags sent from the MySQL C API
 *
 * @generated from enum query.MySqlFlag
 */
export type MySqlFlagJson = "EMPTY" | "NOT_NULL_FLAG" | "PRI_KEY_FLAG" | "UNIQUE_KEY_FLAG" | "MULTIPLE_KEY_FLAG" | "BLOB_FLAG" | "UNSIGNED_FLAG" | "ZEROFILL_FLAG" | "BINARY_FLAG" | "ENUM_FLAG" | "AUTO_INCREMENT_FLAG" | "TIMESTAMP_FLAG" | "SET_FLAG" | "NO_DEFAULT_VALUE_FLAG" | "ON_UPDATE_NOW_FLAG" | "NUM_FLAG" | "PART_KEY_FLAG" | "GROUP_FLAG" | "UNIQUE_FLAG" | "BINCMP_FLAG";

/**
 * Describes the enum query.MySqlFlag.
 */
export const MySqlFlagSchema: GenEnum<MySqlFlag, MySqlFlagJson> = /*@__PURE__*/
  enumDesc(file_query, 0);

/**
 * Flag allows us to qualify types by their common properties.
 *
 * @generated from enum query.Flag
 */
export enum Flag {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: ISINTEGRAL = 256;
   */
  ISINTEGRAL = 256,

  /**
   * @generated from enum value: ISUNSIGNED = 512;
   */
  ISUNSIGNED = 512,

  /**
   * @generated from enum value: ISFLOAT = 1024;
   */
  ISFLOAT = 1024,

  /**
   * @generated from enum value: ISQUOTED = 2048;
   */
  ISQUOTED = 2048,

  /**
   * @generated from enum value: ISTEXT = 4096;
   */
  ISTEXT = 4096,

  /**
   * @generated from enum value: ISBINARY = 8192;
   */
  ISBINARY = 8192,
}

/**
 * Flag allows us to qualify types by their common properties.
 *
 * @generated from enum query.Flag
 */
export type FlagJson = "NONE" | "ISINTEGRAL" | "ISUNSIGNED" | "ISFLOAT" | "ISQUOTED" | "ISTEXT" | "ISBINARY";

/**
 * Describes the enum query.Flag.
 */
export const FlagSchema: GenEnum<Flag, FlagJson> = /*@__PURE__*/
  enumDesc(file_query, 1);

/**
 * Type defines the various supported data types in bind vars
 * and query results.
 *
 * @generated from enum query.Type
 */
export enum Type {
  /**
   * NULL_TYPE specifies a NULL type.
   *
   * @generated from enum value: NULL_TYPE = 0;
   */
  NULL_TYPE = 0,

  /**
   * INT8 specifies a TINYINT type.
   * Properties: 1, IsNumber.
   *
   * @generated from enum value: INT8 = 257;
   */
  INT8 = 257,

  /**
   * UINT8 specifies a TINYINT UNSIGNED type.
   * Properties: 2, IsNumber, IsUnsigned.
   *
   * @generated from enum value: UINT8 = 770;
   */
  UINT8 = 770,

  /**
   * INT16 specifies a SMALLINT type.
   * Properties: 3, IsNumber.
   *
   * @generated from enum value: INT16 = 259;
   */
  INT16 = 259,

  /**
   * UINT16 specifies a SMALLINT UNSIGNED type.
   * Properties: 4, IsNumber, IsUnsigned.
   *
   * @generated from enum value: UINT16 = 772;
   */
  UINT16 = 772,

  /**
   * INT24 specifies a MEDIUMINT type.
   * Properties: 5, IsNumber.
   *
   * @generated from enum value: INT24 = 261;
   */
  INT24 = 261,

  /**
   * UINT24 specifies a MEDIUMINT UNSIGNED type.
   * Properties: 6, IsNumber, IsUnsigned.
   *
   * @generated from enum value: UINT24 = 774;
   */
  UINT24 = 774,

  /**
   * INT32 specifies a INTEGER type.
   * Properties: 7, IsNumber.
   *
   * @generated from enum value: INT32 = 263;
   */
  INT32 = 263,

  /**
   * UINT32 specifies a INTEGER UNSIGNED type.
   * Properties: 8, IsNumber, IsUnsigned.
   *
   * @generated from enum value: UINT32 = 776;
   */
  UINT32 = 776,

  /**
   * INT64 specifies a BIGINT type.
   * Properties: 9, IsNumber.
   *
   * @generated from enum value: INT64 = 265;
   */
  INT64 = 265,

  /**
   * UINT64 specifies a BIGINT UNSIGNED type.
   * Properties: 10, IsNumber, IsUnsigned.
   *
   * @generated from enum value: UINT64 = 778;
   */
  UINT64 = 778,

  /**
   * FLOAT32 specifies a FLOAT type.
   * Properties: 11, IsFloat.
   *
   * @generated from enum value: FLOAT32 = 1035;
   */
  FLOAT32 = 1035,

  /**
   * FLOAT64 specifies a DOUBLE or REAL type.
   * Properties: 12, IsFloat.
   *
   * @generated from enum value: FLOAT64 = 1036;
   */
  FLOAT64 = 1036,

  /**
   * TIMESTAMP specifies a TIMESTAMP type.
   * Properties: 13, IsQuoted.
   *
   * @generated from enum value: TIMESTAMP = 2061;
   */
  TIMESTAMP = 2061,

  /**
   * DATE specifies a DATE type.
   * Properties: 14, IsQuoted.
   *
   * @generated from enum value: DATE = 2062;
   */
  DATE = 2062,

  /**
   * TIME specifies a TIME type.
   * Properties: 15, IsQuoted.
   *
   * @generated from enum value: TIME = 2063;
   */
  TIME = 2063,

  /**
   * DATETIME specifies a DATETIME type.
   * Properties: 16, IsQuoted.
   *
   * @generated from enum value: DATETIME = 2064;
   */
  DATETIME = 2064,

  /**
   * YEAR specifies a YEAR type.
   * Properties: 17, IsNumber, IsUnsigned.
   *
   * @generated from enum value: YEAR = 785;
   */
  YEAR = 785,

  /**
   * DECIMAL specifies a DECIMAL or NUMERIC type.
   * Properties: 18, None.
   *
   * @generated from enum value: DECIMAL = 18;
   */
  DECIMAL = 18,

  /**
   * TEXT specifies a TEXT type.
   * Properties: 19, IsQuoted, IsText.
   *
   * @generated from enum value: TEXT = 6163;
   */
  TEXT = 6163,

  /**
   * BLOB specifies a BLOB type.
   * Properties: 20, IsQuoted, IsBinary.
   *
   * @generated from enum value: BLOB = 10260;
   */
  BLOB = 10260,

  /**
   * VARCHAR specifies a VARCHAR type.
   * Properties: 21, IsQuoted, IsText.
   *
   * @generated from enum value: VARCHAR = 6165;
   */
  VARCHAR = 6165,

  /**
   * VARBINARY specifies a VARBINARY type.
   * Properties: 22, IsQuoted, IsBinary.
   *
   * @generated from enum value: VARBINARY = 10262;
   */
  VARBINARY = 10262,

  /**
   * CHAR specifies a CHAR type.
   * Properties: 23, IsQuoted, IsText.
   *
   * @generated from enum value: CHAR = 6167;
   */
  CHAR = 6167,

  /**
   * BINARY specifies a BINARY type.
   * Properties: 24, IsQuoted, IsBinary.
   *
   * @generated from enum value: BINARY = 10264;
   */
  BINARY = 10264,

  /**
   * BIT specifies a BIT type.
   * Properties: 25, IsQuoted.
   *
   * @generated from enum value: BIT = 2073;
   */
  BIT = 2073,

  /**
   * ENUM specifies an ENUM type.
   * Properties: 26, IsQuoted.
   *
   * @generated from enum value: ENUM = 2074;
   */
  ENUM = 2074,

  /**
   * SET specifies a SET type.
   * Properties: 27, IsQuoted.
   *
   * @generated from enum value: SET = 2075;
   */
  SET = 2075,

  /**
   * TUPLE specifies a tuple. This cannot
   * be returned in a QueryResult, but it can
   * be sent as a bind var.
   * Properties: 28, None.
   *
   * @generated from enum value: TUPLE = 28;
   */
  TUPLE = 28,

  /**
   * GEOMETRY specifies a GEOMETRY type.
   * Properties: 29, IsQuoted.
   *
   * @generated from enum value: GEOMETRY = 2077;
   */
  GEOMETRY = 2077,

  /**
   * JSON specifies a JSON type.
   * Properties: 30, IsQuoted.
   *
   * @generated from enum value: JSON = 2078;
   */
  JSON = 2078,

  /**
   * EXPRESSION specifies a SQL expression.
   * This type is for internal use only.
   * Properties: 31, None.
   *
   * @generated from enum value: EXPRESSION = 31;
   */
  EXPRESSION = 31,

  /**
   * HEXNUM specifies a HEXNUM type (unquoted varbinary).
   * Properties: 32, IsText.
   *
   * @generated from enum value: HEXNUM = 4128;
   */
  HEXNUM = 4128,

  /**
   * HEXVAL specifies a HEXVAL type (unquoted varbinary).
   * Properties: 33, IsText.
   *
   * @generated from enum value: HEXVAL = 4129;
   */
  HEXVAL = 4129,

  /**
   * BITNUM specifies a base 2 binary type (unquoted varbinary).
   * Properties: 34, IsText.
   *
   * @generated from enum value: BITNUM = 4130;
   */
  BITNUM = 4130,

  /**
   * VECTOR specifies a VECTOR type
   * Properties: 35, IsQuoted.
   *
   * @generated from enum value: VECTOR = 2083;
   */
  VECTOR = 2083,

  /**
   * RAW specifies a type which won't be quoted but the value used as-is while encoding.
   *
   * @generated from enum value: RAW = 2084;
   */
  RAW = 2084,
}

/**
 * Type defines the various supported data types in bind vars
 * and query results.
 *
 * @generated from enum query.Type
 */
export type TypeJson = "NULL_TYPE" | "INT8" | "UINT8" | "INT16" | "UINT16" | "INT24" | "UINT24" | "INT32" | "UINT32" | "INT64" | "UINT64" | "FLOAT32" | "FLOAT64" | "TIMESTAMP" | "DATE" | "TIME" | "DATETIME" | "YEAR" | "DECIMAL" | "TEXT" | "BLOB" | "VARCHAR" | "VARBINARY" | "CHAR" | "BINARY" | "BIT" | "ENUM" | "SET" | "TUPLE" | "GEOMETRY" | "JSON" | "EXPRESSION" | "HEXNUM" | "HEXVAL" | "BITNUM" | "VECTOR" | "RAW";

/**
 * Describes the enum query.Type.
 */
export const TypeSchema: GenEnum<Type, TypeJson> = /*@__PURE__*/
  enumDesc(file_query, 2);

/**
 * TransactionState represents the state of a distributed transaction.
 *
 * @generated from enum query.TransactionState
 */
export enum TransactionState {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: PREPARE = 1;
   */
  PREPARE = 1,

  /**
   * @generated from enum value: ROLLBACK = 2;
   */
  ROLLBACK = 2,

  /**
   * @generated from enum value: COMMIT = 3;
   */
  COMMIT = 3,
}

/**
 * TransactionState represents the state of a distributed transaction.
 *
 * @generated from enum query.TransactionState
 */
export type TransactionStateJson = "UNKNOWN" | "PREPARE" | "ROLLBACK" | "COMMIT";

/**
 * Describes the enum query.TransactionState.
 */
export const TransactionStateSchema: GenEnum<TransactionState, TransactionStateJson> = /*@__PURE__*/
  enumDesc(file_query, 3);

/**
 * SchemaTableType represents the type of table requested.
 *
 * @generated from enum query.SchemaTableType
 */
export enum SchemaTableType {
  /**
   * @generated from enum value: VIEWS = 0;
   */
  VIEWS = 0,

  /**
   * @generated from enum value: TABLES = 1;
   */
  TABLES = 1,

  /**
   * @generated from enum value: ALL = 2;
   */
  ALL = 2,

  /**
   * @generated from enum value: UDFS = 3;
   */
  UDFS = 3,
}

/**
 * SchemaTableType represents the type of table requested.
 *
 * @generated from enum query.SchemaTableType
 */
export type SchemaTableTypeJson = "VIEWS" | "TABLES" | "ALL" | "UDFS";

/**
 * Describes the enum query.SchemaTableType.
 */
export const SchemaTableTypeSchema: GenEnum<SchemaTableType, SchemaTableTypeJson> = /*@__PURE__*/
  enumDesc(file_query, 4);

