// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "topodata.proto" (package "topodata", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains the Vitess topology related data structures.
// Very few of these structures are exchanged over the wire (only
// TabletType and KeyRange), but they are all used by the topology
// service.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Time } from "./vttime";
/**
 * KeyRange describes a range of sharding keys, when range-based
 * sharding is used.
 *
 * @generated from protobuf message topodata.KeyRange
 */
export interface KeyRange {
    /**
     * @generated from protobuf field: bytes start = 1;
     */
    start: Uint8Array;
    /**
     * @generated from protobuf field: bytes end = 2;
     */
    end: Uint8Array;
}
/**
 * TabletAlias is a globally unique tablet identifier.
 *
 * @generated from protobuf message topodata.TabletAlias
 */
export interface TabletAlias {
    /**
     * cell is the cell (or datacenter) the tablet is in
     *
     * @generated from protobuf field: string cell = 1;
     */
    cell: string;
    /**
     * uid is a unique id for this tablet within the shard
     * (this is the MySQL server id as well).
     *
     * @generated from protobuf field: uint32 uid = 2;
     */
    uid: number;
}
/**
 * Tablet represents information about a running instance of vttablet.
 *
 * @generated from protobuf message topodata.Tablet
 */
export interface Tablet {
    /**
     * alias is the unique name of the tablet.
     *
     * @generated from protobuf field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;
    /**
     * Fully qualified domain name of the host.
     *
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string;
    /**
     * Map of named ports. Normally this should include vt and grpc.
     * Going forward, the mysql port will be stored in mysql_port
     * instead of here.
     * For accessing mysql port, use topoproto.MysqlPort to fetch, and
     * topoproto.SetMysqlPort to set. These wrappers will ensure
     * legacy behavior is supported.
     *
     * @generated from protobuf field: map<string, int32> port_map = 4;
     */
    portMap: {
        [key: string]: number;
    };
    /**
     * Keyspace name.
     *
     * @generated from protobuf field: string keyspace = 5;
     */
    keyspace: string;
    /**
     * Shard name. If range based sharding is used, it should match
     * key_range.
     *
     * @generated from protobuf field: string shard = 6;
     */
    shard: string;
    /**
     * If range based sharding is used, range for the tablet's shard.
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 7;
     */
    keyRange?: KeyRange;
    /**
     * type is the current type of the tablet.
     *
     * @generated from protobuf field: topodata.TabletType type = 8;
     */
    type: TabletType;
    /**
     * It this is set, it is used as the database name instead of the
     * normal "vt_" + keyspace.
     *
     * @generated from protobuf field: string db_name_override = 9;
     */
    dbNameOverride: string;
    /**
     * tablet tags
     *
     * @generated from protobuf field: map<string, string> tags = 10;
     */
    tags: {
        [key: string]: string;
    };
    /**
     * MySQL hostname.
     *
     * @generated from protobuf field: string mysql_hostname = 12;
     */
    mysqlHostname: string;
    /**
     * MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
     * to access this variable. The functions provide support
     * for legacy behavior.
     *
     * @generated from protobuf field: int32 mysql_port = 13;
     */
    mysqlPort: number;
    /**
     * primary_term_start_time is the time (in UTC) at which the current term of
     * the current tablet began as primary. If this tablet is not currently the
     * primary, this value is ignored.
     *
     * A new primary term begins any time an authoritative decision is communicated
     * about which tablet should be the primary, such as via Vitess
     * replication-management commands like PlannedReparentShard,
     * EmergencyReparentShard, and TabletExternallyReparented.
     *
     *
     * @generated from protobuf field: vttime.Time primary_term_start_time = 14;
     */
    primaryTermStartTime?: Time;
    /**
     * default_conn_collation is the default connection collation used by this tablet.
     *
     * @generated from protobuf field: uint32 default_conn_collation = 16;
     */
    defaultConnCollation: number;
}
/**
 * A Shard contains data about a subset of the data whithin a keyspace.
 *
 * @generated from protobuf message topodata.Shard
 */
export interface Shard {
    /**
     * primary_alias is the tablet alias of the primary for the shard.
     * If it is unset, then there is no primary in this shard yet.
     * No lock is necessary to update this field, when for instance
     * TabletExternallyReparented updates this. However, we lock the
     * shard for reparenting operations (InitShardPrimary,
     * PlannedReparentShard,EmergencyReparentShard), to guarantee
     * exclusive operation.
     *
     * @generated from protobuf field: topodata.TabletAlias primary_alias = 1;
     */
    primaryAlias?: TabletAlias;
    /**
     * primary_term_start_time is the time (in UTC) at which the current term of
     * the primary specified in primary_alias began.
     *
     * A new primary term begins any time an authoritative decision is communicated
     * about which tablet should be the primary, such as via Vitess
     * replication-management commands like PlannedReparentShard,
     * EmergencyReparentShard, and TabletExternallyReparented.
     *
     * The primary_alias should only ever be changed if the new primary's term began
     * at a later time than this. Note that a new term can start for the tablet
     * that is already the primary. In that case, the primary_term_start_time would
     * be increased without changing the primary_alias.
     *
     * @generated from protobuf field: vttime.Time primary_term_start_time = 8;
     */
    primaryTermStartTime?: Time;
    /**
     * key_range is the KeyRange for this shard. It can be unset if:
     * - we are not using range-based sharding in this shard.
     * - the shard covers the entire keyrange.
     * This must match the shard name based on our other conventions, but
     * helpful to have it decomposed here.
     * Once set at creation time, it is never changed.
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;
    /**
     * SourceShards is the list of shards we're replicating from,
     * using filtered replication.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from protobuf field: repeated topodata.Shard.SourceShard source_shards = 4;
     */
    sourceShards: Shard_SourceShard[];
    /**
     * tablet_controls has at most one entry per TabletType.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from protobuf field: repeated topodata.Shard.TabletControl tablet_controls = 6;
     */
    tabletControls: Shard_TabletControl[];
    /**
     * is_primary_serving sets whether this shard primary is serving traffic or not.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from protobuf field: bool is_primary_serving = 7;
     */
    isPrimaryServing: boolean;
}
/**
 * SourceShard represents a data source for filtered replication
 * across shards. When this is used in a destination shard, the primary
 * of that shard will run filtered replication.
 *
 * @generated from protobuf message topodata.Shard.SourceShard
 */
export interface Shard_SourceShard {
    /**
     * Uid is the unique ID for this SourceShard object.
     *
     * @generated from protobuf field: int32 uid = 1;
     */
    uid: number;
    /**
     * the source keyspace
     *
     * @generated from protobuf field: string keyspace = 2;
     */
    keyspace: string;
    /**
     * the source shard
     *
     * @generated from protobuf field: string shard = 3;
     */
    shard: string;
    /**
     * the source shard keyrange
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 4;
     */
    keyRange?: KeyRange;
    /**
     * the source table list to replicate
     *
     * @generated from protobuf field: repeated string tables = 5;
     */
    tables: string[];
}
/**
 * TabletControl controls tablet's behavior
 *
 * @generated from protobuf message topodata.Shard.TabletControl
 */
export interface Shard_TabletControl {
    /**
     * which tablet type is affected
     *
     * @generated from protobuf field: topodata.TabletType tablet_type = 1;
     */
    tabletType: TabletType;
    /**
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
    /**
     * @generated from protobuf field: repeated string denied_tables = 4;
     */
    deniedTables: string[];
    /**
     * frozen is set if we've started failing over traffic for
     * the primary. If set, this record should not be removed.
     *
     * @generated from protobuf field: bool frozen = 5;
     */
    frozen: boolean;
}
/**
 * A Keyspace contains data about a keyspace.
 *
 * @generated from protobuf message topodata.Keyspace
 */
export interface Keyspace {
    /**
     * keyspace_type will determine how this keyspace is treated by
     * vtgate / vschema. Normal keyspaces are routable by
     * any query. Snapshot keyspaces are only accessible
     * by explicit addresssing or by calling "use keyspace" first
     *
     * @generated from protobuf field: topodata.KeyspaceType keyspace_type = 5;
     */
    keyspaceType: KeyspaceType;
    /**
     * base_keyspace is the base keyspace from which a snapshot
     * keyspace is created. empty for normal keyspaces
     *
     * @generated from protobuf field: string base_keyspace = 6;
     */
    baseKeyspace: string;
    /**
     * snapshot_time (in UTC) is a property of snapshot
     * keyspaces which tells us what point in time
     * the snapshot is of
     *
     * @generated from protobuf field: vttime.Time snapshot_time = 7;
     */
    snapshotTime?: Time;
    /**
     * DurabilityPolicy is the durability policy to be
     * used for the keyspace.
     *
     * @generated from protobuf field: string durability_policy = 8;
     */
    durabilityPolicy: string;
    /**
     * ThrottlerConfig has the configuration for the tablet
     * server's lag throttler, and applies to the entire
     * keyspace, across all shards and tablets.
     *
     * @generated from protobuf field: topodata.ThrottlerConfig throttler_config = 9;
     */
    throttlerConfig?: ThrottlerConfig;
    /**
     * SidecarDBName is the name of the Vitess sidecar database
     * used for various system metadata that is stored in each
     * tablet's mysqld instance.
     *
     * @generated from protobuf field: string sidecar_db_name = 10;
     */
    sidecarDbName: string;
}
/**
 * ShardReplication describes the MySQL replication relationships
 * whithin a cell.
 *
 * @generated from protobuf message topodata.ShardReplication
 */
export interface ShardReplication {
    /**
     * Note there can be only one Node in this array
     * for a given tablet.
     *
     * @generated from protobuf field: repeated topodata.ShardReplication.Node nodes = 1;
     */
    nodes: ShardReplication_Node[];
}
/**
 * Node describes a tablet instance within the cell
 *
 * @generated from protobuf message topodata.ShardReplication.Node
 */
export interface ShardReplication_Node {
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;
}
/**
 * ShardReplicationError describes the error being fixed by
 * ShardReplicationFix.
 *
 * @generated from protobuf message topodata.ShardReplicationError
 */
export interface ShardReplicationError {
    /**
     * Type is the category of problem being fixed.
     *
     * @generated from protobuf field: topodata.ShardReplicationError.Type type = 1;
     */
    type: ShardReplicationError_Type;
    /**
     * TabletAlias is the tablet record that has the problem.
     *
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 2;
     */
    tabletAlias?: TabletAlias;
}
/**
 * @generated from protobuf enum topodata.ShardReplicationError.Type
 */
export enum ShardReplicationError_Type {
    /**
     * UNKNOWN is not a valid value.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * NOT_FOUND occurs when a tablet is in the ShardReplication record
     * but does not exist in the topology.
     *
     * @generated from protobuf enum value: NOT_FOUND = 1;
     */
    NOT_FOUND = 1,
    /**
     * TOPOLOGY_MISMATCH occurs when a tablet is in the replication graph and
     * exists in the topology, but at least one of the Keyspace, Shard, or Cell
     * fields for that tablet does not match the ShardReplication record.
     *
     * @generated from protobuf enum value: TOPOLOGY_MISMATCH = 2;
     */
    TOPOLOGY_MISMATCH = 2
}
/**
 * ShardReference is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from protobuf message topodata.ShardReference
 */
export interface ShardReference {
    /**
     * Copied from Shard.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange; // Disable query serving in this shard
}
/**
 * ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from protobuf message topodata.ShardTabletControl
 */
export interface ShardTabletControl {
    /**
     * Copied from Shard.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;
    /**
     * Disable query serving in this shard
     *
     * @generated from protobuf field: bool query_service_disabled = 3;
     */
    queryServiceDisabled: boolean;
}
/**
 * ThrottledAppRule defines an app-specific throttling rule, with expiration.
 *
 * @generated from protobuf message topodata.ThrottledAppRule
 */
export interface ThrottledAppRule {
    /**
     * Name of the app to be throttled, e.g. "vreplication" or "online-ddl"
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Ratio defines how much the app should be throttled, range [0.0...1.0]. 1.0 means fully throttled. 0.0 means not throttled at all.
     * Negative values are reserved for a future implementation.
     *
     * @generated from protobuf field: double ratio = 2;
     */
    ratio: number;
    /**
     * ExpiresAt is the time at which the rule expires.
     *
     * @generated from protobuf field: vttime.Time expires_at = 3;
     */
    expiresAt?: Time;
    /**
     * Exempt indicates the app should never be throttled, even if the throttler is, in general, throttling other apps.
     *
     * @generated from protobuf field: bool exempt = 4;
     */
    exempt: boolean;
}
/**
 * @generated from protobuf message topodata.ThrottlerConfig
 */
export interface ThrottlerConfig {
    /**
     * Enabled indicates that the throttler is actually checking state for
     * requests. When disabled, it automatically returns 200 OK for all
     * checks.
     *
     * @generated from protobuf field: bool enabled = 1;
     */
    enabled: boolean;
    /**
     * Threshold is the threshold for either the default check (heartbeat
     * lag) or custom check.
     *
     * @generated from protobuf field: double threshold = 2;
     */
    threshold: number;
    /**
     * CustomQuery is an optional query that overrides the default check
     * query.
     *
     * @generated from protobuf field: string custom_query = 3;
     */
    customQuery: string;
    /**
     * CheckAsCheckSelf indicates whether a throttler /check request
     * should behave like a /check-self.
     *
     * @generated from protobuf field: bool check_as_check_self = 4;
     */
    checkAsCheckSelf: boolean;
    /**
     * ThrottledApps is a map of rules for app-specific throttling
     *
     * @generated from protobuf field: map<string, topodata.ThrottledAppRule> throttled_apps = 5;
     */
    throttledApps: {
        [key: string]: ThrottledAppRule;
    };
    /**
     * AppCheckedMetrics maps app names to the list of metrics that should be checked for that app
     *
     * @generated from protobuf field: map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics = 6;
     */
    appCheckedMetrics: {
        [key: string]: ThrottlerConfig_MetricNames;
    };
    /**
     * MetricThresholds maps metric names to the threshold values that should be used for that metric
     *
     * @generated from protobuf field: map<string, double> metric_thresholds = 7;
     */
    metricThresholds: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message topodata.ThrottlerConfig.MetricNames
 */
export interface ThrottlerConfig_MetricNames {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
}
/**
 * SrvKeyspace is a rollup node for the keyspace itself.
 *
 * @generated from protobuf message topodata.SrvKeyspace
 */
export interface SrvKeyspace {
    /**
     * The partitions this keyspace is serving, per tablet type.
     *
     * @generated from protobuf field: repeated topodata.SrvKeyspace.KeyspacePartition partitions = 1;
     */
    partitions: SrvKeyspace_KeyspacePartition[];
    /**
     * ThrottlerConfig has the configuration for the tablet server's
     * lag throttler, and applies to the entire keyspace, across all
     * shards and tablets. This is copied from the global keyspace
     * object.
     *
     * @generated from protobuf field: topodata.ThrottlerConfig throttler_config = 6;
     */
    throttlerConfig?: ThrottlerConfig;
}
/**
 * @generated from protobuf message topodata.SrvKeyspace.KeyspacePartition
 */
export interface SrvKeyspace_KeyspacePartition {
    /**
     * The type this partition applies to.
     *
     * @generated from protobuf field: topodata.TabletType served_type = 1;
     */
    servedType: TabletType;
    /**
     * List of non-overlapping continuous shards sorted by range.
     *
     * @generated from protobuf field: repeated topodata.ShardReference shard_references = 2;
     */
    shardReferences: ShardReference[];
    /**
     * List of shard tablet controls
     *
     * @generated from protobuf field: repeated topodata.ShardTabletControl shard_tablet_controls = 3;
     */
    shardTabletControls: ShardTabletControl[];
}
/**
 * CellInfo contains information about a cell. CellInfo objects are
 * stored in the global topology server, and describe how to reach
 * local topology servers.
 *
 * @generated from protobuf message topodata.CellInfo
 */
export interface CellInfo {
    /**
     * ServerAddress contains the address of the server for the cell.
     * The syntax of this field is topology implementation specific.
     * For instance, for Zookeeper, it is a comma-separated list of
     * server addresses.
     *
     * @generated from protobuf field: string server_address = 1;
     */
    serverAddress: string;
    /**
     * Root is the path to store data in. It is only used when talking
     * to server_address.
     *
     * @generated from protobuf field: string root = 2;
     */
    root: string;
}
/**
 * CellsAlias
 *
 * @generated from protobuf message topodata.CellsAlias
 */
export interface CellsAlias {
    /**
     * Cells that map to this alias
     *
     * @generated from protobuf field: repeated string cells = 2;
     */
    cells: string[];
}
/**
 * @generated from protobuf message topodata.TopoConfig
 */
export interface TopoConfig {
    /**
     * @generated from protobuf field: string topo_type = 1;
     */
    topoType: string;
    /**
     * @generated from protobuf field: string server = 2;
     */
    server: string;
    /**
     * @generated from protobuf field: string root = 3;
     */
    root: string;
}
/**
 * @generated from protobuf message topodata.ExternalVitessCluster
 */
export interface ExternalVitessCluster {
    /**
     * @generated from protobuf field: topodata.TopoConfig topo_config = 1;
     */
    topoConfig?: TopoConfig;
}
/**
 * ExternalClusters
 *
 * @generated from protobuf message topodata.ExternalClusters
 */
export interface ExternalClusters {
    /**
     * @generated from protobuf field: repeated topodata.ExternalVitessCluster vitess_cluster = 1;
     */
    vitessCluster: ExternalVitessCluster[];
}
/**
 * KeyspaceType describes the type of the keyspace
 *
 * @generated from protobuf enum topodata.KeyspaceType
 */
export enum KeyspaceType {
    /**
     * NORMAL is the default value
     *
     * @generated from protobuf enum value: NORMAL = 0;
     */
    NORMAL = 0,
    /**
     * SNAPSHOT is when we are creating a snapshot keyspace
     *
     * @generated from protobuf enum value: SNAPSHOT = 1;
     */
    SNAPSHOT = 1
}
/**
 * TabletType represents the type of a given tablet.
 *
 * @generated from protobuf enum topodata.TabletType
 */
export enum TabletType {
    /**
     * UNKNOWN is not a valid value.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
     *
     * @generated from protobuf enum value: PRIMARY = 1;
     */
    PRIMARY = 1,
    /**
     * PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
     *
     * @generated from protobuf enum value: PRIMARY = 1;
     */
    MASTER = 1,
    /**
     * REPLICA replicates from primary. It is used to serve live traffic.
     * A REPLICA can be promoted to PRIMARY. A demoted PRIMARY will go to REPLICA.
     *
     * @generated from protobuf enum value: REPLICA = 2;
     */
    REPLICA = 2,
    /**
     * RDONLY (old name) / BATCH (new name) is used to serve traffic for
     * long-running jobs. It is a separate type from REPLICA so
     * long-running queries don't affect web-like traffic.
     *
     * @generated from protobuf enum value: RDONLY = 3;
     */
    RDONLY = 3,
    /**
     * RDONLY (old name) / BATCH (new name) is used to serve traffic for
     * long-running jobs. It is a separate type from REPLICA so
     * long-running queries don't affect web-like traffic.
     *
     * @generated from protobuf enum value: RDONLY = 3;
     */
    BATCH = 3,
    /**
     * SPARE is a type of servers that cannot serve queries, but is available
     * in case an extra server is needed.
     *
     * @generated from protobuf enum value: SPARE = 4;
     */
    SPARE = 4,
    /**
     * EXPERIMENTAL is like SPARE, except it can serve queries. This
     * type can be used for usages not planned by Vitess, like online
     * export to another storage engine.
     *
     * @generated from protobuf enum value: EXPERIMENTAL = 5;
     */
    EXPERIMENTAL = 5,
    /**
     * BACKUP is the type a server goes to when taking a backup. No queries
     * can be served in BACKUP mode.
     *
     * @generated from protobuf enum value: BACKUP = 6;
     */
    BACKUP = 6,
    /**
     * RESTORE is the type a server uses when restoring a backup, at
     * startup time.  No queries can be served in RESTORE mode.
     *
     * @generated from protobuf enum value: RESTORE = 7;
     */
    RESTORE = 7,
    /**
     * DRAINED is the type a server goes into when used by Vitess tools
     * to perform an offline action. It is a serving type (as
     * the tools processes may need to run queries), but it's not used
     * to route queries from Vitess users. In this state,
     * this tablet is dedicated to the process that uses it.
     *
     * @generated from protobuf enum value: DRAINED = 8;
     */
    DRAINED = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class KeyRange$Type extends MessageType<KeyRange> {
    constructor() {
        super("topodata.KeyRange", [
            { no: 1, name: "start", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "end", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyRange>): KeyRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.start = new Uint8Array(0);
        message.end = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<KeyRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyRange): KeyRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes start */ 1:
                    message.start = reader.bytes();
                    break;
                case /* bytes end */ 2:
                    message.end = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes start = 1; */
        if (message.start.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.start);
        /* bytes end = 2; */
        if (message.end.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.end);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.KeyRange
 */
export const KeyRange = new KeyRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabletAlias$Type extends MessageType<TabletAlias> {
    constructor() {
        super("topodata.TabletAlias", [
            { no: 1, name: "cell", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TabletAlias>): TabletAlias {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cell = "";
        message.uid = 0;
        if (value !== undefined)
            reflectionMergePartial<TabletAlias>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TabletAlias): TabletAlias {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cell */ 1:
                    message.cell = reader.string();
                    break;
                case /* uint32 uid */ 2:
                    message.uid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TabletAlias, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cell = 1; */
        if (message.cell !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cell);
        /* uint32 uid = 2; */
        if (message.uid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.TabletAlias
 */
export const TabletAlias = new TabletAlias$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tablet$Type extends MessageType<Tablet> {
    constructor() {
        super("topodata.Tablet", [
            { no: 1, name: "alias", kind: "message", T: () => TabletAlias },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port_map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 5, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 8, name: "type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 9, name: "db_name_override", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 12, name: "mysql_hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "mysql_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "primary_term_start_time", kind: "message", T: () => Time },
            { no: 16, name: "default_conn_collation", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Tablet>): Tablet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.portMap = {};
        message.keyspace = "";
        message.shard = "";
        message.type = 0;
        message.dbNameOverride = "";
        message.tags = {};
        message.mysqlHostname = "";
        message.mysqlPort = 0;
        message.defaultConnCollation = 0;
        if (value !== undefined)
            reflectionMergePartial<Tablet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tablet): Tablet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias alias */ 1:
                    message.alias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.alias);
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* map<string, int32> port_map */ 4:
                    this.binaryReadMap4(message.portMap, reader, options);
                    break;
                case /* string keyspace */ 5:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 6:
                    message.shard = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 7:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* topodata.TabletType type */ 8:
                    message.type = reader.int32();
                    break;
                case /* string db_name_override */ 9:
                    message.dbNameOverride = reader.string();
                    break;
                case /* map<string, string> tags */ 10:
                    this.binaryReadMap10(message.tags, reader, options);
                    break;
                case /* string mysql_hostname */ 12:
                    message.mysqlHostname = reader.string();
                    break;
                case /* int32 mysql_port */ 13:
                    message.mysqlPort = reader.int32();
                    break;
                case /* vttime.Time primary_term_start_time */ 14:
                    message.primaryTermStartTime = Time.internalBinaryRead(reader, reader.uint32(), options, message.primaryTermStartTime);
                    break;
                case /* uint32 default_conn_collation */ 16:
                    message.defaultConnCollation = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: Tablet["portMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Tablet["portMap"] | undefined, val: Tablet["portMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field topodata.Tablet.port_map");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    private binaryReadMap10(map: Tablet["tags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Tablet["tags"] | undefined, val: Tablet["tags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field topodata.Tablet.tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Tablet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias alias = 1; */
        if (message.alias)
            TabletAlias.internalBinaryWrite(message.alias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* map<string, int32> port_map = 4; */
        for (let k of globalThis.Object.keys(message.portMap))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.portMap[k]).join();
        /* string keyspace = 5; */
        if (message.keyspace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 6; */
        if (message.shard !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.shard);
        /* topodata.KeyRange key_range = 7; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletType type = 8; */
        if (message.type !== 0)
            writer.tag(8, WireType.Varint).int32(message.type);
        /* string db_name_override = 9; */
        if (message.dbNameOverride !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.dbNameOverride);
        /* map<string, string> tags = 10; */
        for (let k of globalThis.Object.keys(message.tags))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.tags[k]).join();
        /* string mysql_hostname = 12; */
        if (message.mysqlHostname !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.mysqlHostname);
        /* int32 mysql_port = 13; */
        if (message.mysqlPort !== 0)
            writer.tag(13, WireType.Varint).int32(message.mysqlPort);
        /* vttime.Time primary_term_start_time = 14; */
        if (message.primaryTermStartTime)
            Time.internalBinaryWrite(message.primaryTermStartTime, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 default_conn_collation = 16; */
        if (message.defaultConnCollation !== 0)
            writer.tag(16, WireType.Varint).uint32(message.defaultConnCollation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.Tablet
 */
export const Tablet = new Tablet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shard$Type extends MessageType<Shard> {
    constructor() {
        super("topodata.Shard", [
            { no: 1, name: "primary_alias", kind: "message", T: () => TabletAlias },
            { no: 8, name: "primary_term_start_time", kind: "message", T: () => Time },
            { no: 2, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 4, name: "source_shards", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Shard_SourceShard },
            { no: 6, name: "tablet_controls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Shard_TabletControl },
            { no: 7, name: "is_primary_serving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Shard>): Shard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceShards = [];
        message.tabletControls = [];
        message.isPrimaryServing = false;
        if (value !== undefined)
            reflectionMergePartial<Shard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shard): Shard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias primary_alias */ 1:
                    message.primaryAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.primaryAlias);
                    break;
                case /* vttime.Time primary_term_start_time */ 8:
                    message.primaryTermStartTime = Time.internalBinaryRead(reader, reader.uint32(), options, message.primaryTermStartTime);
                    break;
                case /* topodata.KeyRange key_range */ 2:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* repeated topodata.Shard.SourceShard source_shards */ 4:
                    message.sourceShards.push(Shard_SourceShard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated topodata.Shard.TabletControl tablet_controls */ 6:
                    message.tabletControls.push(Shard_TabletControl.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_primary_serving */ 7:
                    message.isPrimaryServing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias primary_alias = 1; */
        if (message.primaryAlias)
            TabletAlias.internalBinaryWrite(message.primaryAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vttime.Time primary_term_start_time = 8; */
        if (message.primaryTermStartTime)
            Time.internalBinaryWrite(message.primaryTermStartTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* topodata.KeyRange key_range = 2; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.Shard.SourceShard source_shards = 4; */
        for (let i = 0; i < message.sourceShards.length; i++)
            Shard_SourceShard.internalBinaryWrite(message.sourceShards[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.Shard.TabletControl tablet_controls = 6; */
        for (let i = 0; i < message.tabletControls.length; i++)
            Shard_TabletControl.internalBinaryWrite(message.tabletControls[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool is_primary_serving = 7; */
        if (message.isPrimaryServing !== false)
            writer.tag(7, WireType.Varint).bool(message.isPrimaryServing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.Shard
 */
export const Shard = new Shard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shard_SourceShard$Type extends MessageType<Shard_SourceShard> {
    constructor() {
        super("topodata.Shard.SourceShard", [
            { no: 1, name: "uid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 5, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Shard_SourceShard>): Shard_SourceShard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = 0;
        message.keyspace = "";
        message.shard = "";
        message.tables = [];
        if (value !== undefined)
            reflectionMergePartial<Shard_SourceShard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shard_SourceShard): Shard_SourceShard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 uid */ 1:
                    message.uid = reader.int32();
                    break;
                case /* string keyspace */ 2:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 3:
                    message.shard = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 4:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* repeated string tables */ 5:
                    message.tables.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shard_SourceShard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).int32(message.uid);
        /* string keyspace = 2; */
        if (message.keyspace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 3; */
        if (message.shard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.shard);
        /* topodata.KeyRange key_range = 4; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tables = 5; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.tables[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.Shard.SourceShard
 */
export const Shard_SourceShard = new Shard_SourceShard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shard_TabletControl$Type extends MessageType<Shard_TabletControl> {
    constructor() {
        super("topodata.Shard.TabletControl", [
            { no: 1, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "denied_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "frozen", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Shard_TabletControl>): Shard_TabletControl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tabletType = 0;
        message.cells = [];
        message.deniedTables = [];
        message.frozen = false;
        if (value !== undefined)
            reflectionMergePartial<Shard_TabletControl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shard_TabletControl): Shard_TabletControl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletType tablet_type */ 1:
                    message.tabletType = reader.int32();
                    break;
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                case /* repeated string denied_tables */ 4:
                    message.deniedTables.push(reader.string());
                    break;
                case /* bool frozen */ 5:
                    message.frozen = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Shard_TabletControl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletType tablet_type = 1; */
        if (message.tabletType !== 0)
            writer.tag(1, WireType.Varint).int32(message.tabletType);
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        /* repeated string denied_tables = 4; */
        for (let i = 0; i < message.deniedTables.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.deniedTables[i]);
        /* bool frozen = 5; */
        if (message.frozen !== false)
            writer.tag(5, WireType.Varint).bool(message.frozen);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.Shard.TabletControl
 */
export const Shard_TabletControl = new Shard_TabletControl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Keyspace$Type extends MessageType<Keyspace> {
    constructor() {
        super("topodata.Keyspace", [
            { no: 5, name: "keyspace_type", kind: "enum", T: () => ["topodata.KeyspaceType", KeyspaceType] },
            { no: 6, name: "base_keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "snapshot_time", kind: "message", T: () => Time },
            { no: 8, name: "durability_policy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "throttler_config", kind: "message", T: () => ThrottlerConfig },
            { no: 10, name: "sidecar_db_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Keyspace>): Keyspace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspaceType = 0;
        message.baseKeyspace = "";
        message.durabilityPolicy = "";
        message.sidecarDbName = "";
        if (value !== undefined)
            reflectionMergePartial<Keyspace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Keyspace): Keyspace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.KeyspaceType keyspace_type */ 5:
                    message.keyspaceType = reader.int32();
                    break;
                case /* string base_keyspace */ 6:
                    message.baseKeyspace = reader.string();
                    break;
                case /* vttime.Time snapshot_time */ 7:
                    message.snapshotTime = Time.internalBinaryRead(reader, reader.uint32(), options, message.snapshotTime);
                    break;
                case /* string durability_policy */ 8:
                    message.durabilityPolicy = reader.string();
                    break;
                case /* topodata.ThrottlerConfig throttler_config */ 9:
                    message.throttlerConfig = ThrottlerConfig.internalBinaryRead(reader, reader.uint32(), options, message.throttlerConfig);
                    break;
                case /* string sidecar_db_name */ 10:
                    message.sidecarDbName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Keyspace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.KeyspaceType keyspace_type = 5; */
        if (message.keyspaceType !== 0)
            writer.tag(5, WireType.Varint).int32(message.keyspaceType);
        /* string base_keyspace = 6; */
        if (message.baseKeyspace !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.baseKeyspace);
        /* vttime.Time snapshot_time = 7; */
        if (message.snapshotTime)
            Time.internalBinaryWrite(message.snapshotTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string durability_policy = 8; */
        if (message.durabilityPolicy !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.durabilityPolicy);
        /* topodata.ThrottlerConfig throttler_config = 9; */
        if (message.throttlerConfig)
            ThrottlerConfig.internalBinaryWrite(message.throttlerConfig, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string sidecar_db_name = 10; */
        if (message.sidecarDbName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.sidecarDbName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.Keyspace
 */
export const Keyspace = new Keyspace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplication$Type extends MessageType<ShardReplication> {
    constructor() {
        super("topodata.ShardReplication", [
            { no: 1, name: "nodes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardReplication_Node }
        ]);
    }
    create(value?: PartialMessage<ShardReplication>): ShardReplication {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodes = [];
        if (value !== undefined)
            reflectionMergePartial<ShardReplication>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplication): ShardReplication {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated topodata.ShardReplication.Node nodes */ 1:
                    message.nodes.push(ShardReplication_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplication, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated topodata.ShardReplication.Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            ShardReplication_Node.internalBinaryWrite(message.nodes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ShardReplication
 */
export const ShardReplication = new ShardReplication$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplication_Node$Type extends MessageType<ShardReplication_Node> {
    constructor() {
        super("topodata.ShardReplication.Node", [
            { no: 1, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ShardReplication_Node>): ShardReplication_Node {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ShardReplication_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplication_Node): ShardReplication_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletAlias tablet_alias */ 1:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplication_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletAlias tablet_alias = 1; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ShardReplication.Node
 */
export const ShardReplication_Node = new ShardReplication_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReplicationError$Type extends MessageType<ShardReplicationError> {
    constructor() {
        super("topodata.ShardReplicationError", [
            { no: 1, name: "type", kind: "enum", T: () => ["topodata.ShardReplicationError.Type", ShardReplicationError_Type] },
            { no: 2, name: "tablet_alias", kind: "message", T: () => TabletAlias }
        ]);
    }
    create(value?: PartialMessage<ShardReplicationError>): ShardReplicationError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<ShardReplicationError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReplicationError): ShardReplicationError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.ShardReplicationError.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 2:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReplicationError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.ShardReplicationError.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* topodata.TabletAlias tablet_alias = 2; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ShardReplicationError
 */
export const ShardReplicationError = new ShardReplicationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardReference$Type extends MessageType<ShardReference> {
    constructor() {
        super("topodata.ShardReference", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_range", kind: "message", T: () => KeyRange }
        ]);
    }
    create(value?: PartialMessage<ShardReference>): ShardReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ShardReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardReference): ShardReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 2:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.KeyRange key_range = 2; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ShardReference
 */
export const ShardReference = new ShardReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardTabletControl$Type extends MessageType<ShardTabletControl> {
    constructor() {
        super("topodata.ShardTabletControl", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 3, name: "query_service_disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ShardTabletControl>): ShardTabletControl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.queryServiceDisabled = false;
        if (value !== undefined)
            reflectionMergePartial<ShardTabletControl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardTabletControl): ShardTabletControl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 2:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* bool query_service_disabled */ 3:
                    message.queryServiceDisabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardTabletControl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* topodata.KeyRange key_range = 2; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool query_service_disabled = 3; */
        if (message.queryServiceDisabled !== false)
            writer.tag(3, WireType.Varint).bool(message.queryServiceDisabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ShardTabletControl
 */
export const ShardTabletControl = new ShardTabletControl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThrottledAppRule$Type extends MessageType<ThrottledAppRule> {
    constructor() {
        super("topodata.ThrottledAppRule", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ratio", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "expires_at", kind: "message", T: () => Time },
            { no: 4, name: "exempt", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ThrottledAppRule>): ThrottledAppRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.ratio = 0;
        message.exempt = false;
        if (value !== undefined)
            reflectionMergePartial<ThrottledAppRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThrottledAppRule): ThrottledAppRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* double ratio */ 2:
                    message.ratio = reader.double();
                    break;
                case /* vttime.Time expires_at */ 3:
                    message.expiresAt = Time.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
                    break;
                case /* bool exempt */ 4:
                    message.exempt = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ThrottledAppRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* double ratio = 2; */
        if (message.ratio !== 0)
            writer.tag(2, WireType.Bit64).double(message.ratio);
        /* vttime.Time expires_at = 3; */
        if (message.expiresAt)
            Time.internalBinaryWrite(message.expiresAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool exempt = 4; */
        if (message.exempt !== false)
            writer.tag(4, WireType.Varint).bool(message.exempt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ThrottledAppRule
 */
export const ThrottledAppRule = new ThrottledAppRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThrottlerConfig$Type extends MessageType<ThrottlerConfig> {
    constructor() {
        super("topodata.ThrottlerConfig", [
            { no: 1, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "custom_query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "check_as_check_self", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "throttled_apps", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ThrottledAppRule } },
            { no: 6, name: "app_checked_metrics", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ThrottlerConfig_MetricNames } },
            { no: 7, name: "metric_thresholds", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<ThrottlerConfig>): ThrottlerConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enabled = false;
        message.threshold = 0;
        message.customQuery = "";
        message.checkAsCheckSelf = false;
        message.throttledApps = {};
        message.appCheckedMetrics = {};
        message.metricThresholds = {};
        if (value !== undefined)
            reflectionMergePartial<ThrottlerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThrottlerConfig): ThrottlerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enabled */ 1:
                    message.enabled = reader.bool();
                    break;
                case /* double threshold */ 2:
                    message.threshold = reader.double();
                    break;
                case /* string custom_query */ 3:
                    message.customQuery = reader.string();
                    break;
                case /* bool check_as_check_self */ 4:
                    message.checkAsCheckSelf = reader.bool();
                    break;
                case /* map<string, topodata.ThrottledAppRule> throttled_apps */ 5:
                    this.binaryReadMap5(message.throttledApps, reader, options);
                    break;
                case /* map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics */ 6:
                    this.binaryReadMap6(message.appCheckedMetrics, reader, options);
                    break;
                case /* map<string, double> metric_thresholds */ 7:
                    this.binaryReadMap7(message.metricThresholds, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: ThrottlerConfig["throttledApps"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ThrottlerConfig["throttledApps"] | undefined, val: ThrottlerConfig["throttledApps"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ThrottledAppRule.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field topodata.ThrottlerConfig.throttled_apps");
            }
        }
        map[key ?? ""] = val ?? ThrottledAppRule.create();
    }
    private binaryReadMap6(map: ThrottlerConfig["appCheckedMetrics"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ThrottlerConfig["appCheckedMetrics"] | undefined, val: ThrottlerConfig["appCheckedMetrics"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ThrottlerConfig_MetricNames.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field topodata.ThrottlerConfig.app_checked_metrics");
            }
        }
        map[key ?? ""] = val ?? ThrottlerConfig_MetricNames.create();
    }
    private binaryReadMap7(map: ThrottlerConfig["metricThresholds"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ThrottlerConfig["metricThresholds"] | undefined, val: ThrottlerConfig["metricThresholds"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field topodata.ThrottlerConfig.metric_thresholds");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: ThrottlerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enabled = 1; */
        if (message.enabled !== false)
            writer.tag(1, WireType.Varint).bool(message.enabled);
        /* double threshold = 2; */
        if (message.threshold !== 0)
            writer.tag(2, WireType.Bit64).double(message.threshold);
        /* string custom_query = 3; */
        if (message.customQuery !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.customQuery);
        /* bool check_as_check_self = 4; */
        if (message.checkAsCheckSelf !== false)
            writer.tag(4, WireType.Varint).bool(message.checkAsCheckSelf);
        /* map<string, topodata.ThrottledAppRule> throttled_apps = 5; */
        for (let k of globalThis.Object.keys(message.throttledApps)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ThrottledAppRule.internalBinaryWrite(message.throttledApps[k], writer, options);
            writer.join().join();
        }
        /* map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics = 6; */
        for (let k of globalThis.Object.keys(message.appCheckedMetrics)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ThrottlerConfig_MetricNames.internalBinaryWrite(message.appCheckedMetrics[k], writer, options);
            writer.join().join();
        }
        /* map<string, double> metric_thresholds = 7; */
        for (let k of globalThis.Object.keys(message.metricThresholds))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Bit64).double(message.metricThresholds[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ThrottlerConfig
 */
export const ThrottlerConfig = new ThrottlerConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThrottlerConfig_MetricNames$Type extends MessageType<ThrottlerConfig_MetricNames> {
    constructor() {
        super("topodata.ThrottlerConfig.MetricNames", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ThrottlerConfig_MetricNames>): ThrottlerConfig_MetricNames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.names = [];
        if (value !== undefined)
            reflectionMergePartial<ThrottlerConfig_MetricNames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ThrottlerConfig_MetricNames): ThrottlerConfig_MetricNames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ThrottlerConfig_MetricNames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ThrottlerConfig.MetricNames
 */
export const ThrottlerConfig_MetricNames = new ThrottlerConfig_MetricNames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SrvKeyspace$Type extends MessageType<SrvKeyspace> {
    constructor() {
        super("topodata.SrvKeyspace", [
            { no: 1, name: "partitions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SrvKeyspace_KeyspacePartition },
            { no: 6, name: "throttler_config", kind: "message", T: () => ThrottlerConfig }
        ]);
    }
    create(value?: PartialMessage<SrvKeyspace>): SrvKeyspace {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.partitions = [];
        if (value !== undefined)
            reflectionMergePartial<SrvKeyspace>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SrvKeyspace): SrvKeyspace {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated topodata.SrvKeyspace.KeyspacePartition partitions */ 1:
                    message.partitions.push(SrvKeyspace_KeyspacePartition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* topodata.ThrottlerConfig throttler_config */ 6:
                    message.throttlerConfig = ThrottlerConfig.internalBinaryRead(reader, reader.uint32(), options, message.throttlerConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SrvKeyspace, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated topodata.SrvKeyspace.KeyspacePartition partitions = 1; */
        for (let i = 0; i < message.partitions.length; i++)
            SrvKeyspace_KeyspacePartition.internalBinaryWrite(message.partitions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* topodata.ThrottlerConfig throttler_config = 6; */
        if (message.throttlerConfig)
            ThrottlerConfig.internalBinaryWrite(message.throttlerConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.SrvKeyspace
 */
export const SrvKeyspace = new SrvKeyspace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SrvKeyspace_KeyspacePartition$Type extends MessageType<SrvKeyspace_KeyspacePartition> {
    constructor() {
        super("topodata.SrvKeyspace.KeyspacePartition", [
            { no: 1, name: "served_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 2, name: "shard_references", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardReference },
            { no: 3, name: "shard_tablet_controls", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardTabletControl }
        ]);
    }
    create(value?: PartialMessage<SrvKeyspace_KeyspacePartition>): SrvKeyspace_KeyspacePartition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.servedType = 0;
        message.shardReferences = [];
        message.shardTabletControls = [];
        if (value !== undefined)
            reflectionMergePartial<SrvKeyspace_KeyspacePartition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SrvKeyspace_KeyspacePartition): SrvKeyspace_KeyspacePartition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TabletType served_type */ 1:
                    message.servedType = reader.int32();
                    break;
                case /* repeated topodata.ShardReference shard_references */ 2:
                    message.shardReferences.push(ShardReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated topodata.ShardTabletControl shard_tablet_controls */ 3:
                    message.shardTabletControls.push(ShardTabletControl.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SrvKeyspace_KeyspacePartition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TabletType served_type = 1; */
        if (message.servedType !== 0)
            writer.tag(1, WireType.Varint).int32(message.servedType);
        /* repeated topodata.ShardReference shard_references = 2; */
        for (let i = 0; i < message.shardReferences.length; i++)
            ShardReference.internalBinaryWrite(message.shardReferences[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated topodata.ShardTabletControl shard_tablet_controls = 3; */
        for (let i = 0; i < message.shardTabletControls.length; i++)
            ShardTabletControl.internalBinaryWrite(message.shardTabletControls[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.SrvKeyspace.KeyspacePartition
 */
export const SrvKeyspace_KeyspacePartition = new SrvKeyspace_KeyspacePartition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellInfo$Type extends MessageType<CellInfo> {
    constructor() {
        super("topodata.CellInfo", [
            { no: 1, name: "server_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "root", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CellInfo>): CellInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serverAddress = "";
        message.root = "";
        if (value !== undefined)
            reflectionMergePartial<CellInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CellInfo): CellInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string server_address */ 1:
                    message.serverAddress = reader.string();
                    break;
                case /* string root */ 2:
                    message.root = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CellInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string server_address = 1; */
        if (message.serverAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serverAddress);
        /* string root = 2; */
        if (message.root !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.root);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.CellInfo
 */
export const CellInfo = new CellInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellsAlias$Type extends MessageType<CellsAlias> {
    constructor() {
        super("topodata.CellsAlias", [
            { no: 2, name: "cells", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CellsAlias>): CellsAlias {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cells = [];
        if (value !== undefined)
            reflectionMergePartial<CellsAlias>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CellsAlias): CellsAlias {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string cells */ 2:
                    message.cells.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CellsAlias, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string cells = 2; */
        for (let i = 0; i < message.cells.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.cells[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.CellsAlias
 */
export const CellsAlias = new CellsAlias$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopoConfig$Type extends MessageType<TopoConfig> {
    constructor() {
        super("topodata.TopoConfig", [
            { no: 1, name: "topo_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "root", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TopoConfig>): TopoConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.topoType = "";
        message.server = "";
        message.root = "";
        if (value !== undefined)
            reflectionMergePartial<TopoConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopoConfig): TopoConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string topo_type */ 1:
                    message.topoType = reader.string();
                    break;
                case /* string server */ 2:
                    message.server = reader.string();
                    break;
                case /* string root */ 3:
                    message.root = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TopoConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string topo_type = 1; */
        if (message.topoType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.topoType);
        /* string server = 2; */
        if (message.server !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.server);
        /* string root = 3; */
        if (message.root !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.root);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.TopoConfig
 */
export const TopoConfig = new TopoConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalVitessCluster$Type extends MessageType<ExternalVitessCluster> {
    constructor() {
        super("topodata.ExternalVitessCluster", [
            { no: 1, name: "topo_config", kind: "message", T: () => TopoConfig }
        ]);
    }
    create(value?: PartialMessage<ExternalVitessCluster>): ExternalVitessCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExternalVitessCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalVitessCluster): ExternalVitessCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* topodata.TopoConfig topo_config */ 1:
                    message.topoConfig = TopoConfig.internalBinaryRead(reader, reader.uint32(), options, message.topoConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalVitessCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* topodata.TopoConfig topo_config = 1; */
        if (message.topoConfig)
            TopoConfig.internalBinaryWrite(message.topoConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ExternalVitessCluster
 */
export const ExternalVitessCluster = new ExternalVitessCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExternalClusters$Type extends MessageType<ExternalClusters> {
    constructor() {
        super("topodata.ExternalClusters", [
            { no: 1, name: "vitess_cluster", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExternalVitessCluster }
        ]);
    }
    create(value?: PartialMessage<ExternalClusters>): ExternalClusters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vitessCluster = [];
        if (value !== undefined)
            reflectionMergePartial<ExternalClusters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalClusters): ExternalClusters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated topodata.ExternalVitessCluster vitess_cluster */ 1:
                    message.vitessCluster.push(ExternalVitessCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalClusters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated topodata.ExternalVitessCluster vitess_cluster = 1; */
        for (let i = 0; i < message.vitessCluster.length; i++)
            ExternalVitessCluster.internalBinaryWrite(message.vitessCluster[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message topodata.ExternalClusters
 */
export const ExternalClusters = new ExternalClusters$Type();
