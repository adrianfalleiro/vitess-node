// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtgate.proto" (package "vtgate", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// Data definitions for service vtgateservice.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Field } from "./query";
import { VEvent } from "./binlogdata";
import { Filter } from "./binlogdata";
import { VGtid } from "./binlogdata";
import { TabletType } from "./topodata";
import { ResultWithError } from "./query";
import { QueryResult } from "./query";
import { RPCError } from "./vtrpc";
import { BoundQuery } from "./query";
import { CallerID } from "./vtrpc";
import { TabletAlias } from "./topodata";
import { Target } from "./query";
import { BindVariable } from "./query";
import { QueryWarning } from "./query";
import { ExecuteOptions } from "./query";
/**
 * Session objects are exchanged like cookies through various
 * calls to VTGate. The behavior differs between V2 & V3 APIs.
 * V3 APIs are Execute, ExecuteBatch and StreamExecute. All
 * other APIs are V2. For the V3 APIs, the session
 * must be sent with every call to Execute or ExecuteBatch.
 * For the V2 APIs, Begin does not accept a session. It instead
 * returns a brand new one with in_transaction set to true.
 * After a call to Commit or Rollback, the session can be
 * discarded. If you're not in a transaction, Session is
 * an optional parameter for the V2 APIs.
 *
 * @generated from protobuf message vtgate.Session
 */
export interface Session {
    /**
     * in_transaction is set to true if the session is in a transaction.
     *
     * @generated from protobuf field: bool in_transaction = 1;
     */
    inTransaction: boolean;
    /**
     * shard_sessions keep track of per-shard transaction info.
     *
     * @generated from protobuf field: repeated vtgate.Session.ShardSession shard_sessions = 2;
     */
    shardSessions: Session_ShardSession[];
    /**
     * autocommit specifies if the session is in autocommit mode.
     * This is used only for V3.
     *
     * @generated from protobuf field: bool autocommit = 4;
     */
    autocommit: boolean;
    /**
     * target_string is the target expressed as a string. Valid
     * names are: keyspace:shard@target, keyspace@target or @target.
     * This is used only for V3.
     *
     * @generated from protobuf field: string target_string = 5;
     */
    targetString: string;
    /**
     * options is used only for V3.
     *
     * @generated from protobuf field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;
    /**
     * transaction_mode specifies the current transaction mode.
     *
     * @generated from protobuf field: vtgate.TransactionMode transaction_mode = 7;
     */
    transactionMode: TransactionMode;
    /**
     * warnings contains non-fatal warnings from the previous query
     *
     * @generated from protobuf field: repeated query.QueryWarning warnings = 8;
     */
    warnings: QueryWarning[];
    /**
     * pre_sessions contains sessions that have to be committed first.
     *
     * @generated from protobuf field: repeated vtgate.Session.ShardSession pre_sessions = 9;
     */
    preSessions: Session_ShardSession[];
    /**
     * post_sessions contains sessions that have to be committed last.
     *
     * @generated from protobuf field: repeated vtgate.Session.ShardSession post_sessions = 10;
     */
    postSessions: Session_ShardSession[];
    /**
     * last_insert_id keeps track of the last seen insert_id for this session
     *
     * @generated from protobuf field: uint64 last_insert_id = 11;
     */
    lastInsertId: bigint;
    /**
     * found_rows keeps track of how many rows the last query returned
     *
     * @generated from protobuf field: uint64 found_rows = 12;
     */
    foundRows: bigint;
    /**
     * user_defined_variables contains all the @variables defined for this session
     *
     * @generated from protobuf field: map<string, query.BindVariable> user_defined_variables = 13;
     */
    userDefinedVariables: {
        [key: string]: BindVariable;
    };
    /**
     * system_variables keeps track of all session variables set for this connection
     * TODO: systay should we keep this so we can apply it ordered?
     *
     * @generated from protobuf field: map<string, string> system_variables = 14;
     */
    systemVariables: {
        [key: string]: string;
    };
    /**
     * row_count keeps track of the last seen rows affected for this session
     *
     * @generated from protobuf field: int64 row_count = 15;
     */
    rowCount: bigint;
    /**
     * Stores savepoint and release savepoint calls inside a transaction
     * and is reset once transaction is committed or rolled back.
     *
     * @generated from protobuf field: repeated string savepoints = 16;
     */
    savepoints: string[];
    /**
     * in_reserved_conn is set to true if the session should be using reserved connections.
     *
     * @generated from protobuf field: bool in_reserved_conn = 17;
     */
    inReservedConn: boolean;
    /**
     * lock_session keep tracks of shard on which the lock query is sent.
     *
     * @generated from protobuf field: vtgate.Session.ShardSession lock_session = 18;
     */
    lockSession?: Session_ShardSession;
    /**
     * last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
     *
     * @generated from protobuf field: int64 last_lock_heartbeat = 19;
     */
    lastLockHeartbeat: bigint;
    /**
     * read_after_write tracks the ReadAfterWrite settings for this session.
     *
     * @generated from protobuf field: vtgate.ReadAfterWrite read_after_write = 20;
     */
    readAfterWrite?: ReadAfterWrite;
    /**
     * DDL strategy
     *
     * @generated from protobuf field: string DDLStrategy = 21 [json_name = "DDLStrategy"];
     */
    dDLStrategy: string;
    /**
     * Session UUID
     *
     * @generated from protobuf field: string SessionUUID = 22 [json_name = "SessionUUID"];
     */
    sessionUUID: string;
    /**
     * enable_system_settings defines if we can use reserved connections.
     *
     * @generated from protobuf field: bool enable_system_settings = 23;
     */
    enableSystemSettings: boolean;
    /**
     * @generated from protobuf field: map<string, int64> advisory_lock = 24;
     */
    advisoryLock: {
        [key: string]: bigint;
    };
    /**
     * query_timeout is the maximum amount of time a query is permitted to run
     *
     * @generated from protobuf field: int64 query_timeout = 25;
     */
    queryTimeout: bigint;
    /**
     * @generated from protobuf field: map<string, vtgate.PrepareData> prepare_statement = 26;
     */
    prepareStatement: {
        [key: string]: PrepareData;
    };
    /**
     * MigrationContext
     *
     * @generated from protobuf field: string migration_context = 27;
     */
    migrationContext: string;
}
/**
 * @generated from protobuf message vtgate.Session.ShardSession
 */
export interface Session_ShardSession {
    /**
     * @generated from protobuf field: query.Target target = 1;
     */
    target?: Target;
    /**
     * @generated from protobuf field: int64 transaction_id = 2;
     */
    transactionId: bigint;
    /**
     * @generated from protobuf field: topodata.TabletAlias tablet_alias = 3;
     */
    tabletAlias?: TabletAlias;
    /**
     * reserved connection if a dedicated connection is needed
     *
     * @generated from protobuf field: int64 reserved_id = 4;
     */
    reservedId: bigint;
    /**
     * @generated from protobuf field: bool vindex_only = 5;
     */
    vindexOnly: boolean;
}
/**
 * PrepareData keeps the prepared statement and other information related for execution of it.
 *
 * @generated from protobuf message vtgate.PrepareData
 */
export interface PrepareData {
    /**
     * @generated from protobuf field: string prepare_statement = 1;
     */
    prepareStatement: string;
    /**
     * @generated from protobuf field: int32 params_count = 2;
     */
    paramsCount: number;
}
/**
 * ReadAfterWrite contains information regarding gtid set and timeout
 * Also if the gtid information needs to be passed to client.
 *
 * @generated from protobuf message vtgate.ReadAfterWrite
 */
export interface ReadAfterWrite {
    /**
     * @generated from protobuf field: string read_after_write_gtid = 1;
     */
    readAfterWriteGtid: string;
    /**
     * @generated from protobuf field: double read_after_write_timeout = 2;
     */
    readAfterWriteTimeout: number;
    /**
     * @generated from protobuf field: bool session_track_gtids = 3;
     */
    sessionTrackGtids: boolean;
}
/**
 * ExecuteRequest is the payload to Execute.
 *
 * @generated from protobuf message vtgate.ExecuteRequest
 */
export interface ExecuteRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * session carries the session state.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * query is the query and bind variables to execute.
     *
     * @generated from protobuf field: query.BoundQuery query = 3;
     */
    query?: BoundQuery;
}
/**
 * ExecuteResponse is the returned value from Execute.
 *
 * @generated from protobuf message vtgate.ExecuteResponse
 */
export interface ExecuteResponse {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * session is the updated session information.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * result contains the query result, only set if error is unset.
     *
     * @generated from protobuf field: query.QueryResult result = 3;
     */
    result?: QueryResult;
}
/**
 * ExecuteBatchRequest is the payload to ExecuteBatch.
 *
 * @generated from protobuf message vtgate.ExecuteBatchRequest
 */
export interface ExecuteBatchRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * session carries the session state.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * queries is a list of query and bind variables to execute.
     *
     * @generated from protobuf field: repeated query.BoundQuery queries = 3;
     */
    queries: BoundQuery[];
}
/**
 * ExecuteBatchResponse is the returned value from ExecuteBatch.
 *
 * @generated from protobuf message vtgate.ExecuteBatchResponse
 */
export interface ExecuteBatchResponse {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * session is the updated session information.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * results contains the query results, only set if application level error is unset.
     *
     * @generated from protobuf field: repeated query.ResultWithError results = 3;
     */
    results: ResultWithError[];
}
/**
 * StreamExecuteRequest is the payload to StreamExecute.
 *
 * @generated from protobuf message vtgate.StreamExecuteRequest
 */
export interface StreamExecuteRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * query is the query and bind variables to execute.
     *
     * @generated from protobuf field: query.BoundQuery query = 2;
     */
    query?: BoundQuery;
    /**
     * session carries the session state.
     *
     * @generated from protobuf field: vtgate.Session session = 6;
     */
    session?: Session;
}
/**
 * StreamExecuteResponse is the returned value from StreamExecute.
 * The session is currently not returned because StreamExecute is
 * not expected to modify it.
 *
 * @generated from protobuf message vtgate.StreamExecuteResponse
 */
export interface StreamExecuteResponse {
    /**
     * result contains the result data.
     * The first value contains only Fields information.
     * The next values contain the actual rows, a few values per result.
     *
     * @generated from protobuf field: query.QueryResult result = 1;
     */
    result?: QueryResult;
    /**
     * session is the updated session information.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
}
/**
 * ResolveTransactionRequest is the payload to ResolveTransaction.
 *
 * @generated from protobuf message vtgate.ResolveTransactionRequest
 */
export interface ResolveTransactionRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * dtid is the dtid of the transaction to be resolved.
     *
     * @generated from protobuf field: string dtid = 2;
     */
    dtid: string;
}
/**
 * ResolveTransactionResponse is the returned value from Rollback.
 *
 * @generated from protobuf message vtgate.ResolveTransactionResponse
 */
export interface ResolveTransactionResponse {
}
/**
 * @generated from protobuf message vtgate.VStreamFlags
 */
export interface VStreamFlags {
    /**
     * align streams
     *
     * @generated from protobuf field: bool minimize_skew = 1;
     */
    minimizeSkew: boolean;
    /**
     * how often heartbeats must be sent when idle (seconds)
     *
     * @generated from protobuf field: uint32 heartbeat_interval = 2;
     */
    heartbeatInterval: number;
    /**
     * stop streams on a reshard (journal event)
     *
     * @generated from protobuf field: bool stop_on_reshard = 3;
     */
    stopOnReshard: boolean;
    /**
     * if specified, these cells (comma-separated) are used to pick source tablets from.
     * defaults to the cell of the vtgate serving the VStream API.
     *
     * @generated from protobuf field: string cells = 4;
     */
    cells: string;
    /**
     * @generated from protobuf field: string cell_preference = 5;
     */
    cellPreference: string;
    /**
     * @generated from protobuf field: string tablet_order = 6;
     */
    tabletOrder: string;
    /**
     * When set, all new row events from the `heartbeat` table, for all shards, in the sidecardb will be streamed.
     *
     * @generated from protobuf field: bool stream_keyspace_heartbeats = 7;
     */
    streamKeyspaceHeartbeats: boolean;
    /**
     * Include reshard journal events in the stream.
     *
     * @generated from protobuf field: bool include_reshard_journal_events = 8;
     */
    includeReshardJournalEvents: boolean;
}
/**
 * VStreamRequest is the payload for VStream.
 *
 * @generated from protobuf message vtgate.VStreamRequest
 */
export interface VStreamRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * @generated from protobuf field: topodata.TabletType tablet_type = 2;
     */
    tabletType: TabletType;
    /**
     * position specifies the starting point of the bin log positions
     * as well as the keyspace-shards to pull events from.
     * position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
     *
     * @generated from protobuf field: binlogdata.VGtid vgtid = 3;
     */
    vgtid?: VGtid;
    /**
     * @generated from protobuf field: binlogdata.Filter filter = 4;
     */
    filter?: Filter;
    /**
     * @generated from protobuf field: vtgate.VStreamFlags flags = 5;
     */
    flags?: VStreamFlags;
}
/**
 * VStreamResponse is streamed by VStream.
 *
 * @generated from protobuf message vtgate.VStreamResponse
 */
export interface VStreamResponse {
    /**
     * @generated from protobuf field: repeated binlogdata.VEvent events = 1;
     */
    events: VEvent[];
}
/**
 * PrepareRequest is the payload to Prepare.
 *
 * @generated from protobuf message vtgate.PrepareRequest
 */
export interface PrepareRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * session carries the session state.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * query is the query and bind variables to execute.
     *
     * @generated from protobuf field: query.BoundQuery query = 3;
     */
    query?: BoundQuery;
}
/**
 * PrepareResponse is the returned value from Prepare.
 *
 * @generated from protobuf message vtgate.PrepareResponse
 */
export interface PrepareResponse {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
    /**
     * session is the updated session information.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
    /**
     * fields contains the fields, only set if error is unset.
     *
     * @generated from protobuf field: repeated query.Field fields = 3;
     */
    fields: Field[];
}
/**
 * CloseSessionRequest is the payload to CloseSession.
 *
 * @generated from protobuf message vtgate.CloseSessionRequest
 */
export interface CloseSessionRequest {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from protobuf field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;
    /**
     * session carries the session state.
     *
     * @generated from protobuf field: vtgate.Session session = 2;
     */
    session?: Session;
}
/**
 * CloseSessionResponse is the returned value from CloseSession.
 *
 * @generated from protobuf message vtgate.CloseSessionResponse
 */
export interface CloseSessionResponse {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from protobuf field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;
}
/**
 * TransactionMode controls the execution of distributed transaction
 * across multiple shards.
 *
 * @generated from protobuf enum vtgate.TransactionMode
 */
export enum TransactionMode {
    /**
     * UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * SINGLE disallows distributed transactions.
     *
     * @generated from protobuf enum value: SINGLE = 1;
     */
    SINGLE = 1,
    /**
     * MULTI allows distributed transactions with best effort commit.
     *
     * @generated from protobuf enum value: MULTI = 2;
     */
    MULTI = 2,
    /**
     * TWOPC is for distributed transactions with atomic commits.
     *
     * @generated from protobuf enum value: TWOPC = 3;
     */
    TWOPC = 3
}
/**
 * CommitOrder is used to designate which of the ShardSessions
 * get used for transactions.
 *
 * @generated from protobuf enum vtgate.CommitOrder
 */
export enum CommitOrder {
    /**
     * NORMAL is the default commit order.
     *
     * @generated from protobuf enum value: NORMAL = 0;
     */
    NORMAL = 0,
    /**
     * PRE is used to designate pre_sessions.
     *
     * @generated from protobuf enum value: PRE = 1;
     */
    PRE = 1,
    /**
     * POST is used to designate post_sessions.
     *
     * @generated from protobuf enum value: POST = 2;
     */
    POST = 2,
    /**
     * AUTOCOMMIT is used to run the statement as autocommitted transaction.
     *
     * @generated from protobuf enum value: AUTOCOMMIT = 3;
     */
    AUTOCOMMIT = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Session$Type extends MessageType<Session> {
    constructor() {
        super("vtgate.Session", [
            { no: 1, name: "in_transaction", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "shard_sessions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Session_ShardSession },
            { no: 4, name: "autocommit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "target_string", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "options", kind: "message", T: () => ExecuteOptions },
            { no: 7, name: "transaction_mode", kind: "enum", T: () => ["vtgate.TransactionMode", TransactionMode] },
            { no: 8, name: "warnings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryWarning },
            { no: 9, name: "pre_sessions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Session_ShardSession },
            { no: 10, name: "post_sessions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Session_ShardSession },
            { no: 11, name: "last_insert_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "found_rows", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "user_defined_variables", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BindVariable } },
            { no: 14, name: "system_variables", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 15, name: "row_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "savepoints", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "in_reserved_conn", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "lock_session", kind: "message", T: () => Session_ShardSession },
            { no: 19, name: "last_lock_heartbeat", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "read_after_write", kind: "message", T: () => ReadAfterWrite },
            { no: 21, name: "DDLStrategy", kind: "scalar", jsonName: "DDLStrategy", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "SessionUUID", kind: "scalar", jsonName: "SessionUUID", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "enable_system_settings", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "advisory_lock", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ } },
            { no: 25, name: "query_timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 26, name: "prepare_statement", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PrepareData } },
            { no: 27, name: "migration_context", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Session>): Session {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inTransaction = false;
        message.shardSessions = [];
        message.autocommit = false;
        message.targetString = "";
        message.transactionMode = 0;
        message.warnings = [];
        message.preSessions = [];
        message.postSessions = [];
        message.lastInsertId = 0n;
        message.foundRows = 0n;
        message.userDefinedVariables = {};
        message.systemVariables = {};
        message.rowCount = 0n;
        message.savepoints = [];
        message.inReservedConn = false;
        message.lastLockHeartbeat = 0n;
        message.dDLStrategy = "";
        message.sessionUUID = "";
        message.enableSystemSettings = false;
        message.advisoryLock = {};
        message.queryTimeout = 0n;
        message.prepareStatement = {};
        message.migrationContext = "";
        if (value !== undefined)
            reflectionMergePartial<Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Session): Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool in_transaction */ 1:
                    message.inTransaction = reader.bool();
                    break;
                case /* repeated vtgate.Session.ShardSession shard_sessions */ 2:
                    message.shardSessions.push(Session_ShardSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool autocommit */ 4:
                    message.autocommit = reader.bool();
                    break;
                case /* string target_string */ 5:
                    message.targetString = reader.string();
                    break;
                case /* query.ExecuteOptions options */ 6:
                    message.options = ExecuteOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                case /* vtgate.TransactionMode transaction_mode */ 7:
                    message.transactionMode = reader.int32();
                    break;
                case /* repeated query.QueryWarning warnings */ 8:
                    message.warnings.push(QueryWarning.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vtgate.Session.ShardSession pre_sessions */ 9:
                    message.preSessions.push(Session_ShardSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated vtgate.Session.ShardSession post_sessions */ 10:
                    message.postSessions.push(Session_ShardSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 last_insert_id */ 11:
                    message.lastInsertId = reader.uint64().toBigInt();
                    break;
                case /* uint64 found_rows */ 12:
                    message.foundRows = reader.uint64().toBigInt();
                    break;
                case /* map<string, query.BindVariable> user_defined_variables */ 13:
                    this.binaryReadMap13(message.userDefinedVariables, reader, options);
                    break;
                case /* map<string, string> system_variables */ 14:
                    this.binaryReadMap14(message.systemVariables, reader, options);
                    break;
                case /* int64 row_count */ 15:
                    message.rowCount = reader.int64().toBigInt();
                    break;
                case /* repeated string savepoints */ 16:
                    message.savepoints.push(reader.string());
                    break;
                case /* bool in_reserved_conn */ 17:
                    message.inReservedConn = reader.bool();
                    break;
                case /* vtgate.Session.ShardSession lock_session */ 18:
                    message.lockSession = Session_ShardSession.internalBinaryRead(reader, reader.uint32(), options, message.lockSession);
                    break;
                case /* int64 last_lock_heartbeat */ 19:
                    message.lastLockHeartbeat = reader.int64().toBigInt();
                    break;
                case /* vtgate.ReadAfterWrite read_after_write */ 20:
                    message.readAfterWrite = ReadAfterWrite.internalBinaryRead(reader, reader.uint32(), options, message.readAfterWrite);
                    break;
                case /* string DDLStrategy = 21 [json_name = "DDLStrategy"];*/ 21:
                    message.dDLStrategy = reader.string();
                    break;
                case /* string SessionUUID = 22 [json_name = "SessionUUID"];*/ 22:
                    message.sessionUUID = reader.string();
                    break;
                case /* bool enable_system_settings */ 23:
                    message.enableSystemSettings = reader.bool();
                    break;
                case /* map<string, int64> advisory_lock */ 24:
                    this.binaryReadMap24(message.advisoryLock, reader, options);
                    break;
                case /* int64 query_timeout */ 25:
                    message.queryTimeout = reader.int64().toBigInt();
                    break;
                case /* map<string, vtgate.PrepareData> prepare_statement */ 26:
                    this.binaryReadMap26(message.prepareStatement, reader, options);
                    break;
                case /* string migration_context */ 27:
                    message.migrationContext = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: Session["userDefinedVariables"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Session["userDefinedVariables"] | undefined, val: Session["userDefinedVariables"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BindVariable.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtgate.Session.user_defined_variables");
            }
        }
        map[key ?? ""] = val ?? BindVariable.create();
    }
    private binaryReadMap14(map: Session["systemVariables"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Session["systemVariables"] | undefined, val: Session["systemVariables"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtgate.Session.system_variables");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap24(map: Session["advisoryLock"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Session["advisoryLock"] | undefined, val: Session["advisoryLock"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toBigInt();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtgate.Session.advisory_lock");
            }
        }
        map[key ?? ""] = val ?? 0n;
    }
    private binaryReadMap26(map: Session["prepareStatement"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Session["prepareStatement"] | undefined, val: Session["prepareStatement"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PrepareData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field vtgate.Session.prepare_statement");
            }
        }
        map[key ?? ""] = val ?? PrepareData.create();
    }
    internalBinaryWrite(message: Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool in_transaction = 1; */
        if (message.inTransaction !== false)
            writer.tag(1, WireType.Varint).bool(message.inTransaction);
        /* repeated vtgate.Session.ShardSession shard_sessions = 2; */
        for (let i = 0; i < message.shardSessions.length; i++)
            Session_ShardSession.internalBinaryWrite(message.shardSessions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool autocommit = 4; */
        if (message.autocommit !== false)
            writer.tag(4, WireType.Varint).bool(message.autocommit);
        /* string target_string = 5; */
        if (message.targetString !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.targetString);
        /* query.ExecuteOptions options = 6; */
        if (message.options)
            ExecuteOptions.internalBinaryWrite(message.options, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.TransactionMode transaction_mode = 7; */
        if (message.transactionMode !== 0)
            writer.tag(7, WireType.Varint).int32(message.transactionMode);
        /* repeated query.QueryWarning warnings = 8; */
        for (let i = 0; i < message.warnings.length; i++)
            QueryWarning.internalBinaryWrite(message.warnings[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated vtgate.Session.ShardSession pre_sessions = 9; */
        for (let i = 0; i < message.preSessions.length; i++)
            Session_ShardSession.internalBinaryWrite(message.preSessions[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated vtgate.Session.ShardSession post_sessions = 10; */
        for (let i = 0; i < message.postSessions.length; i++)
            Session_ShardSession.internalBinaryWrite(message.postSessions[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* uint64 last_insert_id = 11; */
        if (message.lastInsertId !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.lastInsertId);
        /* uint64 found_rows = 12; */
        if (message.foundRows !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.foundRows);
        /* map<string, query.BindVariable> user_defined_variables = 13; */
        for (let k of globalThis.Object.keys(message.userDefinedVariables)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BindVariable.internalBinaryWrite(message.userDefinedVariables[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> system_variables = 14; */
        for (let k of globalThis.Object.keys(message.systemVariables))
            writer.tag(14, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.systemVariables[k]).join();
        /* int64 row_count = 15; */
        if (message.rowCount !== 0n)
            writer.tag(15, WireType.Varint).int64(message.rowCount);
        /* repeated string savepoints = 16; */
        for (let i = 0; i < message.savepoints.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.savepoints[i]);
        /* bool in_reserved_conn = 17; */
        if (message.inReservedConn !== false)
            writer.tag(17, WireType.Varint).bool(message.inReservedConn);
        /* vtgate.Session.ShardSession lock_session = 18; */
        if (message.lockSession)
            Session_ShardSession.internalBinaryWrite(message.lockSession, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* int64 last_lock_heartbeat = 19; */
        if (message.lastLockHeartbeat !== 0n)
            writer.tag(19, WireType.Varint).int64(message.lastLockHeartbeat);
        /* vtgate.ReadAfterWrite read_after_write = 20; */
        if (message.readAfterWrite)
            ReadAfterWrite.internalBinaryWrite(message.readAfterWrite, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string DDLStrategy = 21 [json_name = "DDLStrategy"]; */
        if (message.dDLStrategy !== "")
            writer.tag(21, WireType.LengthDelimited).string(message.dDLStrategy);
        /* string SessionUUID = 22 [json_name = "SessionUUID"]; */
        if (message.sessionUUID !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.sessionUUID);
        /* bool enable_system_settings = 23; */
        if (message.enableSystemSettings !== false)
            writer.tag(23, WireType.Varint).bool(message.enableSystemSettings);
        /* map<string, int64> advisory_lock = 24; */
        for (let k of globalThis.Object.keys(message.advisoryLock))
            writer.tag(24, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.advisoryLock[k]).join();
        /* int64 query_timeout = 25; */
        if (message.queryTimeout !== 0n)
            writer.tag(25, WireType.Varint).int64(message.queryTimeout);
        /* map<string, vtgate.PrepareData> prepare_statement = 26; */
        for (let k of globalThis.Object.keys(message.prepareStatement)) {
            writer.tag(26, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PrepareData.internalBinaryWrite(message.prepareStatement[k], writer, options);
            writer.join().join();
        }
        /* string migration_context = 27; */
        if (message.migrationContext !== "")
            writer.tag(27, WireType.LengthDelimited).string(message.migrationContext);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.Session
 */
export const Session = new Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Session_ShardSession$Type extends MessageType<Session_ShardSession> {
    constructor() {
        super("vtgate.Session.ShardSession", [
            { no: 1, name: "target", kind: "message", T: () => Target },
            { no: 2, name: "transaction_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "tablet_alias", kind: "message", T: () => TabletAlias },
            { no: 4, name: "reserved_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "vindex_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Session_ShardSession>): Session_ShardSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transactionId = 0n;
        message.reservedId = 0n;
        message.vindexOnly = false;
        if (value !== undefined)
            reflectionMergePartial<Session_ShardSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Session_ShardSession): Session_ShardSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Target target */ 1:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* int64 transaction_id */ 2:
                    message.transactionId = reader.int64().toBigInt();
                    break;
                case /* topodata.TabletAlias tablet_alias */ 3:
                    message.tabletAlias = TabletAlias.internalBinaryRead(reader, reader.uint32(), options, message.tabletAlias);
                    break;
                case /* int64 reserved_id */ 4:
                    message.reservedId = reader.int64().toBigInt();
                    break;
                case /* bool vindex_only */ 5:
                    message.vindexOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Session_ShardSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Target target = 1; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 transaction_id = 2; */
        if (message.transactionId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.transactionId);
        /* topodata.TabletAlias tablet_alias = 3; */
        if (message.tabletAlias)
            TabletAlias.internalBinaryWrite(message.tabletAlias, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 reserved_id = 4; */
        if (message.reservedId !== 0n)
            writer.tag(4, WireType.Varint).int64(message.reservedId);
        /* bool vindex_only = 5; */
        if (message.vindexOnly !== false)
            writer.tag(5, WireType.Varint).bool(message.vindexOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.Session.ShardSession
 */
export const Session_ShardSession = new Session_ShardSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareData$Type extends MessageType<PrepareData> {
    constructor() {
        super("vtgate.PrepareData", [
            { no: 1, name: "prepare_statement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "params_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareData>): PrepareData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prepareStatement = "";
        message.paramsCount = 0;
        if (value !== undefined)
            reflectionMergePartial<PrepareData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareData): PrepareData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prepare_statement */ 1:
                    message.prepareStatement = reader.string();
                    break;
                case /* int32 params_count */ 2:
                    message.paramsCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prepare_statement = 1; */
        if (message.prepareStatement !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prepareStatement);
        /* int32 params_count = 2; */
        if (message.paramsCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.paramsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.PrepareData
 */
export const PrepareData = new PrepareData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadAfterWrite$Type extends MessageType<ReadAfterWrite> {
    constructor() {
        super("vtgate.ReadAfterWrite", [
            { no: 1, name: "read_after_write_gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "read_after_write_timeout", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "session_track_gtids", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReadAfterWrite>): ReadAfterWrite {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.readAfterWriteGtid = "";
        message.readAfterWriteTimeout = 0;
        message.sessionTrackGtids = false;
        if (value !== undefined)
            reflectionMergePartial<ReadAfterWrite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadAfterWrite): ReadAfterWrite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string read_after_write_gtid */ 1:
                    message.readAfterWriteGtid = reader.string();
                    break;
                case /* double read_after_write_timeout */ 2:
                    message.readAfterWriteTimeout = reader.double();
                    break;
                case /* bool session_track_gtids */ 3:
                    message.sessionTrackGtids = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadAfterWrite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string read_after_write_gtid = 1; */
        if (message.readAfterWriteGtid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.readAfterWriteGtid);
        /* double read_after_write_timeout = 2; */
        if (message.readAfterWriteTimeout !== 0)
            writer.tag(2, WireType.Bit64).double(message.readAfterWriteTimeout);
        /* bool session_track_gtids = 3; */
        if (message.sessionTrackGtids !== false)
            writer.tag(3, WireType.Varint).bool(message.sessionTrackGtids);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ReadAfterWrite
 */
export const ReadAfterWrite = new ReadAfterWrite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteRequest$Type extends MessageType<ExecuteRequest> {
    constructor() {
        super("vtgate.ExecuteRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "query", kind: "message", T: () => BoundQuery }
        ]);
    }
    create(value?: PartialMessage<ExecuteRequest>): ExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteRequest): ExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* query.BoundQuery query */ 3:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 3; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ExecuteRequest
 */
export const ExecuteRequest = new ExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteResponse$Type extends MessageType<ExecuteResponse> {
    constructor() {
        super("vtgate.ExecuteResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "result", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<ExecuteResponse>): ExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteResponse): ExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* query.QueryResult result */ 3:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.QueryResult result = 3; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ExecuteResponse
 */
export const ExecuteResponse = new ExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteBatchRequest$Type extends MessageType<ExecuteBatchRequest> {
    constructor() {
        super("vtgate.ExecuteBatchRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "queries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BoundQuery }
        ]);
    }
    create(value?: PartialMessage<ExecuteBatchRequest>): ExecuteBatchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queries = [];
        if (value !== undefined)
            reflectionMergePartial<ExecuteBatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteBatchRequest): ExecuteBatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* repeated query.BoundQuery queries */ 3:
                    message.queries.push(BoundQuery.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.BoundQuery queries = 3; */
        for (let i = 0; i < message.queries.length; i++)
            BoundQuery.internalBinaryWrite(message.queries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ExecuteBatchRequest
 */
export const ExecuteBatchRequest = new ExecuteBatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteBatchResponse$Type extends MessageType<ExecuteBatchResponse> {
    constructor() {
        super("vtgate.ExecuteBatchResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResultWithError }
        ]);
    }
    create(value?: PartialMessage<ExecuteBatchResponse>): ExecuteBatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.results = [];
        if (value !== undefined)
            reflectionMergePartial<ExecuteBatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteBatchResponse): ExecuteBatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* repeated query.ResultWithError results */ 3:
                    message.results.push(ResultWithError.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.ResultWithError results = 3; */
        for (let i = 0; i < message.results.length; i++)
            ResultWithError.internalBinaryWrite(message.results[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ExecuteBatchResponse
 */
export const ExecuteBatchResponse = new ExecuteBatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamExecuteRequest$Type extends MessageType<StreamExecuteRequest> {
    constructor() {
        super("vtgate.StreamExecuteRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "query", kind: "message", T: () => BoundQuery },
            { no: 6, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<StreamExecuteRequest>): StreamExecuteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamExecuteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamExecuteRequest): StreamExecuteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* query.BoundQuery query */ 2:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                case /* vtgate.Session session */ 6:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamExecuteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 2; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 6; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.StreamExecuteRequest
 */
export const StreamExecuteRequest = new StreamExecuteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamExecuteResponse$Type extends MessageType<StreamExecuteResponse> {
    constructor() {
        super("vtgate.StreamExecuteResponse", [
            { no: 1, name: "result", kind: "message", T: () => QueryResult },
            { no: 2, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<StreamExecuteResponse>): StreamExecuteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamExecuteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamExecuteResponse): StreamExecuteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.QueryResult result */ 1:
                    message.result = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamExecuteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.QueryResult result = 1; */
        if (message.result)
            QueryResult.internalBinaryWrite(message.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.StreamExecuteResponse
 */
export const StreamExecuteResponse = new StreamExecuteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveTransactionRequest$Type extends MessageType<ResolveTransactionRequest> {
    constructor() {
        super("vtgate.ResolveTransactionRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "dtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResolveTransactionRequest>): ResolveTransactionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dtid = "";
        if (value !== undefined)
            reflectionMergePartial<ResolveTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolveTransactionRequest): ResolveTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* string dtid */ 2:
                    message.dtid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResolveTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string dtid = 2; */
        if (message.dtid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dtid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ResolveTransactionRequest
 */
export const ResolveTransactionRequest = new ResolveTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveTransactionResponse$Type extends MessageType<ResolveTransactionResponse> {
    constructor() {
        super("vtgate.ResolveTransactionResponse", []);
    }
    create(value?: PartialMessage<ResolveTransactionResponse>): ResolveTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResolveTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolveTransactionResponse): ResolveTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResolveTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.ResolveTransactionResponse
 */
export const ResolveTransactionResponse = new ResolveTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamFlags$Type extends MessageType<VStreamFlags> {
    constructor() {
        super("vtgate.VStreamFlags", [
            { no: 1, name: "minimize_skew", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "heartbeat_interval", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "stop_on_reshard", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cells", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cell_preference", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "tablet_order", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "stream_keyspace_heartbeats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "include_reshard_journal_events", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VStreamFlags>): VStreamFlags {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.minimizeSkew = false;
        message.heartbeatInterval = 0;
        message.stopOnReshard = false;
        message.cells = "";
        message.cellPreference = "";
        message.tabletOrder = "";
        message.streamKeyspaceHeartbeats = false;
        message.includeReshardJournalEvents = false;
        if (value !== undefined)
            reflectionMergePartial<VStreamFlags>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamFlags): VStreamFlags {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool minimize_skew */ 1:
                    message.minimizeSkew = reader.bool();
                    break;
                case /* uint32 heartbeat_interval */ 2:
                    message.heartbeatInterval = reader.uint32();
                    break;
                case /* bool stop_on_reshard */ 3:
                    message.stopOnReshard = reader.bool();
                    break;
                case /* string cells */ 4:
                    message.cells = reader.string();
                    break;
                case /* string cell_preference */ 5:
                    message.cellPreference = reader.string();
                    break;
                case /* string tablet_order */ 6:
                    message.tabletOrder = reader.string();
                    break;
                case /* bool stream_keyspace_heartbeats */ 7:
                    message.streamKeyspaceHeartbeats = reader.bool();
                    break;
                case /* bool include_reshard_journal_events */ 8:
                    message.includeReshardJournalEvents = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamFlags, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool minimize_skew = 1; */
        if (message.minimizeSkew !== false)
            writer.tag(1, WireType.Varint).bool(message.minimizeSkew);
        /* uint32 heartbeat_interval = 2; */
        if (message.heartbeatInterval !== 0)
            writer.tag(2, WireType.Varint).uint32(message.heartbeatInterval);
        /* bool stop_on_reshard = 3; */
        if (message.stopOnReshard !== false)
            writer.tag(3, WireType.Varint).bool(message.stopOnReshard);
        /* string cells = 4; */
        if (message.cells !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.cells);
        /* string cell_preference = 5; */
        if (message.cellPreference !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.cellPreference);
        /* string tablet_order = 6; */
        if (message.tabletOrder !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.tabletOrder);
        /* bool stream_keyspace_heartbeats = 7; */
        if (message.streamKeyspaceHeartbeats !== false)
            writer.tag(7, WireType.Varint).bool(message.streamKeyspaceHeartbeats);
        /* bool include_reshard_journal_events = 8; */
        if (message.includeReshardJournalEvents !== false)
            writer.tag(8, WireType.Varint).bool(message.includeReshardJournalEvents);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.VStreamFlags
 */
export const VStreamFlags = new VStreamFlags$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamRequest$Type extends MessageType<VStreamRequest> {
    constructor() {
        super("vtgate.VStreamRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 3, name: "vgtid", kind: "message", T: () => VGtid },
            { no: 4, name: "filter", kind: "message", T: () => Filter },
            { no: 5, name: "flags", kind: "message", T: () => VStreamFlags }
        ]);
    }
    create(value?: PartialMessage<VStreamRequest>): VStreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tabletType = 0;
        if (value !== undefined)
            reflectionMergePartial<VStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamRequest): VStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* topodata.TabletType tablet_type */ 2:
                    message.tabletType = reader.int32();
                    break;
                case /* binlogdata.VGtid vgtid */ 3:
                    message.vgtid = VGtid.internalBinaryRead(reader, reader.uint32(), options, message.vgtid);
                    break;
                case /* binlogdata.Filter filter */ 4:
                    message.filter = Filter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* vtgate.VStreamFlags flags */ 5:
                    message.flags = VStreamFlags.internalBinaryRead(reader, reader.uint32(), options, message.flags);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* topodata.TabletType tablet_type = 2; */
        if (message.tabletType !== 0)
            writer.tag(2, WireType.Varint).int32(message.tabletType);
        /* binlogdata.VGtid vgtid = 3; */
        if (message.vgtid)
            VGtid.internalBinaryWrite(message.vgtid, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.Filter filter = 4; */
        if (message.filter)
            Filter.internalBinaryWrite(message.filter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.VStreamFlags flags = 5; */
        if (message.flags)
            VStreamFlags.internalBinaryWrite(message.flags, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.VStreamRequest
 */
export const VStreamRequest = new VStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamResponse$Type extends MessageType<VStreamResponse> {
    constructor() {
        super("vtgate.VStreamResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VEvent }
        ]);
    }
    create(value?: PartialMessage<VStreamResponse>): VStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<VStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamResponse): VStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.VEvent events */ 1:
                    message.events.push(VEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.VEvent events = 1; */
        for (let i = 0; i < message.events.length; i++)
            VEvent.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.VStreamResponse
 */
export const VStreamResponse = new VStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareRequest$Type extends MessageType<PrepareRequest> {
    constructor() {
        super("vtgate.PrepareRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "query", kind: "message", T: () => BoundQuery }
        ]);
    }
    create(value?: PartialMessage<PrepareRequest>): PrepareRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PrepareRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareRequest): PrepareRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* query.BoundQuery query */ 3:
                    message.query = BoundQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.BoundQuery query = 3; */
        if (message.query)
            BoundQuery.internalBinaryWrite(message.query, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.PrepareRequest
 */
export const PrepareRequest = new PrepareRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareResponse$Type extends MessageType<PrepareResponse> {
    constructor() {
        super("vtgate.PrepareResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError },
            { no: 2, name: "session", kind: "message", T: () => Session },
            { no: 3, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field }
        ]);
    }
    create(value?: PartialMessage<PrepareResponse>): PrepareResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<PrepareResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareResponse): PrepareResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* repeated query.Field fields */ 3:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.Field fields = 3; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.PrepareResponse
 */
export const PrepareResponse = new PrepareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseSessionRequest$Type extends MessageType<CloseSessionRequest> {
    constructor() {
        super("vtgate.CloseSessionRequest", [
            { no: 1, name: "caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "session", kind: "message", T: () => Session }
        ]);
    }
    create(value?: PartialMessage<CloseSessionRequest>): CloseSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CloseSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseSessionRequest): CloseSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID caller_id */ 1:
                    message.callerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.callerId);
                    break;
                case /* vtgate.Session session */ 2:
                    message.session = Session.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID caller_id = 1; */
        if (message.callerId)
            CallerID.internalBinaryWrite(message.callerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* vtgate.Session session = 2; */
        if (message.session)
            Session.internalBinaryWrite(message.session, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.CloseSessionRequest
 */
export const CloseSessionRequest = new CloseSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseSessionResponse$Type extends MessageType<CloseSessionResponse> {
    constructor() {
        super("vtgate.CloseSessionResponse", [
            { no: 1, name: "error", kind: "message", T: () => RPCError }
        ]);
    }
    create(value?: PartialMessage<CloseSessionResponse>): CloseSessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CloseSessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseSessionResponse): CloseSessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.RPCError error */ 1:
                    message.error = RPCError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseSessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.RPCError error = 1; */
        if (message.error)
            RPCError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message vtgate.CloseSessionResponse
 */
export const CloseSessionResponse = new CloseSessionResponse$Type();
