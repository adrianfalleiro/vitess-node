// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "vtctlservice.proto" (package "vtctlservice", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This package contains a service allowing you to use vtctld as a
// proxy for vt commands.
//
import { Vtctld } from "./vtctlservice";
import type { WorkflowMirrorTrafficResponse } from "./vtctldata";
import type { WorkflowMirrorTrafficRequest } from "./vtctldata";
import type { GetMirrorRulesResponse } from "./vtctldata";
import type { GetMirrorRulesRequest } from "./vtctldata";
import type { WorkflowUpdateResponse } from "./vtctldata";
import type { WorkflowUpdateRequest } from "./vtctldata";
import type { WorkflowSwitchTrafficResponse } from "./vtctldata";
import type { WorkflowSwitchTrafficRequest } from "./vtctldata";
import type { WorkflowStatusRequest } from "./vtctldata";
import type { WorkflowDeleteResponse } from "./vtctldata";
import type { WorkflowDeleteRequest } from "./vtctldata";
import type { VDiffStopResponse } from "./vtctldata";
import type { VDiffStopRequest } from "./vtctldata";
import type { VDiffShowResponse } from "./vtctldata";
import type { VDiffShowRequest } from "./vtctldata";
import type { VDiffResumeResponse } from "./vtctldata";
import type { VDiffResumeRequest } from "./vtctldata";
import type { VDiffDeleteResponse } from "./vtctldata";
import type { VDiffDeleteRequest } from "./vtctldata";
import type { VDiffCreateResponse } from "./vtctldata";
import type { VDiffCreateRequest } from "./vtctldata";
import type { ValidateVSchemaResponse } from "./vtctldata";
import type { ValidateVSchemaRequest } from "./vtctldata";
import type { ValidateVersionShardResponse } from "./vtctldata";
import type { ValidateVersionShardRequest } from "./vtctldata";
import type { ValidateVersionKeyspaceResponse } from "./vtctldata";
import type { ValidateVersionKeyspaceRequest } from "./vtctldata";
import type { ValidateShardResponse } from "./vtctldata";
import type { ValidateShardRequest } from "./vtctldata";
import type { ValidateSchemaKeyspaceResponse } from "./vtctldata";
import type { ValidateSchemaKeyspaceRequest } from "./vtctldata";
import type { ValidateKeyspaceResponse } from "./vtctldata";
import type { ValidateKeyspaceRequest } from "./vtctldata";
import type { ValidateResponse } from "./vtctldata";
import type { ValidateRequest } from "./vtctldata";
import type { UpdateCellsAliasResponse } from "./vtctldata";
import type { UpdateCellsAliasRequest } from "./vtctldata";
import type { UpdateCellInfoResponse } from "./vtctldata";
import type { UpdateCellInfoRequest } from "./vtctldata";
import type { TabletExternallyReparentedResponse } from "./vtctldata";
import type { TabletExternallyReparentedRequest } from "./vtctldata";
import type { StopReplicationResponse } from "./vtctldata";
import type { StopReplicationRequest } from "./vtctldata";
import type { StartReplicationResponse } from "./vtctldata";
import type { StartReplicationRequest } from "./vtctldata";
import type { SourceShardDeleteResponse } from "./vtctldata";
import type { SourceShardDeleteRequest } from "./vtctldata";
import type { SourceShardAddResponse } from "./vtctldata";
import type { SourceShardAddRequest } from "./vtctldata";
import type { SleepTabletResponse } from "./vtctldata";
import type { SleepTabletRequest } from "./vtctldata";
import type { ShardReplicationRemoveResponse } from "./vtctldata";
import type { ShardReplicationRemoveRequest } from "./vtctldata";
import type { ShardReplicationPositionsResponse } from "./vtctldata";
import type { ShardReplicationPositionsRequest } from "./vtctldata";
import type { ShardReplicationFixResponse } from "./vtctldata";
import type { ShardReplicationFixRequest } from "./vtctldata";
import type { ShardReplicationAddResponse } from "./vtctldata";
import type { ShardReplicationAddRequest } from "./vtctldata";
import type { SetWritableResponse } from "./vtctldata";
import type { SetWritableRequest } from "./vtctldata";
import type { SetShardTabletControlResponse } from "./vtctldata";
import type { SetShardTabletControlRequest } from "./vtctldata";
import type { SetShardIsPrimaryServingResponse } from "./vtctldata";
import type { SetShardIsPrimaryServingRequest } from "./vtctldata";
import type { SetKeyspaceDurabilityPolicyResponse } from "./vtctldata";
import type { SetKeyspaceDurabilityPolicyRequest } from "./vtctldata";
import type { RunHealthCheckResponse } from "./vtctldata";
import type { RunHealthCheckRequest } from "./vtctldata";
import type { RetrySchemaMigrationResponse } from "./vtctldata";
import type { RetrySchemaMigrationRequest } from "./vtctldata";
import type { RestoreFromBackupResponse } from "./vtctldata";
import type { RestoreFromBackupRequest } from "./vtctldata";
import type { ReshardCreateRequest } from "./vtctldata";
import type { ReparentTabletResponse } from "./vtctldata";
import type { ReparentTabletRequest } from "./vtctldata";
import type { RemoveShardCellResponse } from "./vtctldata";
import type { RemoveShardCellRequest } from "./vtctldata";
import type { RemoveKeyspaceCellResponse } from "./vtctldata";
import type { RemoveKeyspaceCellRequest } from "./vtctldata";
import type { RemoveBackupResponse } from "./vtctldata";
import type { RemoveBackupRequest } from "./vtctldata";
import type { ReloadSchemaShardResponse } from "./vtctldata";
import type { ReloadSchemaShardRequest } from "./vtctldata";
import type { ReloadSchemaKeyspaceResponse } from "./vtctldata";
import type { ReloadSchemaKeyspaceRequest } from "./vtctldata";
import type { ReloadSchemaResponse } from "./vtctldata";
import type { ReloadSchemaRequest } from "./vtctldata";
import type { RefreshStateByShardResponse } from "./vtctldata";
import type { RefreshStateByShardRequest } from "./vtctldata";
import type { RefreshStateResponse } from "./vtctldata";
import type { RefreshStateRequest } from "./vtctldata";
import type { RebuildVSchemaGraphResponse } from "./vtctldata";
import type { RebuildVSchemaGraphRequest } from "./vtctldata";
import type { RebuildKeyspaceGraphResponse } from "./vtctldata";
import type { RebuildKeyspaceGraphRequest } from "./vtctldata";
import type { PlannedReparentShardResponse } from "./vtctldata";
import type { PlannedReparentShardRequest } from "./vtctldata";
import type { PingTabletResponse } from "./vtctldata";
import type { PingTabletRequest } from "./vtctldata";
import type { MoveTablesCompleteResponse } from "./vtctldata";
import type { MoveTablesCompleteRequest } from "./vtctldata";
import type { MoveTablesCreateRequest } from "./vtctldata";
import type { MountListResponse } from "./vtctldata";
import type { MountListRequest } from "./vtctldata";
import type { MountShowResponse } from "./vtctldata";
import type { MountShowRequest } from "./vtctldata";
import type { MountUnregisterResponse } from "./vtctldata";
import type { MountUnregisterRequest } from "./vtctldata";
import type { MountRegisterResponse } from "./vtctldata";
import type { MountRegisterRequest } from "./vtctldata";
import type { WorkflowStatusResponse } from "./vtctldata";
import type { MigrateCreateRequest } from "./vtctldata";
import type { MaterializeCreateResponse } from "./vtctldata";
import type { MaterializeCreateRequest } from "./vtctldata";
import type { LookupVindexExternalizeResponse } from "./vtctldata";
import type { LookupVindexExternalizeRequest } from "./vtctldata";
import type { LookupVindexCreateResponse } from "./vtctldata";
import type { LookupVindexCreateRequest } from "./vtctldata";
import type { LaunchSchemaMigrationResponse } from "./vtctldata";
import type { LaunchSchemaMigrationRequest } from "./vtctldata";
import type { InitShardPrimaryResponse } from "./vtctldata";
import type { InitShardPrimaryRequest } from "./vtctldata";
import type { GetWorkflowsResponse } from "./vtctldata";
import type { GetWorkflowsRequest } from "./vtctldata";
import type { GetVSchemaResponse } from "./vtctldata";
import type { GetVSchemaRequest } from "./vtctldata";
import type { GetVersionResponse } from "./vtctldata";
import type { GetVersionRequest } from "./vtctldata";
import type { GetUnresolvedTransactionsResponse } from "./vtctldata";
import type { GetUnresolvedTransactionsRequest } from "./vtctldata";
import type { GetTopologyPathResponse } from "./vtctldata";
import type { GetTopologyPathRequest } from "./vtctldata";
import type { GetThrottlerStatusResponse } from "./vtctldata";
import type { GetThrottlerStatusRequest } from "./vtctldata";
import type { GetTabletsResponse } from "./vtctldata";
import type { GetTabletsRequest } from "./vtctldata";
import type { GetTabletResponse } from "./vtctldata";
import type { GetTabletRequest } from "./vtctldata";
import type { GetSrvVSchemasResponse } from "./vtctldata";
import type { GetSrvVSchemasRequest } from "./vtctldata";
import type { GetSrvVSchemaResponse } from "./vtctldata";
import type { GetSrvVSchemaRequest } from "./vtctldata";
import type { UpdateThrottlerConfigResponse } from "./vtctldata";
import type { UpdateThrottlerConfigRequest } from "./vtctldata";
import type { GetSrvKeyspacesResponse } from "./vtctldata";
import type { GetSrvKeyspacesRequest } from "./vtctldata";
import type { GetSrvKeyspaceNamesResponse } from "./vtctldata";
import type { GetSrvKeyspaceNamesRequest } from "./vtctldata";
import type { GetShardRoutingRulesResponse } from "./vtctldata";
import type { GetShardRoutingRulesRequest } from "./vtctldata";
import type { GetShardResponse } from "./vtctldata";
import type { GetShardRequest } from "./vtctldata";
import type { GetShardReplicationResponse } from "./vtctldata";
import type { GetShardReplicationRequest } from "./vtctldata";
import type { GetSchemaMigrationsResponse } from "./vtctldata";
import type { GetSchemaMigrationsRequest } from "./vtctldata";
import type { GetSchemaResponse } from "./vtctldata";
import type { GetSchemaRequest } from "./vtctldata";
import type { GetRoutingRulesResponse } from "./vtctldata";
import type { GetRoutingRulesRequest } from "./vtctldata";
import type { GetPermissionsResponse } from "./vtctldata";
import type { GetPermissionsRequest } from "./vtctldata";
import type { GetKeyspaceRoutingRulesResponse } from "./vtctldata";
import type { GetKeyspaceRoutingRulesRequest } from "./vtctldata";
import type { GetKeyspacesResponse } from "./vtctldata";
import type { GetKeyspacesRequest } from "./vtctldata";
import type { GetKeyspaceResponse } from "./vtctldata";
import type { GetKeyspaceRequest } from "./vtctldata";
import type { GetFullStatusResponse } from "./vtctldata";
import type { GetFullStatusRequest } from "./vtctldata";
import type { GetCellsAliasesResponse } from "./vtctldata";
import type { GetCellsAliasesRequest } from "./vtctldata";
import type { GetCellInfoNamesResponse } from "./vtctldata";
import type { GetCellInfoNamesRequest } from "./vtctldata";
import type { GetCellInfoResponse } from "./vtctldata";
import type { GetCellInfoRequest } from "./vtctldata";
import type { GetBackupsResponse } from "./vtctldata";
import type { GetBackupsRequest } from "./vtctldata";
import type { ForceCutOverSchemaMigrationResponse } from "./vtctldata";
import type { ForceCutOverSchemaMigrationRequest } from "./vtctldata";
import type { FindAllShardsInKeyspaceResponse } from "./vtctldata";
import type { FindAllShardsInKeyspaceRequest } from "./vtctldata";
import type { ExecuteMultiFetchAsDBAResponse } from "./vtctldata";
import type { ExecuteMultiFetchAsDBARequest } from "./vtctldata";
import type { ExecuteHookResponse } from "./vtctldata";
import type { ExecuteHookRequest } from "./vtctldata";
import type { ExecuteFetchAsDBAResponse } from "./vtctldata";
import type { ExecuteFetchAsDBARequest } from "./vtctldata";
import type { ExecuteFetchAsAppResponse } from "./vtctldata";
import type { ExecuteFetchAsAppRequest } from "./vtctldata";
import type { EmergencyReparentShardResponse } from "./vtctldata";
import type { EmergencyReparentShardRequest } from "./vtctldata";
import type { DeleteTabletsResponse } from "./vtctldata";
import type { DeleteTabletsRequest } from "./vtctldata";
import type { DeleteSrvVSchemaResponse } from "./vtctldata";
import type { DeleteSrvVSchemaRequest } from "./vtctldata";
import type { DeleteShardsResponse } from "./vtctldata";
import type { DeleteShardsRequest } from "./vtctldata";
import type { DeleteKeyspaceResponse } from "./vtctldata";
import type { DeleteKeyspaceRequest } from "./vtctldata";
import type { DeleteCellsAliasResponse } from "./vtctldata";
import type { DeleteCellsAliasRequest } from "./vtctldata";
import type { DeleteCellInfoResponse } from "./vtctldata";
import type { DeleteCellInfoRequest } from "./vtctldata";
import type { CreateShardResponse } from "./vtctldata";
import type { CreateShardRequest } from "./vtctldata";
import type { CreateKeyspaceResponse } from "./vtctldata";
import type { CreateKeyspaceRequest } from "./vtctldata";
import type { ConcludeTransactionResponse } from "./vtctldata";
import type { ConcludeTransactionRequest } from "./vtctldata";
import type { CompleteSchemaMigrationResponse } from "./vtctldata";
import type { CompleteSchemaMigrationRequest } from "./vtctldata";
import type { CleanupSchemaMigrationResponse } from "./vtctldata";
import type { CleanupSchemaMigrationRequest } from "./vtctldata";
import type { CheckThrottlerResponse } from "./vtctldata";
import type { CheckThrottlerRequest } from "./vtctldata";
import type { ChangeTabletTypeResponse } from "./vtctldata";
import type { ChangeTabletTypeRequest } from "./vtctldata";
import type { ChangeTabletTagsResponse } from "./vtctldata";
import type { ChangeTabletTagsRequest } from "./vtctldata";
import type { CancelSchemaMigrationResponse } from "./vtctldata";
import type { CancelSchemaMigrationRequest } from "./vtctldata";
import type { BackupShardRequest } from "./vtctldata";
import type { BackupResponse } from "./vtctldata";
import type { BackupRequest } from "./vtctldata";
import type { ApplyVSchemaResponse } from "./vtctldata";
import type { ApplyVSchemaRequest } from "./vtctldata";
import type { ApplyShardRoutingRulesResponse } from "./vtctldata";
import type { ApplyShardRoutingRulesRequest } from "./vtctldata";
import type { ApplyKeyspaceRoutingRulesResponse } from "./vtctldata";
import type { ApplyKeyspaceRoutingRulesRequest } from "./vtctldata";
import type { ApplySchemaResponse } from "./vtctldata";
import type { ApplySchemaRequest } from "./vtctldata";
import type { ApplyRoutingRulesResponse } from "./vtctldata";
import type { ApplyRoutingRulesRequest } from "./vtctldata";
import type { AddCellsAliasResponse } from "./vtctldata";
import type { AddCellsAliasRequest } from "./vtctldata";
import type { AddCellInfoResponse } from "./vtctldata";
import type { AddCellInfoRequest } from "./vtctldata";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Vtctl } from "./vtctlservice";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ExecuteVtctlCommandResponse } from "./vtctldata";
import type { ExecuteVtctlCommandRequest } from "./vtctldata";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Service Vtctl allows you to call vt commands through gRPC.
 *
 * @generated from protobuf service vtctlservice.Vtctl
 */
export interface IVtctlClient {
    /**
     * @generated from protobuf rpc: ExecuteVtctlCommand(vtctldata.ExecuteVtctlCommandRequest) returns (stream vtctldata.ExecuteVtctlCommandResponse);
     */
    executeVtctlCommand(input: ExecuteVtctlCommandRequest, options?: RpcOptions): ServerStreamingCall<ExecuteVtctlCommandRequest, ExecuteVtctlCommandResponse>;
}
/**
 * Service Vtctl allows you to call vt commands through gRPC.
 *
 * @generated from protobuf service vtctlservice.Vtctl
 */
export class VtctlClient implements IVtctlClient, ServiceInfo {
    typeName = Vtctl.typeName;
    methods = Vtctl.methods;
    options = Vtctl.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: ExecuteVtctlCommand(vtctldata.ExecuteVtctlCommandRequest) returns (stream vtctldata.ExecuteVtctlCommandResponse);
     */
    executeVtctlCommand(input: ExecuteVtctlCommandRequest, options?: RpcOptions): ServerStreamingCall<ExecuteVtctlCommandRequest, ExecuteVtctlCommandResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteVtctlCommandRequest, ExecuteVtctlCommandResponse>("serverStreaming", this._transport, method, opt, input);
    }
}
/**
 * Service Vtctld exposes gRPC endpoints for each vt command.
 *
 * @generated from protobuf service vtctlservice.Vtctld
 */
export interface IVtctldClient {
    /**
     * AddCellInfo registers a local topology service in a new cell by creating
     * the CellInfo with the provided parameters.
     *
     * @generated from protobuf rpc: AddCellInfo(vtctldata.AddCellInfoRequest) returns (vtctldata.AddCellInfoResponse);
     */
    addCellInfo(input: AddCellInfoRequest, options?: RpcOptions): UnaryCall<AddCellInfoRequest, AddCellInfoResponse>;
    /**
     * AddCellsAlias defines a group of cells that can be referenced by a single
     * name (the alias).
     *
     * When routing query traffic, replica/rdonly traffic can be routed across
     * cells within the group (alias). Only primary traffic can be routed across
     * cells not in the same group (alias).
     *
     * @generated from protobuf rpc: AddCellsAlias(vtctldata.AddCellsAliasRequest) returns (vtctldata.AddCellsAliasResponse);
     */
    addCellsAlias(input: AddCellsAliasRequest, options?: RpcOptions): UnaryCall<AddCellsAliasRequest, AddCellsAliasResponse>;
    /**
     * ApplyRoutingRules applies the VSchema routing rules.
     *
     * @generated from protobuf rpc: ApplyRoutingRules(vtctldata.ApplyRoutingRulesRequest) returns (vtctldata.ApplyRoutingRulesResponse);
     */
    applyRoutingRules(input: ApplyRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyRoutingRulesRequest, ApplyRoutingRulesResponse>;
    /**
     * ApplySchema applies a schema to a keyspace.
     *
     * @generated from protobuf rpc: ApplySchema(vtctldata.ApplySchemaRequest) returns (vtctldata.ApplySchemaResponse);
     */
    applySchema(input: ApplySchemaRequest, options?: RpcOptions): UnaryCall<ApplySchemaRequest, ApplySchemaResponse>;
    /**
     * ApplyKeyspaceRoutingRules applies the VSchema keyspace routing rules.
     *
     * @generated from protobuf rpc: ApplyKeyspaceRoutingRules(vtctldata.ApplyKeyspaceRoutingRulesRequest) returns (vtctldata.ApplyKeyspaceRoutingRulesResponse);
     */
    applyKeyspaceRoutingRules(input: ApplyKeyspaceRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyKeyspaceRoutingRulesRequest, ApplyKeyspaceRoutingRulesResponse>;
    /**
     * ApplyShardRoutingRules applies the VSchema shard routing rules.
     *
     * @generated from protobuf rpc: ApplyShardRoutingRules(vtctldata.ApplyShardRoutingRulesRequest) returns (vtctldata.ApplyShardRoutingRulesResponse);
     */
    applyShardRoutingRules(input: ApplyShardRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyShardRoutingRulesRequest, ApplyShardRoutingRulesResponse>;
    /**
     * ApplyVSchema applies a vschema to a keyspace.
     *
     * @generated from protobuf rpc: ApplyVSchema(vtctldata.ApplyVSchemaRequest) returns (vtctldata.ApplyVSchemaResponse);
     */
    applyVSchema(input: ApplyVSchemaRequest, options?: RpcOptions): UnaryCall<ApplyVSchemaRequest, ApplyVSchemaResponse>;
    /**
     * Backup uses the BackupEngine and BackupStorage services on the specified
     * tablet to create and store a new backup.
     *
     * @generated from protobuf rpc: Backup(vtctldata.BackupRequest) returns (stream vtctldata.BackupResponse);
     */
    backup(input: BackupRequest, options?: RpcOptions): ServerStreamingCall<BackupRequest, BackupResponse>;
    /**
     * BackupShard chooses a tablet in the shard and uses it to create a backup.
     *
     * @generated from protobuf rpc: BackupShard(vtctldata.BackupShardRequest) returns (stream vtctldata.BackupResponse);
     */
    backupShard(input: BackupShardRequest, options?: RpcOptions): ServerStreamingCall<BackupShardRequest, BackupResponse>;
    /**
     * CancelSchemaMigration cancels one or all migrations, terminating any running ones as needed.
     *
     * @generated from protobuf rpc: CancelSchemaMigration(vtctldata.CancelSchemaMigrationRequest) returns (vtctldata.CancelSchemaMigrationResponse);
     */
    cancelSchemaMigration(input: CancelSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse>;
    /**
     * ChangeTabletTags changes the tags of the specified tablet, if possible.
     *
     * @generated from protobuf rpc: ChangeTabletTags(vtctldata.ChangeTabletTagsRequest) returns (vtctldata.ChangeTabletTagsResponse);
     */
    changeTabletTags(input: ChangeTabletTagsRequest, options?: RpcOptions): UnaryCall<ChangeTabletTagsRequest, ChangeTabletTagsResponse>;
    /**
     * ChangeTabletType changes the db type for the specified tablet, if possible.
     * This is used primarily to arrange replicas, and it will not convert a
     * primary. For that, use InitShardPrimary.
     *
     * NOTE: This command automatically updates the serving graph.
     *
     * @generated from protobuf rpc: ChangeTabletType(vtctldata.ChangeTabletTypeRequest) returns (vtctldata.ChangeTabletTypeResponse);
     */
    changeTabletType(input: ChangeTabletTypeRequest, options?: RpcOptions): UnaryCall<ChangeTabletTypeRequest, ChangeTabletTypeResponse>;
    /**
     * CheckThrottler issues a 'check' on a tablet's throttler
     *
     * @generated from protobuf rpc: CheckThrottler(vtctldata.CheckThrottlerRequest) returns (vtctldata.CheckThrottlerResponse);
     */
    checkThrottler(input: CheckThrottlerRequest, options?: RpcOptions): UnaryCall<CheckThrottlerRequest, CheckThrottlerResponse>;
    /**
     * CleanupSchemaMigration marks a schema migration as ready for artifact cleanup.
     *
     * @generated from protobuf rpc: CleanupSchemaMigration(vtctldata.CleanupSchemaMigrationRequest) returns (vtctldata.CleanupSchemaMigrationResponse);
     */
    cleanupSchemaMigration(input: CleanupSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse>;
    /**
     * CompleteSchemaMigration completes one or all migrations executed with --postpone-completion.
     *
     * @generated from protobuf rpc: CompleteSchemaMigration(vtctldata.CompleteSchemaMigrationRequest) returns (vtctldata.CompleteSchemaMigrationResponse);
     */
    completeSchemaMigration(input: CompleteSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse>;
    /**
     * CompleteSchemaMigration completes one or all migrations executed with --postpone-completion.
     *
     * @generated from protobuf rpc: ConcludeTransaction(vtctldata.ConcludeTransactionRequest) returns (vtctldata.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse>;
    /**
     * CreateKeyspace creates the specified keyspace in the topology. For a
     * SNAPSHOT keyspace, the request must specify the name of a base keyspace,
     * as well as a snapshot time.
     *
     * @generated from protobuf rpc: CreateKeyspace(vtctldata.CreateKeyspaceRequest) returns (vtctldata.CreateKeyspaceResponse);
     */
    createKeyspace(input: CreateKeyspaceRequest, options?: RpcOptions): UnaryCall<CreateKeyspaceRequest, CreateKeyspaceResponse>;
    /**
     * CreateShard creates the specified shard in the topology.
     *
     * @generated from protobuf rpc: CreateShard(vtctldata.CreateShardRequest) returns (vtctldata.CreateShardResponse);
     */
    createShard(input: CreateShardRequest, options?: RpcOptions): UnaryCall<CreateShardRequest, CreateShardResponse>;
    /**
     * DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
     * be referenced by any Shard record in the topology.
     *
     * @generated from protobuf rpc: DeleteCellInfo(vtctldata.DeleteCellInfoRequest) returns (vtctldata.DeleteCellInfoResponse);
     */
    deleteCellInfo(input: DeleteCellInfoRequest, options?: RpcOptions): UnaryCall<DeleteCellInfoRequest, DeleteCellInfoResponse>;
    /**
     * DeleteCellsAlias deletes the CellsAlias for the provided alias.
     *
     * @generated from protobuf rpc: DeleteCellsAlias(vtctldata.DeleteCellsAliasRequest) returns (vtctldata.DeleteCellsAliasResponse);
     */
    deleteCellsAlias(input: DeleteCellsAliasRequest, options?: RpcOptions): UnaryCall<DeleteCellsAliasRequest, DeleteCellsAliasResponse>;
    /**
     * DeleteKeyspace deletes the specified keyspace from the topology. In
     * recursive mode, it also recursively deletes all shards in the keyspace.
     * Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
     * returns an error.
     *
     * @generated from protobuf rpc: DeleteKeyspace(vtctldata.DeleteKeyspaceRequest) returns (vtctldata.DeleteKeyspaceResponse);
     */
    deleteKeyspace(input: DeleteKeyspaceRequest, options?: RpcOptions): UnaryCall<DeleteKeyspaceRequest, DeleteKeyspaceResponse>;
    /**
     * DeleteShards deletes the specified shards from the topology. In recursive
     * mode, it also deletes all tablets belonging to the shard. Otherwise, the
     * shard must be empty (have no tablets) or DeleteShards returns an error for
     * that shard.
     *
     * @generated from protobuf rpc: DeleteShards(vtctldata.DeleteShardsRequest) returns (vtctldata.DeleteShardsResponse);
     */
    deleteShards(input: DeleteShardsRequest, options?: RpcOptions): UnaryCall<DeleteShardsRequest, DeleteShardsResponse>;
    /**
     * DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
     *
     * @generated from protobuf rpc: DeleteSrvVSchema(vtctldata.DeleteSrvVSchemaRequest) returns (vtctldata.DeleteSrvVSchemaResponse);
     */
    deleteSrvVSchema(input: DeleteSrvVSchemaRequest, options?: RpcOptions): UnaryCall<DeleteSrvVSchemaRequest, DeleteSrvVSchemaResponse>;
    /**
     * DeleteTablets deletes one or more tablets from the topology.
     *
     * @generated from protobuf rpc: DeleteTablets(vtctldata.DeleteTabletsRequest) returns (vtctldata.DeleteTabletsResponse);
     */
    deleteTablets(input: DeleteTabletsRequest, options?: RpcOptions): UnaryCall<DeleteTabletsRequest, DeleteTabletsResponse>;
    /**
     * EmergencyReparentShard reparents the shard to the new primary. It assumes
     * the old primary is dead or otherwise not responding.
     *
     * @generated from protobuf rpc: EmergencyReparentShard(vtctldata.EmergencyReparentShardRequest) returns (vtctldata.EmergencyReparentShardResponse);
     */
    emergencyReparentShard(input: EmergencyReparentShardRequest, options?: RpcOptions): UnaryCall<EmergencyReparentShardRequest, EmergencyReparentShardResponse>;
    /**
     * ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
     *
     * @generated from protobuf rpc: ExecuteFetchAsApp(vtctldata.ExecuteFetchAsAppRequest) returns (vtctldata.ExecuteFetchAsAppResponse);
     */
    executeFetchAsApp(input: ExecuteFetchAsAppRequest, options?: RpcOptions): UnaryCall<ExecuteFetchAsAppRequest, ExecuteFetchAsAppResponse>;
    /**
     * ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
     *
     * @generated from protobuf rpc: ExecuteFetchAsDBA(vtctldata.ExecuteFetchAsDBARequest) returns (vtctldata.ExecuteFetchAsDBAResponse);
     */
    executeFetchAsDBA(input: ExecuteFetchAsDBARequest, options?: RpcOptions): UnaryCall<ExecuteFetchAsDBARequest, ExecuteFetchAsDBAResponse>;
    /**
     * ExecuteHook runs the hook on the tablet.
     *
     * @generated from protobuf rpc: ExecuteHook(vtctldata.ExecuteHookRequest) returns (vtctldata.ExecuteHookResponse);
     */
    executeHook(input: ExecuteHookRequest, options?: RpcOptions): UnaryCall<ExecuteHookRequest, ExecuteHookResponse>;
    /**
     * ExecuteMultiFetchAsDBA executes one or more SQL queries on the remote tablet as the DBA user.
     *
     * @generated from protobuf rpc: ExecuteMultiFetchAsDBA(vtctldata.ExecuteMultiFetchAsDBARequest) returns (vtctldata.ExecuteMultiFetchAsDBAResponse);
     */
    executeMultiFetchAsDBA(input: ExecuteMultiFetchAsDBARequest, options?: RpcOptions): UnaryCall<ExecuteMultiFetchAsDBARequest, ExecuteMultiFetchAsDBAResponse>;
    /**
     * FindAllShardsInKeyspace returns a map of shard names to shard references
     * for a given keyspace.
     *
     * @generated from protobuf rpc: FindAllShardsInKeyspace(vtctldata.FindAllShardsInKeyspaceRequest) returns (vtctldata.FindAllShardsInKeyspaceResponse);
     */
    findAllShardsInKeyspace(input: FindAllShardsInKeyspaceRequest, options?: RpcOptions): UnaryCall<FindAllShardsInKeyspaceRequest, FindAllShardsInKeyspaceResponse>;
    /**
     * ForceCutOverSchemaMigration marks a schema migration for forced cut-over.
     *
     * @generated from protobuf rpc: ForceCutOverSchemaMigration(vtctldata.ForceCutOverSchemaMigrationRequest) returns (vtctldata.ForceCutOverSchemaMigrationResponse);
     */
    forceCutOverSchemaMigration(input: ForceCutOverSchemaMigrationRequest, options?: RpcOptions): UnaryCall<ForceCutOverSchemaMigrationRequest, ForceCutOverSchemaMigrationResponse>;
    /**
     * GetBackups returns all the backups for a shard.
     *
     * @generated from protobuf rpc: GetBackups(vtctldata.GetBackupsRequest) returns (vtctldata.GetBackupsResponse);
     */
    getBackups(input: GetBackupsRequest, options?: RpcOptions): UnaryCall<GetBackupsRequest, GetBackupsResponse>;
    /**
     * GetCellInfo returns the information for a cell.
     *
     * @generated from protobuf rpc: GetCellInfo(vtctldata.GetCellInfoRequest) returns (vtctldata.GetCellInfoResponse);
     */
    getCellInfo(input: GetCellInfoRequest, options?: RpcOptions): UnaryCall<GetCellInfoRequest, GetCellInfoResponse>;
    /**
     * GetCellInfoNames returns all the cells for which we have a CellInfo object,
     * meaning we have a topology service registered.
     *
     * @generated from protobuf rpc: GetCellInfoNames(vtctldata.GetCellInfoNamesRequest) returns (vtctldata.GetCellInfoNamesResponse);
     */
    getCellInfoNames(input: GetCellInfoNamesRequest, options?: RpcOptions): UnaryCall<GetCellInfoNamesRequest, GetCellInfoNamesResponse>;
    /**
     * GetCellsAliases returns a mapping of cell alias to cells identified by that
     * alias.
     *
     * @generated from protobuf rpc: GetCellsAliases(vtctldata.GetCellsAliasesRequest) returns (vtctldata.GetCellsAliasesResponse);
     */
    getCellsAliases(input: GetCellsAliasesRequest, options?: RpcOptions): UnaryCall<GetCellsAliasesRequest, GetCellsAliasesResponse>;
    /**
     * GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
     *
     * @generated from protobuf rpc: GetFullStatus(vtctldata.GetFullStatusRequest) returns (vtctldata.GetFullStatusResponse);
     */
    getFullStatus(input: GetFullStatusRequest, options?: RpcOptions): UnaryCall<GetFullStatusRequest, GetFullStatusResponse>;
    /**
     * GetKeyspace reads the given keyspace from the topo and returns it.
     *
     * @generated from protobuf rpc: GetKeyspace(vtctldata.GetKeyspaceRequest) returns (vtctldata.GetKeyspaceResponse);
     */
    getKeyspace(input: GetKeyspaceRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRequest, GetKeyspaceResponse>;
    /**
     * GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
     *
     * @generated from protobuf rpc: GetKeyspaces(vtctldata.GetKeyspacesRequest) returns (vtctldata.GetKeyspacesResponse);
     */
    getKeyspaces(input: GetKeyspacesRequest, options?: RpcOptions): UnaryCall<GetKeyspacesRequest, GetKeyspacesResponse>;
    /**
     * GetKeyspaceRoutingRules returns the VSchema keyspace routing rules.
     *
     * @generated from protobuf rpc: GetKeyspaceRoutingRules(vtctldata.GetKeyspaceRoutingRulesRequest) returns (vtctldata.GetKeyspaceRoutingRulesResponse);
     */
    getKeyspaceRoutingRules(input: GetKeyspaceRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRoutingRulesRequest, GetKeyspaceRoutingRulesResponse>;
    /**
     * GetPermissions returns the permissions set on the remote tablet.
     *
     * @generated from protobuf rpc: GetPermissions(vtctldata.GetPermissionsRequest) returns (vtctldata.GetPermissionsResponse);
     */
    getPermissions(input: GetPermissionsRequest, options?: RpcOptions): UnaryCall<GetPermissionsRequest, GetPermissionsResponse>;
    /**
     * GetRoutingRules returns the VSchema routing rules.
     *
     * @generated from protobuf rpc: GetRoutingRules(vtctldata.GetRoutingRulesRequest) returns (vtctldata.GetRoutingRulesResponse);
     */
    getRoutingRules(input: GetRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetRoutingRulesRequest, GetRoutingRulesResponse>;
    /**
     * GetSchema returns the schema for a tablet, or just the schema for the
     * specified tables in that tablet.
     *
     * @generated from protobuf rpc: GetSchema(vtctldata.GetSchemaRequest) returns (vtctldata.GetSchemaResponse);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): UnaryCall<GetSchemaRequest, GetSchemaResponse>;
    /**
     * GetSchemaMigrations returns one or more online schema migrations for the
     * specified keyspace, analagous to `SHOW VITESS_MIGRATIONS`.
     *
     * Different fields in the request message result in different filtering
     * behaviors. See the documentation on GetSchemaMigrationsRequest for details.
     *
     * @generated from protobuf rpc: GetSchemaMigrations(vtctldata.GetSchemaMigrationsRequest) returns (vtctldata.GetSchemaMigrationsResponse);
     */
    getSchemaMigrations(input: GetSchemaMigrationsRequest, options?: RpcOptions): UnaryCall<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse>;
    /**
     * GetShardReplication returns the replication graph for a shard in a cell.
     *
     * @generated from protobuf rpc: GetShardReplication(vtctldata.GetShardReplicationRequest) returns (vtctldata.GetShardReplicationResponse);
     */
    getShardReplication(input: GetShardReplicationRequest, options?: RpcOptions): UnaryCall<GetShardReplicationRequest, GetShardReplicationResponse>;
    /**
     * GetShard returns information about a shard in the topology.
     *
     * @generated from protobuf rpc: GetShard(vtctldata.GetShardRequest) returns (vtctldata.GetShardResponse);
     */
    getShard(input: GetShardRequest, options?: RpcOptions): UnaryCall<GetShardRequest, GetShardResponse>;
    /**
     * GetShardRoutingRules returns the VSchema shard routing rules.
     *
     * @generated from protobuf rpc: GetShardRoutingRules(vtctldata.GetShardRoutingRulesRequest) returns (vtctldata.GetShardRoutingRulesResponse);
     */
    getShardRoutingRules(input: GetShardRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetShardRoutingRulesRequest, GetShardRoutingRulesResponse>;
    /**
     * GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
     * in that cell.
     *
     * @generated from protobuf rpc: GetSrvKeyspaceNames(vtctldata.GetSrvKeyspaceNamesRequest) returns (vtctldata.GetSrvKeyspaceNamesResponse);
     */
    getSrvKeyspaceNames(input: GetSrvKeyspaceNamesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspaceNamesRequest, GetSrvKeyspaceNamesResponse>;
    /**
     * GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
     * cells.
     *
     * @generated from protobuf rpc: GetSrvKeyspaces(vtctldata.GetSrvKeyspacesRequest) returns (vtctldata.GetSrvKeyspacesResponse);
     */
    getSrvKeyspaces(input: GetSrvKeyspacesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse>;
    /**
     * UpdateThrottlerConfig updates the tablet throttler configuration
     *
     * @generated from protobuf rpc: UpdateThrottlerConfig(vtctldata.UpdateThrottlerConfigRequest) returns (vtctldata.UpdateThrottlerConfigResponse);
     */
    updateThrottlerConfig(input: UpdateThrottlerConfigRequest, options?: RpcOptions): UnaryCall<UpdateThrottlerConfigRequest, UpdateThrottlerConfigResponse>;
    /**
     * GetSrvVSchema returns the SrvVSchema for a cell.
     *
     * @generated from protobuf rpc: GetSrvVSchema(vtctldata.GetSrvVSchemaRequest) returns (vtctldata.GetSrvVSchemaResponse);
     */
    getSrvVSchema(input: GetSrvVSchemaRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemaRequest, GetSrvVSchemaResponse>;
    /**
     * GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
     * optionally filtered by cell name.
     *
     * @generated from protobuf rpc: GetSrvVSchemas(vtctldata.GetSrvVSchemasRequest) returns (vtctldata.GetSrvVSchemasResponse);
     */
    getSrvVSchemas(input: GetSrvVSchemasRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemasRequest, GetSrvVSchemasResponse>;
    /**
     * GetTablet returns information about a tablet.
     *
     * @generated from protobuf rpc: GetTablet(vtctldata.GetTabletRequest) returns (vtctldata.GetTabletResponse);
     */
    getTablet(input: GetTabletRequest, options?: RpcOptions): UnaryCall<GetTabletRequest, GetTabletResponse>;
    /**
     * GetTablets returns tablets, optionally filtered by keyspace and shard.
     *
     * @generated from protobuf rpc: GetTablets(vtctldata.GetTabletsRequest) returns (vtctldata.GetTabletsResponse);
     */
    getTablets(input: GetTabletsRequest, options?: RpcOptions): UnaryCall<GetTabletsRequest, GetTabletsResponse>;
    /**
     * GetThrottlerStatus gets the status of a tablet throttler
     *
     * @generated from protobuf rpc: GetThrottlerStatus(vtctldata.GetThrottlerStatusRequest) returns (vtctldata.GetThrottlerStatusResponse);
     */
    getThrottlerStatus(input: GetThrottlerStatusRequest, options?: RpcOptions): UnaryCall<GetThrottlerStatusRequest, GetThrottlerStatusResponse>;
    /**
     * GetTopologyPath returns the topology cell at a given path.
     *
     * @generated from protobuf rpc: GetTopologyPath(vtctldata.GetTopologyPathRequest) returns (vtctldata.GetTopologyPathResponse);
     */
    getTopologyPath(input: GetTopologyPathRequest, options?: RpcOptions): UnaryCall<GetTopologyPathRequest, GetTopologyPathResponse>;
    /**
     * GetTransactions returns the unresolved transactions for the request.
     *
     * @generated from protobuf rpc: GetUnresolvedTransactions(vtctldata.GetUnresolvedTransactionsRequest) returns (vtctldata.GetUnresolvedTransactionsResponse);
     */
    getUnresolvedTransactions(input: GetUnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse>;
    /**
     * GetVersion returns the version of a tablet from its debug vars.
     *
     * @generated from protobuf rpc: GetVersion(vtctldata.GetVersionRequest) returns (vtctldata.GetVersionResponse);
     */
    getVersion(input: GetVersionRequest, options?: RpcOptions): UnaryCall<GetVersionRequest, GetVersionResponse>;
    /**
     * GetVSchema returns the vschema for a keyspace.
     *
     * @generated from protobuf rpc: GetVSchema(vtctldata.GetVSchemaRequest) returns (vtctldata.GetVSchemaResponse);
     */
    getVSchema(input: GetVSchemaRequest, options?: RpcOptions): UnaryCall<GetVSchemaRequest, GetVSchemaResponse>;
    /**
     * GetWorkflows returns a list of workflows for the given keyspace.
     *
     * @generated from protobuf rpc: GetWorkflows(vtctldata.GetWorkflowsRequest) returns (vtctldata.GetWorkflowsResponse);
     */
    getWorkflows(input: GetWorkflowsRequest, options?: RpcOptions): UnaryCall<GetWorkflowsRequest, GetWorkflowsResponse>;
    /**
     * InitShardPrimary sets the initial primary for a shard. Will make all other
     * tablets in the shard replicas of the provided primary.
     *
     * WARNING: This could cause data loss on an already replicating shard.
     * PlannedReparentShard or EmergencyReparentShard should be used in those
     * cases instead.
     *
     * @generated from protobuf rpc: InitShardPrimary(vtctldata.InitShardPrimaryRequest) returns (vtctldata.InitShardPrimaryResponse);
     */
    initShardPrimary(input: InitShardPrimaryRequest, options?: RpcOptions): UnaryCall<InitShardPrimaryRequest, InitShardPrimaryResponse>;
    /**
     * LaunchSchemaMigration launches one or all migrations executed with --postpone-launch.
     *
     * @generated from protobuf rpc: LaunchSchemaMigration(vtctldata.LaunchSchemaMigrationRequest) returns (vtctldata.LaunchSchemaMigrationResponse);
     */
    launchSchemaMigration(input: LaunchSchemaMigrationRequest, options?: RpcOptions): UnaryCall<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse>;
    /**
     * @generated from protobuf rpc: LookupVindexCreate(vtctldata.LookupVindexCreateRequest) returns (vtctldata.LookupVindexCreateResponse);
     */
    lookupVindexCreate(input: LookupVindexCreateRequest, options?: RpcOptions): UnaryCall<LookupVindexCreateRequest, LookupVindexCreateResponse>;
    /**
     * @generated from protobuf rpc: LookupVindexExternalize(vtctldata.LookupVindexExternalizeRequest) returns (vtctldata.LookupVindexExternalizeResponse);
     */
    lookupVindexExternalize(input: LookupVindexExternalizeRequest, options?: RpcOptions): UnaryCall<LookupVindexExternalizeRequest, LookupVindexExternalizeResponse>;
    /**
     * MaterializeCreate creates a workflow to materialize one or more tables
     * from a source keyspace to a target keyspace using a provided expressions.
     *
     * @generated from protobuf rpc: MaterializeCreate(vtctldata.MaterializeCreateRequest) returns (vtctldata.MaterializeCreateResponse);
     */
    materializeCreate(input: MaterializeCreateRequest, options?: RpcOptions): UnaryCall<MaterializeCreateRequest, MaterializeCreateResponse>;
    /**
     * MigrateCreate creates a workflow which migrates one or more tables from an
     * external cluster into Vitess.
     *
     * @generated from protobuf rpc: MigrateCreate(vtctldata.MigrateCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    migrateCreate(input: MigrateCreateRequest, options?: RpcOptions): UnaryCall<MigrateCreateRequest, WorkflowStatusResponse>;
    /**
     * MountRegister registers a new external Vitess cluster.
     *
     * @generated from protobuf rpc: MountRegister(vtctldata.MountRegisterRequest) returns (vtctldata.MountRegisterResponse);
     */
    mountRegister(input: MountRegisterRequest, options?: RpcOptions): UnaryCall<MountRegisterRequest, MountRegisterResponse>;
    /**
     * MountUnregister unregisters an external Vitess cluster.
     *
     * @generated from protobuf rpc: MountUnregister(vtctldata.MountUnregisterRequest) returns (vtctldata.MountUnregisterResponse);
     */
    mountUnregister(input: MountUnregisterRequest, options?: RpcOptions): UnaryCall<MountUnregisterRequest, MountUnregisterResponse>;
    /**
     * MountShow returns information about an external Vitess cluster.
     *
     * @generated from protobuf rpc: MountShow(vtctldata.MountShowRequest) returns (vtctldata.MountShowResponse);
     */
    mountShow(input: MountShowRequest, options?: RpcOptions): UnaryCall<MountShowRequest, MountShowResponse>;
    /**
     * MountList lists all registered external Vitess clusters.
     *
     * @generated from protobuf rpc: MountList(vtctldata.MountListRequest) returns (vtctldata.MountListResponse);
     */
    mountList(input: MountListRequest, options?: RpcOptions): UnaryCall<MountListRequest, MountListResponse>;
    /**
     * MoveTablesCreate creates a workflow which moves one or more tables from a
     * source keyspace to a target keyspace.
     *
     * @generated from protobuf rpc: MoveTablesCreate(vtctldata.MoveTablesCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    moveTablesCreate(input: MoveTablesCreateRequest, options?: RpcOptions): UnaryCall<MoveTablesCreateRequest, WorkflowStatusResponse>;
    /**
     * MoveTablesComplete completes the move and cleans up the workflow and
     * its related artifacts.
     *
     * @generated from protobuf rpc: MoveTablesComplete(vtctldata.MoveTablesCompleteRequest) returns (vtctldata.MoveTablesCompleteResponse);
     */
    moveTablesComplete(input: MoveTablesCompleteRequest, options?: RpcOptions): UnaryCall<MoveTablesCompleteRequest, MoveTablesCompleteResponse>;
    /**
     * PingTablet checks that the specified tablet is awake and responding to RPCs.
     * This command can be blocked by other in-flight operations.
     *
     * @generated from protobuf rpc: PingTablet(vtctldata.PingTabletRequest) returns (vtctldata.PingTabletResponse);
     */
    pingTablet(input: PingTabletRequest, options?: RpcOptions): UnaryCall<PingTabletRequest, PingTabletResponse>;
    /**
     * PlannedReparentShard reparents the shard to the new primary, or away from
     * an old primary. Both the old and new primaries need to be reachable and
     * running.
     *
     * **NOTE**: The vtctld will not consider any replicas outside the cell the
     * current shard primary is in for promotion unless NewPrimary is explicitly
     * provided in the request.
     *
     * @generated from protobuf rpc: PlannedReparentShard(vtctldata.PlannedReparentShardRequest) returns (vtctldata.PlannedReparentShardResponse);
     */
    plannedReparentShard(input: PlannedReparentShardRequest, options?: RpcOptions): UnaryCall<PlannedReparentShardRequest, PlannedReparentShardResponse>;
    /**
     * RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
     *
     * This may trigger an update to all connected clients.
     *
     * @generated from protobuf rpc: RebuildKeyspaceGraph(vtctldata.RebuildKeyspaceGraphRequest) returns (vtctldata.RebuildKeyspaceGraphResponse);
     */
    rebuildKeyspaceGraph(input: RebuildKeyspaceGraphRequest, options?: RpcOptions): UnaryCall<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse>;
    /**
     * RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
     * VSchema objects in the provided cells (or all cells in the topo none
     * provided).
     *
     * @generated from protobuf rpc: RebuildVSchemaGraph(vtctldata.RebuildVSchemaGraphRequest) returns (vtctldata.RebuildVSchemaGraphResponse);
     */
    rebuildVSchemaGraph(input: RebuildVSchemaGraphRequest, options?: RpcOptions): UnaryCall<RebuildVSchemaGraphRequest, RebuildVSchemaGraphResponse>;
    /**
     * RefreshState reloads the tablet record on the specified tablet.
     *
     * @generated from protobuf rpc: RefreshState(vtctldata.RefreshStateRequest) returns (vtctldata.RefreshStateResponse);
     */
    refreshState(input: RefreshStateRequest, options?: RpcOptions): UnaryCall<RefreshStateRequest, RefreshStateResponse>;
    /**
     * RefreshStateByShard calls RefreshState on all the tablets in the given shard.
     *
     * @generated from protobuf rpc: RefreshStateByShard(vtctldata.RefreshStateByShardRequest) returns (vtctldata.RefreshStateByShardResponse);
     */
    refreshStateByShard(input: RefreshStateByShardRequest, options?: RpcOptions): UnaryCall<RefreshStateByShardRequest, RefreshStateByShardResponse>;
    /**
     * ReloadSchema instructs the remote tablet to reload its schema.
     *
     * @generated from protobuf rpc: ReloadSchema(vtctldata.ReloadSchemaRequest) returns (vtctldata.ReloadSchemaResponse);
     */
    reloadSchema(input: ReloadSchemaRequest, options?: RpcOptions): UnaryCall<ReloadSchemaRequest, ReloadSchemaResponse>;
    /**
     * ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
     *
     * @generated from protobuf rpc: ReloadSchemaKeyspace(vtctldata.ReloadSchemaKeyspaceRequest) returns (vtctldata.ReloadSchemaKeyspaceResponse);
     */
    reloadSchemaKeyspace(input: ReloadSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ReloadSchemaKeyspaceRequest, ReloadSchemaKeyspaceResponse>;
    /**
     * ReloadSchemaShard reloads the schema on all tablets in a shard.
     *
     * In general, we don't always expect all replicas to be ready to reload, and
     * the periodic schema reload makes them self-healing anyway. So, we do this
     * on a best-effort basis, and log warnings for any tablets that fail to
     * reload within the context deadline.
     *
     * @generated from protobuf rpc: ReloadSchemaShard(vtctldata.ReloadSchemaShardRequest) returns (vtctldata.ReloadSchemaShardResponse);
     */
    reloadSchemaShard(input: ReloadSchemaShardRequest, options?: RpcOptions): UnaryCall<ReloadSchemaShardRequest, ReloadSchemaShardResponse>;
    /**
     * RemoveBackup removes a backup from the BackupStorage used by vtctld.
     *
     * @generated from protobuf rpc: RemoveBackup(vtctldata.RemoveBackupRequest) returns (vtctldata.RemoveBackupResponse);
     */
    removeBackup(input: RemoveBackupRequest, options?: RpcOptions): UnaryCall<RemoveBackupRequest, RemoveBackupResponse>;
    /**
     * RemoveKeyspaceCell removes the specified cell from the Cells list for all
     * shards in the specified keyspace (by calling RemoveShardCell on every
     * shard). It also removes the SrvKeyspace for that keyspace in that cell.
     *
     * @generated from protobuf rpc: RemoveKeyspaceCell(vtctldata.RemoveKeyspaceCellRequest) returns (vtctldata.RemoveKeyspaceCellResponse);
     */
    removeKeyspaceCell(input: RemoveKeyspaceCellRequest, options?: RpcOptions): UnaryCall<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse>;
    /**
     * RemoveShardCell removes the specified cell from the specified shard's Cells
     * list.
     *
     * @generated from protobuf rpc: RemoveShardCell(vtctldata.RemoveShardCellRequest) returns (vtctldata.RemoveShardCellResponse);
     */
    removeShardCell(input: RemoveShardCellRequest, options?: RpcOptions): UnaryCall<RemoveShardCellRequest, RemoveShardCellResponse>;
    /**
     * ReparentTablet reparents a tablet to the current primary in the shard. This
     * only works if the current replica position matches the last known reparent
     * action.
     *
     * @generated from protobuf rpc: ReparentTablet(vtctldata.ReparentTabletRequest) returns (vtctldata.ReparentTabletResponse);
     */
    reparentTablet(input: ReparentTabletRequest, options?: RpcOptions): UnaryCall<ReparentTabletRequest, ReparentTabletResponse>;
    /**
     * ReshardCreate creates a workflow to reshard a keyspace.
     *
     * @generated from protobuf rpc: ReshardCreate(vtctldata.ReshardCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    reshardCreate(input: ReshardCreateRequest, options?: RpcOptions): UnaryCall<ReshardCreateRequest, WorkflowStatusResponse>;
    /**
     * RestoreFromBackup stops mysqld for the given tablet and restores a backup.
     *
     * @generated from protobuf rpc: RestoreFromBackup(vtctldata.RestoreFromBackupRequest) returns (stream vtctldata.RestoreFromBackupResponse);
     */
    restoreFromBackup(input: RestoreFromBackupRequest, options?: RpcOptions): ServerStreamingCall<RestoreFromBackupRequest, RestoreFromBackupResponse>;
    /**
     * RetrySchemaMigration marks a given schema migration for retry.
     *
     * @generated from protobuf rpc: RetrySchemaMigration(vtctldata.RetrySchemaMigrationRequest) returns (vtctldata.RetrySchemaMigrationResponse);
     */
    retrySchemaMigration(input: RetrySchemaMigrationRequest, options?: RpcOptions): UnaryCall<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse>;
    /**
     * RunHealthCheck runs a healthcheck on the remote tablet.
     *
     * @generated from protobuf rpc: RunHealthCheck(vtctldata.RunHealthCheckRequest) returns (vtctldata.RunHealthCheckResponse);
     */
    runHealthCheck(input: RunHealthCheckRequest, options?: RpcOptions): UnaryCall<RunHealthCheckRequest, RunHealthCheckResponse>;
    /**
     * SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
     *
     * @generated from protobuf rpc: SetKeyspaceDurabilityPolicy(vtctldata.SetKeyspaceDurabilityPolicyRequest) returns (vtctldata.SetKeyspaceDurabilityPolicyResponse);
     */
    setKeyspaceDurabilityPolicy(input: SetKeyspaceDurabilityPolicyRequest, options?: RpcOptions): UnaryCall<SetKeyspaceDurabilityPolicyRequest, SetKeyspaceDurabilityPolicyResponse>;
    /**
     * SetShardIsPrimaryServing adds or removes a shard from serving.
     *
     * This is meant as an emergency function. It does not rebuild any serving
     * graph (i.e. it does not run RebuildKeyspaceGraph).
     *
     * @generated from protobuf rpc: SetShardIsPrimaryServing(vtctldata.SetShardIsPrimaryServingRequest) returns (vtctldata.SetShardIsPrimaryServingResponse);
     */
    setShardIsPrimaryServing(input: SetShardIsPrimaryServingRequest, options?: RpcOptions): UnaryCall<SetShardIsPrimaryServingRequest, SetShardIsPrimaryServingResponse>;
    /**
     * SetShardTabletControl updates the TabletControl topo record for a shard and
     * tablet type.
     *
     * This should only be used for an emergency fix, or after a finished
     * Reshard. See the documentation on SetShardTabletControlRequest for more
     * information about the different update modes.
     *
     * @generated from protobuf rpc: SetShardTabletControl(vtctldata.SetShardTabletControlRequest) returns (vtctldata.SetShardTabletControlResponse);
     */
    setShardTabletControl(input: SetShardTabletControlRequest, options?: RpcOptions): UnaryCall<SetShardTabletControlRequest, SetShardTabletControlResponse>;
    /**
     * SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
     *
     * @generated from protobuf rpc: SetWritable(vtctldata.SetWritableRequest) returns (vtctldata.SetWritableResponse);
     */
    setWritable(input: SetWritableRequest, options?: RpcOptions): UnaryCall<SetWritableRequest, SetWritableResponse>;
    /**
     * ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
     *
     * It is a low-level function and should generally not be called.
     *
     * @generated from protobuf rpc: ShardReplicationAdd(vtctldata.ShardReplicationAddRequest) returns (vtctldata.ShardReplicationAddResponse);
     */
    shardReplicationAdd(input: ShardReplicationAddRequest, options?: RpcOptions): UnaryCall<ShardReplicationAddRequest, ShardReplicationAddResponse>;
    /**
     * ShardReplicationFix walks the replication graph for a shard in a cell and
     * attempts to fix the first problem encountered, returning information about
     * the problem fixed, if any.
     *
     * @generated from protobuf rpc: ShardReplicationFix(vtctldata.ShardReplicationFixRequest) returns (vtctldata.ShardReplicationFixResponse);
     */
    shardReplicationFix(input: ShardReplicationFixRequest, options?: RpcOptions): UnaryCall<ShardReplicationFixRequest, ShardReplicationFixResponse>;
    /**
     * ShardReplicationPositions returns the replication position of each tablet
     * in a shard. This RPC makes a best-effort to return partial results. For
     * example, if one tablet in the shard graph is unreachable, then
     * ShardReplicationPositions will return non-error, and include valid results
     * for the reachable tablets.
     *
     * @generated from protobuf rpc: ShardReplicationPositions(vtctldata.ShardReplicationPositionsRequest) returns (vtctldata.ShardReplicationPositionsResponse);
     */
    shardReplicationPositions(input: ShardReplicationPositionsRequest, options?: RpcOptions): UnaryCall<ShardReplicationPositionsRequest, ShardReplicationPositionsResponse>;
    /**
     * ShardReplicationRemove removes an entry from a topodata.ShardReplication
     * object.
     *
     * It is a low-level function and should generally not be called.
     *
     * @generated from protobuf rpc: ShardReplicationRemove(vtctldata.ShardReplicationRemoveRequest) returns (vtctldata.ShardReplicationRemoveResponse);
     */
    shardReplicationRemove(input: ShardReplicationRemoveRequest, options?: RpcOptions): UnaryCall<ShardReplicationRemoveRequest, ShardReplicationRemoveResponse>;
    /**
     * SleepTablet blocks the aciton queue on the specified tablet for the
     * specified duration.
     *
     * This is typically used for testing.
     *
     * @generated from protobuf rpc: SleepTablet(vtctldata.SleepTabletRequest) returns (vtctldata.SleepTabletResponse);
     */
    sleepTablet(input: SleepTabletRequest, options?: RpcOptions): UnaryCall<SleepTabletRequest, SleepTabletResponse>;
    /**
     * SourceShardAdd adds the SourceShard record with the provided index. This
     * should be used only as an emergency function.
     *
     * It does not call RefreshState for the shard primary.
     *
     * @generated from protobuf rpc: SourceShardAdd(vtctldata.SourceShardAddRequest) returns (vtctldata.SourceShardAddResponse);
     */
    sourceShardAdd(input: SourceShardAddRequest, options?: RpcOptions): UnaryCall<SourceShardAddRequest, SourceShardAddResponse>;
    /**
     * SourceShardDelete deletes the SourceShard record with the provided index.
     * This should be used only as an emergency cleanup function.
     *
     * It does not call RefreshState for the shard primary.
     *
     * @generated from protobuf rpc: SourceShardDelete(vtctldata.SourceShardDeleteRequest) returns (vtctldata.SourceShardDeleteResponse);
     */
    sourceShardDelete(input: SourceShardDeleteRequest, options?: RpcOptions): UnaryCall<SourceShardDeleteRequest, SourceShardDeleteResponse>;
    /**
     * StartReplication starts replication on the specified tablet.
     *
     * @generated from protobuf rpc: StartReplication(vtctldata.StartReplicationRequest) returns (vtctldata.StartReplicationResponse);
     */
    startReplication(input: StartReplicationRequest, options?: RpcOptions): UnaryCall<StartReplicationRequest, StartReplicationResponse>;
    /**
     * StopReplication stops replication on the specified tablet.
     *
     * @generated from protobuf rpc: StopReplication(vtctldata.StopReplicationRequest) returns (vtctldata.StopReplicationResponse);
     */
    stopReplication(input: StopReplicationRequest, options?: RpcOptions): UnaryCall<StopReplicationRequest, StopReplicationResponse>;
    /**
     * TabletExternallyReparented changes metadata in the topology server to
     * acknowledge a shard primary change performed by an external tool (e.g.
     * orchestrator).
     *
     * See the Reparenting guide for more information:
     * https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
     *
     * @generated from protobuf rpc: TabletExternallyReparented(vtctldata.TabletExternallyReparentedRequest) returns (vtctldata.TabletExternallyReparentedResponse);
     */
    tabletExternallyReparented(input: TabletExternallyReparentedRequest, options?: RpcOptions): UnaryCall<TabletExternallyReparentedRequest, TabletExternallyReparentedResponse>;
    /**
     * UpdateCellInfo updates the content of a CellInfo with the provided
     * parameters. Empty values are ignored. If the cell does not exist, the
     * CellInfo will be created.
     *
     * @generated from protobuf rpc: UpdateCellInfo(vtctldata.UpdateCellInfoRequest) returns (vtctldata.UpdateCellInfoResponse);
     */
    updateCellInfo(input: UpdateCellInfoRequest, options?: RpcOptions): UnaryCall<UpdateCellInfoRequest, UpdateCellInfoResponse>;
    /**
     * UpdateCellsAlias updates the content of a CellsAlias with the provided
     * parameters. Empty values are ignored. If the alias does not exist, the
     * CellsAlias will be created.
     *
     * @generated from protobuf rpc: UpdateCellsAlias(vtctldata.UpdateCellsAliasRequest) returns (vtctldata.UpdateCellsAliasResponse);
     */
    updateCellsAlias(input: UpdateCellsAliasRequest, options?: RpcOptions): UnaryCall<UpdateCellsAliasRequest, UpdateCellsAliasResponse>;
    /**
     * Validate validates that all nodes from the global replication graph are
     * reachable, and that all tablets in discoverable cells are consistent.
     *
     * @generated from protobuf rpc: Validate(vtctldata.ValidateRequest) returns (vtctldata.ValidateResponse);
     */
    validate(input: ValidateRequest, options?: RpcOptions): UnaryCall<ValidateRequest, ValidateResponse>;
    /**
     * ValidateKeyspace validates that all nodes reachable from the specified
     * keyspace are consistent.
     *
     * @generated from protobuf rpc: ValidateKeyspace(vtctldata.ValidateKeyspaceRequest) returns (vtctldata.ValidateKeyspaceResponse);
     */
    validateKeyspace(input: ValidateKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateKeyspaceRequest, ValidateKeyspaceResponse>;
    /**
     * ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateSchemaKeyspace(vtctldata.ValidateSchemaKeyspaceRequest) returns (vtctldata.ValidateSchemaKeyspaceResponse);
     */
    validateSchemaKeyspace(input: ValidateSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse>;
    /**
     * ValidateShard validates that all nodes reachable from the specified shard
     * are consistent.
     *
     * @generated from protobuf rpc: ValidateShard(vtctldata.ValidateShardRequest) returns (vtctldata.ValidateShardResponse);
     */
    validateShard(input: ValidateShardRequest, options?: RpcOptions): UnaryCall<ValidateShardRequest, ValidateShardResponse>;
    /**
     * ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateVersionKeyspace(vtctldata.ValidateVersionKeyspaceRequest) returns (vtctldata.ValidateVersionKeyspaceResponse);
     */
    validateVersionKeyspace(input: ValidateVersionKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse>;
    /**
     * ValidateVersionShard validates that the version on the primary matches all of the replicas.
     *
     * @generated from protobuf rpc: ValidateVersionShard(vtctldata.ValidateVersionShardRequest) returns (vtctldata.ValidateVersionShardResponse);
     */
    validateVersionShard(input: ValidateVersionShardRequest, options?: RpcOptions): UnaryCall<ValidateVersionShardRequest, ValidateVersionShardResponse>;
    /**
     * ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
     *
     * @generated from protobuf rpc: ValidateVSchema(vtctldata.ValidateVSchemaRequest) returns (vtctldata.ValidateVSchemaResponse);
     */
    validateVSchema(input: ValidateVSchemaRequest, options?: RpcOptions): UnaryCall<ValidateVSchemaRequest, ValidateVSchemaResponse>;
    /**
     * @generated from protobuf rpc: VDiffCreate(vtctldata.VDiffCreateRequest) returns (vtctldata.VDiffCreateResponse);
     */
    vDiffCreate(input: VDiffCreateRequest, options?: RpcOptions): UnaryCall<VDiffCreateRequest, VDiffCreateResponse>;
    /**
     * @generated from protobuf rpc: VDiffDelete(vtctldata.VDiffDeleteRequest) returns (vtctldata.VDiffDeleteResponse);
     */
    vDiffDelete(input: VDiffDeleteRequest, options?: RpcOptions): UnaryCall<VDiffDeleteRequest, VDiffDeleteResponse>;
    /**
     * @generated from protobuf rpc: VDiffResume(vtctldata.VDiffResumeRequest) returns (vtctldata.VDiffResumeResponse);
     */
    vDiffResume(input: VDiffResumeRequest, options?: RpcOptions): UnaryCall<VDiffResumeRequest, VDiffResumeResponse>;
    /**
     * @generated from protobuf rpc: VDiffShow(vtctldata.VDiffShowRequest) returns (vtctldata.VDiffShowResponse);
     */
    vDiffShow(input: VDiffShowRequest, options?: RpcOptions): UnaryCall<VDiffShowRequest, VDiffShowResponse>;
    /**
     * @generated from protobuf rpc: VDiffStop(vtctldata.VDiffStopRequest) returns (vtctldata.VDiffStopResponse);
     */
    vDiffStop(input: VDiffStopRequest, options?: RpcOptions): UnaryCall<VDiffStopRequest, VDiffStopResponse>;
    /**
     * WorkflowDelete deletes a vreplication workflow.
     *
     * @generated from protobuf rpc: WorkflowDelete(vtctldata.WorkflowDeleteRequest) returns (vtctldata.WorkflowDeleteResponse);
     */
    workflowDelete(input: WorkflowDeleteRequest, options?: RpcOptions): UnaryCall<WorkflowDeleteRequest, WorkflowDeleteResponse>;
    /**
     * @generated from protobuf rpc: WorkflowStatus(vtctldata.WorkflowStatusRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    workflowStatus(input: WorkflowStatusRequest, options?: RpcOptions): UnaryCall<WorkflowStatusRequest, WorkflowStatusResponse>;
    /**
     * @generated from protobuf rpc: WorkflowSwitchTraffic(vtctldata.WorkflowSwitchTrafficRequest) returns (vtctldata.WorkflowSwitchTrafficResponse);
     */
    workflowSwitchTraffic(input: WorkflowSwitchTrafficRequest, options?: RpcOptions): UnaryCall<WorkflowSwitchTrafficRequest, WorkflowSwitchTrafficResponse>;
    /**
     * WorkflowUpdate updates the configuration of a vreplication workflow
     * using the provided updated parameters.
     *
     * @generated from protobuf rpc: WorkflowUpdate(vtctldata.WorkflowUpdateRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    workflowUpdate(input: WorkflowUpdateRequest, options?: RpcOptions): UnaryCall<WorkflowUpdateRequest, WorkflowUpdateResponse>;
    /**
     * GetMirrorRules returns the VSchema routing rules.
     *
     * @generated from protobuf rpc: GetMirrorRules(vtctldata.GetMirrorRulesRequest) returns (vtctldata.GetMirrorRulesResponse);
     */
    getMirrorRules(input: GetMirrorRulesRequest, options?: RpcOptions): UnaryCall<GetMirrorRulesRequest, GetMirrorRulesResponse>;
    /**
     * @generated from protobuf rpc: WorkflowMirrorTraffic(vtctldata.WorkflowMirrorTrafficRequest) returns (vtctldata.WorkflowMirrorTrafficResponse);
     */
    workflowMirrorTraffic(input: WorkflowMirrorTrafficRequest, options?: RpcOptions): UnaryCall<WorkflowMirrorTrafficRequest, WorkflowMirrorTrafficResponse>;
}
/**
 * Service Vtctld exposes gRPC endpoints for each vt command.
 *
 * @generated from protobuf service vtctlservice.Vtctld
 */
export class VtctldClient implements IVtctldClient, ServiceInfo {
    typeName = Vtctld.typeName;
    methods = Vtctld.methods;
    options = Vtctld.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * AddCellInfo registers a local topology service in a new cell by creating
     * the CellInfo with the provided parameters.
     *
     * @generated from protobuf rpc: AddCellInfo(vtctldata.AddCellInfoRequest) returns (vtctldata.AddCellInfoResponse);
     */
    addCellInfo(input: AddCellInfoRequest, options?: RpcOptions): UnaryCall<AddCellInfoRequest, AddCellInfoResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<AddCellInfoRequest, AddCellInfoResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * AddCellsAlias defines a group of cells that can be referenced by a single
     * name (the alias).
     *
     * When routing query traffic, replica/rdonly traffic can be routed across
     * cells within the group (alias). Only primary traffic can be routed across
     * cells not in the same group (alias).
     *
     * @generated from protobuf rpc: AddCellsAlias(vtctldata.AddCellsAliasRequest) returns (vtctldata.AddCellsAliasResponse);
     */
    addCellsAlias(input: AddCellsAliasRequest, options?: RpcOptions): UnaryCall<AddCellsAliasRequest, AddCellsAliasResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<AddCellsAliasRequest, AddCellsAliasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ApplyRoutingRules applies the VSchema routing rules.
     *
     * @generated from protobuf rpc: ApplyRoutingRules(vtctldata.ApplyRoutingRulesRequest) returns (vtctldata.ApplyRoutingRulesResponse);
     */
    applyRoutingRules(input: ApplyRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyRoutingRulesRequest, ApplyRoutingRulesResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplyRoutingRulesRequest, ApplyRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ApplySchema applies a schema to a keyspace.
     *
     * @generated from protobuf rpc: ApplySchema(vtctldata.ApplySchemaRequest) returns (vtctldata.ApplySchemaResponse);
     */
    applySchema(input: ApplySchemaRequest, options?: RpcOptions): UnaryCall<ApplySchemaRequest, ApplySchemaResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplySchemaRequest, ApplySchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ApplyKeyspaceRoutingRules applies the VSchema keyspace routing rules.
     *
     * @generated from protobuf rpc: ApplyKeyspaceRoutingRules(vtctldata.ApplyKeyspaceRoutingRulesRequest) returns (vtctldata.ApplyKeyspaceRoutingRulesResponse);
     */
    applyKeyspaceRoutingRules(input: ApplyKeyspaceRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyKeyspaceRoutingRulesRequest, ApplyKeyspaceRoutingRulesResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplyKeyspaceRoutingRulesRequest, ApplyKeyspaceRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ApplyShardRoutingRules applies the VSchema shard routing rules.
     *
     * @generated from protobuf rpc: ApplyShardRoutingRules(vtctldata.ApplyShardRoutingRulesRequest) returns (vtctldata.ApplyShardRoutingRulesResponse);
     */
    applyShardRoutingRules(input: ApplyShardRoutingRulesRequest, options?: RpcOptions): UnaryCall<ApplyShardRoutingRulesRequest, ApplyShardRoutingRulesResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplyShardRoutingRulesRequest, ApplyShardRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ApplyVSchema applies a vschema to a keyspace.
     *
     * @generated from protobuf rpc: ApplyVSchema(vtctldata.ApplyVSchemaRequest) returns (vtctldata.ApplyVSchemaResponse);
     */
    applyVSchema(input: ApplyVSchemaRequest, options?: RpcOptions): UnaryCall<ApplyVSchemaRequest, ApplyVSchemaResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<ApplyVSchemaRequest, ApplyVSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Backup uses the BackupEngine and BackupStorage services on the specified
     * tablet to create and store a new backup.
     *
     * @generated from protobuf rpc: Backup(vtctldata.BackupRequest) returns (stream vtctldata.BackupResponse);
     */
    backup(input: BackupRequest, options?: RpcOptions): ServerStreamingCall<BackupRequest, BackupResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<BackupRequest, BackupResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * BackupShard chooses a tablet in the shard and uses it to create a backup.
     *
     * @generated from protobuf rpc: BackupShard(vtctldata.BackupShardRequest) returns (stream vtctldata.BackupResponse);
     */
    backupShard(input: BackupShardRequest, options?: RpcOptions): ServerStreamingCall<BackupShardRequest, BackupResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<BackupShardRequest, BackupResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * CancelSchemaMigration cancels one or all migrations, terminating any running ones as needed.
     *
     * @generated from protobuf rpc: CancelSchemaMigration(vtctldata.CancelSchemaMigrationRequest) returns (vtctldata.CancelSchemaMigrationResponse);
     */
    cancelSchemaMigration(input: CancelSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<CancelSchemaMigrationRequest, CancelSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ChangeTabletTags changes the tags of the specified tablet, if possible.
     *
     * @generated from protobuf rpc: ChangeTabletTags(vtctldata.ChangeTabletTagsRequest) returns (vtctldata.ChangeTabletTagsResponse);
     */
    changeTabletTags(input: ChangeTabletTagsRequest, options?: RpcOptions): UnaryCall<ChangeTabletTagsRequest, ChangeTabletTagsResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<ChangeTabletTagsRequest, ChangeTabletTagsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ChangeTabletType changes the db type for the specified tablet, if possible.
     * This is used primarily to arrange replicas, and it will not convert a
     * primary. For that, use InitShardPrimary.
     *
     * NOTE: This command automatically updates the serving graph.
     *
     * @generated from protobuf rpc: ChangeTabletType(vtctldata.ChangeTabletTypeRequest) returns (vtctldata.ChangeTabletTypeResponse);
     */
    changeTabletType(input: ChangeTabletTypeRequest, options?: RpcOptions): UnaryCall<ChangeTabletTypeRequest, ChangeTabletTypeResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<ChangeTabletTypeRequest, ChangeTabletTypeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CheckThrottler issues a 'check' on a tablet's throttler
     *
     * @generated from protobuf rpc: CheckThrottler(vtctldata.CheckThrottlerRequest) returns (vtctldata.CheckThrottlerResponse);
     */
    checkThrottler(input: CheckThrottlerRequest, options?: RpcOptions): UnaryCall<CheckThrottlerRequest, CheckThrottlerResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<CheckThrottlerRequest, CheckThrottlerResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CleanupSchemaMigration marks a schema migration as ready for artifact cleanup.
     *
     * @generated from protobuf rpc: CleanupSchemaMigration(vtctldata.CleanupSchemaMigrationRequest) returns (vtctldata.CleanupSchemaMigrationResponse);
     */
    cleanupSchemaMigration(input: CleanupSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<CleanupSchemaMigrationRequest, CleanupSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CompleteSchemaMigration completes one or all migrations executed with --postpone-completion.
     *
     * @generated from protobuf rpc: CompleteSchemaMigration(vtctldata.CompleteSchemaMigrationRequest) returns (vtctldata.CompleteSchemaMigrationResponse);
     */
    completeSchemaMigration(input: CompleteSchemaMigrationRequest, options?: RpcOptions): UnaryCall<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<CompleteSchemaMigrationRequest, CompleteSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CompleteSchemaMigration completes one or all migrations executed with --postpone-completion.
     *
     * @generated from protobuf rpc: ConcludeTransaction(vtctldata.ConcludeTransactionRequest) returns (vtctldata.ConcludeTransactionResponse);
     */
    concludeTransaction(input: ConcludeTransactionRequest, options?: RpcOptions): UnaryCall<ConcludeTransactionRequest, ConcludeTransactionResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<ConcludeTransactionRequest, ConcludeTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateKeyspace creates the specified keyspace in the topology. For a
     * SNAPSHOT keyspace, the request must specify the name of a base keyspace,
     * as well as a snapshot time.
     *
     * @generated from protobuf rpc: CreateKeyspace(vtctldata.CreateKeyspaceRequest) returns (vtctldata.CreateKeyspaceResponse);
     */
    createKeyspace(input: CreateKeyspaceRequest, options?: RpcOptions): UnaryCall<CreateKeyspaceRequest, CreateKeyspaceResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateKeyspaceRequest, CreateKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * CreateShard creates the specified shard in the topology.
     *
     * @generated from protobuf rpc: CreateShard(vtctldata.CreateShardRequest) returns (vtctldata.CreateShardResponse);
     */
    createShard(input: CreateShardRequest, options?: RpcOptions): UnaryCall<CreateShardRequest, CreateShardResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<CreateShardRequest, CreateShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteCellInfo deletes the CellInfo for the provided cell. The cell cannot
     * be referenced by any Shard record in the topology.
     *
     * @generated from protobuf rpc: DeleteCellInfo(vtctldata.DeleteCellInfoRequest) returns (vtctldata.DeleteCellInfoResponse);
     */
    deleteCellInfo(input: DeleteCellInfoRequest, options?: RpcOptions): UnaryCall<DeleteCellInfoRequest, DeleteCellInfoResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteCellInfoRequest, DeleteCellInfoResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteCellsAlias deletes the CellsAlias for the provided alias.
     *
     * @generated from protobuf rpc: DeleteCellsAlias(vtctldata.DeleteCellsAliasRequest) returns (vtctldata.DeleteCellsAliasResponse);
     */
    deleteCellsAlias(input: DeleteCellsAliasRequest, options?: RpcOptions): UnaryCall<DeleteCellsAliasRequest, DeleteCellsAliasResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteCellsAliasRequest, DeleteCellsAliasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteKeyspace deletes the specified keyspace from the topology. In
     * recursive mode, it also recursively deletes all shards in the keyspace.
     * Otherwise, the keyspace must be empty (have no shards), or DeleteKeyspace
     * returns an error.
     *
     * @generated from protobuf rpc: DeleteKeyspace(vtctldata.DeleteKeyspaceRequest) returns (vtctldata.DeleteKeyspaceResponse);
     */
    deleteKeyspace(input: DeleteKeyspaceRequest, options?: RpcOptions): UnaryCall<DeleteKeyspaceRequest, DeleteKeyspaceResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteKeyspaceRequest, DeleteKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteShards deletes the specified shards from the topology. In recursive
     * mode, it also deletes all tablets belonging to the shard. Otherwise, the
     * shard must be empty (have no tablets) or DeleteShards returns an error for
     * that shard.
     *
     * @generated from protobuf rpc: DeleteShards(vtctldata.DeleteShardsRequest) returns (vtctldata.DeleteShardsResponse);
     */
    deleteShards(input: DeleteShardsRequest, options?: RpcOptions): UnaryCall<DeleteShardsRequest, DeleteShardsResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteShardsRequest, DeleteShardsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteSrvVSchema deletes the SrvVSchema object in the specified cell.
     *
     * @generated from protobuf rpc: DeleteSrvVSchema(vtctldata.DeleteSrvVSchemaRequest) returns (vtctldata.DeleteSrvVSchemaResponse);
     */
    deleteSrvVSchema(input: DeleteSrvVSchemaRequest, options?: RpcOptions): UnaryCall<DeleteSrvVSchemaRequest, DeleteSrvVSchemaResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteSrvVSchemaRequest, DeleteSrvVSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * DeleteTablets deletes one or more tablets from the topology.
     *
     * @generated from protobuf rpc: DeleteTablets(vtctldata.DeleteTabletsRequest) returns (vtctldata.DeleteTabletsResponse);
     */
    deleteTablets(input: DeleteTabletsRequest, options?: RpcOptions): UnaryCall<DeleteTabletsRequest, DeleteTabletsResponse> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<DeleteTabletsRequest, DeleteTabletsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * EmergencyReparentShard reparents the shard to the new primary. It assumes
     * the old primary is dead or otherwise not responding.
     *
     * @generated from protobuf rpc: EmergencyReparentShard(vtctldata.EmergencyReparentShardRequest) returns (vtctldata.EmergencyReparentShardResponse);
     */
    emergencyReparentShard(input: EmergencyReparentShardRequest, options?: RpcOptions): UnaryCall<EmergencyReparentShardRequest, EmergencyReparentShardResponse> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<EmergencyReparentShardRequest, EmergencyReparentShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteFetchAsApp executes a SQL query on the remote tablet as the App user.
     *
     * @generated from protobuf rpc: ExecuteFetchAsApp(vtctldata.ExecuteFetchAsAppRequest) returns (vtctldata.ExecuteFetchAsAppResponse);
     */
    executeFetchAsApp(input: ExecuteFetchAsAppRequest, options?: RpcOptions): UnaryCall<ExecuteFetchAsAppRequest, ExecuteFetchAsAppResponse> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteFetchAsAppRequest, ExecuteFetchAsAppResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteFetchAsDBA executes a SQL query on the remote tablet as the DBA user.
     *
     * @generated from protobuf rpc: ExecuteFetchAsDBA(vtctldata.ExecuteFetchAsDBARequest) returns (vtctldata.ExecuteFetchAsDBAResponse);
     */
    executeFetchAsDBA(input: ExecuteFetchAsDBARequest, options?: RpcOptions): UnaryCall<ExecuteFetchAsDBARequest, ExecuteFetchAsDBAResponse> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteFetchAsDBARequest, ExecuteFetchAsDBAResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteHook runs the hook on the tablet.
     *
     * @generated from protobuf rpc: ExecuteHook(vtctldata.ExecuteHookRequest) returns (vtctldata.ExecuteHookResponse);
     */
    executeHook(input: ExecuteHookRequest, options?: RpcOptions): UnaryCall<ExecuteHookRequest, ExecuteHookResponse> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteHookRequest, ExecuteHookResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ExecuteMultiFetchAsDBA executes one or more SQL queries on the remote tablet as the DBA user.
     *
     * @generated from protobuf rpc: ExecuteMultiFetchAsDBA(vtctldata.ExecuteMultiFetchAsDBARequest) returns (vtctldata.ExecuteMultiFetchAsDBAResponse);
     */
    executeMultiFetchAsDBA(input: ExecuteMultiFetchAsDBARequest, options?: RpcOptions): UnaryCall<ExecuteMultiFetchAsDBARequest, ExecuteMultiFetchAsDBAResponse> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept<ExecuteMultiFetchAsDBARequest, ExecuteMultiFetchAsDBAResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * FindAllShardsInKeyspace returns a map of shard names to shard references
     * for a given keyspace.
     *
     * @generated from protobuf rpc: FindAllShardsInKeyspace(vtctldata.FindAllShardsInKeyspaceRequest) returns (vtctldata.FindAllShardsInKeyspaceResponse);
     */
    findAllShardsInKeyspace(input: FindAllShardsInKeyspaceRequest, options?: RpcOptions): UnaryCall<FindAllShardsInKeyspaceRequest, FindAllShardsInKeyspaceResponse> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        return stackIntercept<FindAllShardsInKeyspaceRequest, FindAllShardsInKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ForceCutOverSchemaMigration marks a schema migration for forced cut-over.
     *
     * @generated from protobuf rpc: ForceCutOverSchemaMigration(vtctldata.ForceCutOverSchemaMigrationRequest) returns (vtctldata.ForceCutOverSchemaMigrationResponse);
     */
    forceCutOverSchemaMigration(input: ForceCutOverSchemaMigrationRequest, options?: RpcOptions): UnaryCall<ForceCutOverSchemaMigrationRequest, ForceCutOverSchemaMigrationResponse> {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        return stackIntercept<ForceCutOverSchemaMigrationRequest, ForceCutOverSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetBackups returns all the backups for a shard.
     *
     * @generated from protobuf rpc: GetBackups(vtctldata.GetBackupsRequest) returns (vtctldata.GetBackupsResponse);
     */
    getBackups(input: GetBackupsRequest, options?: RpcOptions): UnaryCall<GetBackupsRequest, GetBackupsResponse> {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetBackupsRequest, GetBackupsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCellInfo returns the information for a cell.
     *
     * @generated from protobuf rpc: GetCellInfo(vtctldata.GetCellInfoRequest) returns (vtctldata.GetCellInfoResponse);
     */
    getCellInfo(input: GetCellInfoRequest, options?: RpcOptions): UnaryCall<GetCellInfoRequest, GetCellInfoResponse> {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCellInfoRequest, GetCellInfoResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCellInfoNames returns all the cells for which we have a CellInfo object,
     * meaning we have a topology service registered.
     *
     * @generated from protobuf rpc: GetCellInfoNames(vtctldata.GetCellInfoNamesRequest) returns (vtctldata.GetCellInfoNamesResponse);
     */
    getCellInfoNames(input: GetCellInfoNamesRequest, options?: RpcOptions): UnaryCall<GetCellInfoNamesRequest, GetCellInfoNamesResponse> {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCellInfoNamesRequest, GetCellInfoNamesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetCellsAliases returns a mapping of cell alias to cells identified by that
     * alias.
     *
     * @generated from protobuf rpc: GetCellsAliases(vtctldata.GetCellsAliasesRequest) returns (vtctldata.GetCellsAliasesResponse);
     */
    getCellsAliases(input: GetCellsAliasesRequest, options?: RpcOptions): UnaryCall<GetCellsAliasesRequest, GetCellsAliasesResponse> {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetCellsAliasesRequest, GetCellsAliasesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetFullStatus returns the full status of MySQL including the replication information, semi-sync information, GTID information among others
     *
     * @generated from protobuf rpc: GetFullStatus(vtctldata.GetFullStatusRequest) returns (vtctldata.GetFullStatusResponse);
     */
    getFullStatus(input: GetFullStatusRequest, options?: RpcOptions): UnaryCall<GetFullStatusRequest, GetFullStatusResponse> {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetFullStatusRequest, GetFullStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetKeyspace reads the given keyspace from the topo and returns it.
     *
     * @generated from protobuf rpc: GetKeyspace(vtctldata.GetKeyspaceRequest) returns (vtctldata.GetKeyspaceResponse);
     */
    getKeyspace(input: GetKeyspaceRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRequest, GetKeyspaceResponse> {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetKeyspaceRequest, GetKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
     *
     * @generated from protobuf rpc: GetKeyspaces(vtctldata.GetKeyspacesRequest) returns (vtctldata.GetKeyspacesResponse);
     */
    getKeyspaces(input: GetKeyspacesRequest, options?: RpcOptions): UnaryCall<GetKeyspacesRequest, GetKeyspacesResponse> {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetKeyspacesRequest, GetKeyspacesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetKeyspaceRoutingRules returns the VSchema keyspace routing rules.
     *
     * @generated from protobuf rpc: GetKeyspaceRoutingRules(vtctldata.GetKeyspaceRoutingRulesRequest) returns (vtctldata.GetKeyspaceRoutingRulesResponse);
     */
    getKeyspaceRoutingRules(input: GetKeyspaceRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetKeyspaceRoutingRulesRequest, GetKeyspaceRoutingRulesResponse> {
        const method = this.methods[38], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetKeyspaceRoutingRulesRequest, GetKeyspaceRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetPermissions returns the permissions set on the remote tablet.
     *
     * @generated from protobuf rpc: GetPermissions(vtctldata.GetPermissionsRequest) returns (vtctldata.GetPermissionsResponse);
     */
    getPermissions(input: GetPermissionsRequest, options?: RpcOptions): UnaryCall<GetPermissionsRequest, GetPermissionsResponse> {
        const method = this.methods[39], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetPermissionsRequest, GetPermissionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetRoutingRules returns the VSchema routing rules.
     *
     * @generated from protobuf rpc: GetRoutingRules(vtctldata.GetRoutingRulesRequest) returns (vtctldata.GetRoutingRulesResponse);
     */
    getRoutingRules(input: GetRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetRoutingRulesRequest, GetRoutingRulesResponse> {
        const method = this.methods[40], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetRoutingRulesRequest, GetRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSchema returns the schema for a tablet, or just the schema for the
     * specified tables in that tablet.
     *
     * @generated from protobuf rpc: GetSchema(vtctldata.GetSchemaRequest) returns (vtctldata.GetSchemaResponse);
     */
    getSchema(input: GetSchemaRequest, options?: RpcOptions): UnaryCall<GetSchemaRequest, GetSchemaResponse> {
        const method = this.methods[41], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemaRequest, GetSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSchemaMigrations returns one or more online schema migrations for the
     * specified keyspace, analagous to `SHOW VITESS_MIGRATIONS`.
     *
     * Different fields in the request message result in different filtering
     * behaviors. See the documentation on GetSchemaMigrationsRequest for details.
     *
     * @generated from protobuf rpc: GetSchemaMigrations(vtctldata.GetSchemaMigrationsRequest) returns (vtctldata.GetSchemaMigrationsResponse);
     */
    getSchemaMigrations(input: GetSchemaMigrationsRequest, options?: RpcOptions): UnaryCall<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse> {
        const method = this.methods[42], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSchemaMigrationsRequest, GetSchemaMigrationsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetShardReplication returns the replication graph for a shard in a cell.
     *
     * @generated from protobuf rpc: GetShardReplication(vtctldata.GetShardReplicationRequest) returns (vtctldata.GetShardReplicationResponse);
     */
    getShardReplication(input: GetShardReplicationRequest, options?: RpcOptions): UnaryCall<GetShardReplicationRequest, GetShardReplicationResponse> {
        const method = this.methods[43], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetShardReplicationRequest, GetShardReplicationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetShard returns information about a shard in the topology.
     *
     * @generated from protobuf rpc: GetShard(vtctldata.GetShardRequest) returns (vtctldata.GetShardResponse);
     */
    getShard(input: GetShardRequest, options?: RpcOptions): UnaryCall<GetShardRequest, GetShardResponse> {
        const method = this.methods[44], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetShardRequest, GetShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetShardRoutingRules returns the VSchema shard routing rules.
     *
     * @generated from protobuf rpc: GetShardRoutingRules(vtctldata.GetShardRoutingRulesRequest) returns (vtctldata.GetShardRoutingRulesResponse);
     */
    getShardRoutingRules(input: GetShardRoutingRulesRequest, options?: RpcOptions): UnaryCall<GetShardRoutingRulesRequest, GetShardRoutingRulesResponse> {
        const method = this.methods[45], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetShardRoutingRulesRequest, GetShardRoutingRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvKeyspaceNames returns a mapping of cell name to the keyspaces served
     * in that cell.
     *
     * @generated from protobuf rpc: GetSrvKeyspaceNames(vtctldata.GetSrvKeyspaceNamesRequest) returns (vtctldata.GetSrvKeyspaceNamesResponse);
     */
    getSrvKeyspaceNames(input: GetSrvKeyspaceNamesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspaceNamesRequest, GetSrvKeyspaceNamesResponse> {
        const method = this.methods[46], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvKeyspaceNamesRequest, GetSrvKeyspaceNamesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvKeyspaces returns the SrvKeyspaces for a keyspace in one or more
     * cells.
     *
     * @generated from protobuf rpc: GetSrvKeyspaces(vtctldata.GetSrvKeyspacesRequest) returns (vtctldata.GetSrvKeyspacesResponse);
     */
    getSrvKeyspaces(input: GetSrvKeyspacesRequest, options?: RpcOptions): UnaryCall<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse> {
        const method = this.methods[47], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvKeyspacesRequest, GetSrvKeyspacesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateThrottlerConfig updates the tablet throttler configuration
     *
     * @generated from protobuf rpc: UpdateThrottlerConfig(vtctldata.UpdateThrottlerConfigRequest) returns (vtctldata.UpdateThrottlerConfigResponse);
     */
    updateThrottlerConfig(input: UpdateThrottlerConfigRequest, options?: RpcOptions): UnaryCall<UpdateThrottlerConfigRequest, UpdateThrottlerConfigResponse> {
        const method = this.methods[48], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateThrottlerConfigRequest, UpdateThrottlerConfigResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvVSchema returns the SrvVSchema for a cell.
     *
     * @generated from protobuf rpc: GetSrvVSchema(vtctldata.GetSrvVSchemaRequest) returns (vtctldata.GetSrvVSchemaResponse);
     */
    getSrvVSchema(input: GetSrvVSchemaRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemaRequest, GetSrvVSchemaResponse> {
        const method = this.methods[49], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvVSchemaRequest, GetSrvVSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetSrvVSchemas returns a mapping from cell name to SrvVSchema for all cells,
     * optionally filtered by cell name.
     *
     * @generated from protobuf rpc: GetSrvVSchemas(vtctldata.GetSrvVSchemasRequest) returns (vtctldata.GetSrvVSchemasResponse);
     */
    getSrvVSchemas(input: GetSrvVSchemasRequest, options?: RpcOptions): UnaryCall<GetSrvVSchemasRequest, GetSrvVSchemasResponse> {
        const method = this.methods[50], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetSrvVSchemasRequest, GetSrvVSchemasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTablet returns information about a tablet.
     *
     * @generated from protobuf rpc: GetTablet(vtctldata.GetTabletRequest) returns (vtctldata.GetTabletResponse);
     */
    getTablet(input: GetTabletRequest, options?: RpcOptions): UnaryCall<GetTabletRequest, GetTabletResponse> {
        const method = this.methods[51], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTabletRequest, GetTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTablets returns tablets, optionally filtered by keyspace and shard.
     *
     * @generated from protobuf rpc: GetTablets(vtctldata.GetTabletsRequest) returns (vtctldata.GetTabletsResponse);
     */
    getTablets(input: GetTabletsRequest, options?: RpcOptions): UnaryCall<GetTabletsRequest, GetTabletsResponse> {
        const method = this.methods[52], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTabletsRequest, GetTabletsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetThrottlerStatus gets the status of a tablet throttler
     *
     * @generated from protobuf rpc: GetThrottlerStatus(vtctldata.GetThrottlerStatusRequest) returns (vtctldata.GetThrottlerStatusResponse);
     */
    getThrottlerStatus(input: GetThrottlerStatusRequest, options?: RpcOptions): UnaryCall<GetThrottlerStatusRequest, GetThrottlerStatusResponse> {
        const method = this.methods[53], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetThrottlerStatusRequest, GetThrottlerStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTopologyPath returns the topology cell at a given path.
     *
     * @generated from protobuf rpc: GetTopologyPath(vtctldata.GetTopologyPathRequest) returns (vtctldata.GetTopologyPathResponse);
     */
    getTopologyPath(input: GetTopologyPathRequest, options?: RpcOptions): UnaryCall<GetTopologyPathRequest, GetTopologyPathResponse> {
        const method = this.methods[54], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTopologyPathRequest, GetTopologyPathResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetTransactions returns the unresolved transactions for the request.
     *
     * @generated from protobuf rpc: GetUnresolvedTransactions(vtctldata.GetUnresolvedTransactionsRequest) returns (vtctldata.GetUnresolvedTransactionsResponse);
     */
    getUnresolvedTransactions(input: GetUnresolvedTransactionsRequest, options?: RpcOptions): UnaryCall<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse> {
        const method = this.methods[55], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetUnresolvedTransactionsRequest, GetUnresolvedTransactionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetVersion returns the version of a tablet from its debug vars.
     *
     * @generated from protobuf rpc: GetVersion(vtctldata.GetVersionRequest) returns (vtctldata.GetVersionResponse);
     */
    getVersion(input: GetVersionRequest, options?: RpcOptions): UnaryCall<GetVersionRequest, GetVersionResponse> {
        const method = this.methods[56], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetVersionRequest, GetVersionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetVSchema returns the vschema for a keyspace.
     *
     * @generated from protobuf rpc: GetVSchema(vtctldata.GetVSchemaRequest) returns (vtctldata.GetVSchemaResponse);
     */
    getVSchema(input: GetVSchemaRequest, options?: RpcOptions): UnaryCall<GetVSchemaRequest, GetVSchemaResponse> {
        const method = this.methods[57], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetVSchemaRequest, GetVSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetWorkflows returns a list of workflows for the given keyspace.
     *
     * @generated from protobuf rpc: GetWorkflows(vtctldata.GetWorkflowsRequest) returns (vtctldata.GetWorkflowsResponse);
     */
    getWorkflows(input: GetWorkflowsRequest, options?: RpcOptions): UnaryCall<GetWorkflowsRequest, GetWorkflowsResponse> {
        const method = this.methods[58], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetWorkflowsRequest, GetWorkflowsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * InitShardPrimary sets the initial primary for a shard. Will make all other
     * tablets in the shard replicas of the provided primary.
     *
     * WARNING: This could cause data loss on an already replicating shard.
     * PlannedReparentShard or EmergencyReparentShard should be used in those
     * cases instead.
     *
     * @generated from protobuf rpc: InitShardPrimary(vtctldata.InitShardPrimaryRequest) returns (vtctldata.InitShardPrimaryResponse);
     */
    initShardPrimary(input: InitShardPrimaryRequest, options?: RpcOptions): UnaryCall<InitShardPrimaryRequest, InitShardPrimaryResponse> {
        const method = this.methods[59], opt = this._transport.mergeOptions(options);
        return stackIntercept<InitShardPrimaryRequest, InitShardPrimaryResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * LaunchSchemaMigration launches one or all migrations executed with --postpone-launch.
     *
     * @generated from protobuf rpc: LaunchSchemaMigration(vtctldata.LaunchSchemaMigrationRequest) returns (vtctldata.LaunchSchemaMigrationResponse);
     */
    launchSchemaMigration(input: LaunchSchemaMigrationRequest, options?: RpcOptions): UnaryCall<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse> {
        const method = this.methods[60], opt = this._transport.mergeOptions(options);
        return stackIntercept<LaunchSchemaMigrationRequest, LaunchSchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: LookupVindexCreate(vtctldata.LookupVindexCreateRequest) returns (vtctldata.LookupVindexCreateResponse);
     */
    lookupVindexCreate(input: LookupVindexCreateRequest, options?: RpcOptions): UnaryCall<LookupVindexCreateRequest, LookupVindexCreateResponse> {
        const method = this.methods[61], opt = this._transport.mergeOptions(options);
        return stackIntercept<LookupVindexCreateRequest, LookupVindexCreateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: LookupVindexExternalize(vtctldata.LookupVindexExternalizeRequest) returns (vtctldata.LookupVindexExternalizeResponse);
     */
    lookupVindexExternalize(input: LookupVindexExternalizeRequest, options?: RpcOptions): UnaryCall<LookupVindexExternalizeRequest, LookupVindexExternalizeResponse> {
        const method = this.methods[62], opt = this._transport.mergeOptions(options);
        return stackIntercept<LookupVindexExternalizeRequest, LookupVindexExternalizeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MaterializeCreate creates a workflow to materialize one or more tables
     * from a source keyspace to a target keyspace using a provided expressions.
     *
     * @generated from protobuf rpc: MaterializeCreate(vtctldata.MaterializeCreateRequest) returns (vtctldata.MaterializeCreateResponse);
     */
    materializeCreate(input: MaterializeCreateRequest, options?: RpcOptions): UnaryCall<MaterializeCreateRequest, MaterializeCreateResponse> {
        const method = this.methods[63], opt = this._transport.mergeOptions(options);
        return stackIntercept<MaterializeCreateRequest, MaterializeCreateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MigrateCreate creates a workflow which migrates one or more tables from an
     * external cluster into Vitess.
     *
     * @generated from protobuf rpc: MigrateCreate(vtctldata.MigrateCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    migrateCreate(input: MigrateCreateRequest, options?: RpcOptions): UnaryCall<MigrateCreateRequest, WorkflowStatusResponse> {
        const method = this.methods[64], opt = this._transport.mergeOptions(options);
        return stackIntercept<MigrateCreateRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MountRegister registers a new external Vitess cluster.
     *
     * @generated from protobuf rpc: MountRegister(vtctldata.MountRegisterRequest) returns (vtctldata.MountRegisterResponse);
     */
    mountRegister(input: MountRegisterRequest, options?: RpcOptions): UnaryCall<MountRegisterRequest, MountRegisterResponse> {
        const method = this.methods[65], opt = this._transport.mergeOptions(options);
        return stackIntercept<MountRegisterRequest, MountRegisterResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MountUnregister unregisters an external Vitess cluster.
     *
     * @generated from protobuf rpc: MountUnregister(vtctldata.MountUnregisterRequest) returns (vtctldata.MountUnregisterResponse);
     */
    mountUnregister(input: MountUnregisterRequest, options?: RpcOptions): UnaryCall<MountUnregisterRequest, MountUnregisterResponse> {
        const method = this.methods[66], opt = this._transport.mergeOptions(options);
        return stackIntercept<MountUnregisterRequest, MountUnregisterResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MountShow returns information about an external Vitess cluster.
     *
     * @generated from protobuf rpc: MountShow(vtctldata.MountShowRequest) returns (vtctldata.MountShowResponse);
     */
    mountShow(input: MountShowRequest, options?: RpcOptions): UnaryCall<MountShowRequest, MountShowResponse> {
        const method = this.methods[67], opt = this._transport.mergeOptions(options);
        return stackIntercept<MountShowRequest, MountShowResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MountList lists all registered external Vitess clusters.
     *
     * @generated from protobuf rpc: MountList(vtctldata.MountListRequest) returns (vtctldata.MountListResponse);
     */
    mountList(input: MountListRequest, options?: RpcOptions): UnaryCall<MountListRequest, MountListResponse> {
        const method = this.methods[68], opt = this._transport.mergeOptions(options);
        return stackIntercept<MountListRequest, MountListResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MoveTablesCreate creates a workflow which moves one or more tables from a
     * source keyspace to a target keyspace.
     *
     * @generated from protobuf rpc: MoveTablesCreate(vtctldata.MoveTablesCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    moveTablesCreate(input: MoveTablesCreateRequest, options?: RpcOptions): UnaryCall<MoveTablesCreateRequest, WorkflowStatusResponse> {
        const method = this.methods[69], opt = this._transport.mergeOptions(options);
        return stackIntercept<MoveTablesCreateRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * MoveTablesComplete completes the move and cleans up the workflow and
     * its related artifacts.
     *
     * @generated from protobuf rpc: MoveTablesComplete(vtctldata.MoveTablesCompleteRequest) returns (vtctldata.MoveTablesCompleteResponse);
     */
    moveTablesComplete(input: MoveTablesCompleteRequest, options?: RpcOptions): UnaryCall<MoveTablesCompleteRequest, MoveTablesCompleteResponse> {
        const method = this.methods[70], opt = this._transport.mergeOptions(options);
        return stackIntercept<MoveTablesCompleteRequest, MoveTablesCompleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PingTablet checks that the specified tablet is awake and responding to RPCs.
     * This command can be blocked by other in-flight operations.
     *
     * @generated from protobuf rpc: PingTablet(vtctldata.PingTabletRequest) returns (vtctldata.PingTabletResponse);
     */
    pingTablet(input: PingTabletRequest, options?: RpcOptions): UnaryCall<PingTabletRequest, PingTabletResponse> {
        const method = this.methods[71], opt = this._transport.mergeOptions(options);
        return stackIntercept<PingTabletRequest, PingTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * PlannedReparentShard reparents the shard to the new primary, or away from
     * an old primary. Both the old and new primaries need to be reachable and
     * running.
     *
     * **NOTE**: The vtctld will not consider any replicas outside the cell the
     * current shard primary is in for promotion unless NewPrimary is explicitly
     * provided in the request.
     *
     * @generated from protobuf rpc: PlannedReparentShard(vtctldata.PlannedReparentShardRequest) returns (vtctldata.PlannedReparentShardResponse);
     */
    plannedReparentShard(input: PlannedReparentShardRequest, options?: RpcOptions): UnaryCall<PlannedReparentShardRequest, PlannedReparentShardResponse> {
        const method = this.methods[72], opt = this._transport.mergeOptions(options);
        return stackIntercept<PlannedReparentShardRequest, PlannedReparentShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RebuildKeyspaceGraph rebuilds the serving data for a keyspace.
     *
     * This may trigger an update to all connected clients.
     *
     * @generated from protobuf rpc: RebuildKeyspaceGraph(vtctldata.RebuildKeyspaceGraphRequest) returns (vtctldata.RebuildKeyspaceGraphResponse);
     */
    rebuildKeyspaceGraph(input: RebuildKeyspaceGraphRequest, options?: RpcOptions): UnaryCall<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse> {
        const method = this.methods[73], opt = this._transport.mergeOptions(options);
        return stackIntercept<RebuildKeyspaceGraphRequest, RebuildKeyspaceGraphResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RebuildVSchemaGraph rebuilds the per-cell SrvVSchema from the global
     * VSchema objects in the provided cells (or all cells in the topo none
     * provided).
     *
     * @generated from protobuf rpc: RebuildVSchemaGraph(vtctldata.RebuildVSchemaGraphRequest) returns (vtctldata.RebuildVSchemaGraphResponse);
     */
    rebuildVSchemaGraph(input: RebuildVSchemaGraphRequest, options?: RpcOptions): UnaryCall<RebuildVSchemaGraphRequest, RebuildVSchemaGraphResponse> {
        const method = this.methods[74], opt = this._transport.mergeOptions(options);
        return stackIntercept<RebuildVSchemaGraphRequest, RebuildVSchemaGraphResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RefreshState reloads the tablet record on the specified tablet.
     *
     * @generated from protobuf rpc: RefreshState(vtctldata.RefreshStateRequest) returns (vtctldata.RefreshStateResponse);
     */
    refreshState(input: RefreshStateRequest, options?: RpcOptions): UnaryCall<RefreshStateRequest, RefreshStateResponse> {
        const method = this.methods[75], opt = this._transport.mergeOptions(options);
        return stackIntercept<RefreshStateRequest, RefreshStateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RefreshStateByShard calls RefreshState on all the tablets in the given shard.
     *
     * @generated from protobuf rpc: RefreshStateByShard(vtctldata.RefreshStateByShardRequest) returns (vtctldata.RefreshStateByShardResponse);
     */
    refreshStateByShard(input: RefreshStateByShardRequest, options?: RpcOptions): UnaryCall<RefreshStateByShardRequest, RefreshStateByShardResponse> {
        const method = this.methods[76], opt = this._transport.mergeOptions(options);
        return stackIntercept<RefreshStateByShardRequest, RefreshStateByShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReloadSchema instructs the remote tablet to reload its schema.
     *
     * @generated from protobuf rpc: ReloadSchema(vtctldata.ReloadSchemaRequest) returns (vtctldata.ReloadSchemaResponse);
     */
    reloadSchema(input: ReloadSchemaRequest, options?: RpcOptions): UnaryCall<ReloadSchemaRequest, ReloadSchemaResponse> {
        const method = this.methods[77], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReloadSchemaRequest, ReloadSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReloadSchemaKeyspace reloads the schema on all tablets in a keyspace.
     *
     * @generated from protobuf rpc: ReloadSchemaKeyspace(vtctldata.ReloadSchemaKeyspaceRequest) returns (vtctldata.ReloadSchemaKeyspaceResponse);
     */
    reloadSchemaKeyspace(input: ReloadSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ReloadSchemaKeyspaceRequest, ReloadSchemaKeyspaceResponse> {
        const method = this.methods[78], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReloadSchemaKeyspaceRequest, ReloadSchemaKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReloadSchemaShard reloads the schema on all tablets in a shard.
     *
     * In general, we don't always expect all replicas to be ready to reload, and
     * the periodic schema reload makes them self-healing anyway. So, we do this
     * on a best-effort basis, and log warnings for any tablets that fail to
     * reload within the context deadline.
     *
     * @generated from protobuf rpc: ReloadSchemaShard(vtctldata.ReloadSchemaShardRequest) returns (vtctldata.ReloadSchemaShardResponse);
     */
    reloadSchemaShard(input: ReloadSchemaShardRequest, options?: RpcOptions): UnaryCall<ReloadSchemaShardRequest, ReloadSchemaShardResponse> {
        const method = this.methods[79], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReloadSchemaShardRequest, ReloadSchemaShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveBackup removes a backup from the BackupStorage used by vtctld.
     *
     * @generated from protobuf rpc: RemoveBackup(vtctldata.RemoveBackupRequest) returns (vtctldata.RemoveBackupResponse);
     */
    removeBackup(input: RemoveBackupRequest, options?: RpcOptions): UnaryCall<RemoveBackupRequest, RemoveBackupResponse> {
        const method = this.methods[80], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveBackupRequest, RemoveBackupResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveKeyspaceCell removes the specified cell from the Cells list for all
     * shards in the specified keyspace (by calling RemoveShardCell on every
     * shard). It also removes the SrvKeyspace for that keyspace in that cell.
     *
     * @generated from protobuf rpc: RemoveKeyspaceCell(vtctldata.RemoveKeyspaceCellRequest) returns (vtctldata.RemoveKeyspaceCellResponse);
     */
    removeKeyspaceCell(input: RemoveKeyspaceCellRequest, options?: RpcOptions): UnaryCall<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse> {
        const method = this.methods[81], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveKeyspaceCellRequest, RemoveKeyspaceCellResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RemoveShardCell removes the specified cell from the specified shard's Cells
     * list.
     *
     * @generated from protobuf rpc: RemoveShardCell(vtctldata.RemoveShardCellRequest) returns (vtctldata.RemoveShardCellResponse);
     */
    removeShardCell(input: RemoveShardCellRequest, options?: RpcOptions): UnaryCall<RemoveShardCellRequest, RemoveShardCellResponse> {
        const method = this.methods[82], opt = this._transport.mergeOptions(options);
        return stackIntercept<RemoveShardCellRequest, RemoveShardCellResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReparentTablet reparents a tablet to the current primary in the shard. This
     * only works if the current replica position matches the last known reparent
     * action.
     *
     * @generated from protobuf rpc: ReparentTablet(vtctldata.ReparentTabletRequest) returns (vtctldata.ReparentTabletResponse);
     */
    reparentTablet(input: ReparentTabletRequest, options?: RpcOptions): UnaryCall<ReparentTabletRequest, ReparentTabletResponse> {
        const method = this.methods[83], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReparentTabletRequest, ReparentTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ReshardCreate creates a workflow to reshard a keyspace.
     *
     * @generated from protobuf rpc: ReshardCreate(vtctldata.ReshardCreateRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    reshardCreate(input: ReshardCreateRequest, options?: RpcOptions): UnaryCall<ReshardCreateRequest, WorkflowStatusResponse> {
        const method = this.methods[84], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReshardCreateRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RestoreFromBackup stops mysqld for the given tablet and restores a backup.
     *
     * @generated from protobuf rpc: RestoreFromBackup(vtctldata.RestoreFromBackupRequest) returns (stream vtctldata.RestoreFromBackupResponse);
     */
    restoreFromBackup(input: RestoreFromBackupRequest, options?: RpcOptions): ServerStreamingCall<RestoreFromBackupRequest, RestoreFromBackupResponse> {
        const method = this.methods[85], opt = this._transport.mergeOptions(options);
        return stackIntercept<RestoreFromBackupRequest, RestoreFromBackupResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * RetrySchemaMigration marks a given schema migration for retry.
     *
     * @generated from protobuf rpc: RetrySchemaMigration(vtctldata.RetrySchemaMigrationRequest) returns (vtctldata.RetrySchemaMigrationResponse);
     */
    retrySchemaMigration(input: RetrySchemaMigrationRequest, options?: RpcOptions): UnaryCall<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse> {
        const method = this.methods[86], opt = this._transport.mergeOptions(options);
        return stackIntercept<RetrySchemaMigrationRequest, RetrySchemaMigrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * RunHealthCheck runs a healthcheck on the remote tablet.
     *
     * @generated from protobuf rpc: RunHealthCheck(vtctldata.RunHealthCheckRequest) returns (vtctldata.RunHealthCheckResponse);
     */
    runHealthCheck(input: RunHealthCheckRequest, options?: RpcOptions): UnaryCall<RunHealthCheckRequest, RunHealthCheckResponse> {
        const method = this.methods[87], opt = this._transport.mergeOptions(options);
        return stackIntercept<RunHealthCheckRequest, RunHealthCheckResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetKeyspaceDurabilityPolicy updates the DurabilityPolicy for a keyspace.
     *
     * @generated from protobuf rpc: SetKeyspaceDurabilityPolicy(vtctldata.SetKeyspaceDurabilityPolicyRequest) returns (vtctldata.SetKeyspaceDurabilityPolicyResponse);
     */
    setKeyspaceDurabilityPolicy(input: SetKeyspaceDurabilityPolicyRequest, options?: RpcOptions): UnaryCall<SetKeyspaceDurabilityPolicyRequest, SetKeyspaceDurabilityPolicyResponse> {
        const method = this.methods[88], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetKeyspaceDurabilityPolicyRequest, SetKeyspaceDurabilityPolicyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetShardIsPrimaryServing adds or removes a shard from serving.
     *
     * This is meant as an emergency function. It does not rebuild any serving
     * graph (i.e. it does not run RebuildKeyspaceGraph).
     *
     * @generated from protobuf rpc: SetShardIsPrimaryServing(vtctldata.SetShardIsPrimaryServingRequest) returns (vtctldata.SetShardIsPrimaryServingResponse);
     */
    setShardIsPrimaryServing(input: SetShardIsPrimaryServingRequest, options?: RpcOptions): UnaryCall<SetShardIsPrimaryServingRequest, SetShardIsPrimaryServingResponse> {
        const method = this.methods[89], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetShardIsPrimaryServingRequest, SetShardIsPrimaryServingResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetShardTabletControl updates the TabletControl topo record for a shard and
     * tablet type.
     *
     * This should only be used for an emergency fix, or after a finished
     * Reshard. See the documentation on SetShardTabletControlRequest for more
     * information about the different update modes.
     *
     * @generated from protobuf rpc: SetShardTabletControl(vtctldata.SetShardTabletControlRequest) returns (vtctldata.SetShardTabletControlResponse);
     */
    setShardTabletControl(input: SetShardTabletControlRequest, options?: RpcOptions): UnaryCall<SetShardTabletControlRequest, SetShardTabletControlResponse> {
        const method = this.methods[90], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetShardTabletControlRequest, SetShardTabletControlResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SetWritable sets a tablet as read-write (writable=true) or read-only (writable=false).
     *
     * @generated from protobuf rpc: SetWritable(vtctldata.SetWritableRequest) returns (vtctldata.SetWritableResponse);
     */
    setWritable(input: SetWritableRequest, options?: RpcOptions): UnaryCall<SetWritableRequest, SetWritableResponse> {
        const method = this.methods[91], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetWritableRequest, SetWritableResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ShardReplicationAdd adds an entry to a topodata.ShardReplication object.
     *
     * It is a low-level function and should generally not be called.
     *
     * @generated from protobuf rpc: ShardReplicationAdd(vtctldata.ShardReplicationAddRequest) returns (vtctldata.ShardReplicationAddResponse);
     */
    shardReplicationAdd(input: ShardReplicationAddRequest, options?: RpcOptions): UnaryCall<ShardReplicationAddRequest, ShardReplicationAddResponse> {
        const method = this.methods[92], opt = this._transport.mergeOptions(options);
        return stackIntercept<ShardReplicationAddRequest, ShardReplicationAddResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ShardReplicationFix walks the replication graph for a shard in a cell and
     * attempts to fix the first problem encountered, returning information about
     * the problem fixed, if any.
     *
     * @generated from protobuf rpc: ShardReplicationFix(vtctldata.ShardReplicationFixRequest) returns (vtctldata.ShardReplicationFixResponse);
     */
    shardReplicationFix(input: ShardReplicationFixRequest, options?: RpcOptions): UnaryCall<ShardReplicationFixRequest, ShardReplicationFixResponse> {
        const method = this.methods[93], opt = this._transport.mergeOptions(options);
        return stackIntercept<ShardReplicationFixRequest, ShardReplicationFixResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ShardReplicationPositions returns the replication position of each tablet
     * in a shard. This RPC makes a best-effort to return partial results. For
     * example, if one tablet in the shard graph is unreachable, then
     * ShardReplicationPositions will return non-error, and include valid results
     * for the reachable tablets.
     *
     * @generated from protobuf rpc: ShardReplicationPositions(vtctldata.ShardReplicationPositionsRequest) returns (vtctldata.ShardReplicationPositionsResponse);
     */
    shardReplicationPositions(input: ShardReplicationPositionsRequest, options?: RpcOptions): UnaryCall<ShardReplicationPositionsRequest, ShardReplicationPositionsResponse> {
        const method = this.methods[94], opt = this._transport.mergeOptions(options);
        return stackIntercept<ShardReplicationPositionsRequest, ShardReplicationPositionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ShardReplicationRemove removes an entry from a topodata.ShardReplication
     * object.
     *
     * It is a low-level function and should generally not be called.
     *
     * @generated from protobuf rpc: ShardReplicationRemove(vtctldata.ShardReplicationRemoveRequest) returns (vtctldata.ShardReplicationRemoveResponse);
     */
    shardReplicationRemove(input: ShardReplicationRemoveRequest, options?: RpcOptions): UnaryCall<ShardReplicationRemoveRequest, ShardReplicationRemoveResponse> {
        const method = this.methods[95], opt = this._transport.mergeOptions(options);
        return stackIntercept<ShardReplicationRemoveRequest, ShardReplicationRemoveResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SleepTablet blocks the aciton queue on the specified tablet for the
     * specified duration.
     *
     * This is typically used for testing.
     *
     * @generated from protobuf rpc: SleepTablet(vtctldata.SleepTabletRequest) returns (vtctldata.SleepTabletResponse);
     */
    sleepTablet(input: SleepTabletRequest, options?: RpcOptions): UnaryCall<SleepTabletRequest, SleepTabletResponse> {
        const method = this.methods[96], opt = this._transport.mergeOptions(options);
        return stackIntercept<SleepTabletRequest, SleepTabletResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SourceShardAdd adds the SourceShard record with the provided index. This
     * should be used only as an emergency function.
     *
     * It does not call RefreshState for the shard primary.
     *
     * @generated from protobuf rpc: SourceShardAdd(vtctldata.SourceShardAddRequest) returns (vtctldata.SourceShardAddResponse);
     */
    sourceShardAdd(input: SourceShardAddRequest, options?: RpcOptions): UnaryCall<SourceShardAddRequest, SourceShardAddResponse> {
        const method = this.methods[97], opt = this._transport.mergeOptions(options);
        return stackIntercept<SourceShardAddRequest, SourceShardAddResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * SourceShardDelete deletes the SourceShard record with the provided index.
     * This should be used only as an emergency cleanup function.
     *
     * It does not call RefreshState for the shard primary.
     *
     * @generated from protobuf rpc: SourceShardDelete(vtctldata.SourceShardDeleteRequest) returns (vtctldata.SourceShardDeleteResponse);
     */
    sourceShardDelete(input: SourceShardDeleteRequest, options?: RpcOptions): UnaryCall<SourceShardDeleteRequest, SourceShardDeleteResponse> {
        const method = this.methods[98], opt = this._transport.mergeOptions(options);
        return stackIntercept<SourceShardDeleteRequest, SourceShardDeleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StartReplication starts replication on the specified tablet.
     *
     * @generated from protobuf rpc: StartReplication(vtctldata.StartReplicationRequest) returns (vtctldata.StartReplicationResponse);
     */
    startReplication(input: StartReplicationRequest, options?: RpcOptions): UnaryCall<StartReplicationRequest, StartReplicationResponse> {
        const method = this.methods[99], opt = this._transport.mergeOptions(options);
        return stackIntercept<StartReplicationRequest, StartReplicationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * StopReplication stops replication on the specified tablet.
     *
     * @generated from protobuf rpc: StopReplication(vtctldata.StopReplicationRequest) returns (vtctldata.StopReplicationResponse);
     */
    stopReplication(input: StopReplicationRequest, options?: RpcOptions): UnaryCall<StopReplicationRequest, StopReplicationResponse> {
        const method = this.methods[100], opt = this._transport.mergeOptions(options);
        return stackIntercept<StopReplicationRequest, StopReplicationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * TabletExternallyReparented changes metadata in the topology server to
     * acknowledge a shard primary change performed by an external tool (e.g.
     * orchestrator).
     *
     * See the Reparenting guide for more information:
     * https://vitess.io/docs/user-guides/configuration-advanced/reparenting/#external-reparenting.
     *
     * @generated from protobuf rpc: TabletExternallyReparented(vtctldata.TabletExternallyReparentedRequest) returns (vtctldata.TabletExternallyReparentedResponse);
     */
    tabletExternallyReparented(input: TabletExternallyReparentedRequest, options?: RpcOptions): UnaryCall<TabletExternallyReparentedRequest, TabletExternallyReparentedResponse> {
        const method = this.methods[101], opt = this._transport.mergeOptions(options);
        return stackIntercept<TabletExternallyReparentedRequest, TabletExternallyReparentedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateCellInfo updates the content of a CellInfo with the provided
     * parameters. Empty values are ignored. If the cell does not exist, the
     * CellInfo will be created.
     *
     * @generated from protobuf rpc: UpdateCellInfo(vtctldata.UpdateCellInfoRequest) returns (vtctldata.UpdateCellInfoResponse);
     */
    updateCellInfo(input: UpdateCellInfoRequest, options?: RpcOptions): UnaryCall<UpdateCellInfoRequest, UpdateCellInfoResponse> {
        const method = this.methods[102], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateCellInfoRequest, UpdateCellInfoResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * UpdateCellsAlias updates the content of a CellsAlias with the provided
     * parameters. Empty values are ignored. If the alias does not exist, the
     * CellsAlias will be created.
     *
     * @generated from protobuf rpc: UpdateCellsAlias(vtctldata.UpdateCellsAliasRequest) returns (vtctldata.UpdateCellsAliasResponse);
     */
    updateCellsAlias(input: UpdateCellsAliasRequest, options?: RpcOptions): UnaryCall<UpdateCellsAliasRequest, UpdateCellsAliasResponse> {
        const method = this.methods[103], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdateCellsAliasRequest, UpdateCellsAliasResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Validate validates that all nodes from the global replication graph are
     * reachable, and that all tablets in discoverable cells are consistent.
     *
     * @generated from protobuf rpc: Validate(vtctldata.ValidateRequest) returns (vtctldata.ValidateResponse);
     */
    validate(input: ValidateRequest, options?: RpcOptions): UnaryCall<ValidateRequest, ValidateResponse> {
        const method = this.methods[104], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateRequest, ValidateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateKeyspace validates that all nodes reachable from the specified
     * keyspace are consistent.
     *
     * @generated from protobuf rpc: ValidateKeyspace(vtctldata.ValidateKeyspaceRequest) returns (vtctldata.ValidateKeyspaceResponse);
     */
    validateKeyspace(input: ValidateKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateKeyspaceRequest, ValidateKeyspaceResponse> {
        const method = this.methods[105], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateKeyspaceRequest, ValidateKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateSchemaKeyspace validates that the schema on the primary tablet for shard 0 matches the schema on all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateSchemaKeyspace(vtctldata.ValidateSchemaKeyspaceRequest) returns (vtctldata.ValidateSchemaKeyspaceResponse);
     */
    validateSchemaKeyspace(input: ValidateSchemaKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse> {
        const method = this.methods[106], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateSchemaKeyspaceRequest, ValidateSchemaKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateShard validates that all nodes reachable from the specified shard
     * are consistent.
     *
     * @generated from protobuf rpc: ValidateShard(vtctldata.ValidateShardRequest) returns (vtctldata.ValidateShardResponse);
     */
    validateShard(input: ValidateShardRequest, options?: RpcOptions): UnaryCall<ValidateShardRequest, ValidateShardResponse> {
        const method = this.methods[107], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateShardRequest, ValidateShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateVersionKeyspace validates that the version on the primary of shard 0 matches all of the other tablets in the keyspace.
     *
     * @generated from protobuf rpc: ValidateVersionKeyspace(vtctldata.ValidateVersionKeyspaceRequest) returns (vtctldata.ValidateVersionKeyspaceResponse);
     */
    validateVersionKeyspace(input: ValidateVersionKeyspaceRequest, options?: RpcOptions): UnaryCall<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse> {
        const method = this.methods[108], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateVersionKeyspaceRequest, ValidateVersionKeyspaceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateVersionShard validates that the version on the primary matches all of the replicas.
     *
     * @generated from protobuf rpc: ValidateVersionShard(vtctldata.ValidateVersionShardRequest) returns (vtctldata.ValidateVersionShardResponse);
     */
    validateVersionShard(input: ValidateVersionShardRequest, options?: RpcOptions): UnaryCall<ValidateVersionShardRequest, ValidateVersionShardResponse> {
        const method = this.methods[109], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateVersionShardRequest, ValidateVersionShardResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * ValidateVSchema compares the schema of each primary tablet in "keyspace/shards..." to the vschema and errs if there are differences.
     *
     * @generated from protobuf rpc: ValidateVSchema(vtctldata.ValidateVSchemaRequest) returns (vtctldata.ValidateVSchemaResponse);
     */
    validateVSchema(input: ValidateVSchemaRequest, options?: RpcOptions): UnaryCall<ValidateVSchemaRequest, ValidateVSchemaResponse> {
        const method = this.methods[110], opt = this._transport.mergeOptions(options);
        return stackIntercept<ValidateVSchemaRequest, ValidateVSchemaResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: VDiffCreate(vtctldata.VDiffCreateRequest) returns (vtctldata.VDiffCreateResponse);
     */
    vDiffCreate(input: VDiffCreateRequest, options?: RpcOptions): UnaryCall<VDiffCreateRequest, VDiffCreateResponse> {
        const method = this.methods[111], opt = this._transport.mergeOptions(options);
        return stackIntercept<VDiffCreateRequest, VDiffCreateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: VDiffDelete(vtctldata.VDiffDeleteRequest) returns (vtctldata.VDiffDeleteResponse);
     */
    vDiffDelete(input: VDiffDeleteRequest, options?: RpcOptions): UnaryCall<VDiffDeleteRequest, VDiffDeleteResponse> {
        const method = this.methods[112], opt = this._transport.mergeOptions(options);
        return stackIntercept<VDiffDeleteRequest, VDiffDeleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: VDiffResume(vtctldata.VDiffResumeRequest) returns (vtctldata.VDiffResumeResponse);
     */
    vDiffResume(input: VDiffResumeRequest, options?: RpcOptions): UnaryCall<VDiffResumeRequest, VDiffResumeResponse> {
        const method = this.methods[113], opt = this._transport.mergeOptions(options);
        return stackIntercept<VDiffResumeRequest, VDiffResumeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: VDiffShow(vtctldata.VDiffShowRequest) returns (vtctldata.VDiffShowResponse);
     */
    vDiffShow(input: VDiffShowRequest, options?: RpcOptions): UnaryCall<VDiffShowRequest, VDiffShowResponse> {
        const method = this.methods[114], opt = this._transport.mergeOptions(options);
        return stackIntercept<VDiffShowRequest, VDiffShowResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: VDiffStop(vtctldata.VDiffStopRequest) returns (vtctldata.VDiffStopResponse);
     */
    vDiffStop(input: VDiffStopRequest, options?: RpcOptions): UnaryCall<VDiffStopRequest, VDiffStopResponse> {
        const method = this.methods[115], opt = this._transport.mergeOptions(options);
        return stackIntercept<VDiffStopRequest, VDiffStopResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * WorkflowDelete deletes a vreplication workflow.
     *
     * @generated from protobuf rpc: WorkflowDelete(vtctldata.WorkflowDeleteRequest) returns (vtctldata.WorkflowDeleteResponse);
     */
    workflowDelete(input: WorkflowDeleteRequest, options?: RpcOptions): UnaryCall<WorkflowDeleteRequest, WorkflowDeleteResponse> {
        const method = this.methods[116], opt = this._transport.mergeOptions(options);
        return stackIntercept<WorkflowDeleteRequest, WorkflowDeleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: WorkflowStatus(vtctldata.WorkflowStatusRequest) returns (vtctldata.WorkflowStatusResponse);
     */
    workflowStatus(input: WorkflowStatusRequest, options?: RpcOptions): UnaryCall<WorkflowStatusRequest, WorkflowStatusResponse> {
        const method = this.methods[117], opt = this._transport.mergeOptions(options);
        return stackIntercept<WorkflowStatusRequest, WorkflowStatusResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: WorkflowSwitchTraffic(vtctldata.WorkflowSwitchTrafficRequest) returns (vtctldata.WorkflowSwitchTrafficResponse);
     */
    workflowSwitchTraffic(input: WorkflowSwitchTrafficRequest, options?: RpcOptions): UnaryCall<WorkflowSwitchTrafficRequest, WorkflowSwitchTrafficResponse> {
        const method = this.methods[118], opt = this._transport.mergeOptions(options);
        return stackIntercept<WorkflowSwitchTrafficRequest, WorkflowSwitchTrafficResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * WorkflowUpdate updates the configuration of a vreplication workflow
     * using the provided updated parameters.
     *
     * @generated from protobuf rpc: WorkflowUpdate(vtctldata.WorkflowUpdateRequest) returns (vtctldata.WorkflowUpdateResponse);
     */
    workflowUpdate(input: WorkflowUpdateRequest, options?: RpcOptions): UnaryCall<WorkflowUpdateRequest, WorkflowUpdateResponse> {
        const method = this.methods[119], opt = this._transport.mergeOptions(options);
        return stackIntercept<WorkflowUpdateRequest, WorkflowUpdateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * GetMirrorRules returns the VSchema routing rules.
     *
     * @generated from protobuf rpc: GetMirrorRules(vtctldata.GetMirrorRulesRequest) returns (vtctldata.GetMirrorRulesResponse);
     */
    getMirrorRules(input: GetMirrorRulesRequest, options?: RpcOptions): UnaryCall<GetMirrorRulesRequest, GetMirrorRulesResponse> {
        const method = this.methods[120], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetMirrorRulesRequest, GetMirrorRulesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: WorkflowMirrorTraffic(vtctldata.WorkflowMirrorTrafficRequest) returns (vtctldata.WorkflowMirrorTrafficResponse);
     */
    workflowMirrorTraffic(input: WorkflowMirrorTrafficRequest, options?: RpcOptions): UnaryCall<WorkflowMirrorTrafficRequest, WorkflowMirrorTrafficResponse> {
        const method = this.methods[121], opt = this._transport.mergeOptions(options);
        return stackIntercept<WorkflowMirrorTrafficRequest, WorkflowMirrorTrafficResponse>("unary", this._transport, method, opt, input);
    }
}
