//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains all the types and servers necessary to make
// RPC calls to VtTablet for the binlog protocol, used by filtered
// replication only.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,json_types=true"
// @generated from file binlogdata.proto (package binlogdata, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { EventToken, EventTokenJson, Field, FieldJson, QueryResult, QueryResultJson, Row, RowJson, Target, TargetJson, VTGateCallerID, VTGateCallerIDJson } from "./query_pb";
import { file_query } from "./query_pb";
import type { KeyRange, KeyRangeJson, TabletType, TabletTypeJson } from "./topodata_pb";
import { file_topodata } from "./topodata_pb";
import type { CallerID, CallerIDJson } from "./vtrpc_pb";
import { file_vtrpc } from "./vtrpc_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file binlogdata.proto.
 */
export const file_binlogdata: GenFile = /*@__PURE__*/
  fileDesc("ChBiaW5sb2dkYXRhLnByb3RvEgpiaW5sb2dkYXRhIjcKB0NoYXJzZXQSDgoGY2xpZW50GAEgASgFEgwKBGNvbm4YAiABKAUSDgoGc2VydmVyGAMgASgFIrUDChFCaW5sb2dUcmFuc2FjdGlvbhI7CgpzdGF0ZW1lbnRzGAEgAygLMicuYmlubG9nZGF0YS5CaW5sb2dUcmFuc2FjdGlvbi5TdGF0ZW1lbnQSJgoLZXZlbnRfdG9rZW4YBCABKAsyES5xdWVyeS5FdmVudFRva2VuGq4CCglTdGF0ZW1lbnQSQgoIY2F0ZWdvcnkYASABKA4yMC5iaW5sb2dkYXRhLkJpbmxvZ1RyYW5zYWN0aW9uLlN0YXRlbWVudC5DYXRlZ29yeRIkCgdjaGFyc2V0GAIgASgLMhMuYmlubG9nZGF0YS5DaGFyc2V0EgsKA3NxbBgDIAEoDCKpAQoIQ2F0ZWdvcnkSEwoPQkxfVU5SRUNPR05JWkVEEAASDAoIQkxfQkVHSU4QARINCglCTF9DT01NSVQQAhIPCgtCTF9ST0xMQkFDSxADEhUKEUJMX0RNTF9ERVBSRUNBVEVEEAQSCgoGQkxfRERMEAUSCgoGQkxfU0VUEAYSDQoJQkxfSU5TRVJUEAcSDQoJQkxfVVBEQVRFEAgSDQoJQkxfREVMRVRFEAlKBAgCEANKBAgDEAQidgoVU3RyZWFtS2V5UmFuZ2VSZXF1ZXN0EhAKCHBvc2l0aW9uGAEgASgJEiUKCWtleV9yYW5nZRgCIAEoCzISLnRvcG9kYXRhLktleVJhbmdlEiQKB2NoYXJzZXQYAyABKAsyEy5iaW5sb2dkYXRhLkNoYXJzZXQiUwoWU3RyZWFtS2V5UmFuZ2VSZXNwb25zZRI5ChJiaW5sb2dfdHJhbnNhY3Rpb24YASABKAsyHS5iaW5sb2dkYXRhLkJpbmxvZ1RyYW5zYWN0aW9uIl0KE1N0cmVhbVRhYmxlc1JlcXVlc3QSEAoIcG9zaXRpb24YASABKAkSDgoGdGFibGVzGAIgAygJEiQKB2NoYXJzZXQYAyABKAsyEy5iaW5sb2dkYXRhLkNoYXJzZXQiUQoUU3RyZWFtVGFibGVzUmVzcG9uc2USOQoSYmlubG9nX3RyYW5zYWN0aW9uGAEgASgLMh0uYmlubG9nZGF0YS5CaW5sb2dUcmFuc2FjdGlvbiI9ChFDaGFyc2V0Q29udmVyc2lvbhIUCgxmcm9tX2NoYXJzZXQYASABKAkSEgoKdG9fY2hhcnNldBgCIAEoCSLDBAoEUnVsZRINCgVtYXRjaBgBIAEoCRIOCgZmaWx0ZXIYAiABKAkSRQoUY29udmVydF9lbnVtX3RvX3RleHQYAyADKAsyJy5iaW5sb2dkYXRhLlJ1bGUuQ29udmVydEVudW1Ub1RleHRFbnRyeRI9Cg9jb252ZXJ0X2NoYXJzZXQYBCADKAsyJC5iaW5sb2dkYXRhLlJ1bGUuQ29udmVydENoYXJzZXRFbnRyeRIhChlzb3VyY2VfdW5pcXVlX2tleV9jb2x1bW5zGAUgASgJEiEKGXRhcmdldF91bmlxdWVfa2V5X2NvbHVtbnMYBiABKAkSKAogc291cmNlX3VuaXF1ZV9rZXlfdGFyZ2V0X2NvbHVtbnMYByABKAkSQwoTY29udmVydF9pbnRfdG9fZW51bRgIIAMoCzImLmJpbmxvZ2RhdGEuUnVsZS5Db252ZXJ0SW50VG9FbnVtRW50cnkSGAoQZm9yY2VfdW5pcXVlX2tleRgJIAEoCRo4ChZDb252ZXJ0RW51bVRvVGV4dEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaVAoTQ29udmVydENoYXJzZXRFbnRyeRILCgNrZXkYASABKAkSLAoFdmFsdWUYAiABKAsyHS5iaW5sb2dkYXRhLkNoYXJzZXRDb252ZXJzaW9uOgI4ARo3ChVDb252ZXJ0SW50VG9FbnVtRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgIOgI4ASLMAQoGRmlsdGVyEh8KBXJ1bGVzGAEgAygLMhAuYmlubG9nZGF0YS5SdWxlEjsKEGZpZWxkX2V2ZW50X21vZGUYAiABKA4yIS5iaW5sb2dkYXRhLkZpbHRlci5GaWVsZEV2ZW50TW9kZRIVCg13b3JrZmxvd190eXBlGAMgASgDEhUKDXdvcmtmbG93X25hbWUYBCABKAkiNgoORmllbGRFdmVudE1vZGUSEwoPRVJSX09OX01JU01BVENIEAASDwoLQkVTVF9FRkZPUlQQASLdAgoMQmlubG9nU291cmNlEhAKCGtleXNwYWNlGAEgASgJEg0KBXNoYXJkGAIgASgJEikKC3RhYmxldF90eXBlGAMgASgOMhQudG9wb2RhdGEuVGFibGV0VHlwZRIlCglrZXlfcmFuZ2UYBCABKAsyEi50b3BvZGF0YS5LZXlSYW5nZRIOCgZ0YWJsZXMYBSADKAkSIgoGZmlsdGVyGAYgASgLMhIuYmlubG9nZGF0YS5GaWx0ZXISJwoGb25fZGRsGAcgASgOMhcuYmlubG9nZGF0YS5PbkRETEFjdGlvbhIWCg5leHRlcm5hbF9teXNxbBgIIAEoCRIXCg9zdG9wX2FmdGVyX2NvcHkYCSABKAgSGAoQZXh0ZXJuYWxfY2x1c3RlchgKIAEoCRIYChBzb3VyY2VfdGltZV96b25lGAsgASgJEhgKEHRhcmdldF90aW1lX3pvbmUYDCABKAkinQEKCVJvd0NoYW5nZRIaCgZiZWZvcmUYASABKAsyCi5xdWVyeS5Sb3cSGQoFYWZ0ZXIYAiABKAsyCi5xdWVyeS5Sb3cSMgoMZGF0YV9jb2x1bW5zGAMgASgLMhwuYmlubG9nZGF0YS5Sb3dDaGFuZ2UuQml0bWFwGiUKBkJpdG1hcBINCgVjb3VudBgBIAEoAxIMCgRjb2xzGAIgASgMIpUBCghSb3dFdmVudBISCgp0YWJsZV9uYW1lGAEgASgJEioKC3Jvd19jaGFuZ2VzGAIgAygLMhUuYmlubG9nZGF0YS5Sb3dDaGFuZ2USEAoIa2V5c3BhY2UYAyABKAkSDQoFc2hhcmQYBCABKAkSDQoFZmxhZ3MYBSABKA0SGQoRaXNfaW50ZXJuYWxfdGFibGUYBiABKAgimgEKCkZpZWxkRXZlbnQSEgoKdGFibGVfbmFtZRgBIAEoCRIcCgZmaWVsZHMYAiADKAsyDC5xdWVyeS5GaWVsZBIQCghrZXlzcGFjZRgDIAEoCRINCgVzaGFyZBgEIAEoCRIeChZlbnVtX3NldF9zdHJpbmdfdmFsdWVzGBkgASgIEhkKEWlzX2ludGVybmFsX3RhYmxlGBogASgIImcKCVNoYXJkR3RpZBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCRIMCgRndGlkGAMgASgJEisKCnRhYmxlX3Bfa3MYBCADKAsyFy5iaW5sb2dkYXRhLlRhYmxlTGFzdFBLIjMKBVZHdGlkEioKC3NoYXJkX2d0aWRzGAEgAygLMhUuYmlubG9nZGF0YS5TaGFyZEd0aWQiMAoNS2V5c3BhY2VTaGFyZBIQCghrZXlzcGFjZRgBIAEoCRINCgVzaGFyZBgCIAEoCSLnAQoHSm91cm5hbBIKCgJpZBgBIAEoAxIxCg5taWdyYXRpb25fdHlwZRgCIAEoDjIZLmJpbmxvZ2RhdGEuTWlncmF0aW9uVHlwZRIOCgZ0YWJsZXMYAyADKAkSFgoObG9jYWxfcG9zaXRpb24YBCABKAkSKgoLc2hhcmRfZ3RpZHMYBSADKAsyFS5iaW5sb2dkYXRhLlNoYXJkR3RpZBIvCgxwYXJ0aWNpcGFudHMYBiADKAsyGS5iaW5sb2dkYXRhLktleXNwYWNlU2hhcmQSGAoQc291cmNlX3dvcmtmbG93cxgHIAMoCSKiAwoGVkV2ZW50EiQKBHR5cGUYASABKA4yFi5iaW5sb2dkYXRhLlZFdmVudFR5cGUSEQoJdGltZXN0YW1wGAIgASgDEgwKBGd0aWQYAyABKAkSEQoJc3RhdGVtZW50GAQgASgJEicKCXJvd19ldmVudBgFIAEoCzIULmJpbmxvZ2RhdGEuUm93RXZlbnQSKwoLZmllbGRfZXZlbnQYBiABKAsyFi5iaW5sb2dkYXRhLkZpZWxkRXZlbnQSIAoFdmd0aWQYByABKAsyES5iaW5sb2dkYXRhLlZHdGlkEiQKB2pvdXJuYWwYCCABKAsyEy5iaW5sb2dkYXRhLkpvdXJuYWwSCwoDZG1sGAkgASgJEhQKDGN1cnJlbnRfdGltZRgUIAEoAxIvCg5sYXN0X3Bfa19ldmVudBgVIAEoCzIXLmJpbmxvZ2RhdGEuTGFzdFBLRXZlbnQSEAoIa2V5c3BhY2UYFiABKAkSDQoFc2hhcmQYFyABKAkSEQoJdGhyb3R0bGVkGBggASgIEhgKEHRocm90dGxlZF9yZWFzb24YGSABKAkiZwoMTWluaW1hbFRhYmxlEgwKBG5hbWUYASABKAkSHAoGZmllbGRzGAIgAygLMgwucXVlcnkuRmllbGQSEwoLcF9rX2NvbHVtbnMYAyADKAMSFgoOcF9rX2luZGV4X25hbWUYBCABKAkiOQoNTWluaW1hbFNjaGVtYRIoCgZ0YWJsZXMYASADKAsyGC5iaW5sb2dkYXRhLk1pbmltYWxUYWJsZSKsAQoOVlN0cmVhbU9wdGlvbnMSFwoPaW50ZXJuYWxfdGFibGVzGAEgAygJEkkKEGNvbmZpZ19vdmVycmlkZXMYAiADKAsyLy5iaW5sb2dkYXRhLlZTdHJlYW1PcHRpb25zLkNvbmZpZ092ZXJyaWRlc0VudHJ5GjYKFENvbmZpZ092ZXJyaWRlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEipgIKDlZTdHJlYW1SZXF1ZXN0EiwKE2VmZmVjdGl2ZV9jYWxsZXJfaWQYASABKAsyDy52dHJwYy5DYWxsZXJJRBIyChNpbW1lZGlhdGVfY2FsbGVyX2lkGAIgASgLMhUucXVlcnkuVlRHYXRlQ2FsbGVySUQSHQoGdGFyZ2V0GAMgASgLMg0ucXVlcnkuVGFyZ2V0EhAKCHBvc2l0aW9uGAQgASgJEiIKBmZpbHRlchgFIAEoCzISLmJpbmxvZ2RhdGEuRmlsdGVyEjAKD3RhYmxlX2xhc3RfcF9rcxgGIAMoCzIXLmJpbmxvZ2RhdGEuVGFibGVMYXN0UEsSKwoHb3B0aW9ucxgHIAEoCzIaLmJpbmxvZ2RhdGEuVlN0cmVhbU9wdGlvbnMiNQoPVlN0cmVhbVJlc3BvbnNlEiIKBmV2ZW50cxgBIAMoCzISLmJpbmxvZ2RhdGEuVkV2ZW50IvUBChJWU3RyZWFtUm93c1JlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSDQoFcXVlcnkYBCABKAkSIgoGbGFzdHBrGAUgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQSKwoHb3B0aW9ucxgGIAEoCzIaLmJpbmxvZ2RhdGEuVlN0cmVhbU9wdGlvbnMi1wEKE1ZTdHJlYW1Sb3dzUmVzcG9uc2USHAoGZmllbGRzGAEgAygLMgwucXVlcnkuRmllbGQSHgoIcGtmaWVsZHMYAiADKAsyDC5xdWVyeS5GaWVsZBIMCgRndGlkGAMgASgJEhgKBHJvd3MYBCADKAsyCi5xdWVyeS5Sb3cSGgoGbGFzdHBrGAUgASgLMgoucXVlcnkuUm93EhEKCXRocm90dGxlZBgGIAEoCBIRCgloZWFydGJlYXQYByABKAgSGAoQdGhyb3R0bGVkX3JlYXNvbhgIIAEoCSLEAQoUVlN0cmVhbVRhYmxlc1JlcXVlc3QSLAoTZWZmZWN0aXZlX2NhbGxlcl9pZBgBIAEoCzIPLnZ0cnBjLkNhbGxlcklEEjIKE2ltbWVkaWF0ZV9jYWxsZXJfaWQYAiABKAsyFS5xdWVyeS5WVEdhdGVDYWxsZXJJRBIdCgZ0YXJnZXQYAyABKAsyDS5xdWVyeS5UYXJnZXQSKwoHb3B0aW9ucxgEIAEoCzIaLmJpbmxvZ2RhdGEuVlN0cmVhbU9wdGlvbnMirQEKFVZTdHJlYW1UYWJsZXNSZXNwb25zZRISCgp0YWJsZV9uYW1lGAEgASgJEhwKBmZpZWxkcxgCIAMoCzIMLnF1ZXJ5LkZpZWxkEh4KCHBrZmllbGRzGAMgAygLMgwucXVlcnkuRmllbGQSDAoEZ3RpZBgEIAEoCRIYCgRyb3dzGAUgAygLMgoucXVlcnkuUm93EhoKBmxhc3RwaxgGIAEoCzIKLnF1ZXJ5LlJvdyJRCgtMYXN0UEtFdmVudBIvCg50YWJsZV9sYXN0X3BfaxgBIAEoCzIXLmJpbmxvZ2RhdGEuVGFibGVMYXN0UEsSEQoJY29tcGxldGVkGAIgASgIIkUKC1RhYmxlTGFzdFBLEhIKCnRhYmxlX25hbWUYASABKAkSIgoGbGFzdHBrGAMgASgLMhIucXVlcnkuUXVlcnlSZXN1bHQipwEKFVZTdHJlYW1SZXN1bHRzUmVxdWVzdBIsChNlZmZlY3RpdmVfY2FsbGVyX2lkGAEgASgLMg8udnRycGMuQ2FsbGVySUQSMgoTaW1tZWRpYXRlX2NhbGxlcl9pZBgCIAEoCzIVLnF1ZXJ5LlZUR2F0ZUNhbGxlcklEEh0KBnRhcmdldBgDIAEoCzINLnF1ZXJ5LlRhcmdldBINCgVxdWVyeRgEIAEoCSJeChZWU3RyZWFtUmVzdWx0c1Jlc3BvbnNlEhwKBmZpZWxkcxgBIAMoCzIMLnF1ZXJ5LkZpZWxkEgwKBGd0aWQYAyABKAkSGAoEcm93cxgEIAMoCzIKLnF1ZXJ5LlJvdyo+CgtPbkRETEFjdGlvbhIKCgZJR05PUkUQABIICgRTVE9QEAESCAoERVhFQxACEg8KC0VYRUNfSUdOT1JFEAMqewoYVlJlcGxpY2F0aW9uV29ya2Zsb3dUeXBlEg8KC01hdGVyaWFsaXplEAASDgoKTW92ZVRhYmxlcxABEhUKEUNyZWF0ZUxvb2t1cEluZGV4EAISCwoHTWlncmF0ZRADEgsKB1Jlc2hhcmQQBBINCglPbmxpbmVEREwQBSpEChtWUmVwbGljYXRpb25Xb3JrZmxvd1N1YlR5cGUSCAoETm9uZRAAEgsKB1BhcnRpYWwQARIOCgpBdG9taWNDb3B5EAIqcQoZVlJlcGxpY2F0aW9uV29ya2Zsb3dTdGF0ZRILCgdVbmtub3duEAASCAoESW5pdBABEgsKB1N0b3BwZWQQAhILCgdDb3B5aW5nEAMSCwoHUnVubmluZxAEEgkKBUVycm9yEAUSCwoHTGFnZ2luZxAGKo0CCgpWRXZlbnRUeXBlEgsKB1VOS05PV04QABIICgRHVElEEAESCQoFQkVHSU4QAhIKCgZDT01NSVQQAxIMCghST0xMQkFDSxAEEgcKA0RETBAFEgoKBklOU0VSVBAGEgsKB1JFUExBQ0UQBxIKCgZVUERBVEUQCBIKCgZERUxFVEUQCRIHCgNTRVQQChIJCgVPVEhFUhALEgcKA1JPVxAMEgkKBUZJRUxEEA0SDQoJSEVBUlRCRUFUEA4SCQoFVkdUSUQQDxILCgdKT1VSTkFMEBASCwoHVkVSU0lPThAREgoKBkxBU1RQSxASEg0KCVNBVkVQT0lOVBATEhIKDkNPUFlfQ09NUExFVEVEEBQqJwoNTWlncmF0aW9uVHlwZRIKCgZUQUJMRVMQABIKCgZTSEFSRFMQAUIpWid2aXRlc3MuaW8vdml0ZXNzL2dvL3Z0L3Byb3RvL2JpbmxvZ2RhdGFiBnByb3RvMw", [file_query, file_topodata, file_vtrpc]);

/**
 * Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
 *
 * @generated from message binlogdata.Charset
 */
export type Charset = Message<"binlogdata.Charset"> & {
  /**
   * @@session.character_set_client
   *
   * @generated from field: int32 client = 1;
   */
  client: number;

  /**
   * @@session.collation_connection
   *
   * @generated from field: int32 conn = 2;
   */
  conn: number;

  /**
   * @@session.collation_server
   *
   * @generated from field: int32 server = 3;
   */
  server: number;
};

/**
 * Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
 *
 * @generated from message binlogdata.Charset
 */
export type CharsetJson = {
  /**
   * @@session.character_set_client
   *
   * @generated from field: int32 client = 1;
   */
  client?: number;

  /**
   * @@session.collation_connection
   *
   * @generated from field: int32 conn = 2;
   */
  conn?: number;

  /**
   * @@session.collation_server
   *
   * @generated from field: int32 server = 3;
   */
  server?: number;
};

/**
 * Describes the message binlogdata.Charset.
 * Use `create(CharsetSchema)` to create a new message.
 */
export const CharsetSchema: GenMessage<Charset, CharsetJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 0);

/**
 * BinlogTransaction describes a transaction inside the binlogs.
 * It is streamed by vttablet for filtered replication, used during resharding.
 *
 * @generated from message binlogdata.BinlogTransaction
 */
export type BinlogTransaction = Message<"binlogdata.BinlogTransaction"> & {
  /**
   * the statements in this transaction
   *
   * @generated from field: repeated binlogdata.BinlogTransaction.Statement statements = 1;
   */
  statements: BinlogTransaction_Statement[];

  /**
   * The Event Token for this event.
   *
   * @generated from field: query.EventToken event_token = 4;
   */
  eventToken?: EventToken;
};

/**
 * BinlogTransaction describes a transaction inside the binlogs.
 * It is streamed by vttablet for filtered replication, used during resharding.
 *
 * @generated from message binlogdata.BinlogTransaction
 */
export type BinlogTransactionJson = {
  /**
   * the statements in this transaction
   *
   * @generated from field: repeated binlogdata.BinlogTransaction.Statement statements = 1;
   */
  statements?: BinlogTransaction_StatementJson[];

  /**
   * The Event Token for this event.
   *
   * @generated from field: query.EventToken event_token = 4;
   */
  eventToken?: EventTokenJson;
};

/**
 * Describes the message binlogdata.BinlogTransaction.
 * Use `create(BinlogTransactionSchema)` to create a new message.
 */
export const BinlogTransactionSchema: GenMessage<BinlogTransaction, BinlogTransactionJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 1);

/**
 * @generated from message binlogdata.BinlogTransaction.Statement
 */
export type BinlogTransaction_Statement = Message<"binlogdata.BinlogTransaction.Statement"> & {
  /**
   * what type of statement is this?
   *
   * @generated from field: binlogdata.BinlogTransaction.Statement.Category category = 1;
   */
  category: BinlogTransaction_Statement_Category;

  /**
   * charset of this statement, if different from pre-negotiated default.
   *
   * @generated from field: binlogdata.Charset charset = 2;
   */
  charset?: Charset;

  /**
   * the sql
   *
   * @generated from field: bytes sql = 3;
   */
  sql: Uint8Array;
};

/**
 * @generated from message binlogdata.BinlogTransaction.Statement
 */
export type BinlogTransaction_StatementJson = {
  /**
   * what type of statement is this?
   *
   * @generated from field: binlogdata.BinlogTransaction.Statement.Category category = 1;
   */
  category?: BinlogTransaction_Statement_CategoryJson;

  /**
   * charset of this statement, if different from pre-negotiated default.
   *
   * @generated from field: binlogdata.Charset charset = 2;
   */
  charset?: CharsetJson;

  /**
   * the sql
   *
   * @generated from field: bytes sql = 3;
   */
  sql?: string;
};

/**
 * Describes the message binlogdata.BinlogTransaction.Statement.
 * Use `create(BinlogTransaction_StatementSchema)` to create a new message.
 */
export const BinlogTransaction_StatementSchema: GenMessage<BinlogTransaction_Statement, BinlogTransaction_StatementJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 1, 0);

/**
 * @generated from enum binlogdata.BinlogTransaction.Statement.Category
 */
export enum BinlogTransaction_Statement_Category {
  /**
   * @generated from enum value: BL_UNRECOGNIZED = 0;
   */
  BL_UNRECOGNIZED = 0,

  /**
   * @generated from enum value: BL_BEGIN = 1;
   */
  BL_BEGIN = 1,

  /**
   * @generated from enum value: BL_COMMIT = 2;
   */
  BL_COMMIT = 2,

  /**
   * @generated from enum value: BL_ROLLBACK = 3;
   */
  BL_ROLLBACK = 3,

  /**
   * BL_DML is deprecated.
   *
   * @generated from enum value: BL_DML_DEPRECATED = 4;
   */
  BL_DML_DEPRECATED = 4,

  /**
   * @generated from enum value: BL_DDL = 5;
   */
  BL_DDL = 5,

  /**
   * @generated from enum value: BL_SET = 6;
   */
  BL_SET = 6,

  /**
   * @generated from enum value: BL_INSERT = 7;
   */
  BL_INSERT = 7,

  /**
   * @generated from enum value: BL_UPDATE = 8;
   */
  BL_UPDATE = 8,

  /**
   * @generated from enum value: BL_DELETE = 9;
   */
  BL_DELETE = 9,
}

/**
 * @generated from enum binlogdata.BinlogTransaction.Statement.Category
 */
export type BinlogTransaction_Statement_CategoryJson = "BL_UNRECOGNIZED" | "BL_BEGIN" | "BL_COMMIT" | "BL_ROLLBACK" | "BL_DML_DEPRECATED" | "BL_DDL" | "BL_SET" | "BL_INSERT" | "BL_UPDATE" | "BL_DELETE";

/**
 * Describes the enum binlogdata.BinlogTransaction.Statement.Category.
 */
export const BinlogTransaction_Statement_CategorySchema: GenEnum<BinlogTransaction_Statement_Category, BinlogTransaction_Statement_CategoryJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 1, 0, 0);

/**
 * StreamKeyRangeRequest is the payload to StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeRequest
 */
export type StreamKeyRangeRequest = Message<"binlogdata.StreamKeyRangeRequest"> & {
  /**
   * where to start
   *
   * @generated from field: string position = 1;
   */
  position: string;

  /**
   * what to get
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRange;

  /**
   * default charset on the player side
   *
   * @generated from field: binlogdata.Charset charset = 3;
   */
  charset?: Charset;
};

/**
 * StreamKeyRangeRequest is the payload to StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeRequest
 */
export type StreamKeyRangeRequestJson = {
  /**
   * where to start
   *
   * @generated from field: string position = 1;
   */
  position?: string;

  /**
   * what to get
   *
   * @generated from field: topodata.KeyRange key_range = 2;
   */
  keyRange?: KeyRangeJson;

  /**
   * default charset on the player side
   *
   * @generated from field: binlogdata.Charset charset = 3;
   */
  charset?: CharsetJson;
};

/**
 * Describes the message binlogdata.StreamKeyRangeRequest.
 * Use `create(StreamKeyRangeRequestSchema)` to create a new message.
 */
export const StreamKeyRangeRequestSchema: GenMessage<StreamKeyRangeRequest, StreamKeyRangeRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 2);

/**
 * StreamKeyRangeResponse is the response from StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeResponse
 */
export type StreamKeyRangeResponse = Message<"binlogdata.StreamKeyRangeResponse"> & {
  /**
   * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
   */
  binlogTransaction?: BinlogTransaction;
};

/**
 * StreamKeyRangeResponse is the response from StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeResponse
 */
export type StreamKeyRangeResponseJson = {
  /**
   * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
   */
  binlogTransaction?: BinlogTransactionJson;
};

/**
 * Describes the message binlogdata.StreamKeyRangeResponse.
 * Use `create(StreamKeyRangeResponseSchema)` to create a new message.
 */
export const StreamKeyRangeResponseSchema: GenMessage<StreamKeyRangeResponse, StreamKeyRangeResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 3);

/**
 * StreamTablesRequest is the payload to StreamTables
 *
 * @generated from message binlogdata.StreamTablesRequest
 */
export type StreamTablesRequest = Message<"binlogdata.StreamTablesRequest"> & {
  /**
   * where to start
   *
   * @generated from field: string position = 1;
   */
  position: string;

  /**
   * what to get
   *
   * @generated from field: repeated string tables = 2;
   */
  tables: string[];

  /**
   * default charset on the player side
   *
   * @generated from field: binlogdata.Charset charset = 3;
   */
  charset?: Charset;
};

/**
 * StreamTablesRequest is the payload to StreamTables
 *
 * @generated from message binlogdata.StreamTablesRequest
 */
export type StreamTablesRequestJson = {
  /**
   * where to start
   *
   * @generated from field: string position = 1;
   */
  position?: string;

  /**
   * what to get
   *
   * @generated from field: repeated string tables = 2;
   */
  tables?: string[];

  /**
   * default charset on the player side
   *
   * @generated from field: binlogdata.Charset charset = 3;
   */
  charset?: CharsetJson;
};

/**
 * Describes the message binlogdata.StreamTablesRequest.
 * Use `create(StreamTablesRequestSchema)` to create a new message.
 */
export const StreamTablesRequestSchema: GenMessage<StreamTablesRequest, StreamTablesRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 4);

/**
 * StreamTablesResponse is the response from StreamTables
 *
 * @generated from message binlogdata.StreamTablesResponse
 */
export type StreamTablesResponse = Message<"binlogdata.StreamTablesResponse"> & {
  /**
   * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
   */
  binlogTransaction?: BinlogTransaction;
};

/**
 * StreamTablesResponse is the response from StreamTables
 *
 * @generated from message binlogdata.StreamTablesResponse
 */
export type StreamTablesResponseJson = {
  /**
   * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
   */
  binlogTransaction?: BinlogTransactionJson;
};

/**
 * Describes the message binlogdata.StreamTablesResponse.
 * Use `create(StreamTablesResponseSchema)` to create a new message.
 */
export const StreamTablesResponseSchema: GenMessage<StreamTablesResponse, StreamTablesResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 5);

/**
 * CharsetConversion represent a conversion of text from one charset to another
 *
 * @generated from message binlogdata.CharsetConversion
 */
export type CharsetConversion = Message<"binlogdata.CharsetConversion"> & {
  /**
   * FromCharset is the charset name from which we convert the text (e.g. latin1)
   *
   * @generated from field: string from_charset = 1;
   */
  fromCharset: string;

  /**
   * ToCharset is the charset name to which we convert the text (e.g. utf8mb4)
   *
   * @generated from field: string to_charset = 2;
   */
  toCharset: string;
};

/**
 * CharsetConversion represent a conversion of text from one charset to another
 *
 * @generated from message binlogdata.CharsetConversion
 */
export type CharsetConversionJson = {
  /**
   * FromCharset is the charset name from which we convert the text (e.g. latin1)
   *
   * @generated from field: string from_charset = 1;
   */
  fromCharset?: string;

  /**
   * ToCharset is the charset name to which we convert the text (e.g. utf8mb4)
   *
   * @generated from field: string to_charset = 2;
   */
  toCharset?: string;
};

/**
 * Describes the message binlogdata.CharsetConversion.
 * Use `create(CharsetConversionSchema)` to create a new message.
 */
export const CharsetConversionSchema: GenMessage<CharsetConversion, CharsetConversionJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 6);

/**
 * Rule represents one rule in a Filter.
 *
 * @generated from message binlogdata.Rule
 */
export type Rule = Message<"binlogdata.Rule"> & {
  /**
   * Match can be a table name or a regular expression.
   * If it starts with a '/', it's a regular expression.
   * For example, "t" matches a table named "t", whereas
   * "/t.*" matches all tables that begin with 't'.
   *
   * @generated from field: string match = 1;
   */
  match: string;

  /**
   * Filter: If empty, all columns and rows of the matching tables
   * are sent. If it's a keyrange like "-80", only rows that
   * match the keyrange are sent.
   * If Match is a table name instead of a regular expression,
   * the Filter can also be a select expression like this:
   * "select * from t", same as an empty Filter, or
   * "select * from t where in_keyrange('-80')", same as "-80", or
   * "select col1, col2 from t where in_keyrange(col1, 'hash', '-80'), or
   * What is allowed in a select expression depends on whether
   * it's a vstreamer or vreplication request. For more details,
   * please refer to the specific package documentation.
   * On the vreplication side, Filter can also accept a special
   * "exclude" value, which will cause the matched tables
   * to be excluded.
   * TODO(sougou): support this on vstreamer side also.
   *
   * ConvertEnumToText: optional, list per enum column name, the list of textual values.
   * When reading the binary log, all enum values are numeric. But sometimes it
   * is useful/needed to know what the textual mapping are.
   * Online DDL provides such use case.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Example: key="color", value="'red','green','blue'"
   *
   * @generated from field: map<string, string> convert_enum_to_text = 3;
   */
  convertEnumToText: { [key: string]: string };

  /**
   * ConvertCharset: optional mapping, between column name and a CharsetConversion.
   * This hints to vreplication that columns are encoded from/to non-trivial charsets
   * The map is only populated when either "from" or "to" charset of a column are non-trivial
   * trivial charsets are utf8 and ascii variants.
   *
   * @generated from field: map<string, binlogdata.CharsetConversion> convert_charset = 4;
   */
  convertCharset: { [key: string]: CharsetConversion };

  /**
   * SourceUniqueKeyColumns represents the ordered columns in the index used by rowstreamer to iterate the table
   * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
   *
   * @generated from field: string source_unique_key_columns = 5;
   */
  sourceUniqueKeyColumns: string;

  /**
   * TargetUniqueKeyColumns represents the ordered columns in that index used by vcopier and vplayer to apply rows
   * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
   *
   * @generated from field: string target_unique_key_columns = 6;
   */
  targetUniqueKeyColumns: string;

  /**
   * SourceUniqueKeyTargetColumns represents the names of columns in target table, mapped from the chosen unique
   * key on source tables (some columns may be renamed from source to target)
   *
   * @generated from field: string source_unique_key_target_columns = 7;
   */
  sourceUniqueKeyTargetColumns: string;

  /**
   * ConvertIntToEnum lists any columns that are converted from an integral value into an enum.
   * such columns need to have special transofrmation of the data, from an integral format into a
   * string format. e.g. the value 0 needs to be converted to '0'.
   *
   * @generated from field: map<string, bool> convert_int_to_enum = 8;
   */
  convertIntToEnum: { [key: string]: boolean };

  /**
   * ForceUniqueKey gives vtreamer a hint for `FORCE INDEX (...)` usage.
   *
   * @generated from field: string force_unique_key = 9;
   */
  forceUniqueKey: string;
};

/**
 * Rule represents one rule in a Filter.
 *
 * @generated from message binlogdata.Rule
 */
export type RuleJson = {
  /**
   * Match can be a table name or a regular expression.
   * If it starts with a '/', it's a regular expression.
   * For example, "t" matches a table named "t", whereas
   * "/t.*" matches all tables that begin with 't'.
   *
   * @generated from field: string match = 1;
   */
  match?: string;

  /**
   * Filter: If empty, all columns and rows of the matching tables
   * are sent. If it's a keyrange like "-80", only rows that
   * match the keyrange are sent.
   * If Match is a table name instead of a regular expression,
   * the Filter can also be a select expression like this:
   * "select * from t", same as an empty Filter, or
   * "select * from t where in_keyrange('-80')", same as "-80", or
   * "select col1, col2 from t where in_keyrange(col1, 'hash', '-80'), or
   * What is allowed in a select expression depends on whether
   * it's a vstreamer or vreplication request. For more details,
   * please refer to the specific package documentation.
   * On the vreplication side, Filter can also accept a special
   * "exclude" value, which will cause the matched tables
   * to be excluded.
   * TODO(sougou): support this on vstreamer side also.
   *
   * ConvertEnumToText: optional, list per enum column name, the list of textual values.
   * When reading the binary log, all enum values are numeric. But sometimes it
   * is useful/needed to know what the textual mapping are.
   * Online DDL provides such use case.
   *
   * @generated from field: string filter = 2;
   */
  filter?: string;

  /**
   * Example: key="color", value="'red','green','blue'"
   *
   * @generated from field: map<string, string> convert_enum_to_text = 3;
   */
  convertEnumToText?: { [key: string]: string };

  /**
   * ConvertCharset: optional mapping, between column name and a CharsetConversion.
   * This hints to vreplication that columns are encoded from/to non-trivial charsets
   * The map is only populated when either "from" or "to" charset of a column are non-trivial
   * trivial charsets are utf8 and ascii variants.
   *
   * @generated from field: map<string, binlogdata.CharsetConversion> convert_charset = 4;
   */
  convertCharset?: { [key: string]: CharsetConversionJson };

  /**
   * SourceUniqueKeyColumns represents the ordered columns in the index used by rowstreamer to iterate the table
   * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
   *
   * @generated from field: string source_unique_key_columns = 5;
   */
  sourceUniqueKeyColumns?: string;

  /**
   * TargetUniqueKeyColumns represents the ordered columns in that index used by vcopier and vplayer to apply rows
   * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
   *
   * @generated from field: string target_unique_key_columns = 6;
   */
  targetUniqueKeyColumns?: string;

  /**
   * SourceUniqueKeyTargetColumns represents the names of columns in target table, mapped from the chosen unique
   * key on source tables (some columns may be renamed from source to target)
   *
   * @generated from field: string source_unique_key_target_columns = 7;
   */
  sourceUniqueKeyTargetColumns?: string;

  /**
   * ConvertIntToEnum lists any columns that are converted from an integral value into an enum.
   * such columns need to have special transofrmation of the data, from an integral format into a
   * string format. e.g. the value 0 needs to be converted to '0'.
   *
   * @generated from field: map<string, bool> convert_int_to_enum = 8;
   */
  convertIntToEnum?: { [key: string]: boolean };

  /**
   * ForceUniqueKey gives vtreamer a hint for `FORCE INDEX (...)` usage.
   *
   * @generated from field: string force_unique_key = 9;
   */
  forceUniqueKey?: string;
};

/**
 * Describes the message binlogdata.Rule.
 * Use `create(RuleSchema)` to create a new message.
 */
export const RuleSchema: GenMessage<Rule, RuleJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 7);

/**
 * Filter represents a list of ordered rules. The first
 * match wins.
 *
 * @generated from message binlogdata.Filter
 */
export type Filter = Message<"binlogdata.Filter"> & {
  /**
   * @generated from field: repeated binlogdata.Rule rules = 1;
   */
  rules: Rule[];

  /**
   * FieldEventMode specifies the behavior if there is a mismatch
   * between the current schema and the fields in the binlog. This
   * can happen if the binlog position is before a DDL that would
   * cause the fields to change. If vstreamer detects such
   * an inconsistency, the behavior depends on the FieldEventMode.
   * If the value is ERR_ON_MISMATCH (default), then it errors out.
   * If it's BEST_EFFORT, it sends a field event with fake column
   * names as "@1", "@2", etc.
   *
   * @generated from field: binlogdata.Filter.FieldEventMode field_event_mode = 2;
   */
  fieldEventMode: Filter_FieldEventMode;

  /**
   * @generated from field: int64 workflow_type = 3;
   */
  workflowType: bigint;

  /**
   * @generated from field: string workflow_name = 4;
   */
  workflowName: string;
};

/**
 * Filter represents a list of ordered rules. The first
 * match wins.
 *
 * @generated from message binlogdata.Filter
 */
export type FilterJson = {
  /**
   * @generated from field: repeated binlogdata.Rule rules = 1;
   */
  rules?: RuleJson[];

  /**
   * FieldEventMode specifies the behavior if there is a mismatch
   * between the current schema and the fields in the binlog. This
   * can happen if the binlog position is before a DDL that would
   * cause the fields to change. If vstreamer detects such
   * an inconsistency, the behavior depends on the FieldEventMode.
   * If the value is ERR_ON_MISMATCH (default), then it errors out.
   * If it's BEST_EFFORT, it sends a field event with fake column
   * names as "@1", "@2", etc.
   *
   * @generated from field: binlogdata.Filter.FieldEventMode field_event_mode = 2;
   */
  fieldEventMode?: Filter_FieldEventModeJson;

  /**
   * @generated from field: int64 workflow_type = 3;
   */
  workflowType?: string;

  /**
   * @generated from field: string workflow_name = 4;
   */
  workflowName?: string;
};

/**
 * Describes the message binlogdata.Filter.
 * Use `create(FilterSchema)` to create a new message.
 */
export const FilterSchema: GenMessage<Filter, FilterJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 8);

/**
 * @generated from enum binlogdata.Filter.FieldEventMode
 */
export enum Filter_FieldEventMode {
  /**
   * @generated from enum value: ERR_ON_MISMATCH = 0;
   */
  ERR_ON_MISMATCH = 0,

  /**
   * @generated from enum value: BEST_EFFORT = 1;
   */
  BEST_EFFORT = 1,
}

/**
 * @generated from enum binlogdata.Filter.FieldEventMode
 */
export type Filter_FieldEventModeJson = "ERR_ON_MISMATCH" | "BEST_EFFORT";

/**
 * Describes the enum binlogdata.Filter.FieldEventMode.
 */
export const Filter_FieldEventModeSchema: GenEnum<Filter_FieldEventMode, Filter_FieldEventModeJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 8, 0);

/**
 * BinlogSource specifies the source  and filter parameters for
 * Filtered Replication. KeyRange and Tables are legacy. Filter
 * is the new way to specify the filtering rules.
 *
 * @generated from message binlogdata.BinlogSource
 */
export type BinlogSource = Message<"binlogdata.BinlogSource"> & {
  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * the source tablet type
   *
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType: TabletType;

  /**
   * KeyRange is set if the request is for a keyrange
   *
   * @generated from field: topodata.KeyRange key_range = 4;
   */
  keyRange?: KeyRange;

  /**
   * Tables is set if the request is for a list of tables
   *
   * @generated from field: repeated string tables = 5;
   */
  tables: string[];

  /**
   * Filter is set if we're using the generalized representation
   * for the filter.
   *
   * @generated from field: binlogdata.Filter filter = 6;
   */
  filter?: Filter;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: binlogdata.OnDDLAction on_ddl = 7;
   */
  onDdl: OnDDLAction;

  /**
   * Source is an external mysql. This attribute should be set to the username
   * to use in the connection
   *
   * @generated from field: string external_mysql = 8;
   */
  externalMysql: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped
   * after copying is done.
   *
   * @generated from field: bool stop_after_copy = 9;
   */
  stopAfterCopy: boolean;

  /**
   * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
   * it is of the type <cluster_type.cluster_name>
   *
   * @generated from field: string external_cluster = 10;
   */
  externalCluster: string;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 11;
   */
  sourceTimeZone: string;

  /**
   * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
   * and to the SourceTimeZone in reverse workflows
   *
   * @generated from field: string target_time_zone = 12;
   */
  targetTimeZone: string;
};

/**
 * BinlogSource specifies the source  and filter parameters for
 * Filtered Replication. KeyRange and Tables are legacy. Filter
 * is the new way to specify the filtering rules.
 *
 * @generated from message binlogdata.BinlogSource
 */
export type BinlogSourceJson = {
  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * the source tablet type
   *
   * @generated from field: topodata.TabletType tablet_type = 3;
   */
  tabletType?: TabletTypeJson;

  /**
   * KeyRange is set if the request is for a keyrange
   *
   * @generated from field: topodata.KeyRange key_range = 4;
   */
  keyRange?: KeyRangeJson;

  /**
   * Tables is set if the request is for a list of tables
   *
   * @generated from field: repeated string tables = 5;
   */
  tables?: string[];

  /**
   * Filter is set if we're using the generalized representation
   * for the filter.
   *
   * @generated from field: binlogdata.Filter filter = 6;
   */
  filter?: FilterJson;

  /**
   * OnDdl specifies the action to be taken when a DDL is encountered.
   *
   * @generated from field: binlogdata.OnDDLAction on_ddl = 7;
   */
  onDdl?: OnDDLActionJson;

  /**
   * Source is an external mysql. This attribute should be set to the username
   * to use in the connection
   *
   * @generated from field: string external_mysql = 8;
   */
  externalMysql?: string;

  /**
   * StopAfterCopy specifies if vreplication should be stopped
   * after copying is done.
   *
   * @generated from field: bool stop_after_copy = 9;
   */
  stopAfterCopy?: boolean;

  /**
   * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
   * it is of the type <cluster_type.cluster_name>
   *
   * @generated from field: string external_cluster = 10;
   */
  externalCluster?: string;

  /**
   * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
   *
   * @generated from field: string source_time_zone = 11;
   */
  sourceTimeZone?: string;

  /**
   * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
   * and to the SourceTimeZone in reverse workflows
   *
   * @generated from field: string target_time_zone = 12;
   */
  targetTimeZone?: string;
};

/**
 * Describes the message binlogdata.BinlogSource.
 * Use `create(BinlogSourceSchema)` to create a new message.
 */
export const BinlogSourceSchema: GenMessage<BinlogSource, BinlogSourceJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 9);

/**
 * RowChange represents one row change.
 * If Before is set and not After, it's a delete.
 * If After is set and not Before, it's an insert.
 * If both are set, it's an update.
 *
 * @generated from message binlogdata.RowChange
 */
export type RowChange = Message<"binlogdata.RowChange"> & {
  /**
   * @generated from field: query.Row before = 1;
   */
  before?: Row;

  /**
   * @generated from field: query.Row after = 2;
   */
  after?: Row;

  /**
   * DataColumns is a bitmap of all columns: bit is set if column is present in the after image
   *
   * @generated from field: binlogdata.RowChange.Bitmap data_columns = 3;
   */
  dataColumns?: RowChange_Bitmap;
};

/**
 * RowChange represents one row change.
 * If Before is set and not After, it's a delete.
 * If After is set and not Before, it's an insert.
 * If both are set, it's an update.
 *
 * @generated from message binlogdata.RowChange
 */
export type RowChangeJson = {
  /**
   * @generated from field: query.Row before = 1;
   */
  before?: RowJson;

  /**
   * @generated from field: query.Row after = 2;
   */
  after?: RowJson;

  /**
   * DataColumns is a bitmap of all columns: bit is set if column is present in the after image
   *
   * @generated from field: binlogdata.RowChange.Bitmap data_columns = 3;
   */
  dataColumns?: RowChange_BitmapJson;
};

/**
 * Describes the message binlogdata.RowChange.
 * Use `create(RowChangeSchema)` to create a new message.
 */
export const RowChangeSchema: GenMessage<RowChange, RowChangeJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 10);

/**
 * @generated from message binlogdata.RowChange.Bitmap
 */
export type RowChange_Bitmap = Message<"binlogdata.RowChange.Bitmap"> & {
  /**
   * @generated from field: int64 count = 1;
   */
  count: bigint;

  /**
   * @generated from field: bytes cols = 2;
   */
  cols: Uint8Array;
};

/**
 * @generated from message binlogdata.RowChange.Bitmap
 */
export type RowChange_BitmapJson = {
  /**
   * @generated from field: int64 count = 1;
   */
  count?: string;

  /**
   * @generated from field: bytes cols = 2;
   */
  cols?: string;
};

/**
 * Describes the message binlogdata.RowChange.Bitmap.
 * Use `create(RowChange_BitmapSchema)` to create a new message.
 */
export const RowChange_BitmapSchema: GenMessage<RowChange_Bitmap, RowChange_BitmapJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 10, 0);

/**
 * RowEvent represent row events for one table.
 *
 * @generated from message binlogdata.RowEvent
 */
export type RowEvent = Message<"binlogdata.RowEvent"> & {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * @generated from field: repeated binlogdata.RowChange row_changes = 2;
   */
  rowChanges: RowChange[];

  /**
   * @generated from field: string keyspace = 3;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 4;
   */
  shard: string;

  /**
   * https://dev.mysql.com/doc/dev/mysql-server/latest/classbinary__log_1_1Rows__event.html
   *
   * @generated from field: uint32 flags = 5;
   */
  flags: number;

  /**
   * set for sidecardb tables
   *
   * @generated from field: bool is_internal_table = 6;
   */
  isInternalTable: boolean;
};

/**
 * RowEvent represent row events for one table.
 *
 * @generated from message binlogdata.RowEvent
 */
export type RowEventJson = {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName?: string;

  /**
   * @generated from field: repeated binlogdata.RowChange row_changes = 2;
   */
  rowChanges?: RowChangeJson[];

  /**
   * @generated from field: string keyspace = 3;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 4;
   */
  shard?: string;

  /**
   * https://dev.mysql.com/doc/dev/mysql-server/latest/classbinary__log_1_1Rows__event.html
   *
   * @generated from field: uint32 flags = 5;
   */
  flags?: number;

  /**
   * set for sidecardb tables
   *
   * @generated from field: bool is_internal_table = 6;
   */
  isInternalTable?: boolean;
};

/**
 * Describes the message binlogdata.RowEvent.
 * Use `create(RowEventSchema)` to create a new message.
 */
export const RowEventSchema: GenMessage<RowEvent, RowEventJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 11);

/**
 * FieldEvent represents the field info for a table.
 *
 * @generated from message binlogdata.FieldEvent
 */
export type FieldEvent = Message<"binlogdata.FieldEvent"> & {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields: Field[];

  /**
   * @generated from field: string keyspace = 3;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 4;
   */
  shard: string;

  /**
   * Are ENUM and SET field values already mapped to strings in the ROW
   * events? This allows us to transition VTGate VStream consumers from
   * the pre v20 behavior of having to do this mapping themselves to the
   * v20+ behavior of not having to do this anymore and to expect string
   * values directly.
   * NOTE: because this is the use case, this is ONLY ever set today in
   * vstreams managed by the vstreamManager.
   *
   * @generated from field: bool enum_set_string_values = 25;
   */
  enumSetStringValues: boolean;

  /**
   * set for sidecardb tables
   *
   * @generated from field: bool is_internal_table = 26;
   */
  isInternalTable: boolean;
};

/**
 * FieldEvent represents the field info for a table.
 *
 * @generated from message binlogdata.FieldEvent
 */
export type FieldEventJson = {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName?: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: string keyspace = 3;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 4;
   */
  shard?: string;

  /**
   * Are ENUM and SET field values already mapped to strings in the ROW
   * events? This allows us to transition VTGate VStream consumers from
   * the pre v20 behavior of having to do this mapping themselves to the
   * v20+ behavior of not having to do this anymore and to expect string
   * values directly.
   * NOTE: because this is the use case, this is ONLY ever set today in
   * vstreams managed by the vstreamManager.
   *
   * @generated from field: bool enum_set_string_values = 25;
   */
  enumSetStringValues?: boolean;

  /**
   * set for sidecardb tables
   *
   * @generated from field: bool is_internal_table = 26;
   */
  isInternalTable?: boolean;
};

/**
 * Describes the message binlogdata.FieldEvent.
 * Use `create(FieldEventSchema)` to create a new message.
 */
export const FieldEventSchema: GenMessage<FieldEvent, FieldEventJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 12);

/**
 * ShardGtid contains the GTID position for one shard.
 * It's used in a request for requesting a starting position.
 * It's used in a response to transmit the current position
 * of a shard. It's also used in a Journal to indicate the
 * list of targets and shard positions to migrate to.
 *
 * @generated from message binlogdata.ShardGtid
 */
export type ShardGtid = Message<"binlogdata.ShardGtid"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;

  /**
   * @generated from field: string gtid = 3;
   */
  gtid: string;

  /**
   * @generated from field: repeated binlogdata.TableLastPK table_p_ks = 4;
   */
  tablePKs: TableLastPK[];
};

/**
 * ShardGtid contains the GTID position for one shard.
 * It's used in a request for requesting a starting position.
 * It's used in a response to transmit the current position
 * of a shard. It's also used in a Journal to indicate the
 * list of targets and shard positions to migrate to.
 *
 * @generated from message binlogdata.ShardGtid
 */
export type ShardGtidJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;

  /**
   * @generated from field: string gtid = 3;
   */
  gtid?: string;

  /**
   * @generated from field: repeated binlogdata.TableLastPK table_p_ks = 4;
   */
  tablePKs?: TableLastPKJson[];
};

/**
 * Describes the message binlogdata.ShardGtid.
 * Use `create(ShardGtidSchema)` to create a new message.
 */
export const ShardGtidSchema: GenMessage<ShardGtid, ShardGtidJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 13);

/**
 * A VGtid is a list of ShardGtids.
 *
 * @generated from message binlogdata.VGtid
 */
export type VGtid = Message<"binlogdata.VGtid"> & {
  /**
   * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 1;
   */
  shardGtids: ShardGtid[];
};

/**
 * A VGtid is a list of ShardGtids.
 *
 * @generated from message binlogdata.VGtid
 */
export type VGtidJson = {
  /**
   * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 1;
   */
  shardGtids?: ShardGtidJson[];
};

/**
 * Describes the message binlogdata.VGtid.
 * Use `create(VGtidSchema)` to create a new message.
 */
export const VGtidSchema: GenMessage<VGtid, VGtidJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 14);

/**
 * KeyspaceShard represents a keyspace and shard.
 *
 * @generated from message binlogdata.KeyspaceShard
 */
export type KeyspaceShard = Message<"binlogdata.KeyspaceShard"> & {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard: string;
};

/**
 * KeyspaceShard represents a keyspace and shard.
 *
 * @generated from message binlogdata.KeyspaceShard
 */
export type KeyspaceShardJson = {
  /**
   * @generated from field: string keyspace = 1;
   */
  keyspace?: string;

  /**
   * @generated from field: string shard = 2;
   */
  shard?: string;
};

/**
 * Describes the message binlogdata.KeyspaceShard.
 * Use `create(KeyspaceShardSchema)` to create a new message.
 */
export const KeyspaceShardSchema: GenMessage<KeyspaceShard, KeyspaceShardJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 15);

/**
 * Journal contains the metadata for a journal event.
 * The commit of a journal event indicates the point of no return
 * for a migration.
 *
 * @generated from message binlogdata.Journal
 */
export type Journal = Message<"binlogdata.Journal"> & {
  /**
   * Id represents a unique journal id.
   *
   * @generated from field: int64 id = 1;
   */
  id: bigint;

  /**
   * @generated from field: binlogdata.MigrationType migration_type = 2;
   */
  migrationType: MigrationType;

  /**
   * Tables is set if the journal represents a TABLES migration.
   *
   * @generated from field: repeated string tables = 3;
   */
  tables: string[];

  /**
   * LocalPosition is the source position at which the migration happened.
   *
   * @generated from field: string local_position = 4;
   */
  localPosition: string;

  /**
   * ShardGtids is the list of targets to which the migration took place.
   *
   * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 5;
   */
  shardGtids: ShardGtid[];

  /**
   * Participants is the list of source participants for a migration.
   * Every participant is expected to have an identical journal entry.
   * While streaming, the client must wait for the journal entry to
   * be received from all pariticipants, and then replace them with new
   * streams specified by ShardGtid.
   * If a stream does not have all participants, a consistent migration
   * is not possible.
   *
   * @generated from field: repeated binlogdata.KeyspaceShard participants = 6;
   */
  participants: KeyspaceShard[];

  /**
   * SourceWorkflows is the list of workflows in the source shard that
   * were migrated to the target. If a migration fails after a Journal
   * is committed, this information is used to start the target streams
   * that were created prior to the creation of the journal.
   *
   * @generated from field: repeated string source_workflows = 7;
   */
  sourceWorkflows: string[];
};

/**
 * Journal contains the metadata for a journal event.
 * The commit of a journal event indicates the point of no return
 * for a migration.
 *
 * @generated from message binlogdata.Journal
 */
export type JournalJson = {
  /**
   * Id represents a unique journal id.
   *
   * @generated from field: int64 id = 1;
   */
  id?: string;

  /**
   * @generated from field: binlogdata.MigrationType migration_type = 2;
   */
  migrationType?: MigrationTypeJson;

  /**
   * Tables is set if the journal represents a TABLES migration.
   *
   * @generated from field: repeated string tables = 3;
   */
  tables?: string[];

  /**
   * LocalPosition is the source position at which the migration happened.
   *
   * @generated from field: string local_position = 4;
   */
  localPosition?: string;

  /**
   * ShardGtids is the list of targets to which the migration took place.
   *
   * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 5;
   */
  shardGtids?: ShardGtidJson[];

  /**
   * Participants is the list of source participants for a migration.
   * Every participant is expected to have an identical journal entry.
   * While streaming, the client must wait for the journal entry to
   * be received from all pariticipants, and then replace them with new
   * streams specified by ShardGtid.
   * If a stream does not have all participants, a consistent migration
   * is not possible.
   *
   * @generated from field: repeated binlogdata.KeyspaceShard participants = 6;
   */
  participants?: KeyspaceShardJson[];

  /**
   * SourceWorkflows is the list of workflows in the source shard that
   * were migrated to the target. If a migration fails after a Journal
   * is committed, this information is used to start the target streams
   * that were created prior to the creation of the journal.
   *
   * @generated from field: repeated string source_workflows = 7;
   */
  sourceWorkflows?: string[];
};

/**
 * Describes the message binlogdata.Journal.
 * Use `create(JournalSchema)` to create a new message.
 */
export const JournalSchema: GenMessage<Journal, JournalJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 16);

/**
 * VEvent represents a vstream event.
 * A FieldEvent is sent once for every table, just before
 * the first event for that table. The client is expected
 * to cache this information and match it against the RowEvent
 * which contains the table name.
 * A GTID event always precedes a commitable event, which can be
 * COMMIT, DDL or OTHER.
 * OTHER events are non-material events that have no additional metadata.
 *
 * @generated from message binlogdata.VEvent
 */
export type VEvent = Message<"binlogdata.VEvent"> & {
  /**
   * @generated from field: binlogdata.VEventType type = 1;
   */
  type: VEventType;

  /**
   * Timestamp is the binlog timestamp in seconds.
   * The value should be ignored if 0.
   *
   * @generated from field: int64 timestamp = 2;
   */
  timestamp: bigint;

  /**
   * Gtid is set if the event type is GTID.
   *
   * @generated from field: string gtid = 3;
   */
  gtid: string;

  /**
   * Statement is set if the event type is DDL, DML or SAVEPOINT.
   *
   * @generated from field: string statement = 4;
   */
  statement: string;

  /**
   * RowEvent is set if the event type is ROW.
   *
   * @generated from field: binlogdata.RowEvent row_event = 5;
   */
  rowEvent?: RowEvent;

  /**
   * FieldEvent is set if the event type is FIELD.
   *
   * @generated from field: binlogdata.FieldEvent field_event = 6;
   */
  fieldEvent?: FieldEvent;

  /**
   * Vgtid is set if the event type is VGTID.
   * This event is only generated by VTGate's VStream function.
   *
   * @generated from field: binlogdata.VGtid vgtid = 7;
   */
  vgtid?: VGtid;

  /**
   * Journal is set if the event type is JOURNAL.
   *
   * @generated from field: binlogdata.Journal journal = 8;
   */
  journal?: Journal;

  /**
   * Dml is set if the event type is INSERT, REPLACE, UPDATE or DELETE.
   *
   * @generated from field: string dml = 9;
   */
  dml: string;

  /**
   * CurrentTime specifies the current time when the message was sent.
   * This can be used to compenssate for clock skew.
   *
   * @generated from field: int64 current_time = 20;
   */
  currentTime: bigint;

  /**
   * LastPK is the last PK for a table
   *
   * @generated from field: binlogdata.LastPKEvent last_p_k_event = 21;
   */
  lastPKEvent?: LastPKEvent;

  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 22;
   */
  keyspace: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 23;
   */
  shard: string;

  /**
   * indicate that we are being throttled right now
   *
   * @generated from field: bool throttled = 24;
   */
  throttled: boolean;

  /**
   * ThrottledReason is a human readable string that explains why the stream is throttled
   *
   * @generated from field: string throttled_reason = 25;
   */
  throttledReason: string;
};

/**
 * VEvent represents a vstream event.
 * A FieldEvent is sent once for every table, just before
 * the first event for that table. The client is expected
 * to cache this information and match it against the RowEvent
 * which contains the table name.
 * A GTID event always precedes a commitable event, which can be
 * COMMIT, DDL or OTHER.
 * OTHER events are non-material events that have no additional metadata.
 *
 * @generated from message binlogdata.VEvent
 */
export type VEventJson = {
  /**
   * @generated from field: binlogdata.VEventType type = 1;
   */
  type?: VEventTypeJson;

  /**
   * Timestamp is the binlog timestamp in seconds.
   * The value should be ignored if 0.
   *
   * @generated from field: int64 timestamp = 2;
   */
  timestamp?: string;

  /**
   * Gtid is set if the event type is GTID.
   *
   * @generated from field: string gtid = 3;
   */
  gtid?: string;

  /**
   * Statement is set if the event type is DDL, DML or SAVEPOINT.
   *
   * @generated from field: string statement = 4;
   */
  statement?: string;

  /**
   * RowEvent is set if the event type is ROW.
   *
   * @generated from field: binlogdata.RowEvent row_event = 5;
   */
  rowEvent?: RowEventJson;

  /**
   * FieldEvent is set if the event type is FIELD.
   *
   * @generated from field: binlogdata.FieldEvent field_event = 6;
   */
  fieldEvent?: FieldEventJson;

  /**
   * Vgtid is set if the event type is VGTID.
   * This event is only generated by VTGate's VStream function.
   *
   * @generated from field: binlogdata.VGtid vgtid = 7;
   */
  vgtid?: VGtidJson;

  /**
   * Journal is set if the event type is JOURNAL.
   *
   * @generated from field: binlogdata.Journal journal = 8;
   */
  journal?: JournalJson;

  /**
   * Dml is set if the event type is INSERT, REPLACE, UPDATE or DELETE.
   *
   * @generated from field: string dml = 9;
   */
  dml?: string;

  /**
   * CurrentTime specifies the current time when the message was sent.
   * This can be used to compenssate for clock skew.
   *
   * @generated from field: int64 current_time = 20;
   */
  currentTime?: string;

  /**
   * LastPK is the last PK for a table
   *
   * @generated from field: binlogdata.LastPKEvent last_p_k_event = 21;
   */
  lastPKEvent?: LastPKEventJson;

  /**
   * the source keyspace
   *
   * @generated from field: string keyspace = 22;
   */
  keyspace?: string;

  /**
   * the source shard
   *
   * @generated from field: string shard = 23;
   */
  shard?: string;

  /**
   * indicate that we are being throttled right now
   *
   * @generated from field: bool throttled = 24;
   */
  throttled?: boolean;

  /**
   * ThrottledReason is a human readable string that explains why the stream is throttled
   *
   * @generated from field: string throttled_reason = 25;
   */
  throttledReason?: string;
};

/**
 * Describes the message binlogdata.VEvent.
 * Use `create(VEventSchema)` to create a new message.
 */
export const VEventSchema: GenMessage<VEvent, VEventJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 17);

/**
 * @generated from message binlogdata.MinimalTable
 */
export type MinimalTable = Message<"binlogdata.MinimalTable"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields: Field[];

  /**
   * @generated from field: repeated int64 p_k_columns = 3;
   */
  pKColumns: bigint[];

  /**
   * This will be PRIMARY when the actual primary key is used and it
   * will be the name of the Primary Key equivalent if one is used
   * instead. Otherwise it will be empty.
   *
   * @generated from field: string p_k_index_name = 4;
   */
  pKIndexName: string;
};

/**
 * @generated from message binlogdata.MinimalTable
 */
export type MinimalTableJson = {
  /**
   * @generated from field: string name = 1;
   */
  name?: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: repeated int64 p_k_columns = 3;
   */
  pKColumns?: string[];

  /**
   * This will be PRIMARY when the actual primary key is used and it
   * will be the name of the Primary Key equivalent if one is used
   * instead. Otherwise it will be empty.
   *
   * @generated from field: string p_k_index_name = 4;
   */
  pKIndexName?: string;
};

/**
 * Describes the message binlogdata.MinimalTable.
 * Use `create(MinimalTableSchema)` to create a new message.
 */
export const MinimalTableSchema: GenMessage<MinimalTable, MinimalTableJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 18);

/**
 * @generated from message binlogdata.MinimalSchema
 */
export type MinimalSchema = Message<"binlogdata.MinimalSchema"> & {
  /**
   * @generated from field: repeated binlogdata.MinimalTable tables = 1;
   */
  tables: MinimalTable[];
};

/**
 * @generated from message binlogdata.MinimalSchema
 */
export type MinimalSchemaJson = {
  /**
   * @generated from field: repeated binlogdata.MinimalTable tables = 1;
   */
  tables?: MinimalTableJson[];
};

/**
 * Describes the message binlogdata.MinimalSchema.
 * Use `create(MinimalSchemaSchema)` to create a new message.
 */
export const MinimalSchemaSchema: GenMessage<MinimalSchema, MinimalSchemaJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 19);

/**
 * @generated from message binlogdata.VStreamOptions
 */
export type VStreamOptions = Message<"binlogdata.VStreamOptions"> & {
  /**
   * @generated from field: repeated string internal_tables = 1;
   */
  internalTables: string[];

  /**
   * @generated from field: map<string, string> config_overrides = 2;
   */
  configOverrides: { [key: string]: string };
};

/**
 * @generated from message binlogdata.VStreamOptions
 */
export type VStreamOptionsJson = {
  /**
   * @generated from field: repeated string internal_tables = 1;
   */
  internalTables?: string[];

  /**
   * @generated from field: map<string, string> config_overrides = 2;
   */
  configOverrides?: { [key: string]: string };
};

/**
 * Describes the message binlogdata.VStreamOptions.
 * Use `create(VStreamOptionsSchema)` to create a new message.
 */
export const VStreamOptionsSchema: GenMessage<VStreamOptions, VStreamOptionsJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 20);

/**
 * VStreamRequest is the payload for VStreamer
 *
 * @generated from message binlogdata.VStreamRequest
 */
export type VStreamRequest = Message<"binlogdata.VStreamRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string position = 4;
   */
  position: string;

  /**
   * @generated from field: binlogdata.Filter filter = 5;
   */
  filter?: Filter;

  /**
   * @generated from field: repeated binlogdata.TableLastPK table_last_p_ks = 6;
   */
  tableLastPKs: TableLastPK[];

  /**
   * @generated from field: binlogdata.VStreamOptions options = 7;
   */
  options?: VStreamOptions;
};

/**
 * VStreamRequest is the payload for VStreamer
 *
 * @generated from message binlogdata.VStreamRequest
 */
export type VStreamRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string position = 4;
   */
  position?: string;

  /**
   * @generated from field: binlogdata.Filter filter = 5;
   */
  filter?: FilterJson;

  /**
   * @generated from field: repeated binlogdata.TableLastPK table_last_p_ks = 6;
   */
  tableLastPKs?: TableLastPKJson[];

  /**
   * @generated from field: binlogdata.VStreamOptions options = 7;
   */
  options?: VStreamOptionsJson;
};

/**
 * Describes the message binlogdata.VStreamRequest.
 * Use `create(VStreamRequestSchema)` to create a new message.
 */
export const VStreamRequestSchema: GenMessage<VStreamRequest, VStreamRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 21);

/**
 * VStreamResponse is the response from VStreamer
 *
 * @generated from message binlogdata.VStreamResponse
 */
export type VStreamResponse = Message<"binlogdata.VStreamResponse"> & {
  /**
   * @generated from field: repeated binlogdata.VEvent events = 1;
   */
  events: VEvent[];
};

/**
 * VStreamResponse is the response from VStreamer
 *
 * @generated from message binlogdata.VStreamResponse
 */
export type VStreamResponseJson = {
  /**
   * @generated from field: repeated binlogdata.VEvent events = 1;
   */
  events?: VEventJson[];
};

/**
 * Describes the message binlogdata.VStreamResponse.
 * Use `create(VStreamResponseSchema)` to create a new message.
 */
export const VStreamResponseSchema: GenMessage<VStreamResponse, VStreamResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 22);

/**
 * VStreamRowsRequest is the payload for VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsRequest
 */
export type VStreamRowsRequest = Message<"binlogdata.VStreamRowsRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string query = 4;
   */
  query: string;

  /**
   * @generated from field: query.QueryResult lastpk = 5;
   */
  lastpk?: QueryResult;

  /**
   * @generated from field: binlogdata.VStreamOptions options = 6;
   */
  options?: VStreamOptions;
};

/**
 * VStreamRowsRequest is the payload for VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsRequest
 */
export type VStreamRowsRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string query = 4;
   */
  query?: string;

  /**
   * @generated from field: query.QueryResult lastpk = 5;
   */
  lastpk?: QueryResultJson;

  /**
   * @generated from field: binlogdata.VStreamOptions options = 6;
   */
  options?: VStreamOptionsJson;
};

/**
 * Describes the message binlogdata.VStreamRowsRequest.
 * Use `create(VStreamRowsRequestSchema)` to create a new message.
 */
export const VStreamRowsRequestSchema: GenMessage<VStreamRowsRequest, VStreamRowsRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 23);

/**
 * VStreamRowsResponse is the response from VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsResponse
 */
export type VStreamRowsResponse = Message<"binlogdata.VStreamRowsResponse"> & {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields: Field[];

  /**
   * @generated from field: repeated query.Field pkfields = 2;
   */
  pkfields: Field[];

  /**
   * @generated from field: string gtid = 3;
   */
  gtid: string;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows: Row[];

  /**
   * @generated from field: query.Row lastpk = 5;
   */
  lastpk?: Row;

  /**
   * Throttled indicates that rowstreamer is being throttled right now
   *
   * @generated from field: bool throttled = 6;
   */
  throttled: boolean;

  /**
   * Heartbeat indicates that this is a heartbeat message
   *
   * @generated from field: bool heartbeat = 7;
   */
  heartbeat: boolean;

  /**
   * ThrottledReason is a human readable string that explains why the stream is throttled
   *
   * @generated from field: string throttled_reason = 8;
   */
  throttledReason: string;
};

/**
 * VStreamRowsResponse is the response from VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsResponse
 */
export type VStreamRowsResponseJson = {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: repeated query.Field pkfields = 2;
   */
  pkfields?: FieldJson[];

  /**
   * @generated from field: string gtid = 3;
   */
  gtid?: string;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows?: RowJson[];

  /**
   * @generated from field: query.Row lastpk = 5;
   */
  lastpk?: RowJson;

  /**
   * Throttled indicates that rowstreamer is being throttled right now
   *
   * @generated from field: bool throttled = 6;
   */
  throttled?: boolean;

  /**
   * Heartbeat indicates that this is a heartbeat message
   *
   * @generated from field: bool heartbeat = 7;
   */
  heartbeat?: boolean;

  /**
   * ThrottledReason is a human readable string that explains why the stream is throttled
   *
   * @generated from field: string throttled_reason = 8;
   */
  throttledReason?: string;
};

/**
 * Describes the message binlogdata.VStreamRowsResponse.
 * Use `create(VStreamRowsResponseSchema)` to create a new message.
 */
export const VStreamRowsResponseSchema: GenMessage<VStreamRowsResponse, VStreamRowsResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 24);

/**
 * VStreamTablesRequest is the payload for VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesRequest
 */
export type VStreamTablesRequest = Message<"binlogdata.VStreamTablesRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: binlogdata.VStreamOptions options = 4;
   */
  options?: VStreamOptions;
};

/**
 * VStreamTablesRequest is the payload for VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesRequest
 */
export type VStreamTablesRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: binlogdata.VStreamOptions options = 4;
   */
  options?: VStreamOptionsJson;
};

/**
 * Describes the message binlogdata.VStreamTablesRequest.
 * Use `create(VStreamTablesRequestSchema)` to create a new message.
 */
export const VStreamTablesRequestSchema: GenMessage<VStreamTablesRequest, VStreamTablesRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 25);

/**
 * VStreamTablesResponse is the response from VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesResponse
 */
export type VStreamTablesResponse = Message<"binlogdata.VStreamTablesResponse"> & {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields: Field[];

  /**
   * @generated from field: repeated query.Field pkfields = 3;
   */
  pkfields: Field[];

  /**
   * @generated from field: string gtid = 4;
   */
  gtid: string;

  /**
   * @generated from field: repeated query.Row rows = 5;
   */
  rows: Row[];

  /**
   * @generated from field: query.Row lastpk = 6;
   */
  lastpk?: Row;
};

/**
 * VStreamTablesResponse is the response from VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesResponse
 */
export type VStreamTablesResponseJson = {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName?: string;

  /**
   * @generated from field: repeated query.Field fields = 2;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: repeated query.Field pkfields = 3;
   */
  pkfields?: FieldJson[];

  /**
   * @generated from field: string gtid = 4;
   */
  gtid?: string;

  /**
   * @generated from field: repeated query.Row rows = 5;
   */
  rows?: RowJson[];

  /**
   * @generated from field: query.Row lastpk = 6;
   */
  lastpk?: RowJson;
};

/**
 * Describes the message binlogdata.VStreamTablesResponse.
 * Use `create(VStreamTablesResponseSchema)` to create a new message.
 */
export const VStreamTablesResponseSchema: GenMessage<VStreamTablesResponse, VStreamTablesResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 26);

/**
 * @generated from message binlogdata.LastPKEvent
 */
export type LastPKEvent = Message<"binlogdata.LastPKEvent"> & {
  /**
   * @generated from field: binlogdata.TableLastPK table_last_p_k = 1;
   */
  tableLastPK?: TableLastPK;

  /**
   * @generated from field: bool completed = 2;
   */
  completed: boolean;
};

/**
 * @generated from message binlogdata.LastPKEvent
 */
export type LastPKEventJson = {
  /**
   * @generated from field: binlogdata.TableLastPK table_last_p_k = 1;
   */
  tableLastPK?: TableLastPKJson;

  /**
   * @generated from field: bool completed = 2;
   */
  completed?: boolean;
};

/**
 * Describes the message binlogdata.LastPKEvent.
 * Use `create(LastPKEventSchema)` to create a new message.
 */
export const LastPKEventSchema: GenMessage<LastPKEvent, LastPKEventJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 27);

/**
 * @generated from message binlogdata.TableLastPK
 */
export type TableLastPK = Message<"binlogdata.TableLastPK"> & {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName: string;

  /**
   * @generated from field: query.QueryResult lastpk = 3;
   */
  lastpk?: QueryResult;
};

/**
 * @generated from message binlogdata.TableLastPK
 */
export type TableLastPKJson = {
  /**
   * @generated from field: string table_name = 1;
   */
  tableName?: string;

  /**
   * @generated from field: query.QueryResult lastpk = 3;
   */
  lastpk?: QueryResultJson;
};

/**
 * Describes the message binlogdata.TableLastPK.
 * Use `create(TableLastPKSchema)` to create a new message.
 */
export const TableLastPKSchema: GenMessage<TableLastPK, TableLastPKJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 28);

/**
 * VStreamResultsRequest is the payload for VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsRequest
 */
export type VStreamResultsRequest = Message<"binlogdata.VStreamResultsRequest"> & {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerID;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerID;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: Target;

  /**
   * @generated from field: string query = 4;
   */
  query: string;
};

/**
 * VStreamResultsRequest is the payload for VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsRequest
 */
export type VStreamResultsRequestJson = {
  /**
   * @generated from field: vtrpc.CallerID effective_caller_id = 1;
   */
  effectiveCallerId?: CallerIDJson;

  /**
   * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
   */
  immediateCallerId?: VTGateCallerIDJson;

  /**
   * @generated from field: query.Target target = 3;
   */
  target?: TargetJson;

  /**
   * @generated from field: string query = 4;
   */
  query?: string;
};

/**
 * Describes the message binlogdata.VStreamResultsRequest.
 * Use `create(VStreamResultsRequestSchema)` to create a new message.
 */
export const VStreamResultsRequestSchema: GenMessage<VStreamResultsRequest, VStreamResultsRequestJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 29);

/**
 * VStreamResultsResponse is the response from VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsResponse
 */
export type VStreamResultsResponse = Message<"binlogdata.VStreamResultsResponse"> & {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields: Field[];

  /**
   * @generated from field: string gtid = 3;
   */
  gtid: string;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows: Row[];
};

/**
 * VStreamResultsResponse is the response from VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsResponse
 */
export type VStreamResultsResponseJson = {
  /**
   * @generated from field: repeated query.Field fields = 1;
   */
  fields?: FieldJson[];

  /**
   * @generated from field: string gtid = 3;
   */
  gtid?: string;

  /**
   * @generated from field: repeated query.Row rows = 4;
   */
  rows?: RowJson[];
};

/**
 * Describes the message binlogdata.VStreamResultsResponse.
 * Use `create(VStreamResultsResponseSchema)` to create a new message.
 */
export const VStreamResultsResponseSchema: GenMessage<VStreamResultsResponse, VStreamResultsResponseJson> = /*@__PURE__*/
  messageDesc(file_binlogdata, 30);

/**
 * OnDDLAction lists the possible actions for DDLs.
 *
 * @generated from enum binlogdata.OnDDLAction
 */
export enum OnDDLAction {
  /**
   * @generated from enum value: IGNORE = 0;
   */
  IGNORE = 0,

  /**
   * @generated from enum value: STOP = 1;
   */
  STOP = 1,

  /**
   * @generated from enum value: EXEC = 2;
   */
  EXEC = 2,

  /**
   * @generated from enum value: EXEC_IGNORE = 3;
   */
  EXEC_IGNORE = 3,
}

/**
 * OnDDLAction lists the possible actions for DDLs.
 *
 * @generated from enum binlogdata.OnDDLAction
 */
export type OnDDLActionJson = "IGNORE" | "STOP" | "EXEC" | "EXEC_IGNORE";

/**
 * Describes the enum binlogdata.OnDDLAction.
 */
export const OnDDLActionSchema: GenEnum<OnDDLAction, OnDDLActionJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 0);

/**
 * VReplicationWorkflowType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowType
 */
export enum VReplicationWorkflowType {
  /**
   * @generated from enum value: Materialize = 0;
   */
  Materialize = 0,

  /**
   * @generated from enum value: MoveTables = 1;
   */
  MoveTables = 1,

  /**
   * @generated from enum value: CreateLookupIndex = 2;
   */
  CreateLookupIndex = 2,

  /**
   * @generated from enum value: Migrate = 3;
   */
  Migrate = 3,

  /**
   * @generated from enum value: Reshard = 4;
   */
  Reshard = 4,

  /**
   * @generated from enum value: OnlineDDL = 5;
   */
  OnlineDDL = 5,
}

/**
 * VReplicationWorkflowType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowType
 */
export type VReplicationWorkflowTypeJson = "Materialize" | "MoveTables" | "CreateLookupIndex" | "Migrate" | "Reshard" | "OnlineDDL";

/**
 * Describes the enum binlogdata.VReplicationWorkflowType.
 */
export const VReplicationWorkflowTypeSchema: GenEnum<VReplicationWorkflowType, VReplicationWorkflowTypeJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 1);

/**
 * VReplicationWorkflowSubType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowSubType
 */
export enum VReplicationWorkflowSubType {
  /**
   * @generated from enum value: None = 0;
   */
  None = 0,

  /**
   * @generated from enum value: Partial = 1;
   */
  Partial = 1,

  /**
   * @generated from enum value: AtomicCopy = 2;
   */
  AtomicCopy = 2,
}

/**
 * VReplicationWorkflowSubType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowSubType
 */
export type VReplicationWorkflowSubTypeJson = "None" | "Partial" | "AtomicCopy";

/**
 * Describes the enum binlogdata.VReplicationWorkflowSubType.
 */
export const VReplicationWorkflowSubTypeSchema: GenEnum<VReplicationWorkflowSubType, VReplicationWorkflowSubTypeJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 2);

/**
 * VReplicationWorklfowState defines the valid states that a workflow can be in.
 *
 * @generated from enum binlogdata.VReplicationWorkflowState
 */
export enum VReplicationWorkflowState {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: Init = 1;
   */
  Init = 1,

  /**
   * @generated from enum value: Stopped = 2;
   */
  Stopped = 2,

  /**
   * @generated from enum value: Copying = 3;
   */
  Copying = 3,

  /**
   * @generated from enum value: Running = 4;
   */
  Running = 4,

  /**
   * @generated from enum value: Error = 5;
   */
  Error = 5,

  /**
   * @generated from enum value: Lagging = 6;
   */
  Lagging = 6,
}

/**
 * VReplicationWorklfowState defines the valid states that a workflow can be in.
 *
 * @generated from enum binlogdata.VReplicationWorkflowState
 */
export type VReplicationWorkflowStateJson = "Unknown" | "Init" | "Stopped" | "Copying" | "Running" | "Error" | "Lagging";

/**
 * Describes the enum binlogdata.VReplicationWorkflowState.
 */
export const VReplicationWorkflowStateSchema: GenEnum<VReplicationWorkflowState, VReplicationWorkflowStateJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 3);

/**
 * VEventType enumerates the event types. Many of these types
 * will not be encountered in RBR mode.
 *
 * @generated from enum binlogdata.VEventType
 */
export enum VEventType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: GTID = 1;
   */
  GTID = 1,

  /**
   * @generated from enum value: BEGIN = 2;
   */
  BEGIN = 2,

  /**
   * @generated from enum value: COMMIT = 3;
   */
  COMMIT = 3,

  /**
   * @generated from enum value: ROLLBACK = 4;
   */
  ROLLBACK = 4,

  /**
   * @generated from enum value: DDL = 5;
   */
  DDL = 5,

  /**
   * INSERT, REPLACE, UPDATE, DELETE and SET will not be seen in RBR mode.
   *
   * @generated from enum value: INSERT = 6;
   */
  INSERT = 6,

  /**
   * @generated from enum value: REPLACE = 7;
   */
  REPLACE = 7,

  /**
   * @generated from enum value: UPDATE = 8;
   */
  UPDATE = 8,

  /**
   * @generated from enum value: DELETE = 9;
   */
  DELETE = 9,

  /**
   * @generated from enum value: SET = 10;
   */
  SET = 10,

  /**
   * OTHER is a dummy event. If encountered, the current GTID must be
   * recorded by the client to be able to resume.
   *
   * @generated from enum value: OTHER = 11;
   */
  OTHER = 11,

  /**
   * @generated from enum value: ROW = 12;
   */
  ROW = 12,

  /**
   * @generated from enum value: FIELD = 13;
   */
  FIELD = 13,

  /**
   * HEARTBEAT is sent if there is inactivity. If a client does not
   * receive events beyond the hearbeat interval, it can assume that it's
   * lost connection to the vstreamer.
   *
   * @generated from enum value: HEARTBEAT = 14;
   */
  HEARTBEAT = 14,

  /**
   * VGTID is generated by VTGate's VStream that combines multiple
   * GTIDs.
   *
   * @generated from enum value: VGTID = 15;
   */
  VGTID = 15,

  /**
   * @generated from enum value: JOURNAL = 16;
   */
  JOURNAL = 16,

  /**
   * @generated from enum value: VERSION = 17;
   */
  VERSION = 17,

  /**
   * @generated from enum value: LASTPK = 18;
   */
  LASTPK = 18,

  /**
   * @generated from enum value: SAVEPOINT = 19;
   */
  SAVEPOINT = 19,

  /**
   * COPY_COMPLETED is sent when VTGate's VStream copy operation is done.
   * If a client experiences some disruptions before receiving the event,
   * the client should restart the copy operation.
   *
   * @generated from enum value: COPY_COMPLETED = 20;
   */
  COPY_COMPLETED = 20,
}

/**
 * VEventType enumerates the event types. Many of these types
 * will not be encountered in RBR mode.
 *
 * @generated from enum binlogdata.VEventType
 */
export type VEventTypeJson = "UNKNOWN" | "GTID" | "BEGIN" | "COMMIT" | "ROLLBACK" | "DDL" | "INSERT" | "REPLACE" | "UPDATE" | "DELETE" | "SET" | "OTHER" | "ROW" | "FIELD" | "HEARTBEAT" | "VGTID" | "JOURNAL" | "VERSION" | "LASTPK" | "SAVEPOINT" | "COPY_COMPLETED";

/**
 * Describes the enum binlogdata.VEventType.
 */
export const VEventTypeSchema: GenEnum<VEventType, VEventTypeJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 4);

/**
 * MigrationType specifies the type of migration for the Journal.
 *
 * @generated from enum binlogdata.MigrationType
 */
export enum MigrationType {
  /**
   * @generated from enum value: TABLES = 0;
   */
  TABLES = 0,

  /**
   * @generated from enum value: SHARDS = 1;
   */
  SHARDS = 1,
}

/**
 * MigrationType specifies the type of migration for the Journal.
 *
 * @generated from enum binlogdata.MigrationType
 */
export type MigrationTypeJson = "TABLES" | "SHARDS";

/**
 * Describes the enum binlogdata.MigrationType.
 */
export const MigrationTypeSchema: GenEnum<MigrationType, MigrationTypeJson> = /*@__PURE__*/
  enumDesc(file_binlogdata, 5);

