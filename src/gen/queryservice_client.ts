//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the service VtTablet exposes for queries.

// @generated by protoc-gen-json-service-es v1.0.0 with parameter "target=ts"
// @generated from file queryservice.proto (package queryservice, syntax proto3)
/* eslint-disable */

import type { CallOptions, Client } from "@connectrpc/connect";
import { createClient } from "@connectrpc/connect";
import { Query } from "./queryservice_pb";
import type { GrpcTransportOptions } from "@connectrpc/connect-node";
import { createGrpcTransport } from "@connectrpc/connect-node";
import type { BeginExecuteRequestJson, BeginExecuteResponseJson, BeginRequestJson, BeginResponseJson, BeginStreamExecuteRequestJson, BeginStreamExecuteResponseJson, CommitPreparedRequestJson, CommitPreparedResponseJson, CommitRequestJson, CommitResponseJson, ConcludeTransactionRequestJson, ConcludeTransactionResponseJson, CreateTransactionRequestJson, CreateTransactionResponseJson, ExecuteRequestJson, ExecuteResponseJson, GetSchemaRequestJson, GetSchemaResponseJson, MessageAckRequestJson, MessageAckResponseJson, MessageStreamRequestJson, MessageStreamResponseJson, PrepareRequestJson, PrepareResponseJson, ReadTransactionRequestJson, ReadTransactionResponseJson, ReleaseRequestJson, ReleaseResponseJson, ReserveBeginExecuteRequestJson, ReserveBeginExecuteResponseJson, ReserveBeginStreamExecuteRequestJson, ReserveBeginStreamExecuteResponseJson, ReserveExecuteRequestJson, ReserveExecuteResponseJson, ReserveStreamExecuteRequestJson, ReserveStreamExecuteResponseJson, RollbackPreparedRequestJson, RollbackPreparedResponseJson, RollbackRequestJson, RollbackResponseJson, SetRollbackRequestJson, SetRollbackResponseJson, StartCommitRequestJson, StartCommitResponseJson, StreamExecuteRequestJson, StreamExecuteResponseJson, StreamHealthRequestJson, StreamHealthResponseJson, UnresolvedTransactionsRequestJson, UnresolvedTransactionsResponseJson } from "./query_pb";
import { BeginExecuteRequestSchema, BeginExecuteResponseSchema, BeginRequestSchema, BeginResponseSchema, BeginStreamExecuteRequestSchema, BeginStreamExecuteResponseSchema, CommitPreparedRequestSchema, CommitPreparedResponseSchema, CommitRequestSchema, CommitResponseSchema, ConcludeTransactionRequestSchema, ConcludeTransactionResponseSchema, CreateTransactionRequestSchema, CreateTransactionResponseSchema, ExecuteRequestSchema, ExecuteResponseSchema, GetSchemaRequestSchema, GetSchemaResponseSchema, MessageAckRequestSchema, MessageAckResponseSchema, MessageStreamRequestSchema, MessageStreamResponseSchema, PrepareRequestSchema, PrepareResponseSchema, ReadTransactionRequestSchema, ReadTransactionResponseSchema, ReleaseRequestSchema, ReleaseResponseSchema, ReserveBeginExecuteRequestSchema, ReserveBeginExecuteResponseSchema, ReserveBeginStreamExecuteRequestSchema, ReserveBeginStreamExecuteResponseSchema, ReserveExecuteRequestSchema, ReserveExecuteResponseSchema, ReserveStreamExecuteRequestSchema, ReserveStreamExecuteResponseSchema, RollbackPreparedRequestSchema, RollbackPreparedResponseSchema, RollbackRequestSchema, RollbackResponseSchema, SetRollbackRequestSchema, SetRollbackResponseSchema, StartCommitRequestSchema, StartCommitResponseSchema, StreamExecuteRequestSchema, StreamExecuteResponseSchema, StreamHealthRequestSchema, StreamHealthResponseSchema, UnresolvedTransactionsRequestSchema, UnresolvedTransactionsResponseSchema } from "./query_pb";
import { fromJson, toJson } from "@bufbuild/protobuf";
import type { VStreamRequestJson, VStreamResponseJson, VStreamResultsRequestJson, VStreamResultsResponseJson, VStreamRowsRequestJson, VStreamRowsResponseJson, VStreamTablesRequestJson, VStreamTablesResponseJson } from "./binlogdata_pb";
import { VStreamRequestSchema, VStreamResponseSchema, VStreamResultsRequestSchema, VStreamResultsResponseSchema, VStreamRowsRequestSchema, VStreamRowsResponseSchema, VStreamTablesRequestSchema, VStreamTablesResponseSchema } from "./binlogdata_pb";

/**
 * Query defines the tablet query service, implemented by vttablet.
 *
 * @generated from service queryservice.Query
 */
export class QueryClient {
  #client: Client<typeof Query>;

  constructor(options: GrpcTransportOptions) {
    const transport = createGrpcTransport(options);
    this.#client = createClient(Query, transport);
  }

  async execute(params: ExecuteRequestJson, opts?: CallOptions): Promise<ExecuteResponseJson> {
    const response = await this.#client.execute(fromJson(ExecuteRequestSchema, params), opts);
    return toJson(ExecuteResponseSchema, response);
  }

  async *streamExecute(params: StreamExecuteRequestJson, opts?: CallOptions): AsyncGenerator<StreamExecuteResponseJson> {
    const stream = this.#client.streamExecute(fromJson(StreamExecuteRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(StreamExecuteResponseSchema, response);
    }
  }

  async begin(params: BeginRequestJson, opts?: CallOptions): Promise<BeginResponseJson> {
    const response = await this.#client.begin(fromJson(BeginRequestSchema, params), opts);
    return toJson(BeginResponseSchema, response);
  }

  async commit(params: CommitRequestJson, opts?: CallOptions): Promise<CommitResponseJson> {
    const response = await this.#client.commit(fromJson(CommitRequestSchema, params), opts);
    return toJson(CommitResponseSchema, response);
  }

  async rollback(params: RollbackRequestJson, opts?: CallOptions): Promise<RollbackResponseJson> {
    const response = await this.#client.rollback(fromJson(RollbackRequestSchema, params), opts);
    return toJson(RollbackResponseSchema, response);
  }

  async prepare(params: PrepareRequestJson, opts?: CallOptions): Promise<PrepareResponseJson> {
    const response = await this.#client.prepare(fromJson(PrepareRequestSchema, params), opts);
    return toJson(PrepareResponseSchema, response);
  }

  async commitPrepared(params: CommitPreparedRequestJson, opts?: CallOptions): Promise<CommitPreparedResponseJson> {
    const response = await this.#client.commitPrepared(fromJson(CommitPreparedRequestSchema, params), opts);
    return toJson(CommitPreparedResponseSchema, response);
  }

  async rollbackPrepared(params: RollbackPreparedRequestJson, opts?: CallOptions): Promise<RollbackPreparedResponseJson> {
    const response = await this.#client.rollbackPrepared(fromJson(RollbackPreparedRequestSchema, params), opts);
    return toJson(RollbackPreparedResponseSchema, response);
  }

  async createTransaction(params: CreateTransactionRequestJson, opts?: CallOptions): Promise<CreateTransactionResponseJson> {
    const response = await this.#client.createTransaction(fromJson(CreateTransactionRequestSchema, params), opts);
    return toJson(CreateTransactionResponseSchema, response);
  }

  async startCommit(params: StartCommitRequestJson, opts?: CallOptions): Promise<StartCommitResponseJson> {
    const response = await this.#client.startCommit(fromJson(StartCommitRequestSchema, params), opts);
    return toJson(StartCommitResponseSchema, response);
  }

  async setRollback(params: SetRollbackRequestJson, opts?: CallOptions): Promise<SetRollbackResponseJson> {
    const response = await this.#client.setRollback(fromJson(SetRollbackRequestSchema, params), opts);
    return toJson(SetRollbackResponseSchema, response);
  }

  async concludeTransaction(params: ConcludeTransactionRequestJson, opts?: CallOptions): Promise<ConcludeTransactionResponseJson> {
    const response = await this.#client.concludeTransaction(fromJson(ConcludeTransactionRequestSchema, params), opts);
    return toJson(ConcludeTransactionResponseSchema, response);
  }

  async readTransaction(params: ReadTransactionRequestJson, opts?: CallOptions): Promise<ReadTransactionResponseJson> {
    const response = await this.#client.readTransaction(fromJson(ReadTransactionRequestSchema, params), opts);
    return toJson(ReadTransactionResponseSchema, response);
  }

  async unresolvedTransactions(params: UnresolvedTransactionsRequestJson, opts?: CallOptions): Promise<UnresolvedTransactionsResponseJson> {
    const response = await this.#client.unresolvedTransactions(fromJson(UnresolvedTransactionsRequestSchema, params), opts);
    return toJson(UnresolvedTransactionsResponseSchema, response);
  }

  async beginExecute(params: BeginExecuteRequestJson, opts?: CallOptions): Promise<BeginExecuteResponseJson> {
    const response = await this.#client.beginExecute(fromJson(BeginExecuteRequestSchema, params), opts);
    return toJson(BeginExecuteResponseSchema, response);
  }

  async *beginStreamExecute(params: BeginStreamExecuteRequestJson, opts?: CallOptions): AsyncGenerator<BeginStreamExecuteResponseJson> {
    const stream = this.#client.beginStreamExecute(fromJson(BeginStreamExecuteRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(BeginStreamExecuteResponseSchema, response);
    }
  }

  async *messageStream(params: MessageStreamRequestJson, opts?: CallOptions): AsyncGenerator<MessageStreamResponseJson> {
    const stream = this.#client.messageStream(fromJson(MessageStreamRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(MessageStreamResponseSchema, response);
    }
  }

  async messageAck(params: MessageAckRequestJson, opts?: CallOptions): Promise<MessageAckResponseJson> {
    const response = await this.#client.messageAck(fromJson(MessageAckRequestSchema, params), opts);
    return toJson(MessageAckResponseSchema, response);
  }

  async reserveExecute(params: ReserveExecuteRequestJson, opts?: CallOptions): Promise<ReserveExecuteResponseJson> {
    const response = await this.#client.reserveExecute(fromJson(ReserveExecuteRequestSchema, params), opts);
    return toJson(ReserveExecuteResponseSchema, response);
  }

  async reserveBeginExecute(params: ReserveBeginExecuteRequestJson, opts?: CallOptions): Promise<ReserveBeginExecuteResponseJson> {
    const response = await this.#client.reserveBeginExecute(fromJson(ReserveBeginExecuteRequestSchema, params), opts);
    return toJson(ReserveBeginExecuteResponseSchema, response);
  }

  async *reserveStreamExecute(params: ReserveStreamExecuteRequestJson, opts?: CallOptions): AsyncGenerator<ReserveStreamExecuteResponseJson> {
    const stream = this.#client.reserveStreamExecute(fromJson(ReserveStreamExecuteRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(ReserveStreamExecuteResponseSchema, response);
    }
  }

  async *reserveBeginStreamExecute(params: ReserveBeginStreamExecuteRequestJson, opts?: CallOptions): AsyncGenerator<ReserveBeginStreamExecuteResponseJson> {
    const stream = this.#client.reserveBeginStreamExecute(fromJson(ReserveBeginStreamExecuteRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(ReserveBeginStreamExecuteResponseSchema, response);
    }
  }

  async release(params: ReleaseRequestJson, opts?: CallOptions): Promise<ReleaseResponseJson> {
    const response = await this.#client.release(fromJson(ReleaseRequestSchema, params), opts);
    return toJson(ReleaseResponseSchema, response);
  }

  async *streamHealth(params: StreamHealthRequestJson, opts?: CallOptions): AsyncGenerator<StreamHealthResponseJson> {
    const stream = this.#client.streamHealth(fromJson(StreamHealthRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(StreamHealthResponseSchema, response);
    }
  }

  async *vStream(params: VStreamRequestJson, opts?: CallOptions): AsyncGenerator<VStreamResponseJson> {
    const stream = this.#client.vStream(fromJson(VStreamRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(VStreamResponseSchema, response);
    }
  }

  async *vStreamRows(params: VStreamRowsRequestJson, opts?: CallOptions): AsyncGenerator<VStreamRowsResponseJson> {
    const stream = this.#client.vStreamRows(fromJson(VStreamRowsRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(VStreamRowsResponseSchema, response);
    }
  }

  async *vStreamTables(params: VStreamTablesRequestJson, opts?: CallOptions): AsyncGenerator<VStreamTablesResponseJson> {
    const stream = this.#client.vStreamTables(fromJson(VStreamTablesRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(VStreamTablesResponseSchema, response);
    }
  }

  async *vStreamResults(params: VStreamResultsRequestJson, opts?: CallOptions): AsyncGenerator<VStreamResultsResponseJson> {
    const stream = this.#client.vStreamResults(fromJson(VStreamResultsRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(VStreamResultsResponseSchema, response);
    }
  }

  async *getSchema(params: GetSchemaRequestJson, opts?: CallOptions): AsyncGenerator<GetSchemaResponseJson> {
    const stream = this.#client.getSchema(fromJson(GetSchemaRequestSchema, params), opts);
    for await (const response of stream) {
      yield toJson(GetSchemaResponseSchema, response);
    }
  }

}
