// @generated by protobuf-ts 2.9.6 with parameter long_type_bigint
// @generated from protobuf file "binlogdata.proto" (package "binlogdata", syntax proto3)
// tslint:disable
//
//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//
//
// This file contains all the types and servers necessary to make
// RPC calls to VtTablet for the binlog protocol, used by filtered
// replication only.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { QueryResult } from "./query";
import { Target } from "./query";
import { VTGateCallerID } from "./query";
import { CallerID } from "./vtrpc";
import { Field } from "./query";
import { Row } from "./query";
import { TabletType } from "./topodata";
import { KeyRange } from "./topodata";
import { EventToken } from "./query";
/**
 * Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
 *
 * @generated from protobuf message binlogdata.Charset
 */
export interface Charset {
    /**
     * @@session.character_set_client
     *
     * @generated from protobuf field: int32 client = 1;
     */
    client: number;
    /**
     * @@session.collation_connection
     *
     * @generated from protobuf field: int32 conn = 2;
     */
    conn: number;
    /**
     * @@session.collation_server
     *
     * @generated from protobuf field: int32 server = 3;
     */
    server: number;
}
/**
 * BinlogTransaction describes a transaction inside the binlogs.
 * It is streamed by vttablet for filtered replication, used during resharding.
 *
 * @generated from protobuf message binlogdata.BinlogTransaction
 */
export interface BinlogTransaction {
    /**
     * the statements in this transaction
     *
     * @generated from protobuf field: repeated binlogdata.BinlogTransaction.Statement statements = 1;
     */
    statements: BinlogTransaction_Statement[];
    /**
     * The Event Token for this event.
     *
     * @generated from protobuf field: query.EventToken event_token = 4;
     */
    eventToken?: EventToken;
}
/**
 * @generated from protobuf message binlogdata.BinlogTransaction.Statement
 */
export interface BinlogTransaction_Statement {
    /**
     * what type of statement is this?
     *
     * @generated from protobuf field: binlogdata.BinlogTransaction.Statement.Category category = 1;
     */
    category: BinlogTransaction_Statement_Category;
    /**
     * charset of this statement, if different from pre-negotiated default.
     *
     * @generated from protobuf field: binlogdata.Charset charset = 2;
     */
    charset?: Charset;
    /**
     * the sql
     *
     * @generated from protobuf field: bytes sql = 3;
     */
    sql: Uint8Array;
}
/**
 * @generated from protobuf enum binlogdata.BinlogTransaction.Statement.Category
 */
export enum BinlogTransaction_Statement_Category {
    /**
     * @generated from protobuf enum value: BL_UNRECOGNIZED = 0;
     */
    BL_UNRECOGNIZED = 0,
    /**
     * @generated from protobuf enum value: BL_BEGIN = 1;
     */
    BL_BEGIN = 1,
    /**
     * @generated from protobuf enum value: BL_COMMIT = 2;
     */
    BL_COMMIT = 2,
    /**
     * @generated from protobuf enum value: BL_ROLLBACK = 3;
     */
    BL_ROLLBACK = 3,
    /**
     * BL_DML is deprecated.
     *
     * @generated from protobuf enum value: BL_DML_DEPRECATED = 4;
     */
    BL_DML_DEPRECATED = 4,
    /**
     * @generated from protobuf enum value: BL_DDL = 5;
     */
    BL_DDL = 5,
    /**
     * @generated from protobuf enum value: BL_SET = 6;
     */
    BL_SET = 6,
    /**
     * @generated from protobuf enum value: BL_INSERT = 7;
     */
    BL_INSERT = 7,
    /**
     * @generated from protobuf enum value: BL_UPDATE = 8;
     */
    BL_UPDATE = 8,
    /**
     * @generated from protobuf enum value: BL_DELETE = 9;
     */
    BL_DELETE = 9
}
/**
 * StreamKeyRangeRequest is the payload to StreamKeyRange
 *
 * @generated from protobuf message binlogdata.StreamKeyRangeRequest
 */
export interface StreamKeyRangeRequest {
    /**
     * where to start
     *
     * @generated from protobuf field: string position = 1;
     */
    position: string;
    /**
     * what to get
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;
    /**
     * default charset on the player side
     *
     * @generated from protobuf field: binlogdata.Charset charset = 3;
     */
    charset?: Charset;
}
/**
 * StreamKeyRangeResponse is the response from StreamKeyRange
 *
 * @generated from protobuf message binlogdata.StreamKeyRangeResponse
 */
export interface StreamKeyRangeResponse {
    /**
     * @generated from protobuf field: binlogdata.BinlogTransaction binlog_transaction = 1;
     */
    binlogTransaction?: BinlogTransaction;
}
/**
 * StreamTablesRequest is the payload to StreamTables
 *
 * @generated from protobuf message binlogdata.StreamTablesRequest
 */
export interface StreamTablesRequest {
    /**
     * where to start
     *
     * @generated from protobuf field: string position = 1;
     */
    position: string;
    /**
     * what to get
     *
     * @generated from protobuf field: repeated string tables = 2;
     */
    tables: string[];
    /**
     * default charset on the player side
     *
     * @generated from protobuf field: binlogdata.Charset charset = 3;
     */
    charset?: Charset;
}
/**
 * StreamTablesResponse is the response from StreamTables
 *
 * @generated from protobuf message binlogdata.StreamTablesResponse
 */
export interface StreamTablesResponse {
    /**
     * @generated from protobuf field: binlogdata.BinlogTransaction binlog_transaction = 1;
     */
    binlogTransaction?: BinlogTransaction;
}
/**
 * CharsetConversion represent a conversion of text from one charset to another
 *
 * @generated from protobuf message binlogdata.CharsetConversion
 */
export interface CharsetConversion {
    /**
     * FromCharset is the charset name from which we convert the text (e.g. latin1)
     *
     * @generated from protobuf field: string from_charset = 1;
     */
    fromCharset: string;
    /**
     * ToCharset is the charset name to which we convert the text (e.g. utf8mb4)
     *
     * @generated from protobuf field: string to_charset = 2;
     */
    toCharset: string;
}
/**
 * Rule represents one rule in a Filter.
 *
 * @generated from protobuf message binlogdata.Rule
 */
export interface Rule {
    /**
     * Match can be a table name or a regular expression.
     * If it starts with a '/', it's a regular expression.
     * For example, "t" matches a table named "t", whereas
     * "/t.*" matches all tables that begin with 't'.
     *
     * @generated from protobuf field: string match = 1;
     */
    match: string;
    /**
     * Filter: If empty, all columns and rows of the matching tables
     * are sent. If it's a keyrange like "-80", only rows that
     * match the keyrange are sent.
     * If Match is a table name instead of a regular expression,
     * the Filter can also be a select expression like this:
     * "select * from t", same as an empty Filter, or
     * "select * from t where in_keyrange('-80')", same as "-80", or
     * "select col1, col2 from t where in_keyrange(col1, 'hash', '-80'), or
     * What is allowed in a select expression depends on whether
     * it's a vstreamer or vreplication request. For more details,
     * please refer to the specific package documentation.
     * On the vreplication side, Filter can also accept a special
     * "exclude" value, which will cause the matched tables
     * to be excluded.
     * TODO(sougou): support this on vstreamer side also.
     *
     * @generated from protobuf field: string filter = 2;
     */
    filter: string; // ConvertEnumToText: optional, list per enum column name, the list of textual values.
    // When reading the binary log, all enum values are numeric. But sometimes it
    // is useful/needed to know what the textual mapping are.
    // Online DDL provides such use case.
    /**
     * Example: key="color", value="'red','green','blue'"
     *
     * @generated from protobuf field: map<string, string> convert_enum_to_text = 3;
     */
    convertEnumToText: {
        [key: string]: string;
    };
    /**
     * ConvertCharset: optional mapping, between column name and a CharsetConversion.
     * This hints to vreplication that columns are encoded from/to non-trivial charsets
     * The map is only populated when either "from" or "to" charset of a column are non-trivial
     * trivial charsets are utf8 and ascii variants.
     *
     * @generated from protobuf field: map<string, binlogdata.CharsetConversion> convert_charset = 4;
     */
    convertCharset: {
        [key: string]: CharsetConversion;
    };
    /**
     * SourceUniqueKeyColumns represents the ordered columns in the index used by rowstreamer to iterate the table
     * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
     *
     * @generated from protobuf field: string source_unique_key_columns = 5;
     */
    sourceUniqueKeyColumns: string;
    /**
     * TargetUniqueKeyColumns represents the ordered columns in that index used by vcopier and vplayer to apply rows
     * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
     *
     * @generated from protobuf field: string target_unique_key_columns = 6;
     */
    targetUniqueKeyColumns: string;
    /**
     * SourceUniqueKeyTargetColumns represents the names of columns in target table, mapped from the chosen unique
     * key on source tables (some columns may be renamed from source to target)
     *
     * @generated from protobuf field: string source_unique_key_target_columns = 7;
     */
    sourceUniqueKeyTargetColumns: string;
    /**
     * ConvertIntToEnum lists any columns that are converted from an integral value into an enum.
     * such columns need to have special transofrmation of the data, from an integral format into a
     * string format. e.g. the value 0 needs to be converted to '0'.
     *
     * @generated from protobuf field: map<string, bool> convert_int_to_enum = 8;
     */
    convertIntToEnum: {
        [key: string]: boolean;
    };
    /**
     * ForceUniqueKey gives vtreamer a hint for `FORCE INDEX (...)` usage.
     *
     * @generated from protobuf field: string force_unique_key = 9;
     */
    forceUniqueKey: string;
}
/**
 * Filter represents a list of ordered rules. The first
 * match wins.
 *
 * @generated from protobuf message binlogdata.Filter
 */
export interface Filter {
    /**
     * @generated from protobuf field: repeated binlogdata.Rule rules = 1;
     */
    rules: Rule[];
    /**
     * FieldEventMode specifies the behavior if there is a mismatch
     * between the current schema and the fields in the binlog. This
     * can happen if the binlog position is before a DDL that would
     * cause the fields to change. If vstreamer detects such
     * an inconsistency, the behavior depends on the FieldEventMode.
     * If the value is ERR_ON_MISMATCH (default), then it errors out.
     * If it's BEST_EFFORT, it sends a field event with fake column
     * names as "@1", "@2", etc.
     *
     * @generated from protobuf field: binlogdata.Filter.FieldEventMode field_event_mode = 2;
     */
    fieldEventMode: Filter_FieldEventMode;
    /**
     * @generated from protobuf field: int64 workflow_type = 3;
     */
    workflowType: bigint;
    /**
     * @generated from protobuf field: string workflow_name = 4;
     */
    workflowName: string;
}
/**
 * @generated from protobuf enum binlogdata.Filter.FieldEventMode
 */
export enum Filter_FieldEventMode {
    /**
     * @generated from protobuf enum value: ERR_ON_MISMATCH = 0;
     */
    ERR_ON_MISMATCH = 0,
    /**
     * @generated from protobuf enum value: BEST_EFFORT = 1;
     */
    BEST_EFFORT = 1
}
/**
 * BinlogSource specifies the source  and filter parameters for
 * Filtered Replication. KeyRange and Tables are legacy. Filter
 * is the new way to specify the filtering rules.
 *
 * @generated from protobuf message binlogdata.BinlogSource
 */
export interface BinlogSource {
    /**
     * the source keyspace
     *
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * the source shard
     *
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * the source tablet type
     *
     * @generated from protobuf field: topodata.TabletType tablet_type = 3;
     */
    tabletType: TabletType;
    /**
     * KeyRange is set if the request is for a keyrange
     *
     * @generated from protobuf field: topodata.KeyRange key_range = 4;
     */
    keyRange?: KeyRange;
    /**
     * Tables is set if the request is for a list of tables
     *
     * @generated from protobuf field: repeated string tables = 5;
     */
    tables: string[];
    /**
     * Filter is set if we're using the generalized representation
     * for the filter.
     *
     * @generated from protobuf field: binlogdata.Filter filter = 6;
     */
    filter?: Filter;
    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from protobuf field: binlogdata.OnDDLAction on_ddl = 7;
     */
    onDdl: OnDDLAction;
    /**
     * Source is an external mysql. This attribute should be set to the username
     * to use in the connection
     *
     * @generated from protobuf field: string external_mysql = 8;
     */
    externalMysql: string;
    /**
     * StopAfterCopy specifies if vreplication should be stopped
     * after copying is done.
     *
     * @generated from protobuf field: bool stop_after_copy = 9;
     */
    stopAfterCopy: boolean;
    /**
     * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
     * it is of the type <cluster_type.cluster_name>
     *
     * @generated from protobuf field: string external_cluster = 10;
     */
    externalCluster: string;
    /**
     * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
     *
     * @generated from protobuf field: string source_time_zone = 11;
     */
    sourceTimeZone: string;
    /**
     * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
     * and to the SourceTimeZone in reverse workflows
     *
     * @generated from protobuf field: string target_time_zone = 12;
     */
    targetTimeZone: string;
}
/**
 * RowChange represents one row change.
 * If Before is set and not After, it's a delete.
 * If After is set and not Before, it's an insert.
 * If both are set, it's an update.
 *
 * @generated from protobuf message binlogdata.RowChange
 */
export interface RowChange {
    /**
     * @generated from protobuf field: query.Row before = 1;
     */
    before?: Row;
    /**
     * @generated from protobuf field: query.Row after = 2;
     */
    after?: Row;
    /**
     * DataColumns is a bitmap of all columns: bit is set if column is present in the after image
     *
     * @generated from protobuf field: binlogdata.RowChange.Bitmap data_columns = 3;
     */
    dataColumns?: RowChange_Bitmap;
}
/**
 * @generated from protobuf message binlogdata.RowChange.Bitmap
 */
export interface RowChange_Bitmap {
    /**
     * @generated from protobuf field: int64 count = 1;
     */
    count: bigint;
    /**
     * @generated from protobuf field: bytes cols = 2;
     */
    cols: Uint8Array;
}
/**
 * RowEvent represent row events for one table.
 *
 * @generated from protobuf message binlogdata.RowEvent
 */
export interface RowEvent {
    /**
     * @generated from protobuf field: string table_name = 1;
     */
    tableName: string;
    /**
     * @generated from protobuf field: repeated binlogdata.RowChange row_changes = 2;
     */
    rowChanges: RowChange[];
    /**
     * @generated from protobuf field: string keyspace = 3;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 4;
     */
    shard: string;
    /**
     * @generated from protobuf field: uint32 flags = 5;
     */
    flags: number; // https://dev.mysql.com/doc/dev/mysql-server/latest/classbinary__log_1_1Rows__event.html
    /**
     * @generated from protobuf field: bool is_internal_table = 6;
     */
    isInternalTable: boolean; // set for sidecardb tables
}
/**
 * FieldEvent represents the field info for a table.
 *
 * @generated from protobuf message binlogdata.FieldEvent
 */
export interface FieldEvent {
    /**
     * @generated from protobuf field: string table_name = 1;
     */
    tableName: string;
    /**
     * @generated from protobuf field: repeated query.Field fields = 2;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: string keyspace = 3;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 4;
     */
    shard: string;
    /**
     * Are ENUM and SET field values already mapped to strings in the ROW
     * events? This allows us to transition VTGate VStream consumers from
     * the pre v20 behavior of having to do this mapping themselves to the
     * v20+ behavior of not having to do this anymore and to expect string
     * values directly.
     * NOTE: because this is the use case, this is ONLY ever set today in
     * vstreams managed by the vstreamManager.
     *
     * @generated from protobuf field: bool enum_set_string_values = 25;
     */
    enumSetStringValues: boolean;
    /**
     * @generated from protobuf field: bool is_internal_table = 26;
     */
    isInternalTable: boolean; // set for sidecardb tables
}
/**
 * ShardGtid contains the GTID position for one shard.
 * It's used in a request for requesting a starting position.
 * It's used in a response to transmit the current position
 * of a shard. It's also used in a Journal to indicate the
 * list of targets and shard positions to migrate to.
 *
 * @generated from protobuf message binlogdata.ShardGtid
 */
export interface ShardGtid {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
    /**
     * @generated from protobuf field: string gtid = 3;
     */
    gtid: string;
    /**
     * @generated from protobuf field: repeated binlogdata.TableLastPK table_p_ks = 4;
     */
    tablePKs: TableLastPK[];
}
/**
 * A VGtid is a list of ShardGtids.
 *
 * @generated from protobuf message binlogdata.VGtid
 */
export interface VGtid {
    /**
     * @generated from protobuf field: repeated binlogdata.ShardGtid shard_gtids = 1;
     */
    shardGtids: ShardGtid[];
}
/**
 * KeyspaceShard represents a keyspace and shard.
 *
 * @generated from protobuf message binlogdata.KeyspaceShard
 */
export interface KeyspaceShard {
    /**
     * @generated from protobuf field: string keyspace = 1;
     */
    keyspace: string;
    /**
     * @generated from protobuf field: string shard = 2;
     */
    shard: string;
}
/**
 * Journal contains the metadata for a journal event.
 * The commit of a journal event indicates the point of no return
 * for a migration.
 *
 * @generated from protobuf message binlogdata.Journal
 */
export interface Journal {
    /**
     * Id represents a unique journal id.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: binlogdata.MigrationType migration_type = 2;
     */
    migrationType: MigrationType;
    /**
     * Tables is set if the journal represents a TABLES migration.
     *
     * @generated from protobuf field: repeated string tables = 3;
     */
    tables: string[];
    /**
     * LocalPosition is the source position at which the migration happened.
     *
     * @generated from protobuf field: string local_position = 4;
     */
    localPosition: string;
    /**
     * ShardGtids is the list of targets to which the migration took place.
     *
     * @generated from protobuf field: repeated binlogdata.ShardGtid shard_gtids = 5;
     */
    shardGtids: ShardGtid[];
    /**
     * Participants is the list of source participants for a migration.
     * Every participant is expected to have an identical journal entry.
     * While streaming, the client must wait for the journal entry to
     * be received from all pariticipants, and then replace them with new
     * streams specified by ShardGtid.
     * If a stream does not have all participants, a consistent migration
     * is not possible.
     *
     * @generated from protobuf field: repeated binlogdata.KeyspaceShard participants = 6;
     */
    participants: KeyspaceShard[];
    /**
     * SourceWorkflows is the list of workflows in the source shard that
     * were migrated to the target. If a migration fails after a Journal
     * is committed, this information is used to start the target streams
     * that were created prior to the creation of the journal.
     *
     * @generated from protobuf field: repeated string source_workflows = 7;
     */
    sourceWorkflows: string[];
}
/**
 * VEvent represents a vstream event.
 * A FieldEvent is sent once for every table, just before
 * the first event for that table. The client is expected
 * to cache this information and match it against the RowEvent
 * which contains the table name.
 * A GTID event always precedes a commitable event, which can be
 * COMMIT, DDL or OTHER.
 * OTHER events are non-material events that have no additional metadata.
 *
 * @generated from protobuf message binlogdata.VEvent
 */
export interface VEvent {
    /**
     * @generated from protobuf field: binlogdata.VEventType type = 1;
     */
    type: VEventType;
    /**
     * Timestamp is the binlog timestamp in seconds.
     * The value should be ignored if 0.
     *
     * @generated from protobuf field: int64 timestamp = 2;
     */
    timestamp: bigint;
    /**
     * Gtid is set if the event type is GTID.
     *
     * @generated from protobuf field: string gtid = 3;
     */
    gtid: string;
    /**
     * Statement is set if the event type is DDL, DML or SAVEPOINT.
     *
     * @generated from protobuf field: string statement = 4;
     */
    statement: string;
    /**
     * RowEvent is set if the event type is ROW.
     *
     * @generated from protobuf field: binlogdata.RowEvent row_event = 5;
     */
    rowEvent?: RowEvent;
    /**
     * FieldEvent is set if the event type is FIELD.
     *
     * @generated from protobuf field: binlogdata.FieldEvent field_event = 6;
     */
    fieldEvent?: FieldEvent;
    /**
     * Vgtid is set if the event type is VGTID.
     * This event is only generated by VTGate's VStream function.
     *
     * @generated from protobuf field: binlogdata.VGtid vgtid = 7;
     */
    vgtid?: VGtid;
    /**
     * Journal is set if the event type is JOURNAL.
     *
     * @generated from protobuf field: binlogdata.Journal journal = 8;
     */
    journal?: Journal;
    /**
     * Dml is set if the event type is INSERT, REPLACE, UPDATE or DELETE.
     *
     * @generated from protobuf field: string dml = 9;
     */
    dml: string;
    /**
     * CurrentTime specifies the current time when the message was sent.
     * This can be used to compenssate for clock skew.
     *
     * @generated from protobuf field: int64 current_time = 20;
     */
    currentTime: bigint;
    /**
     * LastPK is the last PK for a table
     *
     * @generated from protobuf field: binlogdata.LastPKEvent last_p_k_event = 21;
     */
    lastPKEvent?: LastPKEvent;
    /**
     * the source keyspace
     *
     * @generated from protobuf field: string keyspace = 22;
     */
    keyspace: string;
    /**
     * the source shard
     *
     * @generated from protobuf field: string shard = 23;
     */
    shard: string;
    /**
     * indicate that we are being throttled right now
     *
     * @generated from protobuf field: bool throttled = 24;
     */
    throttled: boolean;
    /**
     * ThrottledReason is a human readable string that explains why the stream is throttled
     *
     * @generated from protobuf field: string throttled_reason = 25;
     */
    throttledReason: string;
}
/**
 * @generated from protobuf message binlogdata.MinimalTable
 */
export interface MinimalTable {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated query.Field fields = 2;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: repeated int64 p_k_columns = 3;
     */
    pKColumns: bigint[];
    /**
     * This will be PRIMARY when the actual primary key is used and it
     * will be the name of the Primary Key equivalent if one is used
     * instead. Otherwise it will be empty.
     *
     * @generated from protobuf field: string p_k_index_name = 4;
     */
    pKIndexName: string;
}
/**
 * @generated from protobuf message binlogdata.MinimalSchema
 */
export interface MinimalSchema {
    /**
     * @generated from protobuf field: repeated binlogdata.MinimalTable tables = 1;
     */
    tables: MinimalTable[];
}
/**
 * @generated from protobuf message binlogdata.VStreamOptions
 */
export interface VStreamOptions {
    /**
     * @generated from protobuf field: repeated string internal_tables = 1;
     */
    internalTables: string[];
    /**
     * @generated from protobuf field: map<string, string> config_overrides = 2;
     */
    configOverrides: {
        [key: string]: string;
    };
}
/**
 * VStreamRequest is the payload for VStreamer
 *
 * @generated from protobuf message binlogdata.VStreamRequest
 */
export interface VStreamRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string position = 4;
     */
    position: string;
    /**
     * @generated from protobuf field: binlogdata.Filter filter = 5;
     */
    filter?: Filter;
    /**
     * @generated from protobuf field: repeated binlogdata.TableLastPK table_last_p_ks = 6;
     */
    tableLastPKs: TableLastPK[];
    /**
     * @generated from protobuf field: binlogdata.VStreamOptions options = 7;
     */
    options?: VStreamOptions;
}
/**
 * VStreamResponse is the response from VStreamer
 *
 * @generated from protobuf message binlogdata.VStreamResponse
 */
export interface VStreamResponse {
    /**
     * @generated from protobuf field: repeated binlogdata.VEvent events = 1;
     */
    events: VEvent[];
}
/**
 * VStreamRowsRequest is the payload for VStreamRows
 *
 * @generated from protobuf message binlogdata.VStreamRowsRequest
 */
export interface VStreamRowsRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string query = 4;
     */
    query: string;
    /**
     * @generated from protobuf field: query.QueryResult lastpk = 5;
     */
    lastpk?: QueryResult;
    /**
     * @generated from protobuf field: binlogdata.VStreamOptions options = 6;
     */
    options?: VStreamOptions;
}
/**
 * VStreamRowsResponse is the response from VStreamRows
 *
 * @generated from protobuf message binlogdata.VStreamRowsResponse
 */
export interface VStreamRowsResponse {
    /**
     * @generated from protobuf field: repeated query.Field fields = 1;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: repeated query.Field pkfields = 2;
     */
    pkfields: Field[];
    /**
     * @generated from protobuf field: string gtid = 3;
     */
    gtid: string;
    /**
     * @generated from protobuf field: repeated query.Row rows = 4;
     */
    rows: Row[];
    /**
     * @generated from protobuf field: query.Row lastpk = 5;
     */
    lastpk?: Row;
    /**
     * Throttled indicates that rowstreamer is being throttled right now
     *
     * @generated from protobuf field: bool throttled = 6;
     */
    throttled: boolean;
    /**
     * Heartbeat indicates that this is a heartbeat message
     *
     * @generated from protobuf field: bool heartbeat = 7;
     */
    heartbeat: boolean;
    /**
     * ThrottledReason is a human readable string that explains why the stream is throttled
     *
     * @generated from protobuf field: string throttled_reason = 8;
     */
    throttledReason: string;
}
/**
 * VStreamTablesRequest is the payload for VStreamTables
 *
 * @generated from protobuf message binlogdata.VStreamTablesRequest
 */
export interface VStreamTablesRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: binlogdata.VStreamOptions options = 4;
     */
    options?: VStreamOptions;
}
/**
 * VStreamTablesResponse is the response from VStreamTables
 *
 * @generated from protobuf message binlogdata.VStreamTablesResponse
 */
export interface VStreamTablesResponse {
    /**
     * @generated from protobuf field: string table_name = 1;
     */
    tableName: string;
    /**
     * @generated from protobuf field: repeated query.Field fields = 2;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: repeated query.Field pkfields = 3;
     */
    pkfields: Field[];
    /**
     * @generated from protobuf field: string gtid = 4;
     */
    gtid: string;
    /**
     * @generated from protobuf field: repeated query.Row rows = 5;
     */
    rows: Row[];
    /**
     * @generated from protobuf field: query.Row lastpk = 6;
     */
    lastpk?: Row;
}
/**
 * @generated from protobuf message binlogdata.LastPKEvent
 */
export interface LastPKEvent {
    /**
     * @generated from protobuf field: binlogdata.TableLastPK table_last_p_k = 1;
     */
    tableLastPK?: TableLastPK;
    /**
     * @generated from protobuf field: bool completed = 2;
     */
    completed: boolean;
}
/**
 * @generated from protobuf message binlogdata.TableLastPK
 */
export interface TableLastPK {
    /**
     * @generated from protobuf field: string table_name = 1;
     */
    tableName: string;
    /**
     * @generated from protobuf field: query.QueryResult lastpk = 3;
     */
    lastpk?: QueryResult;
}
/**
 * VStreamResultsRequest is the payload for VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from protobuf message binlogdata.VStreamResultsRequest
 */
export interface VStreamResultsRequest {
    /**
     * @generated from protobuf field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;
    /**
     * @generated from protobuf field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;
    /**
     * @generated from protobuf field: query.Target target = 3;
     */
    target?: Target;
    /**
     * @generated from protobuf field: string query = 4;
     */
    query: string;
}
/**
 * VStreamResultsResponse is the response from VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from protobuf message binlogdata.VStreamResultsResponse
 */
export interface VStreamResultsResponse {
    /**
     * @generated from protobuf field: repeated query.Field fields = 1;
     */
    fields: Field[];
    /**
     * @generated from protobuf field: string gtid = 3;
     */
    gtid: string;
    /**
     * @generated from protobuf field: repeated query.Row rows = 4;
     */
    rows: Row[];
}
/**
 * OnDDLAction lists the possible actions for DDLs.
 *
 * @generated from protobuf enum binlogdata.OnDDLAction
 */
export enum OnDDLAction {
    /**
     * @generated from protobuf enum value: IGNORE = 0;
     */
    IGNORE = 0,
    /**
     * @generated from protobuf enum value: STOP = 1;
     */
    STOP = 1,
    /**
     * @generated from protobuf enum value: EXEC = 2;
     */
    EXEC = 2,
    /**
     * @generated from protobuf enum value: EXEC_IGNORE = 3;
     */
    EXEC_IGNORE = 3
}
/**
 * VReplicationWorkflowType define types of vreplication workflows.
 *
 * @generated from protobuf enum binlogdata.VReplicationWorkflowType
 */
export enum VReplicationWorkflowType {
    /**
     * @generated from protobuf enum value: Materialize = 0;
     */
    Materialize = 0,
    /**
     * @generated from protobuf enum value: MoveTables = 1;
     */
    MoveTables = 1,
    /**
     * @generated from protobuf enum value: CreateLookupIndex = 2;
     */
    CreateLookupIndex = 2,
    /**
     * @generated from protobuf enum value: Migrate = 3;
     */
    Migrate = 3,
    /**
     * @generated from protobuf enum value: Reshard = 4;
     */
    Reshard = 4,
    /**
     * @generated from protobuf enum value: OnlineDDL = 5;
     */
    OnlineDDL = 5
}
/**
 * VReplicationWorkflowSubType define types of vreplication workflows.
 *
 * @generated from protobuf enum binlogdata.VReplicationWorkflowSubType
 */
export enum VReplicationWorkflowSubType {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Partial = 1;
     */
    Partial = 1,
    /**
     * @generated from protobuf enum value: AtomicCopy = 2;
     */
    AtomicCopy = 2
}
/**
 * VReplicationWorklfowState defines the valid states that a workflow can be in.
 *
 * @generated from protobuf enum binlogdata.VReplicationWorkflowState
 */
export enum VReplicationWorkflowState {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    Unknown = 0,
    /**
     * @generated from protobuf enum value: Init = 1;
     */
    Init = 1,
    /**
     * @generated from protobuf enum value: Stopped = 2;
     */
    Stopped = 2,
    /**
     * @generated from protobuf enum value: Copying = 3;
     */
    Copying = 3,
    /**
     * @generated from protobuf enum value: Running = 4;
     */
    Running = 4,
    /**
     * @generated from protobuf enum value: Error = 5;
     */
    Error = 5,
    /**
     * @generated from protobuf enum value: Lagging = 6;
     */
    Lagging = 6
}
/**
 * VEventType enumerates the event types. Many of these types
 * will not be encountered in RBR mode.
 *
 * @generated from protobuf enum binlogdata.VEventType
 */
export enum VEventType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: GTID = 1;
     */
    GTID = 1,
    /**
     * @generated from protobuf enum value: BEGIN = 2;
     */
    BEGIN = 2,
    /**
     * @generated from protobuf enum value: COMMIT = 3;
     */
    COMMIT = 3,
    /**
     * @generated from protobuf enum value: ROLLBACK = 4;
     */
    ROLLBACK = 4,
    /**
     * @generated from protobuf enum value: DDL = 5;
     */
    DDL = 5,
    /**
     * INSERT, REPLACE, UPDATE, DELETE and SET will not be seen in RBR mode.
     *
     * @generated from protobuf enum value: INSERT = 6;
     */
    INSERT = 6,
    /**
     * @generated from protobuf enum value: REPLACE = 7;
     */
    REPLACE = 7,
    /**
     * @generated from protobuf enum value: UPDATE = 8;
     */
    UPDATE = 8,
    /**
     * @generated from protobuf enum value: DELETE = 9;
     */
    DELETE = 9,
    /**
     * @generated from protobuf enum value: SET = 10;
     */
    SET = 10,
    /**
     * OTHER is a dummy event. If encountered, the current GTID must be
     * recorded by the client to be able to resume.
     *
     * @generated from protobuf enum value: OTHER = 11;
     */
    OTHER = 11,
    /**
     * @generated from protobuf enum value: ROW = 12;
     */
    ROW = 12,
    /**
     * @generated from protobuf enum value: FIELD = 13;
     */
    FIELD = 13,
    /**
     * HEARTBEAT is sent if there is inactivity. If a client does not
     * receive events beyond the hearbeat interval, it can assume that it's
     * lost connection to the vstreamer.
     *
     * @generated from protobuf enum value: HEARTBEAT = 14;
     */
    HEARTBEAT = 14,
    /**
     * VGTID is generated by VTGate's VStream that combines multiple
     * GTIDs.
     *
     * @generated from protobuf enum value: VGTID = 15;
     */
    VGTID = 15,
    /**
     * @generated from protobuf enum value: JOURNAL = 16;
     */
    JOURNAL = 16,
    /**
     * @generated from protobuf enum value: VERSION = 17;
     */
    VERSION = 17,
    /**
     * @generated from protobuf enum value: LASTPK = 18;
     */
    LASTPK = 18,
    /**
     * @generated from protobuf enum value: SAVEPOINT = 19;
     */
    SAVEPOINT = 19,
    /**
     * COPY_COMPLETED is sent when VTGate's VStream copy operation is done.
     * If a client experiences some disruptions before receiving the event,
     * the client should restart the copy operation.
     *
     * @generated from protobuf enum value: COPY_COMPLETED = 20;
     */
    COPY_COMPLETED = 20
}
/**
 * MigrationType specifies the type of migration for the Journal.
 *
 * @generated from protobuf enum binlogdata.MigrationType
 */
export enum MigrationType {
    /**
     * @generated from protobuf enum value: TABLES = 0;
     */
    TABLES = 0,
    /**
     * @generated from protobuf enum value: SHARDS = 1;
     */
    SHARDS = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Charset$Type extends MessageType<Charset> {
    constructor() {
        super("binlogdata.Charset", [
            { no: 1, name: "client", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "conn", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "server", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Charset>): Charset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.client = 0;
        message.conn = 0;
        message.server = 0;
        if (value !== undefined)
            reflectionMergePartial<Charset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Charset): Charset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 client */ 1:
                    message.client = reader.int32();
                    break;
                case /* int32 conn */ 2:
                    message.conn = reader.int32();
                    break;
                case /* int32 server */ 3:
                    message.server = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Charset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 client = 1; */
        if (message.client !== 0)
            writer.tag(1, WireType.Varint).int32(message.client);
        /* int32 conn = 2; */
        if (message.conn !== 0)
            writer.tag(2, WireType.Varint).int32(message.conn);
        /* int32 server = 3; */
        if (message.server !== 0)
            writer.tag(3, WireType.Varint).int32(message.server);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.Charset
 */
export const Charset = new Charset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinlogTransaction$Type extends MessageType<BinlogTransaction> {
    constructor() {
        super("binlogdata.BinlogTransaction", [
            { no: 1, name: "statements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BinlogTransaction_Statement },
            { no: 4, name: "event_token", kind: "message", T: () => EventToken }
        ]);
    }
    create(value?: PartialMessage<BinlogTransaction>): BinlogTransaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statements = [];
        if (value !== undefined)
            reflectionMergePartial<BinlogTransaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinlogTransaction): BinlogTransaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.BinlogTransaction.Statement statements */ 1:
                    message.statements.push(BinlogTransaction_Statement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* query.EventToken event_token */ 4:
                    message.eventToken = EventToken.internalBinaryRead(reader, reader.uint32(), options, message.eventToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinlogTransaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.BinlogTransaction.Statement statements = 1; */
        for (let i = 0; i < message.statements.length; i++)
            BinlogTransaction_Statement.internalBinaryWrite(message.statements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.EventToken event_token = 4; */
        if (message.eventToken)
            EventToken.internalBinaryWrite(message.eventToken, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.BinlogTransaction
 */
export const BinlogTransaction = new BinlogTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinlogTransaction_Statement$Type extends MessageType<BinlogTransaction_Statement> {
    constructor() {
        super("binlogdata.BinlogTransaction.Statement", [
            { no: 1, name: "category", kind: "enum", T: () => ["binlogdata.BinlogTransaction.Statement.Category", BinlogTransaction_Statement_Category] },
            { no: 2, name: "charset", kind: "message", T: () => Charset },
            { no: 3, name: "sql", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BinlogTransaction_Statement>): BinlogTransaction_Statement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.category = 0;
        message.sql = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<BinlogTransaction_Statement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinlogTransaction_Statement): BinlogTransaction_Statement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* binlogdata.BinlogTransaction.Statement.Category category */ 1:
                    message.category = reader.int32();
                    break;
                case /* binlogdata.Charset charset */ 2:
                    message.charset = Charset.internalBinaryRead(reader, reader.uint32(), options, message.charset);
                    break;
                case /* bytes sql */ 3:
                    message.sql = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinlogTransaction_Statement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* binlogdata.BinlogTransaction.Statement.Category category = 1; */
        if (message.category !== 0)
            writer.tag(1, WireType.Varint).int32(message.category);
        /* binlogdata.Charset charset = 2; */
        if (message.charset)
            Charset.internalBinaryWrite(message.charset, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes sql = 3; */
        if (message.sql.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.sql);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.BinlogTransaction.Statement
 */
export const BinlogTransaction_Statement = new BinlogTransaction_Statement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamKeyRangeRequest$Type extends MessageType<StreamKeyRangeRequest> {
    constructor() {
        super("binlogdata.StreamKeyRangeRequest", [
            { no: 1, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 3, name: "charset", kind: "message", T: () => Charset }
        ]);
    }
    create(value?: PartialMessage<StreamKeyRangeRequest>): StreamKeyRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = "";
        if (value !== undefined)
            reflectionMergePartial<StreamKeyRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamKeyRangeRequest): StreamKeyRangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position */ 1:
                    message.position = reader.string();
                    break;
                case /* topodata.KeyRange key_range */ 2:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* binlogdata.Charset charset */ 3:
                    message.charset = Charset.internalBinaryRead(reader, reader.uint32(), options, message.charset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamKeyRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position = 1; */
        if (message.position !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.position);
        /* topodata.KeyRange key_range = 2; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.Charset charset = 3; */
        if (message.charset)
            Charset.internalBinaryWrite(message.charset, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.StreamKeyRangeRequest
 */
export const StreamKeyRangeRequest = new StreamKeyRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamKeyRangeResponse$Type extends MessageType<StreamKeyRangeResponse> {
    constructor() {
        super("binlogdata.StreamKeyRangeResponse", [
            { no: 1, name: "binlog_transaction", kind: "message", T: () => BinlogTransaction }
        ]);
    }
    create(value?: PartialMessage<StreamKeyRangeResponse>): StreamKeyRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamKeyRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamKeyRangeResponse): StreamKeyRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* binlogdata.BinlogTransaction binlog_transaction */ 1:
                    message.binlogTransaction = BinlogTransaction.internalBinaryRead(reader, reader.uint32(), options, message.binlogTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamKeyRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* binlogdata.BinlogTransaction binlog_transaction = 1; */
        if (message.binlogTransaction)
            BinlogTransaction.internalBinaryWrite(message.binlogTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.StreamKeyRangeResponse
 */
export const StreamKeyRangeResponse = new StreamKeyRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTablesRequest$Type extends MessageType<StreamTablesRequest> {
    constructor() {
        super("binlogdata.StreamTablesRequest", [
            { no: 1, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "charset", kind: "message", T: () => Charset }
        ]);
    }
    create(value?: PartialMessage<StreamTablesRequest>): StreamTablesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = "";
        message.tables = [];
        if (value !== undefined)
            reflectionMergePartial<StreamTablesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTablesRequest): StreamTablesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string position */ 1:
                    message.position = reader.string();
                    break;
                case /* repeated string tables */ 2:
                    message.tables.push(reader.string());
                    break;
                case /* binlogdata.Charset charset */ 3:
                    message.charset = Charset.internalBinaryRead(reader, reader.uint32(), options, message.charset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTablesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string position = 1; */
        if (message.position !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.position);
        /* repeated string tables = 2; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.tables[i]);
        /* binlogdata.Charset charset = 3; */
        if (message.charset)
            Charset.internalBinaryWrite(message.charset, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.StreamTablesRequest
 */
export const StreamTablesRequest = new StreamTablesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamTablesResponse$Type extends MessageType<StreamTablesResponse> {
    constructor() {
        super("binlogdata.StreamTablesResponse", [
            { no: 1, name: "binlog_transaction", kind: "message", T: () => BinlogTransaction }
        ]);
    }
    create(value?: PartialMessage<StreamTablesResponse>): StreamTablesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamTablesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamTablesResponse): StreamTablesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* binlogdata.BinlogTransaction binlog_transaction */ 1:
                    message.binlogTransaction = BinlogTransaction.internalBinaryRead(reader, reader.uint32(), options, message.binlogTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamTablesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* binlogdata.BinlogTransaction binlog_transaction = 1; */
        if (message.binlogTransaction)
            BinlogTransaction.internalBinaryWrite(message.binlogTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.StreamTablesResponse
 */
export const StreamTablesResponse = new StreamTablesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharsetConversion$Type extends MessageType<CharsetConversion> {
    constructor() {
        super("binlogdata.CharsetConversion", [
            { no: 1, name: "from_charset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "to_charset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CharsetConversion>): CharsetConversion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fromCharset = "";
        message.toCharset = "";
        if (value !== undefined)
            reflectionMergePartial<CharsetConversion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharsetConversion): CharsetConversion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string from_charset */ 1:
                    message.fromCharset = reader.string();
                    break;
                case /* string to_charset */ 2:
                    message.toCharset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharsetConversion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string from_charset = 1; */
        if (message.fromCharset !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fromCharset);
        /* string to_charset = 2; */
        if (message.toCharset !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.toCharset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.CharsetConversion
 */
export const CharsetConversion = new CharsetConversion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rule$Type extends MessageType<Rule> {
    constructor() {
        super("binlogdata.Rule", [
            { no: 1, name: "match", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "convert_enum_to_text", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "convert_charset", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => CharsetConversion } },
            { no: 5, name: "source_unique_key_columns", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "target_unique_key_columns", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "source_unique_key_target_columns", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "convert_int_to_enum", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 9, name: "force_unique_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Rule>): Rule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.match = "";
        message.filter = "";
        message.convertEnumToText = {};
        message.convertCharset = {};
        message.sourceUniqueKeyColumns = "";
        message.targetUniqueKeyColumns = "";
        message.sourceUniqueKeyTargetColumns = "";
        message.convertIntToEnum = {};
        message.forceUniqueKey = "";
        if (value !== undefined)
            reflectionMergePartial<Rule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rule): Rule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string match */ 1:
                    message.match = reader.string();
                    break;
                case /* string filter */ 2:
                    message.filter = reader.string();
                    break;
                case /* map<string, string> convert_enum_to_text */ 3:
                    this.binaryReadMap3(message.convertEnumToText, reader, options);
                    break;
                case /* map<string, binlogdata.CharsetConversion> convert_charset */ 4:
                    this.binaryReadMap4(message.convertCharset, reader, options);
                    break;
                case /* string source_unique_key_columns */ 5:
                    message.sourceUniqueKeyColumns = reader.string();
                    break;
                case /* string target_unique_key_columns */ 6:
                    message.targetUniqueKeyColumns = reader.string();
                    break;
                case /* string source_unique_key_target_columns */ 7:
                    message.sourceUniqueKeyTargetColumns = reader.string();
                    break;
                case /* map<string, bool> convert_int_to_enum */ 8:
                    this.binaryReadMap8(message.convertIntToEnum, reader, options);
                    break;
                case /* string force_unique_key */ 9:
                    message.forceUniqueKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Rule["convertEnumToText"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Rule["convertEnumToText"] | undefined, val: Rule["convertEnumToText"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field binlogdata.Rule.convert_enum_to_text");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap4(map: Rule["convertCharset"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Rule["convertCharset"] | undefined, val: Rule["convertCharset"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = CharsetConversion.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field binlogdata.Rule.convert_charset");
            }
        }
        map[key ?? ""] = val ?? CharsetConversion.create();
    }
    private binaryReadMap8(map: Rule["convertIntToEnum"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Rule["convertIntToEnum"] | undefined, val: Rule["convertIntToEnum"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field binlogdata.Rule.convert_int_to_enum");
            }
        }
        map[key ?? ""] = val ?? false;
    }
    internalBinaryWrite(message: Rule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string match = 1; */
        if (message.match !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.match);
        /* string filter = 2; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        /* map<string, string> convert_enum_to_text = 3; */
        for (let k of globalThis.Object.keys(message.convertEnumToText))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.convertEnumToText[k]).join();
        /* map<string, binlogdata.CharsetConversion> convert_charset = 4; */
        for (let k of globalThis.Object.keys(message.convertCharset)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            CharsetConversion.internalBinaryWrite(message.convertCharset[k], writer, options);
            writer.join().join();
        }
        /* string source_unique_key_columns = 5; */
        if (message.sourceUniqueKeyColumns !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sourceUniqueKeyColumns);
        /* string target_unique_key_columns = 6; */
        if (message.targetUniqueKeyColumns !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.targetUniqueKeyColumns);
        /* string source_unique_key_target_columns = 7; */
        if (message.sourceUniqueKeyTargetColumns !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.sourceUniqueKeyTargetColumns);
        /* map<string, bool> convert_int_to_enum = 8; */
        for (let k of globalThis.Object.keys(message.convertIntToEnum))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).bool(message.convertIntToEnum[k]).join();
        /* string force_unique_key = 9; */
        if (message.forceUniqueKey !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.forceUniqueKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.Rule
 */
export const Rule = new Rule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends MessageType<Filter> {
    constructor() {
        super("binlogdata.Filter", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Rule },
            { no: 2, name: "field_event_mode", kind: "enum", T: () => ["binlogdata.Filter.FieldEventMode", Filter_FieldEventMode] },
            { no: 3, name: "workflow_type", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "workflow_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Filter>): Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        message.fieldEventMode = 0;
        message.workflowType = 0n;
        message.workflowName = "";
        if (value !== undefined)
            reflectionMergePartial<Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter): Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.Rule rules */ 1:
                    message.rules.push(Rule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* binlogdata.Filter.FieldEventMode field_event_mode */ 2:
                    message.fieldEventMode = reader.int32();
                    break;
                case /* int64 workflow_type */ 3:
                    message.workflowType = reader.int64().toBigInt();
                    break;
                case /* string workflow_name */ 4:
                    message.workflowName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.Rule rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            Rule.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.Filter.FieldEventMode field_event_mode = 2; */
        if (message.fieldEventMode !== 0)
            writer.tag(2, WireType.Varint).int32(message.fieldEventMode);
        /* int64 workflow_type = 3; */
        if (message.workflowType !== 0n)
            writer.tag(3, WireType.Varint).int64(message.workflowType);
        /* string workflow_name = 4; */
        if (message.workflowName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workflowName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.Filter
 */
export const Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BinlogSource$Type extends MessageType<BinlogSource> {
    constructor() {
        super("binlogdata.BinlogSource", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tablet_type", kind: "enum", T: () => ["topodata.TabletType", TabletType] },
            { no: 4, name: "key_range", kind: "message", T: () => KeyRange },
            { no: 5, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "filter", kind: "message", T: () => Filter },
            { no: 7, name: "on_ddl", kind: "enum", T: () => ["binlogdata.OnDDLAction", OnDDLAction] },
            { no: 8, name: "external_mysql", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "stop_after_copy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "external_cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "source_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "target_time_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BinlogSource>): BinlogSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.tabletType = 0;
        message.tables = [];
        message.onDdl = 0;
        message.externalMysql = "";
        message.stopAfterCopy = false;
        message.externalCluster = "";
        message.sourceTimeZone = "";
        message.targetTimeZone = "";
        if (value !== undefined)
            reflectionMergePartial<BinlogSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BinlogSource): BinlogSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* topodata.TabletType tablet_type */ 3:
                    message.tabletType = reader.int32();
                    break;
                case /* topodata.KeyRange key_range */ 4:
                    message.keyRange = KeyRange.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* repeated string tables */ 5:
                    message.tables.push(reader.string());
                    break;
                case /* binlogdata.Filter filter */ 6:
                    message.filter = Filter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* binlogdata.OnDDLAction on_ddl */ 7:
                    message.onDdl = reader.int32();
                    break;
                case /* string external_mysql */ 8:
                    message.externalMysql = reader.string();
                    break;
                case /* bool stop_after_copy */ 9:
                    message.stopAfterCopy = reader.bool();
                    break;
                case /* string external_cluster */ 10:
                    message.externalCluster = reader.string();
                    break;
                case /* string source_time_zone */ 11:
                    message.sourceTimeZone = reader.string();
                    break;
                case /* string target_time_zone */ 12:
                    message.targetTimeZone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BinlogSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* topodata.TabletType tablet_type = 3; */
        if (message.tabletType !== 0)
            writer.tag(3, WireType.Varint).int32(message.tabletType);
        /* topodata.KeyRange key_range = 4; */
        if (message.keyRange)
            KeyRange.internalBinaryWrite(message.keyRange, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string tables = 5; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.tables[i]);
        /* binlogdata.Filter filter = 6; */
        if (message.filter)
            Filter.internalBinaryWrite(message.filter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.OnDDLAction on_ddl = 7; */
        if (message.onDdl !== 0)
            writer.tag(7, WireType.Varint).int32(message.onDdl);
        /* string external_mysql = 8; */
        if (message.externalMysql !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.externalMysql);
        /* bool stop_after_copy = 9; */
        if (message.stopAfterCopy !== false)
            writer.tag(9, WireType.Varint).bool(message.stopAfterCopy);
        /* string external_cluster = 10; */
        if (message.externalCluster !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.externalCluster);
        /* string source_time_zone = 11; */
        if (message.sourceTimeZone !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sourceTimeZone);
        /* string target_time_zone = 12; */
        if (message.targetTimeZone !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.targetTimeZone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.BinlogSource
 */
export const BinlogSource = new BinlogSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RowChange$Type extends MessageType<RowChange> {
    constructor() {
        super("binlogdata.RowChange", [
            { no: 1, name: "before", kind: "message", T: () => Row },
            { no: 2, name: "after", kind: "message", T: () => Row },
            { no: 3, name: "data_columns", kind: "message", T: () => RowChange_Bitmap }
        ]);
    }
    create(value?: PartialMessage<RowChange>): RowChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RowChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RowChange): RowChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* query.Row before */ 1:
                    message.before = Row.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* query.Row after */ 2:
                    message.after = Row.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                case /* binlogdata.RowChange.Bitmap data_columns */ 3:
                    message.dataColumns = RowChange_Bitmap.internalBinaryRead(reader, reader.uint32(), options, message.dataColumns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RowChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* query.Row before = 1; */
        if (message.before)
            Row.internalBinaryWrite(message.before, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.Row after = 2; */
        if (message.after)
            Row.internalBinaryWrite(message.after, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.RowChange.Bitmap data_columns = 3; */
        if (message.dataColumns)
            RowChange_Bitmap.internalBinaryWrite(message.dataColumns, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.RowChange
 */
export const RowChange = new RowChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RowChange_Bitmap$Type extends MessageType<RowChange_Bitmap> {
    constructor() {
        super("binlogdata.RowChange.Bitmap", [
            { no: 1, name: "count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cols", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RowChange_Bitmap>): RowChange_Bitmap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0n;
        message.cols = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<RowChange_Bitmap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RowChange_Bitmap): RowChange_Bitmap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 count */ 1:
                    message.count = reader.int64().toBigInt();
                    break;
                case /* bytes cols */ 2:
                    message.cols = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RowChange_Bitmap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 count = 1; */
        if (message.count !== 0n)
            writer.tag(1, WireType.Varint).int64(message.count);
        /* bytes cols = 2; */
        if (message.cols.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.cols);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.RowChange.Bitmap
 */
export const RowChange_Bitmap = new RowChange_Bitmap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RowEvent$Type extends MessageType<RowEvent> {
    constructor() {
        super("binlogdata.RowEvent", [
            { no: 1, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "row_changes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RowChange },
            { no: 3, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_internal_table", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RowEvent>): RowEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableName = "";
        message.rowChanges = [];
        message.keyspace = "";
        message.shard = "";
        message.flags = 0;
        message.isInternalTable = false;
        if (value !== undefined)
            reflectionMergePartial<RowEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RowEvent): RowEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table_name */ 1:
                    message.tableName = reader.string();
                    break;
                case /* repeated binlogdata.RowChange row_changes */ 2:
                    message.rowChanges.push(RowChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string keyspace */ 3:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 4:
                    message.shard = reader.string();
                    break;
                case /* uint32 flags */ 5:
                    message.flags = reader.uint32();
                    break;
                case /* bool is_internal_table */ 6:
                    message.isInternalTable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RowEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table_name = 1; */
        if (message.tableName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tableName);
        /* repeated binlogdata.RowChange row_changes = 2; */
        for (let i = 0; i < message.rowChanges.length; i++)
            RowChange.internalBinaryWrite(message.rowChanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 3; */
        if (message.keyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 4; */
        if (message.shard !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shard);
        /* uint32 flags = 5; */
        if (message.flags !== 0)
            writer.tag(5, WireType.Varint).uint32(message.flags);
        /* bool is_internal_table = 6; */
        if (message.isInternalTable !== false)
            writer.tag(6, WireType.Varint).bool(message.isInternalTable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.RowEvent
 */
export const RowEvent = new RowEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldEvent$Type extends MessageType<FieldEvent> {
    constructor() {
        super("binlogdata.FieldEvent", [
            { no: 1, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 3, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "enum_set_string_values", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "is_internal_table", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FieldEvent>): FieldEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableName = "";
        message.fields = [];
        message.keyspace = "";
        message.shard = "";
        message.enumSetStringValues = false;
        message.isInternalTable = false;
        if (value !== undefined)
            reflectionMergePartial<FieldEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldEvent): FieldEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table_name */ 1:
                    message.tableName = reader.string();
                    break;
                case /* repeated query.Field fields */ 2:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string keyspace */ 3:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 4:
                    message.shard = reader.string();
                    break;
                case /* bool enum_set_string_values */ 25:
                    message.enumSetStringValues = reader.bool();
                    break;
                case /* bool is_internal_table */ 26:
                    message.isInternalTable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table_name = 1; */
        if (message.tableName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tableName);
        /* repeated query.Field fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 3; */
        if (message.keyspace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 4; */
        if (message.shard !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.shard);
        /* bool enum_set_string_values = 25; */
        if (message.enumSetStringValues !== false)
            writer.tag(25, WireType.Varint).bool(message.enumSetStringValues);
        /* bool is_internal_table = 26; */
        if (message.isInternalTable !== false)
            writer.tag(26, WireType.Varint).bool(message.isInternalTable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.FieldEvent
 */
export const FieldEvent = new FieldEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShardGtid$Type extends MessageType<ShardGtid> {
    constructor() {
        super("binlogdata.ShardGtid", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "table_p_ks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TableLastPK }
        ]);
    }
    create(value?: PartialMessage<ShardGtid>): ShardGtid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        message.gtid = "";
        message.tablePKs = [];
        if (value !== undefined)
            reflectionMergePartial<ShardGtid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShardGtid): ShardGtid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                case /* string gtid */ 3:
                    message.gtid = reader.string();
                    break;
                case /* repeated binlogdata.TableLastPK table_p_ks */ 4:
                    message.tablePKs.push(TableLastPK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShardGtid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        /* string gtid = 3; */
        if (message.gtid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gtid);
        /* repeated binlogdata.TableLastPK table_p_ks = 4; */
        for (let i = 0; i < message.tablePKs.length; i++)
            TableLastPK.internalBinaryWrite(message.tablePKs[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.ShardGtid
 */
export const ShardGtid = new ShardGtid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VGtid$Type extends MessageType<VGtid> {
    constructor() {
        super("binlogdata.VGtid", [
            { no: 1, name: "shard_gtids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardGtid }
        ]);
    }
    create(value?: PartialMessage<VGtid>): VGtid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shardGtids = [];
        if (value !== undefined)
            reflectionMergePartial<VGtid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VGtid): VGtid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.ShardGtid shard_gtids */ 1:
                    message.shardGtids.push(ShardGtid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VGtid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.ShardGtid shard_gtids = 1; */
        for (let i = 0; i < message.shardGtids.length; i++)
            ShardGtid.internalBinaryWrite(message.shardGtids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VGtid
 */
export const VGtid = new VGtid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyspaceShard$Type extends MessageType<KeyspaceShard> {
    constructor() {
        super("binlogdata.KeyspaceShard", [
            { no: 1, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeyspaceShard>): KeyspaceShard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keyspace = "";
        message.shard = "";
        if (value !== undefined)
            reflectionMergePartial<KeyspaceShard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyspaceShard): KeyspaceShard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string keyspace */ 1:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 2:
                    message.shard = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyspaceShard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string keyspace = 1; */
        if (message.keyspace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 2; */
        if (message.shard !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.shard);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.KeyspaceShard
 */
export const KeyspaceShard = new KeyspaceShard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Journal$Type extends MessageType<Journal> {
    constructor() {
        super("binlogdata.Journal", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "migration_type", kind: "enum", T: () => ["binlogdata.MigrationType", MigrationType] },
            { no: 3, name: "tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "local_position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "shard_gtids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ShardGtid },
            { no: 6, name: "participants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyspaceShard },
            { no: 7, name: "source_workflows", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Journal>): Journal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.migrationType = 0;
        message.tables = [];
        message.localPosition = "";
        message.shardGtids = [];
        message.participants = [];
        message.sourceWorkflows = [];
        if (value !== undefined)
            reflectionMergePartial<Journal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Journal): Journal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                case /* binlogdata.MigrationType migration_type */ 2:
                    message.migrationType = reader.int32();
                    break;
                case /* repeated string tables */ 3:
                    message.tables.push(reader.string());
                    break;
                case /* string local_position */ 4:
                    message.localPosition = reader.string();
                    break;
                case /* repeated binlogdata.ShardGtid shard_gtids */ 5:
                    message.shardGtids.push(ShardGtid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated binlogdata.KeyspaceShard participants */ 6:
                    message.participants.push(KeyspaceShard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string source_workflows */ 7:
                    message.sourceWorkflows.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Journal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        /* binlogdata.MigrationType migration_type = 2; */
        if (message.migrationType !== 0)
            writer.tag(2, WireType.Varint).int32(message.migrationType);
        /* repeated string tables = 3; */
        for (let i = 0; i < message.tables.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.tables[i]);
        /* string local_position = 4; */
        if (message.localPosition !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.localPosition);
        /* repeated binlogdata.ShardGtid shard_gtids = 5; */
        for (let i = 0; i < message.shardGtids.length; i++)
            ShardGtid.internalBinaryWrite(message.shardGtids[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated binlogdata.KeyspaceShard participants = 6; */
        for (let i = 0; i < message.participants.length; i++)
            KeyspaceShard.internalBinaryWrite(message.participants[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string source_workflows = 7; */
        for (let i = 0; i < message.sourceWorkflows.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.sourceWorkflows[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.Journal
 */
export const Journal = new Journal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VEvent$Type extends MessageType<VEvent> {
    constructor() {
        super("binlogdata.VEvent", [
            { no: 1, name: "type", kind: "enum", T: () => ["binlogdata.VEventType", VEventType] },
            { no: 2, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "statement", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "row_event", kind: "message", T: () => RowEvent },
            { no: 6, name: "field_event", kind: "message", T: () => FieldEvent },
            { no: 7, name: "vgtid", kind: "message", T: () => VGtid },
            { no: 8, name: "journal", kind: "message", T: () => Journal },
            { no: 9, name: "dml", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "current_time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "last_p_k_event", kind: "message", T: () => LastPKEvent },
            { no: 22, name: "keyspace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "shard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "throttled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "throttled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VEvent>): VEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.timestamp = 0n;
        message.gtid = "";
        message.statement = "";
        message.dml = "";
        message.currentTime = 0n;
        message.keyspace = "";
        message.shard = "";
        message.throttled = false;
        message.throttledReason = "";
        if (value !== undefined)
            reflectionMergePartial<VEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VEvent): VEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* binlogdata.VEventType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int64 timestamp */ 2:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* string gtid */ 3:
                    message.gtid = reader.string();
                    break;
                case /* string statement */ 4:
                    message.statement = reader.string();
                    break;
                case /* binlogdata.RowEvent row_event */ 5:
                    message.rowEvent = RowEvent.internalBinaryRead(reader, reader.uint32(), options, message.rowEvent);
                    break;
                case /* binlogdata.FieldEvent field_event */ 6:
                    message.fieldEvent = FieldEvent.internalBinaryRead(reader, reader.uint32(), options, message.fieldEvent);
                    break;
                case /* binlogdata.VGtid vgtid */ 7:
                    message.vgtid = VGtid.internalBinaryRead(reader, reader.uint32(), options, message.vgtid);
                    break;
                case /* binlogdata.Journal journal */ 8:
                    message.journal = Journal.internalBinaryRead(reader, reader.uint32(), options, message.journal);
                    break;
                case /* string dml */ 9:
                    message.dml = reader.string();
                    break;
                case /* int64 current_time */ 20:
                    message.currentTime = reader.int64().toBigInt();
                    break;
                case /* binlogdata.LastPKEvent last_p_k_event */ 21:
                    message.lastPKEvent = LastPKEvent.internalBinaryRead(reader, reader.uint32(), options, message.lastPKEvent);
                    break;
                case /* string keyspace */ 22:
                    message.keyspace = reader.string();
                    break;
                case /* string shard */ 23:
                    message.shard = reader.string();
                    break;
                case /* bool throttled */ 24:
                    message.throttled = reader.bool();
                    break;
                case /* string throttled_reason */ 25:
                    message.throttledReason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* binlogdata.VEventType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int64 timestamp = 2; */
        if (message.timestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.timestamp);
        /* string gtid = 3; */
        if (message.gtid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gtid);
        /* string statement = 4; */
        if (message.statement !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.statement);
        /* binlogdata.RowEvent row_event = 5; */
        if (message.rowEvent)
            RowEvent.internalBinaryWrite(message.rowEvent, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.FieldEvent field_event = 6; */
        if (message.fieldEvent)
            FieldEvent.internalBinaryWrite(message.fieldEvent, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.VGtid vgtid = 7; */
        if (message.vgtid)
            VGtid.internalBinaryWrite(message.vgtid, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.Journal journal = 8; */
        if (message.journal)
            Journal.internalBinaryWrite(message.journal, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string dml = 9; */
        if (message.dml !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.dml);
        /* int64 current_time = 20; */
        if (message.currentTime !== 0n)
            writer.tag(20, WireType.Varint).int64(message.currentTime);
        /* binlogdata.LastPKEvent last_p_k_event = 21; */
        if (message.lastPKEvent)
            LastPKEvent.internalBinaryWrite(message.lastPKEvent, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* string keyspace = 22; */
        if (message.keyspace !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.keyspace);
        /* string shard = 23; */
        if (message.shard !== "")
            writer.tag(23, WireType.LengthDelimited).string(message.shard);
        /* bool throttled = 24; */
        if (message.throttled !== false)
            writer.tag(24, WireType.Varint).bool(message.throttled);
        /* string throttled_reason = 25; */
        if (message.throttledReason !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.throttledReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VEvent
 */
export const VEvent = new VEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinimalTable$Type extends MessageType<MinimalTable> {
    constructor() {
        super("binlogdata.MinimalTable", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 3, name: "p_k_columns", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "p_k_index_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MinimalTable>): MinimalTable {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.fields = [];
        message.pKColumns = [];
        message.pKIndexName = "";
        if (value !== undefined)
            reflectionMergePartial<MinimalTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MinimalTable): MinimalTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated query.Field fields */ 2:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int64 p_k_columns */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pKColumns.push(reader.int64().toBigInt());
                    else
                        message.pKColumns.push(reader.int64().toBigInt());
                    break;
                case /* string p_k_index_name */ 4:
                    message.pKIndexName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MinimalTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated query.Field fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated int64 p_k_columns = 3; */
        if (message.pKColumns.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.pKColumns.length; i++)
                writer.int64(message.pKColumns[i]);
            writer.join();
        }
        /* string p_k_index_name = 4; */
        if (message.pKIndexName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pKIndexName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.MinimalTable
 */
export const MinimalTable = new MinimalTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinimalSchema$Type extends MessageType<MinimalSchema> {
    constructor() {
        super("binlogdata.MinimalSchema", [
            { no: 1, name: "tables", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MinimalTable }
        ]);
    }
    create(value?: PartialMessage<MinimalSchema>): MinimalSchema {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tables = [];
        if (value !== undefined)
            reflectionMergePartial<MinimalSchema>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MinimalSchema): MinimalSchema {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.MinimalTable tables */ 1:
                    message.tables.push(MinimalTable.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MinimalSchema, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.MinimalTable tables = 1; */
        for (let i = 0; i < message.tables.length; i++)
            MinimalTable.internalBinaryWrite(message.tables[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.MinimalSchema
 */
export const MinimalSchema = new MinimalSchema$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamOptions$Type extends MessageType<VStreamOptions> {
    constructor() {
        super("binlogdata.VStreamOptions", [
            { no: 1, name: "internal_tables", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config_overrides", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<VStreamOptions>): VStreamOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.internalTables = [];
        message.configOverrides = {};
        if (value !== undefined)
            reflectionMergePartial<VStreamOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamOptions): VStreamOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string internal_tables */ 1:
                    message.internalTables.push(reader.string());
                    break;
                case /* map<string, string> config_overrides */ 2:
                    this.binaryReadMap2(message.configOverrides, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: VStreamOptions["configOverrides"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof VStreamOptions["configOverrides"] | undefined, val: VStreamOptions["configOverrides"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field binlogdata.VStreamOptions.config_overrides");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: VStreamOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string internal_tables = 1; */
        for (let i = 0; i < message.internalTables.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.internalTables[i]);
        /* map<string, string> config_overrides = 2; */
        for (let k of globalThis.Object.keys(message.configOverrides))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.configOverrides[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamOptions
 */
export const VStreamOptions = new VStreamOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamRequest$Type extends MessageType<VStreamRequest> {
    constructor() {
        super("binlogdata.VStreamRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "position", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "filter", kind: "message", T: () => Filter },
            { no: 6, name: "table_last_p_ks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TableLastPK },
            { no: 7, name: "options", kind: "message", T: () => VStreamOptions }
        ]);
    }
    create(value?: PartialMessage<VStreamRequest>): VStreamRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.position = "";
        message.tableLastPKs = [];
        if (value !== undefined)
            reflectionMergePartial<VStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamRequest): VStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string position */ 4:
                    message.position = reader.string();
                    break;
                case /* binlogdata.Filter filter */ 5:
                    message.filter = Filter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* repeated binlogdata.TableLastPK table_last_p_ks */ 6:
                    message.tableLastPKs.push(TableLastPK.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* binlogdata.VStreamOptions options */ 7:
                    message.options = VStreamOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string position = 4; */
        if (message.position !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.position);
        /* binlogdata.Filter filter = 5; */
        if (message.filter)
            Filter.internalBinaryWrite(message.filter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated binlogdata.TableLastPK table_last_p_ks = 6; */
        for (let i = 0; i < message.tableLastPKs.length; i++)
            TableLastPK.internalBinaryWrite(message.tableLastPKs[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.VStreamOptions options = 7; */
        if (message.options)
            VStreamOptions.internalBinaryWrite(message.options, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamRequest
 */
export const VStreamRequest = new VStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamResponse$Type extends MessageType<VStreamResponse> {
    constructor() {
        super("binlogdata.VStreamResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VEvent }
        ]);
    }
    create(value?: PartialMessage<VStreamResponse>): VStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<VStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamResponse): VStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated binlogdata.VEvent events */ 1:
                    message.events.push(VEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated binlogdata.VEvent events = 1; */
        for (let i = 0; i < message.events.length; i++)
            VEvent.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamResponse
 */
export const VStreamResponse = new VStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamRowsRequest$Type extends MessageType<VStreamRowsRequest> {
    constructor() {
        super("binlogdata.VStreamRowsRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lastpk", kind: "message", T: () => QueryResult },
            { no: 6, name: "options", kind: "message", T: () => VStreamOptions }
        ]);
    }
    create(value?: PartialMessage<VStreamRowsRequest>): VStreamRowsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<VStreamRowsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamRowsRequest): VStreamRowsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string query */ 4:
                    message.query = reader.string();
                    break;
                case /* query.QueryResult lastpk */ 5:
                    message.lastpk = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.lastpk);
                    break;
                case /* binlogdata.VStreamOptions options */ 6:
                    message.options = VStreamOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamRowsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string query = 4; */
        if (message.query !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.query);
        /* query.QueryResult lastpk = 5; */
        if (message.lastpk)
            QueryResult.internalBinaryWrite(message.lastpk, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.VStreamOptions options = 6; */
        if (message.options)
            VStreamOptions.internalBinaryWrite(message.options, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamRowsRequest
 */
export const VStreamRowsRequest = new VStreamRowsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamRowsResponse$Type extends MessageType<VStreamRowsResponse> {
    constructor() {
        super("binlogdata.VStreamRowsResponse", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 2, name: "pkfields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 3, name: "gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Row },
            { no: 5, name: "lastpk", kind: "message", T: () => Row },
            { no: 6, name: "throttled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "heartbeat", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "throttled_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VStreamRowsResponse>): VStreamRowsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        message.pkfields = [];
        message.gtid = "";
        message.rows = [];
        message.throttled = false;
        message.heartbeat = false;
        message.throttledReason = "";
        if (value !== undefined)
            reflectionMergePartial<VStreamRowsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamRowsResponse): VStreamRowsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.Field fields */ 1:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated query.Field pkfields */ 2:
                    message.pkfields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string gtid */ 3:
                    message.gtid = reader.string();
                    break;
                case /* repeated query.Row rows */ 4:
                    message.rows.push(Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* query.Row lastpk */ 5:
                    message.lastpk = Row.internalBinaryRead(reader, reader.uint32(), options, message.lastpk);
                    break;
                case /* bool throttled */ 6:
                    message.throttled = reader.bool();
                    break;
                case /* bool heartbeat */ 7:
                    message.heartbeat = reader.bool();
                    break;
                case /* string throttled_reason */ 8:
                    message.throttledReason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamRowsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.Field fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.Field pkfields = 2; */
        for (let i = 0; i < message.pkfields.length; i++)
            Field.internalBinaryWrite(message.pkfields[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string gtid = 3; */
        if (message.gtid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gtid);
        /* repeated query.Row rows = 4; */
        for (let i = 0; i < message.rows.length; i++)
            Row.internalBinaryWrite(message.rows[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* query.Row lastpk = 5; */
        if (message.lastpk)
            Row.internalBinaryWrite(message.lastpk, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool throttled = 6; */
        if (message.throttled !== false)
            writer.tag(6, WireType.Varint).bool(message.throttled);
        /* bool heartbeat = 7; */
        if (message.heartbeat !== false)
            writer.tag(7, WireType.Varint).bool(message.heartbeat);
        /* string throttled_reason = 8; */
        if (message.throttledReason !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.throttledReason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamRowsResponse
 */
export const VStreamRowsResponse = new VStreamRowsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamTablesRequest$Type extends MessageType<VStreamTablesRequest> {
    constructor() {
        super("binlogdata.VStreamTablesRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "options", kind: "message", T: () => VStreamOptions }
        ]);
    }
    create(value?: PartialMessage<VStreamTablesRequest>): VStreamTablesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VStreamTablesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamTablesRequest): VStreamTablesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* binlogdata.VStreamOptions options */ 4:
                    message.options = VStreamOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamTablesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* binlogdata.VStreamOptions options = 4; */
        if (message.options)
            VStreamOptions.internalBinaryWrite(message.options, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamTablesRequest
 */
export const VStreamTablesRequest = new VStreamTablesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamTablesResponse$Type extends MessageType<VStreamTablesResponse> {
    constructor() {
        super("binlogdata.VStreamTablesResponse", [
            { no: 1, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 3, name: "pkfields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 4, name: "gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "rows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Row },
            { no: 6, name: "lastpk", kind: "message", T: () => Row }
        ]);
    }
    create(value?: PartialMessage<VStreamTablesResponse>): VStreamTablesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableName = "";
        message.fields = [];
        message.pkfields = [];
        message.gtid = "";
        message.rows = [];
        if (value !== undefined)
            reflectionMergePartial<VStreamTablesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamTablesResponse): VStreamTablesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table_name */ 1:
                    message.tableName = reader.string();
                    break;
                case /* repeated query.Field fields */ 2:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated query.Field pkfields */ 3:
                    message.pkfields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string gtid */ 4:
                    message.gtid = reader.string();
                    break;
                case /* repeated query.Row rows */ 5:
                    message.rows.push(Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* query.Row lastpk */ 6:
                    message.lastpk = Row.internalBinaryRead(reader, reader.uint32(), options, message.lastpk);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamTablesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table_name = 1; */
        if (message.tableName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tableName);
        /* repeated query.Field fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated query.Field pkfields = 3; */
        for (let i = 0; i < message.pkfields.length; i++)
            Field.internalBinaryWrite(message.pkfields[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string gtid = 4; */
        if (message.gtid !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.gtid);
        /* repeated query.Row rows = 5; */
        for (let i = 0; i < message.rows.length; i++)
            Row.internalBinaryWrite(message.rows[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* query.Row lastpk = 6; */
        if (message.lastpk)
            Row.internalBinaryWrite(message.lastpk, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamTablesResponse
 */
export const VStreamTablesResponse = new VStreamTablesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastPKEvent$Type extends MessageType<LastPKEvent> {
    constructor() {
        super("binlogdata.LastPKEvent", [
            { no: 1, name: "table_last_p_k", kind: "message", T: () => TableLastPK },
            { no: 2, name: "completed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LastPKEvent>): LastPKEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.completed = false;
        if (value !== undefined)
            reflectionMergePartial<LastPKEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastPKEvent): LastPKEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* binlogdata.TableLastPK table_last_p_k */ 1:
                    message.tableLastPK = TableLastPK.internalBinaryRead(reader, reader.uint32(), options, message.tableLastPK);
                    break;
                case /* bool completed */ 2:
                    message.completed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastPKEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* binlogdata.TableLastPK table_last_p_k = 1; */
        if (message.tableLastPK)
            TableLastPK.internalBinaryWrite(message.tableLastPK, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool completed = 2; */
        if (message.completed !== false)
            writer.tag(2, WireType.Varint).bool(message.completed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.LastPKEvent
 */
export const LastPKEvent = new LastPKEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableLastPK$Type extends MessageType<TableLastPK> {
    constructor() {
        super("binlogdata.TableLastPK", [
            { no: 1, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "lastpk", kind: "message", T: () => QueryResult }
        ]);
    }
    create(value?: PartialMessage<TableLastPK>): TableLastPK {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tableName = "";
        if (value !== undefined)
            reflectionMergePartial<TableLastPK>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TableLastPK): TableLastPK {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table_name */ 1:
                    message.tableName = reader.string();
                    break;
                case /* query.QueryResult lastpk */ 3:
                    message.lastpk = QueryResult.internalBinaryRead(reader, reader.uint32(), options, message.lastpk);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TableLastPK, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string table_name = 1; */
        if (message.tableName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tableName);
        /* query.QueryResult lastpk = 3; */
        if (message.lastpk)
            QueryResult.internalBinaryWrite(message.lastpk, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.TableLastPK
 */
export const TableLastPK = new TableLastPK$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamResultsRequest$Type extends MessageType<VStreamResultsRequest> {
    constructor() {
        super("binlogdata.VStreamResultsRequest", [
            { no: 1, name: "effective_caller_id", kind: "message", T: () => CallerID },
            { no: 2, name: "immediate_caller_id", kind: "message", T: () => VTGateCallerID },
            { no: 3, name: "target", kind: "message", T: () => Target },
            { no: 4, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VStreamResultsRequest>): VStreamResultsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<VStreamResultsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamResultsRequest): VStreamResultsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* vtrpc.CallerID effective_caller_id */ 1:
                    message.effectiveCallerId = CallerID.internalBinaryRead(reader, reader.uint32(), options, message.effectiveCallerId);
                    break;
                case /* query.VTGateCallerID immediate_caller_id */ 2:
                    message.immediateCallerId = VTGateCallerID.internalBinaryRead(reader, reader.uint32(), options, message.immediateCallerId);
                    break;
                case /* query.Target target */ 3:
                    message.target = Target.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string query */ 4:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamResultsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* vtrpc.CallerID effective_caller_id = 1; */
        if (message.effectiveCallerId)
            CallerID.internalBinaryWrite(message.effectiveCallerId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* query.VTGateCallerID immediate_caller_id = 2; */
        if (message.immediateCallerId)
            VTGateCallerID.internalBinaryWrite(message.immediateCallerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* query.Target target = 3; */
        if (message.target)
            Target.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string query = 4; */
        if (message.query !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamResultsRequest
 */
export const VStreamResultsRequest = new VStreamResultsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VStreamResultsResponse$Type extends MessageType<VStreamResultsResponse> {
    constructor() {
        super("binlogdata.VStreamResultsResponse", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Field },
            { no: 3, name: "gtid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rows", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Row }
        ]);
    }
    create(value?: PartialMessage<VStreamResultsResponse>): VStreamResultsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        message.gtid = "";
        message.rows = [];
        if (value !== undefined)
            reflectionMergePartial<VStreamResultsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VStreamResultsResponse): VStreamResultsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated query.Field fields */ 1:
                    message.fields.push(Field.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string gtid */ 3:
                    message.gtid = reader.string();
                    break;
                case /* repeated query.Row rows */ 4:
                    message.rows.push(Row.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VStreamResultsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated query.Field fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Field.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string gtid = 3; */
        if (message.gtid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.gtid);
        /* repeated query.Row rows = 4; */
        for (let i = 0; i < message.rows.length; i++)
            Row.internalBinaryWrite(message.rows[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message binlogdata.VStreamResultsResponse
 */
export const VStreamResultsResponse = new VStreamResultsResponse$Type();
